#
# This computer program is the confidential information and proprietary trade
# secret of Anuta Networks, Inc. Possessions and use of this program must
# conform strictly to the license agreement between the user and
# Anuta Networks, Inc., and receipt or possession does not convey any rights
# to divulge, reproduce, or allow others to use this program without specific
# written authorization of Anuta Networks, Inc.
#
# Copyright (c) 2015-2016 Anuta Networks, Inc. All Rights Reserved.
#

#
#DO NOT EDIT THIS FILE ITS AUTOGENERATED ONE
#

from servicemodel import util
from servicemodel import yang
from servicemodel import devicemgr
import copy
import re
from servicemodel.controller import devices
from com.anuta.api import DataNodeNotFoundException

managed_cpe_services_debug = False


def log(s):
  if managed_cpe_services_debug:
    util.log_debug(s)


def getCurrentObjectConfig(id, sdata, currentobj):
    log('id = %s, serviceData = %s' % (id, sdata))
    log('payload: %s' % (sdata.getPayload()))

    # using util library to parse xml
    # sdata.getPayload() will return a XML string posted by user
    key = 'current_config'
    config = sdata.getSessionItem(key)
    if config == None:
      config = util.parseXmlString(sdata.getPayload())
      sdata.setSessionItem(key, config, False) # set this specific to this callback
      log('getCurrentObjectConfig:cache-miss key=%s' % (key))
    else:
      log('getCurrentObjectConfig:cache-hit key=%s' % (key))
    if currentobj is not None and hasattr(config, currentobj):
      config = getattr(config, currentobj)
    else:
      log('%s attribute not present in current configuration'%currentobj)
      return None
    log('getCurrentObjectConfig: %s' % (config.toXml()))
    return config


def getInputDict(config):
    inputattribs = config.__dict__
    inputdict=copy.deepcopy(inputattribs)
    return inputdict


def getDeviceObject(mgmt_leaf, sdata = None):
    key = 'device.%s' % (mgmt_leaf)
    if sdata != None:
        dev = sdata.getSessionItem(key)
        if dev != None:
            log('getDeviceObject:cache-hit key=%s' % (key))
            return dev
        else:
            log('getDeviceObject:cache-miss key=%s' % (key))
          
    dev = []
    for device in util.convert_to_list(mgmt_leaf):
      dev_object = devicemgr.getDeviceById(device)
      if (dev_object == None):
          log('No device by ip: %s' % (mgmt_leaf))
          raise Exception('No device by ip: %s' % (mgmt_leaf))
      dev.append(dev_object)
    if sdata != None:
      sdata.setSessionItem(key, dev, True)
    return dev


def getParentObject(sdata):
    rcpath =  util.get_parent_rcpath(sdata.getRcPath())
    log('setting rcpath= %s' % (rcpath))

    key = 'parent.%s' % (rcpath)
    obj = sdata.getSessionItem(key)
    if obj != None:
        log('getParentObject:cache-hit key=%s' % (key))
        return obj
    log('getParentObject:cache-miss key=%s' % (key))
    xml_output = yang.Sdk.getData(rcpath, '', sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    if obj != None:
      sdata.setSessionItem(key, obj, True)

    return obj


def find_exact_match_first_occurance (rcpath, elem, relativedist):
    idx = rcpath.find(elem)
    if idx < 0:
        log('cant find pattern in rcpath = %s' % (rcpath))
        return relativedist
    idx = rcpath.find('/', idx)
    if idx < 0:
        log('cant find / in rcpath = %s, idx = %d' % (rcpath, idx))
        return relativedist

    trcpath = rcpath[:idx]
    relativedist = relativedist + idx
    if trcpath.split('/')[-1] != elem:
        trcpath = rcpath[idx:]
        return find_exact_match_first_occurance(trcpath, elem, relativedist)
    return relativedist


def getLocalObject(sdata, elem):
    rcpath = sdata.getRcPath()
    log('rcpath = %s' % (rcpath))
    pattern = '/controller:services'
    idx = rcpath.find(pattern)
    if idx < 0:
        log('cant find pattern in rcpath = %s' % (rcpath))
        return rcpath

    idx = find_exact_match_first_occurance(rcpath, elem, 0)
    log('rcpath = %s, new = %s' % (rcpath, rcpath[:idx]))
    rcpath = rcpath[:idx]

    key = 'local.%s' % (rcpath)
    obj = sdata.getSessionItem(key)
    if obj == None:
      log('getLocalObject:cache-miss key=%s' % (key))
      xml_output = yang.Sdk.getData(rcpath, '', sdata.getTaskId())
      log('%s object: %s' % (elem, xml_output))
      obj = util.parseXmlString(xml_output)
      sdata.setSessionItem(key, obj, True)
    else:
      log('getLocalObject:cache-hit key=%s' % (key))
      
    return obj


def natpool(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    pool_name = inputdict['pool_name']
    start_ip = inputdict['start_ip']
    end_ip = inputdict['end_ip']
    mask = inputdict['mask']
    netmask = inputdict['netmask']
    prefix_length = inputdict['prefix_length']
    pool_type = inputdict['pool_type']
    natobj = devices.device.ip_nat_pool.pool.pool()
    natobj.pool_name = pool_name
    natobj.start_ip = start_ip
    natobj.end_ip = end_ip
    natobj.mask = mask
    if mask == 'netmask':
        natobj.netmask = netmask
    elif mask == 'prefix-length':
        natobj.prefix_length = prefix_length
    if util.isNotEmpty(pool_type):
        natobj.pool_type = pool_type

    natpool_url = dev.url + '/ip-nat-pool'
    yang.Sdk.createData(natpool_url, natobj.getxml(filter=True), sdata.getSession())


def nat_trans_pool(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    pool_name = inputdict['pool_name']
    vrf = inputdict['vrf']
    overload = inputdict['overload']
    obj = getLocalObject(sdata, 'address-translation')
    if hasattr(obj.address_translation, 'side'):
        side = obj.address_translation.side
    else:
        side = None
    if hasattr(obj.address_translation, 'address_translation'):
        address_translation = obj.address_translation.address_translation
    else:
        address_translation = None
    if hasattr(obj.address_translation, 'list'):
        list = obj.address_translation.list
    else:
        list = None
    if hasattr(obj.address_translation, 'value'):
        value = obj.address_translation.value
    else:
        value = None
    natobj = devices.device.ip_nat.address_translation.address_translation()
    natobj.side = side
    natobj.address_translation = address_translation
    natobj.nat_list = list
    natobj.value = value
    yang.Sdk.createData(dev.url, '<ip-nat/>', sdata.getSession(), False)
    yang.Sdk.createData(dev.url + '/ip-nat', natobj.getxml(filter=True), sdata.getSession())
    natobj_pool = devices.device.ip_nat.address_translation.pool.pool()
    natobj_pool.pool_name = pool_name
    natobj_pool.vrf = vrf
    natobj_pool.overload = overload
    natobj_pool.match_in_vrf = 'false'
    natobj_pool.oer = 'false'
    natpool_url = dev.url + '/ip-nat/address-translation=%s,%s' % (list,value)
    yang.Sdk.createData(natpool_url, natobj_pool.getxml(filter=True), sdata.getSession())


def nat_trans_int(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    interface_name = inputdict['interface_name']
    vrf = inputdict['vrf']
    overload = inputdict['overload']
    obj = getLocalObject(sdata, 'address-translation')
    if hasattr(obj.address_translation, 'side'):
        side = obj.address_translation.side
    else:
        side = None
    if hasattr(obj.address_translation, 'address_translation'):
        address_translation = obj.address_translation.address_translation
    else:
        address_translation = None
    if hasattr(obj.address_translation, 'list'):
        list = obj.address_translation.list
    else:
        list = None
    if hasattr(obj.address_translation, 'value'):
        value = obj.address_translation.value
    else:
        value = None
    natobj = devices.device.ip_nat.address_translation.address_translation()
    natobj.side = side
    natobj.address_translation = address_translation
    natobj.nat_list = list
    natobj.value = value
    yang.Sdk.createData(dev.url, '<ip-nat/>', sdata.getSession(), False)
    yang.Sdk.createData(dev.url + '/ip-nat', natobj.getxml(filter=True), sdata.getSession())
    natobj_pool = devices.device.ip_nat.address_translation.interface.interface()
    natobj_pool.interface_name = interface_name
    natobj_pool.vrf = vrf
    natobj_pool.overload = overload
    natobj_pool.oer = 'false'
    natobj_pool.extended = 'false'
    natpool_url = dev.url + '/ip-nat/address-translation=%s,%s' % (list,value)
    yang.Sdk.createData(natpool_url, natobj_pool.getxml(filter=True), sdata.getSession())


def eigrp(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    vrf = inputdict['vrf_name']
    process_id = inputdict['process_id']
    eigrp_stub = inputdict['eigrp_stub']

    if util.isEmpty(vrf):
        if entity == 'cpe':
            obj = getLocalObject(sdata, 'single-cpe-site-services')
            if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                vrf = obj.single_cpe_site_services.cpe.vrf_name
        elif entity == 'cpe_dual':
            obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
            if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
        elif entity == 'cpe_primary':
            obj = getLocalObject(sdata, 'dual-cpe-site-services')
            if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
        elif entity == 'cpe_secondary':
            obj = getLocalObject(sdata, 'dual-cpe-site-services')
            if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    if util.isEmpty(vrf):
        vrf = 'GLOBAL'

    eigrp_obj = devices.device.vrfs.vrf.router_eigrp.router_eigrp()
    eigrp_obj.process_id = process_id
    if util.isNotEmpty(eigrp_stub):
        eigrp_obj.eigrp_stub = eigrp_stub

    eigrp_url = dev.url + '/vrfs/vrf=%s' % (vrf)
    yang.Sdk.createData(eigrp_url, eigrp_obj.getxml(filter=True), sdata.getSession())


def eigrp_network(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    prefix_in = inputdict['prefix']
    prefix = util.IPPrefix(prefix_in)
    ip_address = prefix.address
    wildcard = prefix.wildcard
    (addrStr, cidrStr) = prefix_in.split('/')
    addr = addrStr.split('.')
    cidr = int(cidrStr)
    mask = [0, 0, 0, 0]
    for i in range(cidr):
        mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
    net = []
    for i in range(4):
        net.append(int(addr[i]) & mask[i])

    network = ".".join(map(str, net))
    vrf = None
    obj_in = getLocalObject(sdata, 'router-eigrp')

    eigrp_net_obj = devices.device.vrfs.vrf.router_eigrp.network.network()
    if util.isNotEmpty(ip_address):
        eigrp_net_obj.ip_address = network
    if util.isNotEmpty(wildcard):
        eigrp_net_obj.wild_card = wildcard

    if hasattr(obj_in.router_eigrp, 'vrf_name'):
        vrf = obj_in.router_eigrp.vrf_name
        if util.isEmpty(vrf):
            if entity == 'cpe':
                obj = getLocalObject(sdata, 'single-cpe-site-services')
                if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_site_services.cpe.vrf_name
            elif entity == 'cpe_dual':
                obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
            elif entity == 'cpe_primary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
            elif entity == 'cpe_secondary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'

    eigrp_net_url = dev.url + '/vrfs/vrf=%s/router-eigrp' % (vrf)
    yang.Sdk.createData(eigrp_net_url, eigrp_net_obj.getxml(filter=True), sdata.getSession())


def eigrp_on_bgp(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    redistribute_eigrp_on_bgp = inputdict['redistribute_eigrp_on_bgp']
    route_map = inputdict['route_map']
    vrf = None
    eigrp_process_id = None
    obj_in = getLocalObject(sdata, 'router-eigrp')
    if hasattr(obj_in.router_eigrp, 'process_id'):
        eigrp_process_id = obj_in.router_eigrp.process_id
    if hasattr(obj_in.router_eigrp, 'vrf_name'):
        vrf = obj_in.router_eigrp.vrf_name
        if util.isEmpty(vrf):
            if entity == 'cpe':
                obj = getLocalObject(sdata, 'single-cpe-site-services')
                if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_site_services.cpe.vrf_name
            elif entity == 'cpe_dual':
                obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
            elif entity == 'cpe_primary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
            elif entity == 'cpe_secondary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'
    rebgpredisobj1 = devices.device.vrfs.vrf.router_bgp.redistribute.redistribute()
    if redistribute_eigrp_on_bgp == 'true':
        if util.isNotEmpty(eigrp_process_id):
            rebgpredisobj1.protocol = 'eigrp'
            rebgpredisobj1.eigrp_process_id = eigrp_process_id
            if util.isNotEmpty(route_map):
                rebgpredisobj1.route_map = route_map
                route_maps(route_map, dev, sdata)

            router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())


def ospf_redis(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    protocol = inputdict['protocol']
    route_map = inputdict['route_map']
    # key1 = inputdict['key1']
    # key2 = inputdict['key2']
    metric = inputdict['metric']
    metric_type = inputdict['metric_type']
    tag = inputdict['tag']
    process_id_entry = inputdict['process_id']
    vrf = None
    process_id = None
    bgpas = None
    if entity == 'cpe':
        obj = getLocalObject(sdata, 'single-cpe-site-services')
        if hasattr(obj.single_cpe_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_dual':
        obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
        if hasattr(obj.single_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_dual_wan_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_primary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_primary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_primary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_secondary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_secondary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_secondary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_tertiary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    if vrf is None:
        vrf = 'GLOBAL'
    ospfredisobj1 = devices.device.vrfs.vrf.router_ospf.redistribute.ospf_redistribute.ospf_redistribute()
    ospfredisobj1.protocol = protocol
    if protocol == 'bgp':
        ospfredisobj1.bgp_as_number = bgpas
    if protocol == 'ospf':
        ospfredisobj1.process_id_entry = process_id_entry
    if util.isNotEmpty(route_map):
        ospfredisobj1.route_map = route_map
    if util.isNotEmpty(tag):
        ospfredisobj1.tag = tag
    if util.isNotEmpty(metric):
        ospfredisobj1.value1 = metric
    if util.isNotEmpty(metric_type):
        ospfredisobj1.value2 = metric_type

    ospf_red_url1 = device.url + '/vrfs/vrf=%s/router-ospf=%s' % (vrf, process_id)
    yang.Sdk.createData(ospf_red_url1, '<redistribute/>', sdata.getSession())

    ospf_red_url = device.url + '/vrfs/vrf=%s/router-ospf=%s/redistribute' % (vrf, process_id)
    yang.Sdk.createData(ospf_red_url, ospfredisobj1.getxml(filter=True), sdata.getSession())


def ospf_on_bgp(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    redistribute_ospf_on_bgp = inputdict['redistribute_ospf_on_bgp']
    ospf_internal = inputdict['ospf_internal']
    ospf_external1 = inputdict['ospf_external1']
    ospf_external2 = inputdict['ospf_external2']
    route_map = inputdict['route_map']
    vrf = None
    process_id = None
    obj_in = getLocalObject(sdata, 'router-ospf')
    if hasattr(obj_in.router_ospf, 'process_id'):
        process_id = obj_in.router_ospf.process_id
    if hasattr(obj_in.router_ospf, 'vrf_name'):
        vrf = obj_in.router_ospf.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'
    rebgpredisobj1 = devices.device.vrfs.vrf.router_bgp.redistribute.redistribute()
    if redistribute_ospf_on_bgp == 'true':
        rebgpredisobj1.protocol = 'ospf'
        if util.isNotEmpty(process_id):
            rebgpredisobj1.ospf_process_id = process_id
            if ospf_internal == 'true':
                rebgpredisobj1.ospf_internal = ospf_internal
            if ospf_external1 == 'true':
                rebgpredisobj1.ospf_external1 = "1"
            if ospf_external2 == 'true':
                rebgpredisobj1.ospf_external2 = "2"
            if util.isNotEmpty(route_map):
                rebgpredisobj1.route_map = route_map

            router_bgp_redist_url = device.url + '/vrfs/vrf=%s/router-bgp' % (vrf)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())


def ospf(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    process_id = inputdict['process_id']
    vrf = inputdict['vrf_name']
    router_id = inputdict['router_id']
    reference_bandwidth = inputdict['reference_bandwidth']
    snmp = inputdict['snmp']
    context = inputdict['context']
    community = inputdict['community']
    access = inputdict['access']
    global_acl_name = inputdict['global_acl_name']
    site_acl_name = inputdict['site_acl_name']
    maximum_paths = inputdict['maximum_paths']
    default_information = inputdict['default_information']
    # default_inf_key1 = inputdict['default_inf_key1']
    # default_inf_key2 = inputdict['default_inf_key2']
    # default_inf_key3 = inputdict['default_inf_key3']
    default_inf_metric = inputdict['default_inf_metric']
    default_inf_metric_type = inputdict['default_inf_metric_type']
    default_inf_route_map = inputdict['default_inf_route_map']
    distribute_list = inputdict['distribute_list']
    dis_list_route_map = inputdict['dis_list_route_map']
    dis_list_route_update = inputdict['dis_list_route_update']

    if util.isEmpty(vrf):
        vrf = 'GLOBAL'

    ospf_obj = devices.device.vrfs.vrf.router_ospf.router_ospf()
    ospf_obj.process_id = process_id
    if util.isNotEmpty(router_id):
        ospf_obj.router_id = router_id
    if util.isNotEmpty(reference_bandwidth):
        ospf_obj.reference_bandwidth = reference_bandwidth
    if snmp == 'true':
        if util.isNotEmpty(context):
            ospf_obj.context = context
        else:
            raise Exception("Please provide context")
        if util.isNotEmpty(community):
            ospf_obj.community = community
        if util.isNotEmpty(access):
            ospf_obj.access = access
        if util.isNotEmpty(global_acl_name):
            ospf_obj.acl_name = global_acl_name
        if util.isNotEmpty(site_acl_name):
            ospf_obj.acl_name = site_acl_name
    if util.isNotEmpty(maximum_paths):
        ospf_obj.maximum_paths = maximum_paths
    if default_information == 'true':
        ospf_obj.default_information = default_information
        if util.isNotEmpty(default_inf_metric):
            ospf_obj.default_inf_value = default_inf_metric
        if util.isNotEmpty(default_inf_metric_type):
            ospf_obj.default_inf_value1 = default_inf_metric_type
        if util.isNotEmpty(default_inf_route_map):
            ospf_obj.default_inf_value2 = default_inf_route_map
    if distribute_list == 'true':
        if util.isNotEmpty(dis_list_route_map) and util.isNotEmpty(dis_list_route_update):
            ospf_obj.dis_list_route_map = dis_list_route_map
            ospf_obj.dis_list_route_update = dis_list_route_update
    ospf_url = device.url + '/vrfs/vrf=%s' % (vrf)
    yang.Sdk.createData(ospf_url, ospf_obj.getxml(filter=True), sdata.getSession())


def ospf_networks(entity, vrf, smodelctx, sdata, device_ip, **kwargs):
    key = 'deviceid.%s' % (device_ip)
    device = sdata.getSessionItem(key)
    if device == None:
      log('ospf_networks:cache-miss key=%s' % (key))
      device = devicemgr.getDeviceById(device_ip)
      sdata.setSessionItem(key, device, True)
    else:
      log('ospf_networks:cache-hit key=%s' % (key))
      
    inputdict = kwargs['inputdict']
    prefix_in = inputdict['prefix']
    prefix = util.IPPrefix(prefix_in)
    ip_address = prefix.address
    wildcard = prefix.wildcard
    (addrStr, cidrStr) = prefix_in.split('/')
    addr = addrStr.split('.')
    cidr = int(cidrStr)
    mask = [0, 0, 0, 0]
    for i in range(cidr):
        mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
    net = []
    for i in range(4):
        net.append(int(addr[i]) & mask[i])

    network = ".".join(map(str, net))
    area = inputdict['area']
    nssa = inputdict['nssa']
    ospf_net_obj = devices.device.vrfs.vrf.router_ospf.network.network()
    ospf_net_obj.ip_address = network
    ospf_net_obj.wild_card = wildcard
    if util.isNotEmpty(area):
        ospf_net_obj.area = area
    if nssa == 'true':
        ospf_net_obj.nssa = 'true'
    if entity == 'cpe_primary':
        ospf_net_obj.translate = 'true'
    else:
        ospf_net_obj.translate = 'false'

    # ospf_networks_url1 = device.url + '/vrfs/vrf=%s' % (vrf)
    # yang.Sdk.createData(ospf_networks_url1, '<router-ospf/>', sdata.getSession())

    ospf_net_url = device.url + '/vrfs/vrf=%s/router-ospf=%s' % (vrf, inputdict['ospf_id'])
    yang.Sdk.createData(ospf_net_url, ospf_net_obj.getxml(filter=True), sdata.getSession())


def access_list(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    name = inputdict['name']
    access_list_entry = inputdict['access_list_entry']
    if access_list_entry == 'extended':
        access_obj = devices.device.access_lists.access_list.access_list()
        access_obj.acl_type = access_list_entry
        if name is not None:
            access_obj.name = name
    #yang.Sdk.createData(dev.url, '<access-lists/>', sdata.getSession(), False)

    access_obj_url = dev.url + '/access-lists'
    yang.Sdk.createData(access_obj_url, access_obj.getxml(filter=True), sdata.getSession())


def object_group_def(source_object_group, dev, sdata):
    uri = sdata.getRcPath()
    uri_list = uri.split('/', 5)
    url = '/'.join(uri_list[0:4])
    xml_output = yang.Sdk.getData(url+"/object-groups/object-group="+str(source_object_group), '', sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    objectgroup_obj = devices.device.object_groups_acl.object_group.object_group()
    objectgroup_obj.name = obj.object_group.name
    objectgroup_obj.type = obj.object_group.type
    if hasattr(obj.object_group, 'description'):
        if util.isNotEmpty(obj.object_group.description):
            objectgroup_obj.description = obj.object_group.description
    objectgroup_url = dev.url + '/object-groups-acl'
    yang.Sdk.createData(dev.url, '<object-groups-acl/>', sdata.getSession())
    yang.Sdk.createData(objectgroup_url, objectgroup_obj.getxml(filter=True), sdata.getSession())
    if hasattr(obj.object_group, 'networks'):
        if hasattr(obj.object_group.networks, 'network'):
            for objectgroup in util.convert_to_list(obj.object_group.networks.network):
                net_url = dev.url + '/object-groups-acl/object-group=%s' %(obj.object_group.name)
                yang.Sdk.createData(net_url, '<networks/>', sdata.getSession())

                if hasattr(objectgroup, 'group_object'):
                    if util.isNotEmpty(objectgroup.group_object):
                        network_obj = devices.device.object_groups_acl.object_group.networks.network.network()
                        network_obj.group_object = objectgroup.group_object
                        network_obj.name = "group-object" + " " + objectgroup.group_object
                        network_url = dev.url + '/object-groups-acl/object-group=%s/networks' %(obj.object_group.name)
                        yang.Sdk.createData(network_url, network_obj.getxml(filter=True), sdata.getSession())

                if hasattr(objectgroup, 'host'):
                    if util.isNotEmpty(objectgroup.host):
                        network_obj1 = devices.device.object_groups_acl.object_group.networks.network.network()
                        network_obj1.host = objectgroup.host
                        network_obj1.name = "host" + " " + objectgroup.host
                        network_url = dev.url + '/object-groups-acl/object-group=%s/networks' %(obj.object_group.name)
                        yang.Sdk.createData(network_url, network_obj1.getxml(filter=True), sdata.getSession())

                if hasattr(objectgroup, 'prefix'):
                    if util.isNotEmpty(objectgroup.prefix):
                        network_obj2 = devices.device.object_groups_acl.object_group.networks.network.network()
                        prefix = util.IPPrefix(objectgroup.prefix)
                        ip_address = prefix.address
                        netmask = prefix.netmask
                        network_obj2.ip_address = ip_address
                        network_obj2.netmask = netmask
                        network_obj2.name = ip_address + " " + netmask
                        network_url = dev.url + '/object-groups-acl/object-group=%s/networks' %(obj.object_group.name)
                        yang.Sdk.createData(network_url, network_obj2.getxml(filter=True), sdata.getSession())


def access_list_rule(smodelctx, sdata, dev, access_list_name, **kwargs):
    inputdict = kwargs['inputdict']
    action = inputdict['action']
    protocol = inputdict['protocol']
    source_condition = inputdict['source_condition']
    source_object = inputdict['source_object']
    source_port = inputdict['source_port']
    destination_condition = inputdict['destination_condition']
    destination_object = inputdict['destination_object']
    port_number = inputdict['port_number']
    match_packets = inputdict['match_packets']
    precedence = inputdict['precedence']
    dscp = inputdict['dscp']
    source_object_group = inputdict['source_object_group']
    destination_object_group = inputdict['destination_object_group']
    service_obj_name = inputdict['service_obj_name']

    port_dict = {
        '23': 'telnet',
        '80': 'www',
        '179': 'bgp',
        '500': 'isakmp',
        '53': 'domain',
        '21': 'ftp',
        '20': 'ftp-data',
        '135': 'msrpc',
        '110': 'pop3',
        '25': 'smtp',
        '514': 'syslog',
        '49': 'tacacs'
        }

    #name = inputdict['name']
    access_rule_obj = devices.device.access_lists.access_list.acl_rules.acl_rule.acl_rule()
    access_rule_obj.action = action
    access_rule_obj.layer4protocol = protocol
    name_rule = action + ' ' + protocol
    if util.isNotEmpty(service_obj_name):
        object_group_def(service_obj_name, dev, sdata)
        access_rule_obj.service_obj_name = service_obj_name
        name_rule += ' ' + service_obj_name
    access_rule_obj.source_condition_type = source_condition
    if source_condition == 'cidr':
        cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$'; 
        if re.match(cidr_pattern,source_object) == None:
            raise Exception ("Please provide valid CIDR for source-object in access-list")
        prefix = util.IPPrefix(source_object)
        ip_address = prefix.address
        netmask = prefix.wildcard
        access_rule_obj.source_mask = netmask
        (addrStr, cidrStr) = source_object.split('/')
        addr = addrStr.split('.')
        cidr = int(cidrStr)
        mask = [0, 0, 0, 0]
        for i in range(cidr):
            mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
        net = []
        for i in range(4):
            net.append(int(addr[i]) & mask[i])

        network = ".".join(map(str, net))
        name_rule += ' ' + network + ' ' + netmask
        access_rule_obj.source_ip = network
    if source_condition == 'host':
        host_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$';
        if re.match(host_pattern,source_object) == None:
            raise Exception ("Please provide valid ip-address for source-object in access-list")
        access_rule_obj.source_ip = source_object
        name_rule += ' ' + 'host' + ' ' + source_object
    if source_condition == 'objectgroup':
        if util.isNotEmpty(source_object_group):
            object_group_def(source_object_group, device, sdata)
            access_rule_obj.source_obj_name = source_object_group
            name_rule += ' ' + 'object-group' + ' ' + source_object_group
    if source_condition == 'any':
        name_rule += ' ' + 'any'
    if util.isNotEmpty(source_port):
        access_rule_obj.source_port_operator = 'eq'

        if source_port in port_dict:
            source_port = port_dict[source_port]

        access_rule_obj.source_port = source_port
        name_rule += ' eq ' + source_port
    access_rule_obj.dest_condition_type = destination_condition
    if destination_condition == 'cidr':
        cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
        if re.match(cidr_pattern,destination_object) == None:
            raise Exception ("Please provide valid CIDR for destination-object in access-list")
        prefix = util.IPPrefix(destination_object)
        ip_address = prefix.address
        netmask = prefix.wildcard
        access_rule_obj.dest_mask = netmask
        (addrStr, cidrStr) = destination_object.split('/')
        addr = addrStr.split('.')
        cidr = int(cidrStr)
        mask = [0, 0, 0, 0]
        for i in range(cidr):
            mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
        net = []
        for i in range(4):
            net.append(int(addr[i]) & mask[i])

        network = ".".join(map(str, net))
        name_rule += ' ' + network + ' ' + netmask
        access_rule_obj.dest_ip = network
    if destination_condition == 'host':
        host_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$';
        if re.match(host_pattern,destination_object) == None:
            raise Exception ("Please provide valid ip-address for destination-object in access-list")
        access_rule_obj.dest_ip = destination_object
        name_rule += ' ' + 'host' + ' ' + destination_object
    if destination_condition == 'objectgroup':
        if util.isNotEmpty(destination_object_group):
            object_group_def(destination_object_group, device, sdata)
            access_rule_obj.dest_obj_name = destination_object_group
            name_rule += ' ' + 'object-group' + ' ' + destination_object_group
    if destination_condition == 'any':
        name_rule += ' ' + 'any'
    if util.isNotEmpty(port_number):
        access_rule_obj.dest_port_operator = 'eq'

        if port_number in port_dict:
            port_number = port_dict[port_number]
        
        access_rule_obj.dest_port = port_number
        name_rule += ' eq ' + port_number
    if util.isNotEmpty(match_packets):
        access_rule_obj.match_packets = match_packets
        name_rule += ' ' + match_packets
    if match_packets == 'precedence':
        if util.isNotEmpty(precedence):
            access_rule_obj.precedence = precedence
            name_rule += ' ' + precedence
    else:
        if util.isNotEmpty(dscp):
            access_rule_obj.precedence = dscp
            name_rule += ' ' + dscp
    print "ACL_RULE_NAME: ", name_rule
    access_rule_obj.name = name_rule
    access_rules_url = dev.url + "/access-lists/access-list=%s" %(access_list_name)
    #is_acl_rule_xml_output = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
    #is_acl_rule_obj = util.parseXmlString(is_acl_rule_xml_output)
    #util.log_debug( "is_acl_rule_obj:", is_acl_rule_obj)
    #if not hasattr(is_acl_rule_obj.device, 'acl_rules'):      
        #yang.Sdk.createData(access_rules_url, '<acl-rules/>', sdata.getSession(), False)

    access_rule_url = dev.url + '/access-lists/access-list=%s/acl-rules' %(access_list_name)
    yang.Sdk.createData(access_rule_url, access_rule_obj.getxml(filter=True), sdata.getSession())


def route_maps(redistroutepolicy, device, sdata, int_name=None, entity=None):
    device.addRouteMapsContainer(sdata.getSession())
    obj = getLocalObject(sdata, 'customer')
    log("obj of routemap is: %s" % (obj))
    log("xml of route map obj: %s" % (obj.toXml()))
    log("route map obj is: %s" % (obj.customer.route_maps))
    if hasattr(obj.customer.route_maps, 'route_map'):
        obj.customer.route_maps.route_map = util.convert_to_list(obj.customer.route_maps.route_map)
        util.log_debug( "route map obj is:",obj.customer.route_maps.route_map)
        for route_map_obj in obj.customer.route_maps.route_map:
            route_map_name = route_map_obj.get_field_value('route_map_name')
            if redistroutepolicy == route_map_name :
                util.log_debug( "route_map_name is:",route_map_name)
                route_maps_url = device.url + '/route-maps'
                routemap_obj = devices.device.route_maps.route_map.route_map()
                if route_map_name is not None:
                    routemap_obj.name = route_map_name
                    yang.Sdk.createData(route_maps_url, routemap_obj.getxml(filter=True), sdata.getSession())
                    if hasattr(route_map_obj,'route_map_entries'):
                        print "Enter into route_map_entry"
                        route_map_entries = util.convert_to_list(route_map_obj.route_map_entries)
                        for route_map_entry in route_map_entries:
                            route_map(route_map_name, route_map_entry, device, sdata, int_name, entity)


def prefix_list_gen(smodelctx, sdata, device, **kwarg):
    '''
    :param smodelctx:
    :param sdata:
    :param device:
    :param vrf_name:
    :param kwarg:
    :return:
    '''
    prefixlist_name = kwarg['inputdict']['prefix_list_name']
    if prefixlist_name is not None:
        device.addIpPrefixListListsContainer(sdata.getSession())
        obj = getLocalObject(sdata, 'customer')
        if hasattr(obj.customer.prefix_lists, 'prefix_list'):
            obj.customer.prefix_lists.prefix_list = util.convert_to_list(obj.customer.prefix_lists.prefix_list)
            for prefixlist_obj in obj.customer.prefix_lists.prefix_list:
                prefix_list_name = prefixlist_obj.get_field_value('prefix_list_name')
                if prefixlist_name == prefix_list_name :
                    ip_prefixlist_lists_url = device.url + '/ip-prefixlist-list'
                    ip_prefixlist_lists_obj = devices.device.ip_prefixlist_list.ip_prefixlist.ip_prefixlist()
                    if prefix_list_name is not None:
                        ip_prefixlist_lists_obj.name = prefix_list_name
                        yang.Sdk.createData(ip_prefixlist_lists_url, ip_prefixlist_lists_obj.getxml(filter=True), sdata.getSession())
                        if hasattr(prefixlist_obj,'prefix'):
                            prefixs = util.convert_to_list(prefixlist_obj.prefix)
                            for prefix in prefixs:
                                prefix_gen(prefix_list_name, prefix, device, sdata)


def prefix_gen(prefix_list_name, prefix, device, sdata):
    '''

    :param smodelctx:
    :param sdata:
    :param device:
    :param vrf_name:
    :param kwarg:
    :return:
    '''

    prefix_obj = devices.device.ip_prefixlist_list.ip_prefixlist.ip_prefixlist_entries.ip_prefixlist_entry.ip_prefixlist_entry()

    prefix_name = prefix.get_field_value('prefix_name')
    if util.isNotEmpty(prefix_name):
        prefix_obj.prefix_name = prefix_name
    rule_num = prefix.get_field_value('rule_num')
    if util.isNotEmpty(rule_num):
        prefix_obj.rule_num = rule_num
    ipv4_prefix = prefix.get_field_value('ipv4_prefix')
    if util.isNotEmpty(ipv4_prefix):
        prefix_obj.subnet = ipv4_prefix
    condition = prefix.get_field_value('condition')
    if util.isNotEmpty(condition):
        prefix_obj.condition = condition
    exact_matching_prefix_length = prefix.get_field_value('exact_matching_prefix_length')
    if util.isNotEmpty(exact_matching_prefix_length):
        prefix_obj.num = exact_matching_prefix_length
    minimum_matching_prefix_length = prefix.get_field_value('minimum_matching_prefix_length')
    if util.isNotEmpty(minimum_matching_prefix_length):
        prefix_obj.num = minimum_matching_prefix_length
        prefix_obj.compare = 'ge'
    maximum_matching_prefix_length = prefix.get_field_value('maximum_matching_prefix_length')
    if util.isNotEmpty(maximum_matching_prefix_length):
        prefix_obj.num = maximum_matching_prefix_length
        prefix_obj.compare = 'le'
    device.addIpPrefixListEntriesContainer(prefix_list_name, sdata.getSession())

    prefix_list_url = device.url + '/ip-prefixlist-list/ip-prefixlist=%s/ip-prefixlist-entries' % (prefix_list_name)
    yang.Sdk.createData(prefix_list_url, prefix_obj.getxml(filter=True), sdata.getSession())


def route_map(route_map_name, route_map_entries, device, sdata, int_name=None, entity=None):
    print "Entering into Route map"
    routemapentry_obj = devices.device.route_maps.route_map.route_map_entries.route_map_entries()
    action = route_map_entries.get_field_value('action')
    if action is not None:
        routemapentry_obj.action = action
    seq = route_map_entries.get_field_value('sequence_number')
    if seq is not None:
        routemapentry_obj.seq = seq
    routemap_entry_url = device.url + '/route-maps/route-map=%s' % (route_map_name)
    yang.Sdk.createData(routemap_entry_url, routemapentry_obj.getxml(filter=True), sdata.getSession())
    if hasattr(route_map_entries,'match_condition'):
        for match_obj in util.convert_to_list(route_map_entries.match_condition):
            matchcondition_obj = devices.device.route_maps.route_map.route_map_entries.match_condition.match_condition()
            condition_type = match_obj.get_field_value('condition_type')
            if condition_type is not None:
                matchcondition_obj.condition_type = condition_type
            condition_value = match_obj.get_field_value('value')
            if condition_value is not None:
                if condition_value == 'LAN-INTERFACE' and condition_type == 'interface':
                    matchcondition_obj.value = int_name
                else:
                    matchcondition_obj.value = condition_value
            if condition_type == 'as-path' and condition_value is not None:
                as_path_acl(condition_value, device, sdata)
            if condition_type == 'community' and condition_value is not None:
                community_lists(condition_value, device, sdata)
            match_condition_url = device.url + '/route-maps/route-map=%s/route-map-entries=%s' % (route_map_name,seq)
            if util.isNotEmpty(matchcondition_obj.value):
                yang.Sdk.createData(match_condition_url, matchcondition_obj.getxml(filter=True), sdata.getSession())
    if hasattr(route_map_entries,'set_action'):
        for set_obj in util.convert_to_list(route_map_entries.set_action):
            set_ip = None
            set_obj1 = devices.device.route_maps.route_map.route_map_entries.set_action.set_action()
            set_type = set_obj.get_field_value('set_type')
            if set_type is not None:
                set_obj1.set_type = set_type
                if set_type == 'ip':
                    set_ip = set_obj.get_field_value('ip')
                    if set_ip is None:
                        raise Exception("Please provide ip precedence/df/next-hop")
                    else:
                        set_obj1.ip = set_ip
            set_value = set_obj.get_field_value('value')
            bgp_as_regex = re.match(r'\bAS\b', set_value)
            if set_value is not None:
                if set_value == 'IP' and set_ip == 'next-hop':
                    obj = modifiedGetLocalObject(sdata, 'cpe-name')
                    if hasattr(obj.cpe_name, "next_hop_ip"):
                        set_obj1.value = obj.cpe_name.next_hop_ip
                #Handle Keywork 'AS' in Route-Map for AS-Path Prepending
                elif bgp_as_regex is not None and set_type == 'as-path prepend':
					if entity == 'cpe':
							obj_bgp_as = getLocalObject(sdata, 'single-cpe-site-services')
							if hasattr(obj_bgp_as.single_cpe_site_services, 'bgp_as'):
									bgpas = obj_bgp_as.single_cpe_site_services.bgp_as
									set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
					elif entity == 'cpe_dual':
							obj_bgp_as = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
							if hasattr(obj_bgp_as.single_cpe_dual_wan_site_services, 'bgp_as'):
								bgpas = obj_bgp_as.single_cpe_dual_wan_site_services.bgp_as
								set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
					elif entity == 'cpe_primary' or entity == 'cpe_secondary':
							obj_bgp_as = getLocalObject(sdata, 'dual-cpe-site-services')
							if hasattr(obj_bgp_as.dual_cpe_site_services, 'bgp_as'):
								bgpas = obj_bgp_as.dual_cpe_site_services.bgp_as
								set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
					elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
							obj_bgp_as = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
							if hasattr(obj_bgp_as.dual_cpe_dual_wan_site_services, 'bgp_as'):
								bgpas = obj_bgp_as.dual_cpe_dual_wan_site_services.bgp_as
								set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
					elif entity == 'cpe_primary_triple' or entity == 'cpe_secondary_triple' or entity == 'cpe_tertiary_triple':
							obj_bgp_as = getLocalObject(sdata, 'triple-cpe-site-services')
							if hasattr(obj_bgp_as.triple_cpe_site_services, 'bgp_as'):
								bgpas = obj_bgp_as.triple_cpe_site_services.bgp_as
								set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
                else:
                    set_obj1.value = set_value
            # if set_type == 'as-path' and set_value is not None:
            #     as_path_acl(set_value, device, sdata)
            if set_type == 'community' and set_value is not None:
                community_lists(set_value, device, sdata)
            set_action_url = device.url + '/route-maps/route-map=%s/route-map-entries=%s' % (route_map_name,seq)
            yang.Sdk.createData(set_action_url, set_obj1.getxml(filter=True), sdata.getSession())


def as_path_acl(condition_value, device, sdata):
    uri = sdata.getRcPath()
    uri_list = uri.split('/',5)
    url = '/'.join(uri_list[0:4])

    xml_output = yang.Sdk.getData(url+"/as-path-acls", '',sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    util.log_debug( "obj: ",obj)
    yang.Sdk.createData(device.url, '<as-path-acls/>', sdata.getSession())

    if hasattr(obj.as_path_acls, 'as_path_acl'):
        obj.as_path_acls.as_path_acl = util.convert_to_list(obj.as_path_acls.as_path_acl)
        for as_path_acl_obj in obj.as_path_acls.as_path_acl:
            number = as_path_acl_obj.get_field_value('number')
            if condition_value == number:
                condition = as_path_acl_obj.get_field_value('condition')
                expression = as_path_acl_obj.get_field_value('expression')
                as_path_obj = devices.device.as_path_acls.as_path_acl.as_path_acl()
                as_path_obj.number = number
                as_path_obj.condition = condition
                as_path_obj.expression = expression

                as_path_url = device.url + '/as-path-acls'
                yang.Sdk.createData(as_path_url, as_path_obj.getxml(filter=True), sdata.getSession())


def adv_networks(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    prefix = inputdict['prefix']
    route_map = inputdict['route_map']
    vrf = inputdict['vrf_name']
    prefix = util.IPPrefix(prefix)
    ip_address = prefix.address
    netmask = prefix.netmask
    adv_networks_obj = devices.device.vrfs.vrf.router_bgp.network.network()
    adv_networks_obj.ip_address = ip_address
    adv_networks_obj.netmask = netmask
    if util.isNotEmpty(route_map):
        adv_networks_obj.route_map = route_map

    if util.isEmpty(vrf):
        vrf = 'GLOBAL'
    adv_networks_url1 = device.url + '/vrfs/vrf=%s' % (vrf)
    is_router_bgp_xml_output = yang.Sdk.getData(adv_networks_url1, '', smodelctx.task_id)
    is_router_bgp_obj = util.parseXmlString(is_router_bgp_xml_output)
    util.log_debug( "is_router_bgp_obj is:", is_router_bgp_obj)
    #if not hasattr(is_router_bgp_obj.vrf, 'router_bgp'):
        #yang.Sdk.createData(adv_networks_url1, '<router-bgp/>', sdata.getSession())

    adv_networks_url = device.url + '/vrfs/vrf=%s/router-bgp' % (vrf)
    yang.Sdk.createData(adv_networks_url, adv_networks_obj.getxml(filter=True), sdata.getSession())


def ip_sla(smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    vrf_name = inputdict["vrf_name"]
    entry_number = inputdict['entry_number']
    operation_type = inputdict['operation_type']
    destination = inputdict['destination']
    source = inputdict['source']
    source_interface_name = None
    source_interface_ip = None
    if source == 'source-interface':
        source_interface_name = inputdict['source_interface_name']
    elif source == 'source-ip':
        source_interface_ip = inputdict['source_interface_ip']
    data_size = inputdict['data_size']
    frequency = inputdict['frequency']
    timeout = inputdict['timeout']
    threshold = inputdict['threshold']
    track_number = inputdict['track_number']
    response_data_size = inputdict['response_data_size']
    destination_port = inputdict['destination_port']
    source_port = inputdict['source_port']
    interval = inputdict['interval']
    tos = inputdict['tos']
    tag = inputdict['tag']
    history_interval = inputdict['history_interval']
    buckets_size = inputdict['buckets_size']
    http_request_type = inputdict['http_request_type']
    http_url = inputdict['http_url']
    http_raw_request = inputdict['http_raw_request']
    num_packets = inputdict['num_packets']

    sla_obj = devices.device.ip_sla.sla.sla()
    sla_obj.vrf_name = vrf_name
    sla_obj.entry_number = entry_number
    sla_obj.operation_type = operation_type
    if operation_type == 'http':
        if util.isNotEmpty(http_request_type):
            sla_obj.http_request_type = http_request_type
        if util.isNotEmpty(http_url):
            sla_obj.http_url = http_url
        if util.isNotEmpty(http_raw_request):
            sla_obj.http_raw_request = http_raw_request
    sla_obj.destination = destination
    sla_obj.source = source
    if util.isNotEmpty(source_interface_name):
        sla_obj.source_interface_name = source_interface_name
    if util.isNotEmpty(source_interface_ip):
        sla_obj.source_interface_ip = source_interface_ip
    sla_obj.data_size = data_size
    if util.isNotEmpty(frequency):
        sla_obj.frequency = frequency
        if util.isNotEmpty(history_interval):
            sla_obj.history_interval = history_interval
            if int(history_interval)%int(frequency) != 0:
                raise Exception('History Interval should be a multiple of operation frequency')
        if util.isNotEmpty(buckets_size):
            sla_obj.buckets_size = buckets_size

    sla_obj.timeout = timeout
    sla_obj.threshold = threshold
    if util.isNotEmpty(response_data_size):
        sla_obj.response_data_size = response_data_size
    if util.isNotEmpty(destination_port):
        sla_obj.destination_port = destination_port
    if util.isNotEmpty(source_port):
        sla_obj.source_port = source_port
    if util.isNotEmpty(interval):
        sla_obj.interval = interval
    if util.isNotEmpty(tos):
        sla_obj.tos = tos
    if util.isNotEmpty(tag):
        sla_obj.tag = tag
    if util.isNotEmpty(num_packets):
        sla_obj.num_packets = num_packets

    #yang.Sdk.createData(device.url, '<ip-sla/>', sdata.getSession(), False)
    ip_sla_url = device.url + '/ip-sla'
    yang.Sdk.createData(ip_sla_url, sla_obj.getxml(filter=True), sdata.getSession())

    #yang.Sdk.createData(device.url, '<ip-sla-schedules/>', sdata.getSession(), False)
    schedules_obj = devices.device.ip_sla_schedules.ip_sla_schedule.ip_sla_schedule()
    schedules_obj.entry_number = entry_number
    ip_sla_schedules_url = device.url + '/ip-sla-schedules'
    yang.Sdk.createData(ip_sla_schedules_url, schedules_obj.getxml(filter=True), sdata.getSession())

    if util.isNotEmpty(track_number):
        #yang.Sdk.createData(device.url, '<tracks/>', sdata.getSession(), False)
        tracks_obj = devices.device.tracks.track.track()
        tracks_obj.track_number = track_number
        tracks_obj.entry_number = entry_number
        tracks_url = device.url + '/tracks'
        yang.Sdk.createData(tracks_url, tracks_obj.getxml(filter=True), sdata.getSession())


def staticroute(smodelctx, sdata, dev, **kwarg):
    vrf_name = kwarg['inputdict']['vrf']

    if vrf_name is not None:
        list_vrf = []
        obj_vrf = getLocalObject(sdata, 'customer')
        #util.log_debug("obj_vrf: ", obj_vrf)
        if hasattr(obj_vrf.customer.vrfs, 'vrf'):
            obj_vrf.customer.vrfs.vrf = util.convert_to_list(obj_vrf.customer.vrfs.vrf)
            for vrf in obj_vrf.customer.vrfs.vrf:
                if vrf.vrf_name == vrf_name:
                    vrfobj = devices.device.vrfs.vrf.vrf()
                    vrfobj.name = vrf_name
                    if hasattr(vrf, 'rd'):
                        if util.isNotEmpty(vrf.rd):
                            vrfobj.rd = vrf.rd
                    if hasattr(vrf, 'description'):
                        if util.isNotEmpty(vrf.description):
                            vrfobj.description = vrf.description
                    if util.isNotEmpty(vrf.vrf_definition_mode):
                        vrfobj.vrf_definition_mode = vrf.vrf_definition_mode

                    vrf_test_url = dev.url + 'vrfs/vrf=%s' % (vrf_name)
                    try:
                        vrf_xml_output = yang.Sdk.getData(vrf_test_url, '', smodelctx.task_id)
                        vrf_obj_get = util.parseXmlString(vrf_xml_output)
                        util.log_debug( "obj of vrf is: ",obj_get)
                    except DataNodeNotFoundException:
                        yang.Sdk.createData(dev.url + '/vrfs', vrfobj.getxml(filter=True), sdata.getSession())

                list_vrf.append(vrf.vrf_name)
        if vrf_name not in list_vrf:
            raise Exception('VRF is not part of customer')


        #is_vrf_xml_output = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
        #is_vrf_obj = util.parseXmlString(is_vrf_xml_output)
        #util.log_debug( "is_vrf_obj is:", is_vrf_obj)
        #if not hasattr(is_vrf_obj.device, 'vrfs'):
            #yang.Sdk.createData(dev.url, '<vrfs/>', sdata.getSession(), False)

        static_routes_url = dev.url + '/vrfs/vrf=%s/routes' % (vrf_name)
        static_obj1 = devices.device.vrfs.vrf.routes.route.route()
    else:
        static_routes_url = dev.url + '/routes'
        static_obj1 = devices.device.routes.route.route()

    #yang.Sdk.createData(static_routes_url, '<routes/>', sdata.getSession(), False)

    obj_local = getLocalObject(sdata, 'static-route=')
    util.log_debug("static route obj is:",obj_local.static_route)

   

    static_obj1.dest_ip_address = obj_local.static_route.dest_ip_address
    static_obj1.dest_mask = obj_local.static_route.dest_mask

    if vrf_name is None:
        get_static_route_url = dev.url + '/routes/route=%s,%s' % (obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    else:
        get_static_route_url = dev.url + '/vrfs/vrf=%s/routes/route=%s,%s' % (vrf_name,obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    try:
        xml_output = yang.Sdk.getData(get_static_route_url, '', smodelctx.task_id)
        obj_get = util.parseXmlString(xml_output)
        util.log_debug( "obj of route is: ",obj_get)
        #yang.Sdk.createData(static_routes_url, static_obj1.getxml(filter=True), sdata.getSession(), False)
    except DataNodeNotFoundException:
        yang.Sdk.createData(static_routes_url, static_obj1.getxml(filter=True), sdata.getSession())
    
    if vrf_name is not None:
        
        static_obj = devices.device.vrfs.vrf.routes.route.options.options()
       
    else:
        static_obj = devices.device.routes.route.options.options()


    id = 'ip route'
    if vrf_name is not None:
        id += ' vrf' + ' ' + vrf_name
    id += ' ' + obj_local.static_route.dest_ip_address + ' ' + obj_local.static_route.dest_mask
    interface_name = kwarg['inputdict']['interface_name']
    if interface_name is not None:
        id += ' ' + interface_name
        static_obj.interface_name = interface_name

    next_hop_ip = kwarg['inputdict']['next_hop_ip']
    if next_hop_ip is not None:
        id += ' ' + next_hop_ip
        static_obj.next_hop_ip = next_hop_ip

    if interface_name is None and next_hop_ip is None:
        raise Exception("Both Interface Name & Next Hop IP can not be empty in static routes")

    if vrf_name is not None:
        global_address = kwarg['inputdict']['global_address']
        if global_address == "true":
            id += ' ' + 'global'
            static_obj.global_address = global_address

    metric = kwarg['inputdict']['metric']
    if metric is not None:
        id += ' ' + metric
        static_obj.metric = metric

    tag = kwarg['inputdict']['tag']
    if tag is not None:
        id += ' tag ' + tag
        static_obj.tag = tag

    name = kwarg['inputdict']['name']
    if name is not None:
        id += ' name ' + name
        static_obj.name = name

    track = kwarg['inputdict']['track']
    if track is not None:
        id += ' track ' + track
        static_obj.track = track

    description = kwarg['inputdict']['description']
    if description is not None:
        static_obj.description = description
    static_obj.id = id

    if vrf_name is not None:
        static_url = dev.url + '/vrfs/vrf=%s/routes/route=%s,%s' % (vrf_name,obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    else:
        static_url = dev.url + '/routes/route=%s,%s' % (obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    
    
    yang.Sdk.createData(static_url, static_obj.getxml(filter=True), sdata.getSession())


# def delete_staticroute(smodelctx, sdata, device, **kwarg):
#     vrf_name = kwarg['inputdict']['vrf']
#     obj_local = getLocalObject(sdata, 'static-route=')
#     static_obj1 = devices.device.routes.route.route()
#     static_obj1.dest_ip_address = obj_local.static_route.dest_ip_address
#     static_obj1.dest_mask = obj_local.static_route.dest_mask
#     if vrf_name is not None:
#         static_obj = devices.device.vrfs.vrf.routes.route.options.options()
#     else:
#         static_obj = devices.device.routes.route.options.options()
#
#     id = 'ip route'
#     if vrf_name is not None:
#         id += ' vrf' + ' ' + vrf_name
#     id += ' ' + obj_local.static_route.dest_ip_address + ' ' + obj_local.static_route.dest_mask
#     interface_name = kwarg['inputdict']['interface_name']
#     if interface_name is not None:
#         id += ' ' + interface_name
#         static_obj.interface_name = interface_name
#
#     next_hop_ip = kwarg['inputdict']['next_hop_ip']
#     if next_hop_ip is not None:
#         id += ' ' + next_hop_ip
#         static_obj.next_hop_ip = next_hop_ip
#
#     if vrf_name is not None:
#         global_address = kwarg['inputdict']['global_address']
#         if global_address is not None:
#             id += ' ' + 'global'
#             static_obj.global_address = global_address
#
#     metric = kwarg['inputdict']['metric']
#     if metric is not None:
#         id += ' ' + metric
#         static_obj.metric = metric
#
#     tag = kwarg['inputdict']['tag']
#     if tag is not None:
#         id += ' tag ' + tag
#         static_obj.tag = tag
#
#     name = kwarg['inputdict']['name']
#     if name is not None:
#         id += ' name ' + name
#         static_obj.name = name
#
#     track = kwarg['inputdict']['track']
#     if track is not None:
#         id += ' track ' + track
#         static_obj.track = track
#
#     description = kwarg['inputdict']['description']
#     if description is not None:
#         static_obj.description = description
#     static_obj.id = id
#     id = id.replace(' ', '%20')
#     if vrf_name is not None:
#         static_url = device.url + '/l3features:vrfs/vrf=%s/routes/route=%s,%s/options=%s' % (vrf_name,obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask,id)
#         static_route_url = device.url + '/vrfs/vrf=%s/routes/route=%s,%s' % (vrf_name,obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
#         static_obj1 = devices.device.vrfs.vrf.routes.route.route()
#     else:
#         static_url = device.url + '/l3features:routes/route=%s,%s/options=%s' % (obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask,id)
#         static_route_url = device.url + '/routes/route=%s,%s' % (obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
#         static_obj1 = devices.device.routes.route.route()
#
#     yang.Sdk.deleteData(static_url, static_obj.getxml(filter=True), sdata.getTaskId(), sdata.getSession())
#     xml_output = yang.Sdk.getData(static_route_url, '', smodelctx.task_id)
#     obj = util.parseXmlString(xml_output)
#     util.log_debug( "obj of route is: ",obj)
#     static_obj1.dest_ip_address = obj.route.dest_ip_address
#     static_obj1.dest_mask = obj.route.dest_mask
#     if not hasattr(obj.route, 'options'):
#         yang.Sdk.deleteData(static_route_url, static_obj1.getxml(filter=True), sdata.getTaskId(), sdata.getSession())


def community_lists(community_list_name_given, device, sdata, **kwargs):
    #yang.Sdk.createData(device.url, '<community-lists/>', sdata.getSession(), False)
    obj = getLocalObject(sdata, 'customer')
    util.log_debug( "obj of communitylist is: ",obj)
    util.log_debug( "communitylist obj is:",obj.customer.community_lists)
    if hasattr(obj.customer.community_lists, 'community_list'):
        obj.customer.community_lists.community_list = util.convert_to_list(obj.customer.community_lists.community_list)
        util.log_debug( "communitylist obj is:",obj.customer.community_lists.community_list)
        for community_list_obj in obj.customer.community_lists.community_list:
            community_list_name = community_list_obj.get_field_value('community_list_name')
            if community_list_name_given == community_list_name:
                print "community_list_name is:",community_list_name
                print "community_list_name_given is:", community_list_name_given
                if community_list_obj.extcommunity == 'true':
                    extcommunity_list(sdata, device, community_list_obj)
                elif community_list_obj.extcommunity == 'false':
                    community_list(sdata, device, community_list_obj)


def community_list(sdata, device, community_list_obj_given):
    community_list_obj = devices.device.community_lists.community_list.community_list()
    community_list_entry = community_list_obj_given.community_list_entry
    if util.isNotEmpty(community_list_entry):
        community_list_obj.community_list_entry = community_list_entry
    community_list_name = community_list_obj_given.community_list_name
    if util.isNotEmpty(community_list_name):
        community_list_obj.community_list_name = community_list_name
    condition = community_list_obj_given.condition
    if util.isNotEmpty(condition):
        community_list_obj.condition = condition
    value = community_list_obj_given.value
    if util.isNotEmpty(value):
        community_list_obj.value = value
    community_list_url = device.url + '/community-lists'
    yang.Sdk.createData(community_list_url, community_list_obj.getxml(filter=True), sdata.getSession())


def extcommunity_lists(extcommunity_list_name_given, dev, sdata, **kwargs):
    #yang.Sdk.createData(dev.url, '<extcommunity-lists/>', sdata.getSession(), False)
    obj = getLocalObject(sdata, 'customer')
    util.log_debug( "extcommunitylist obj is:",obj.customer.extcommunity_lists)
    if hasattr(obj.customer.extcommunity_lists, 'extcommunity_list'):
        obj.customer.extcommunity_lists.extcommunity_list = util.convert_to_list(obj.customer.extcommunity_lists.extcommunity_list)
        util.log_debug( "extcommunitylist obj is:",obj.customer.extcommunity_lists.extcommunity_list)
        for extcommunity_list_obj in obj.customer.extcommunity_lists.extcommunity_list:
            extcommunity_list_name = extcommunity_list_obj.get_field_value('extcommunity_list_name')
            if extcommunity_list_name_given == extcommunity_list_name :
                print "extcommunity_list_name is:",extcommunity_list_name
                print "extcommunity_list_name_given is:", extcommunity_list_name_given
                extcommunity_list(sdata, dev, extcommunity_list_obj)


def extcommunity_list(sdata, device, extcommunity_list_obj_given):
    extcommunity_list_obj = devices.device.extcommunity_lists.extcommunity_list.extcommunity_list()
    extcommunity_list_entry = extcommunity_list_obj_given.community_list_entry
    if util.isNotEmpty(extcommunity_list_entry):
        extcommunity_list_obj.extcommunity_list_entry = extcommunity_list_entry
    extcommunity_list_name = extcommunity_list_obj_given.community_list_name
    if util.isNotEmpty(extcommunity_list_name):
        extcommunity_list_obj.extcommunity_list_name = extcommunity_list_name
    condition = extcommunity_list_obj_given.condition
    if util.isNotEmpty(condition):
        extcommunity_list_obj.condition = condition
    extcomm = extcommunity_list_obj_given.extcomm
    if util.isNotEmpty(extcomm):
        extcommunity_list_obj.extcomm = extcomm
    value = extcommunity_list_obj_given.value
    if util.isNotEmpty(value):
        extcommunity_list_obj.value = value
    extcommunity_list_url = device.url + '/extcommunity-lists'
    yang.Sdk.createData(extcommunity_list_url, extcommunity_list_obj.getxml(filter=True), sdata.getSession())


def modifiedGetLocalObject(sdata, elem):
    smodelctx = ServiceModelContext(id, sdata)
    rcpath = sdata.getRcPath() + '/'
    print 'rcpath = %s' % (rcpath)
    pattern = '/controller:services'
    idx = rcpath.find(pattern)
    if idx < 0:
        print 'cant find pattern in rcpath = %s' % (rcpath)
        return rcpath
    idx = rcpath.find(elem, idx)
    if idx < 0:
        print 'cant find pattern in rcpath = %s' % (rcpath)
        return rcpath
    idx = rcpath.find('/', idx)
    print 'idx = %d' % (idx)
    if idx < 0:
        print 'cant find / in rcpath = %s, idx = %d' % (rcpath, idx)
        return rcpath
    print 'rcpath = %s, new = %s' % (rcpath, rcpath[:idx])
    rcpath = rcpath[:idx]
    print 'setting rcpath= %s' % (rcpath)

    xml_output = yang.Sdk.getData(rcpath, '', smodelctx.task_id)
    obj = util.parseXmlString(xml_output)
    return obj


def interface(entity, dev, sdata, **kwarg):
    obj = getLocalObject(sdata, 'vrf=')
    redistconnected = obj.vrf.redistribute_connected_route_policy
    if util.isEmpty(redistconnected):
        raise Exception("Please provide redistribute connected route policy")
    int_name = kwarg['inputdict']['interface_name']
    seq_num = kwarg['inputdict']['entry_sequence_number']

    """
    value = None
    match_condition_url = dev.url + '/route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
    route_output = yang.Sdk.getData(match_condition_url, '', sdata.getTaskId())
    route_output = util.parseXmlString(route_output)
    
    
    if hasattr(route_output.route_map_entries,'match_condition'):
        for match_obj in util.convert_to_list(route_output.route_map_entries.match_condition):
            if match_obj.condition_type == 'interface':
                value = match_obj.value
    """

    matchcondition_obj = devices.device.route_maps.route_map.route_map_entries.match_condition.match_condition()
    matchcondition_obj.condition_type = 'interface'
    matchcondition_obj.value = int_name

    #intf_obj = devices.device.interfaces.interface.interface()
    #intf_obj.name = int_name
    #intf_obj.long_name = int_name
    #if not dev.isInterfaceInDeviceExists(int_name):
        #yang.Sdk.createData(dev.url+'/interfaces', intf_obj.getxml(filter=True), sdata.getSession())

    """
    if value is None:
        
    else:
        int_name = value + ' ' + int_name
        matchcondition_obj.value = int_name
        value = value.replace(' ', '%20')
        match_condition_url1 = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (redistconnected,seq_num,value)
        yang.Sdk.deleteData(match_condition_url1, '', sdata.getTaskId(), sdata.getSession())
    """
    match_condition_url = dev.url + '/route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
    yang.Sdk.createData(match_condition_url, matchcondition_obj.getxml(filter=True), sdata.getSession(), False)


def vrf(entity, dev, sdata, **kwarg):

    print "Entering into vrf creation"

    vrf_name = kwarg['inputdict']['vrf_name']
    if util.isEmpty(vrf_name):
        vrf_name = "GLOBAL"
    is_vrf_xml_output = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
    is_vrf_obj = util.parseXmlString(is_vrf_xml_output)
    util.log_debug( "is_vrf_obj is:", is_vrf_obj)
    #if not hasattr(is_vrf_obj.device, 'vrfs'):
        #yang.Sdk.createData(dev.url, '<vrfs/>', sdata.getSession(), False)

    uri = sdata.getRcPath()
    uri_list = uri.split('/',5)
    url = '/'.join(uri_list[0:4])

    if vrf_name != 'GLOBAL':
        xml_output = yang.Sdk.getData(url+"/vrfs", '',sdata.getTaskId())
        obj = util.parseXmlString(xml_output)
        util.log_debug( "obj: ",obj)

        if hasattr(obj.vrfs, 'vrf'):
            obj.vrfs.vrf = util.convert_to_list(obj.vrfs.vrf)
            for vrf in obj.vrfs.vrf:
                if vrf.vrf_name == vrf_name:
                    vrfobj = devices.device.vrfs.vrf.vrf()
                    vrfobj.name = vrf_name
                    if hasattr(vrf, 'rd'):
                        if util.isNotEmpty(vrf.rd):
                            vrfobj.rd = vrf.rd
                    if hasattr(vrf, 'description'):
                        if util.isNotEmpty(vrf.description):
                            vrfobj.description = vrf.description
                    if util.isNotEmpty(vrf.vrf_definition_mode):
                        vrfobj.vrf_definition_mode = vrf.vrf_definition_mode
                    yang.Sdk.createData(dev.url + '/vrfs', vrfobj.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'rt_import'):
                        vrf.rt_import = util.convert_to_list(vrf.rt_import)
                        for rtimport in vrf.rt_import:
                            vrfobj1 = devices.device.vrfs.vrf.rt_import.rt_import()
                            if util.isNotEmpty(rtimport.rt_import):
                                vrfobj1.rt_import = rtimport.rt_import
                            import_url = dev.url + '/vrfs/vrf=%s' % (vrf_name)
                            yang.Sdk.createData(import_url, vrfobj1.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'rt_export'):
                        vrf.rt_export = util.convert_to_list(vrf.rt_export)
                        for rtexport in vrf.rt_export:
                            vrfobj1 = devices.device.vrfs.vrf.rt_export.rt_export()
                            if util.isNotEmpty(rtexport.rt_export):
                                vrfobj1.rt_export = rtexport.rt_export
                            export_url = dev.url + '/vrfs/vrf=%s' % (vrf_name)
                            yang.Sdk.createData(export_url, vrfobj1.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'import_map'):
                        vrf.import_map = util.convert_to_list(vrf.import_map)
                        for importmap in vrf.import_map:
                            vrfobj1 = devices.device.vrfs.vrf.import_map.import_map()
                            if util.isNotEmpty(importmap.import_map):
                                route_maps(importmap.import_map, dev, sdata)
                                vrfobj1.import_map = importmap.import_map
                            if hasattr(importmap, 'ipv4'):
                                vrfobj1.ipv4 = importmap.ipv4
                            if hasattr(importmap, 'traffic'):
                                if util.isNotEmpty(importmap.traffic):
                                    vrfobj1.table = importmap.traffic
                            if hasattr(importmap, 'upper_limit'):
                                if util.isNotEmpty(importmap.upper_limit):
                                    vrfobj1.upper_limit = importmap.upper_limit
                            importmap_url = dev.url + '/vrfs/vrf=%s' % (vrf_name)
                            yang.Sdk.createData(importmap_url, vrfobj1.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'export_map'):
                        vrf.export_map = util.convert_to_list(vrf.export_map)
                        for exportmap in vrf.export_map:
                            vrfobj1 = devices.device.vrfs.vrf.export_map.export_map()
                            if util.isNotEmpty(exportmap.export_map):
                                route_maps(exportmap.export_map, dev, sdata)
                                vrfobj1.export_map = exportmap.export_map
                            if hasattr(exportmap, 'ipv4'):
                                vrfobj1.ipv4 = exportmap.ipv4
                            if hasattr(exportmap, 'traffic'):
                                if util.isNotEmpty(exportmap.traffic):
                                    vrfobj1.table = exportmap.traffic
                            if hasattr(exportmap, 'upper_limit'):
                                if util.isNotEmpty(exportmap.upper_limit):
                                    vrfobj1.upper_limit = exportmap.upper_limit
                            importmap_url = dev.url + '/vrfs/vrf=%s' % (vrf_name)
                            yang.Sdk.createData(importmap_url, vrfobj1.getxml(filter=True), sdata.getSession())
    else:
        vrfobj = devices.device.vrfs.vrf.vrf()
        vrfobj.name = vrf_name
        yang.Sdk.createData(dev.url + '/vrfs', vrfobj.getxml(filter=True), sdata.getSession())

    bgpas = None
    if entity == 'cpe_dual':
        obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
        if hasattr(obj.single_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe':
        obj = getLocalObject(sdata, 'single-cpe-site-services')
        if hasattr(obj.single_cpe_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_site_services.bgp_as
    elif entity == 'cpe_primary' or entity == 'cpe_secondary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
    elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe_primary_triple' or entity == 'cpe_secondary_triple' or entity == 'cpe_tertiary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as

    bgprouterid = kwarg['inputdict']['bgp_router_id']
    bgp_community_new = kwarg['inputdict']['bgp_community_new']
    bgpaddfamily = kwarg['inputdict']['bgp_address_family']
    bgpglobalkeepalive = kwarg['inputdict']['bgp_keepalive_timer']
    bgpglobalholdtime = kwarg['inputdict']['bgp_holdtime_timer']
    default_information_originate = kwarg['inputdict']['default_information_originate']
    peer_group = kwarg['inputdict']['peer_group']
    listen_cidr = kwarg['inputdict']['listen_cidr']
    if bgp_community_new == "true":
        newobj = devices.device.bgp.bgp()
        newobj.bgp_community_new = 'true'
        yang.Sdk.createData(dev.url, newobj.getxml(filter=True), sdata.getSession())

    bgpobj = devices.device.vrfs.vrf.router_bgp.router_bgp()
    if util.isNotEmpty(bgpas):
        bgpobj.as_number = bgpas
        if util.isNotEmpty(bgprouterid) and vrf_name == 'GLOBAL':
            bgpobj.router_id = bgprouterid
        if vrf_name == 'GLOBAL':
            bgpobj.log_neighbor_changes = "true"
        if vrf_name != 'GLOBAL':
            if util.isEmpty(bgpaddfamily):
                raise Exception("Address family should not be empty when vrf is given")
        bgpobj.address_family = bgpaddfamily
        bgpobj.bgp_holdtime_timer = bgpglobalholdtime
        bgpobj.bgp_keepalive_timer = bgpglobalkeepalive
        #bgpobj.address_family = "ipv4"
        bgpobj.default_information_originate = default_information_originate
        router_bgp_url = dev.url + '/vrfs/vrf=%s' % (vrf_name)
        yang.Sdk.createData(router_bgp_url, bgpobj.getxml(filter=True), sdata.getSession())

    if util.isNotEmpty(listen_cidr) and util.isNotEmpty(peer_group) and vrf_name == 'GLOBAL':
        bgp_listen_obj = devices.device.vrfs.vrf.router_bgp.listen_range.listen_range()
        bgp_listen_obj.name = peer_group
        bgp_listen_obj.cidr = listen_cidr
        router_bgp_listen_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
        yang.Sdk.createData(router_bgp_listen_url, bgp_listen_obj.getxml(filter=True), sdata.getSession())

    if util.isNotEmpty(peer_group):
        xml_output = yang.Sdk.getData(url+"/bgp-peer-groups", '',sdata.getTaskId())
        obj = util.parseXmlString(xml_output)
        util.log_debug( "obj: ",obj)
        remote_as = peer_description = next_hop_self = send_community = import_route_map = None
        export_route_map = soft_reconfiguration = password = default_originate = None
        default_originate_route_map = timers = keepalive_interval = holdtime = None
        advertisement_interval = time_in_sec = None
        if hasattr(obj.bgp_peer_groups, 'bgp_peer_group'):
            obj.bgp_peer_groups.bgp_peer_group = util.convert_to_list(obj.bgp_peer_groups.bgp_peer_group)
            for peergroup in obj.bgp_peer_groups.bgp_peer_group:
                if peergroup.peer_group == peer_group:
                    if hasattr(peergroup, 'remote_as'):
                        remote_as = peergroup.remote_as
                    if hasattr(peergroup, 'peer_description'):
                        peer_description = peergroup.peer_description
                    if hasattr(peergroup, 'next_hop_self'):
                        next_hop_self = peergroup.next_hop_self
                    if hasattr(peergroup, 'send_community'):
                        send_community = peergroup.send_community
                    if hasattr(peergroup, 'import_route_map'):
                        import_route_map = peergroup.import_route_map
                    if hasattr(peergroup, 'export_route_map'):
                        export_route_map = peergroup.export_route_map
                    if hasattr(peergroup, 'soft_reconfiguration'):
                        soft_reconfiguration = peergroup.soft_reconfiguration
                    if hasattr(peergroup, 'password'):
                        password = peergroup.password
                    if hasattr(peergroup, 'default_originate'):
                        default_originate = peergroup.default_originate
                    if hasattr(peergroup, 'default_originate_route_map'):
                        default_originate_route_map = peergroup.default_originate_route_map
                    if hasattr(peergroup, 'timers'):
                        timers = peergroup.timers
                    if hasattr(peergroup, 'keepalive_interval'):
                        keepalive_interval = peergroup.keepalive_interval
                    if hasattr(peergroup, 'holdtime'):
                        holdtime = peergroup.holdtime
                    if hasattr(peergroup, 'advertisement_interval'):
                        advertisement_interval = peergroup.advertisement_interval
                    if hasattr(peergroup, 'time_in_sec'):
                        time_in_sec = peergroup.time_in_sec

        bgp_neighbor_obj = devices.device.vrfs.vrf.router_bgp.peer_group.peer_group()
        bgp_neighbor_obj.name = peer_group
        if util.isNotEmpty(remote_as) or remote_as is not None:
            bgp_neighbor_obj.remote_as = remote_as
        if util.isNotEmpty(peer_description) or peer_description is not None:
            bgp_neighbor_obj.description = peer_description
        if util.isNotEmpty(next_hop_self) or next_hop_self is not None:
            bgp_neighbor_obj.next_hop_self = next_hop_self
        if util.isNotEmpty(send_community) or send_community is not None:
            bgp_neighbor_obj.send_community = send_community
        if util.isNotEmpty(import_route_map) or import_route_map is not None:
            bgp_neighbor_obj.in_route_map = import_route_map
        if util.isNotEmpty(export_route_map) or export_route_map is not None:
            bgp_neighbor_obj.out_route_map = export_route_map
        if util.isNotEmpty(soft_reconfiguration) or soft_reconfiguration is not None:
            bgp_neighbor_obj.soft_reconfiguration = soft_reconfiguration
        if util.isNotEmpty(password) or password is not None:
            bgp_neighbor_obj.password = password
        if util.isNotEmpty(default_originate) or default_originate is not None:
            bgp_neighbor_obj.default_originate = default_originate
        if util.isNotEmpty(default_originate_route_map) or default_originate_route_map is not None:
            bgp_neighbor_obj.def_originate_route_map = default_originate_route_map
        if timers == 'true':
            bgp_neighbor_obj.keepalive_interval = keepalive_interval
            bgp_neighbor_obj.holdtime = holdtime
        if advertisement_interval == 'true':
            bgp_neighbor_obj.advertisement_interval = time_in_sec
        router_bgp_neighbor_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
        yang.Sdk.createData(router_bgp_neighbor_url, bgp_neighbor_obj.getxml(filter=True), sdata.getSession())

    redistconnected = kwarg['inputdict']['redistribute_connected']
    if redistconnected == 'true':
        redistroutepolicy = kwarg['inputdict']['redistribute_connected_route_policy']
        if redistroutepolicy is not None:
            route_maps(redistroutepolicy, dev, sdata)

            rebgpredisobj1 = devices.device.vrfs.vrf.router_bgp.redistribute.redistribute()
            rebgpredisobj1.protocol = 'connected'
            rebgpredisobj1.route_map = redistroutepolicy
            router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())

    rediststatic = kwarg['inputdict']['redistribute_static']
    if rediststatic == 'true':
        redistroutepolicy = kwarg['inputdict']['redistribute_static_route_policy']
        if redistroutepolicy is not None:
            route_maps(redistroutepolicy, dev, sdata)
            rebgpredisobj1 = devices.device.vrfs.vrf.router_bgp.redistribute.redistribute()
            rebgpredisobj1.protocol = 'static'
            rebgpredisobj1.route_map = redistroutepolicy
            router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())

    aggsumnetworks = kwarg['inputdict']['aggregate_summary_networks']
    if aggsumnetworks == 'true':
        sumnetworks = kwarg['inputdict']['summary_networks']
        if sumnetworks is not None:
            each_sumnet = sumnetworks.split(",")
            for i in range(len(each_sumnet)):
                net = each_sumnet[i].strip()
                summaryobj = devices.device.vrfs.vrf.router_bgp.aggregate_summary_network.aggregate_summary_network()
                cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
                if re.match(cidr_pattern,net) == None:
                    raise Exception("Please provide CIDR for summary networks")

                netmasklen = net.split("/")[1]
                prefix = util.IPPrefix(net)
                ip_address = prefix.address
                netmask = prefix.netmask
                summaryobj.network = ip_address + ' ' + netmask
                router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
                yang.Sdk.createData(router_bgp_redist_url, summaryobj.getxml(filter=True), sdata.getSession())


class ServiceModelContext(yang.ServiceModelContext):
    def __init__(self, id, sdata):
        yang.ServiceModelContext.__init__(self, id, sdata)
        self.load_service_object()

    def load_service_object(self):
        pattern = '/controller:services/cpedeployment:managed-cpe-services'
        key = 'service_object.%s' % (self.service_rcpath)
        obj = self.sdata.getSessionItem(key)
        if obj != None:
          log('load_service_object:cache-hit key=%s' % (key))
          self.service_obj = obj
          log('Getting service object from cache. rcPath = %s' % (self.service_rcpath))
          return obj
        log('load_service_object:cache-miss key=%s' % (key))
        self.service_rcpath = pattern
        log('setting rcpath = %s' % (self.service_rcpath))
        yang.ServiceModelContext.load_service_object(self, self.service_rcpath)
        self.service_obj = self.service_xmlobj
        #log('[ServiceModelContext]service_obj: %s' % (self.service_obj))
        obj = self.service_obj
        self.sdata.setSessionItem(key, obj, True)
        return obj
