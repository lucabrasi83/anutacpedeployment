#
# This computer program is the confidential information and proprietary trade
# secret of Anuta Networks, Inc. Possessions and use of this program must
# conform strictly to the license agreement between the user and
# Anuta Networks, Inc., and receipt or possession does not convey any rights
# to divulge, reproduce, or allow others to use this program without specific
# written authorization of Anuta Networks, Inc.
#
# Copyright (c) 2015-2016 Anuta Networks, Inc. All Rights Reserved.
#

#
#DO NOT EDIT THIS FILE ITS AUTOGENERATED ONE
#

from servicemodel import util
from servicemodel import yang
from servicemodel import devicemgr
import copy
import re
from servicemodel.controller.devices.device import vrfs
from servicemodel.controller.devices.device import ip_nat_pool
from servicemodel.controller.devices.device import ip_nat
from servicemodel.controller.devices.device import access_lists
from servicemodel.controller.devices.device import object_groups_acl
from servicemodel.controller.devices.device import ip_prefixlist_list
from servicemodel.controller.devices.device import route_maps
from servicemodel.controller.devices.device import as_path_acls
from servicemodel.controller.devices.device import ip_sla
from servicemodel.controller.devices.device import ip_sla_schedules
from servicemodel.controller.devices.device import tracks
from servicemodel.controller.devices.device import routes
from servicemodel.controller.devices.device import community_lists
from servicemodel.controller.devices.device import extcommunity_lists
from servicemodel.controller.devices.device import interfaces
from servicemodel.controller.devices.device import bgp

from com.anuta.api import DataNodeNotFoundException

managed_cpe_services_debug = False


def log(s):
  if managed_cpe_services_debug:
    util.log_debug(s)


def getCurrentObjectConfig(id, sdata, currentobj, invalidate_cache=False):
    log('id = %s, serviceData = %s' % (id, sdata))
    log('payload: %s' % (sdata.getPayload()))

    # using util library to parse xml
    # sdata.getPayload() will return a XML string posted by user
    key = 'current_config'
    config = sdata.getSessionItem(key)
    if config == None:
      config = util.parseXmlString(sdata.getPayload())
      sdata.setSessionItem(key, config, False) # set this specific to this callback
      log('getCurrentObjectConfig:cache-miss key=%s' % (key))
    else:
      log('getCurrentObjectConfig:cache-hit key=%s' % (key))
    if currentobj is not None and hasattr(config, currentobj):
      config = getattr(config, currentobj)
    else:
      log('%s attribute not present in current configuration'%currentobj)
      return None
    log('getCurrentObjectConfig: %s' % (config.toXml()))
    return config

def getPreviousObjectConfig(id, sdata, prevobj):
    log('id = %s, serviceData = %s' % (id, sdata))
    log('previous payload: %s' % (sdata.getPreviousPayload()))

    # using util library to parse xml
    # sdata.getPreviousPayload() will return a Previous XML string posted by user
    config = util.parseXmlString(sdata.getPreviousPayload())
    if prevobj is not None and hasattr(config, prevobj):
        config = getattr(config, prevobj)
    else:
        log('%s attribute not present in current configuration'%prevobj)
        return None
    log(config.toXml())
    return config

def getInputDict(config):
    inputattribs = config.__dict__
    inputdict=copy.deepcopy(inputattribs)
    return inputdict


def getDeviceObject(mgmt_leaf, sdata = None):
    key = 'device.%s' % (mgmt_leaf)
    if sdata != None:
        dev = sdata.getSessionItem(key)
        if dev != None:
            log('getDeviceObject:cache-hit key=%s' % (key))
            return dev
        else:
            log('getDeviceObject:cache-miss key=%s' % (key))
          
    dev = []
    for device in util.convert_to_list(mgmt_leaf):
      dev_object = devicemgr.getDeviceById(device, False, 5)
      if (dev_object == None):
          log('No device by ip: %s' % (mgmt_leaf))
          raise Exception('No device by ip: %s' % (mgmt_leaf))
      dev.append(dev_object)
    if sdata != None:
      sdata.setSessionItem(key, dev, True)
    return dev


def getParentObject(sdata):
    rcpath =  util.get_parent_rcpath(sdata.getRcPath())
    log('setting rcpath= %s' % (rcpath))

    key = 'parent.%s' % (rcpath)
    obj = sdata.getSessionItem(key)
    if obj != None:
        log('getParentObject:cache-hit key=%s' % (key))
        return obj
    log('getParentObject:cache-miss key=%s' % (key))
    xml_output = yang.Sdk.getData(rcpath, '', sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    if obj != None:
      sdata.setSessionItem(key, obj, True)

    return obj


def find_exact_match_first_occurance (rcpath, elem, relativedist):
    idx = rcpath.find(elem)
    if idx < 0:
        log('cant find pattern in rcpath = %s' % (rcpath))
        return relativedist
    idx = rcpath.find('/', idx)
    if idx < 0:
        log('cant find / in rcpath = %s, idx = %d' % (rcpath, idx))
        return relativedist

    trcpath = rcpath[:idx]
    relativedist = relativedist + idx
    if trcpath.split('/')[-1] != elem:
        trcpath = rcpath[idx:]
        return find_exact_match_first_occurance(trcpath, elem, relativedist)
    return relativedist


def getLocalObject(sdata, elem):
    rcpath = sdata.getRcPath()
    log('rcpath = %s' % (rcpath))
    pattern = '/controller:services'
    idx = rcpath.find(pattern)
    if idx < 0:
        log('cant find pattern in rcpath = %s' % (rcpath))
        return rcpath

    idx = find_exact_match_first_occurance(rcpath, elem, 0)
    log('rcpath = %s, new = %s' % (rcpath, rcpath[:idx]))
    rcpath = rcpath[:idx]

    key = 'local.%s' % (rcpath)
    obj = sdata.getSessionItem(key)
    if obj == None:
      log('getLocalObject:cache-miss key=%s' % (key))
      xml_output = yang.Sdk.getData(rcpath, '', sdata.getTaskId())
      #log('%s object: %s' % (elem, xml_output))
      obj = util.parseXmlString(xml_output)
      sdata.setSessionItem(key, obj, True)
    else:
      log('getLocalObject:cache-hit key=%s' % (key))
      
    return obj


def natstatic(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    side = inputdict['side']
    address_translation = inputdict['address_translation']
    static = inputdict['static']
    network = inputdict['network']
    inside_ip = inputdict['inside_ip']
    inside_global_ip = inputdict['inside_global_ip']
    route_map = inputdict['route_map']
    prefix_length = inputdict['prefix_length']
    natstaticobj = ip_nat.address_translation.address_translation()
    natstaticobj.side = side
    natstaticobj.address_translation = address_translation
    natstaticobj.nat_list = static
    natstaticobj.value = inside_ip
    natstaticobj.inside_global_ip = inside_global_ip
    if network == 'false':
        natstaticobj.route_map_name = route_map
        route_maps(route_map, dev, sdata)
    natstaticobj.network = network
    if network == 'true':
        if '/' not in prefix_length and util.isNotEmpty(prefix_length):
            natstaticobj.prefix_length = '/'+ prefix_length
        else:
            natstaticobj.prefix_length = prefix_length
    if not yang.Sdk.dataExists(dev.url + '/l3features:ip-nat'):
        yang.Sdk.createData(dev.url, '<ip-nat/>', sdata.getSession(), False)
    yang.Sdk.createData(dev.url + '/l3features:ip-nat', natstaticobj.getxml(filter=True), sdata.getSession())


def nattranslation(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    nat_flow = inputdict['nat_flow']
    timeout = inputdict['timeout']
    nattranslationobj = ip_nat.nat_translation.nat_translation()
    nattranslationobj.nat_flow = nat_flow
    nattranslationobj.timeout = timeout
    if not yang.Sdk.dataExists(dev.url + '/l3features:ip-nat'):
        yang.Sdk.createData(dev.url, '<ip-nat/>', sdata.getSession(), False)
    yang.Sdk.createData(dev.url + '/l3features:ip-nat', nattranslationobj.getxml(filter=True), sdata.getSession())


def natpool(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    pool_name = inputdict['pool_name']
    start_ip = inputdict['start_ip']
    end_ip = inputdict['end_ip']
    mask = inputdict['mask']
    netmask = inputdict['netmask']
    prefix_length = inputdict['prefix_length']
    pool_type = inputdict['pool_type']
    natobj = ip_nat_pool.pool.pool()
    natobj.pool_name = pool_name
    natobj.start_ip = start_ip
    natobj.end_ip = end_ip
    natobj.mask = mask
    if mask == 'netmask':
        natobj.netmask = netmask
    elif mask == 'prefix-length':
        natobj.prefix_length = prefix_length
    if util.isNotEmpty(pool_type):
        natobj.pool_type = pool_type

    natpool_url = dev.url + '/l3features:ip-nat-pool'
    yang.Sdk.createData(natpool_url, natobj.getxml(filter=True), sdata.getSession())


def nat_trans_pool(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    pool_name = inputdict['pool_name']
    vrf = inputdict['vrf']
    overload = inputdict['overload']
    obj = getLocalObject(sdata, 'address-translation')
    if hasattr(obj.address_translation, 'side'):
        side = obj.address_translation.side
    else:
        side = None
    if hasattr(obj.address_translation, 'address_translation'):
        address_translation = obj.address_translation.address_translation
    else:
        address_translation = None
    if hasattr(obj.address_translation, 'list'):
        list = obj.address_translation.list
    else:
        list = None
    if hasattr(obj.address_translation, 'value'):
        value = obj.address_translation.value
        from endpoint_lib import access_group_def
        uri = sdata.getRcPath()
        uri_list = uri.split('/',5)
        url = '/'.join(uri_list[0:4])
        acl_url = url+"/access-lists/access-list=%s" % (value)
        if yang.Sdk.dataExists(acl_url):
            access_group_def(url, value, dev, sdata)
        
    else:
        value = None
    natobj = ip_nat.address_translation.address_translation()
    natobj.side = side
    natobj.address_translation = address_translation
    natobj.nat_list = list
    natobj.value = value
    if not yang.Sdk.dataExists(dev.url + '/l3features:ip-nat'):
        yang.Sdk.createData(dev.url, '<ip-nat/>', sdata.getSession(), False)
    yang.Sdk.createData(dev.url + '/l3features:ip-nat', natobj.getxml(filter=True), sdata.getSession())
    natobj_pool = ip_nat.address_translation.pool.pool()
    natobj_pool.pool_name = pool_name
    natobj_pool.vrf = vrf
    natobj_pool.overload = overload
    natobj_pool.match_in_vrf = 'false'
    natobj_pool.oer = 'false'
    natpool_url = dev.url + '/l3features:ip-nat/address-translation=%s,%s' % (list,value)
    yang.Sdk.createData(natpool_url, natobj_pool.getxml(filter=True), sdata.getSession())


def nat_trans_int(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    interface_name = inputdict['interface_name']
    vrf = inputdict['vrf']
    overload = inputdict['overload']
    obj = getLocalObject(sdata, 'address-translation')
    if hasattr(obj.address_translation, 'side'):
        side = obj.address_translation.side
    else:
        side = None
    if hasattr(obj.address_translation, 'address_translation'):
        address_translation = obj.address_translation.address_translation
    else:
        address_translation = None
    if hasattr(obj.address_translation, 'list'):
        list = obj.address_translation.list
    else:
        list = None
    if hasattr(obj.address_translation, 'value'):
        value = obj.address_translation.value
        from endpoint_lib import access_group_def
        uri = sdata.getRcPath()
        uri_list = uri.split('/',5)
        url = '/'.join(uri_list[0:4])
        acl_url = url+"/access-lists/access-list=%s" % (value)
        if yang.Sdk.dataExists(acl_url):
            access_group_def(url, value, dev, sdata)
        
    else:
        value = None
    natobj = ip_nat.address_translation.address_translation()
    natobj.side = side
    natobj.address_translation = address_translation
    natobj.nat_list = list
    natobj.value = value
    if not yang.Sdk.dataExists(dev.url + '/l3features:ip-nat'):
        yang.Sdk.createData(dev.url, '<ip-nat/>', sdata.getSession(), False)
    yang.Sdk.createData(dev.url + '/l3features:ip-nat', natobj.getxml(filter=True), sdata.getSession())
    natobj_pool = ip_nat.address_translation.interface.interface()
    natobj_pool.interface_name = interface_name
    natobj_pool.vrf = vrf
    natobj_pool.overload = overload
    natobj_pool.oer = 'false'
    natobj_pool.extended = 'false'
    natpool_url = dev.url + '/l3features:ip-nat/address-translation=%s,%s' % (list,value)
    yang.Sdk.createData(natpool_url, natobj_pool.getxml(filter=True), sdata.getSession())


def eigrpRedis(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    protocol = inputdict['protocol']
    as_number = inputdict['as_number']
    ospf_id = inputdict['ospf_id']
    route_map = inputdict['route_map']
    bandwidth_metric = inputdict['bandwidth_metric']
    delay_metric = inputdict['delay_metric']
    reliability_metric = inputdict['reliability_metric']
    load_metric = inputdict['load_metric']
    mtu = inputdict['mtu']
    vrf = None
    process_id = None
    obj_in = getLocalObject(sdata, 'router-eigrp')
    if hasattr(obj_in.router_eigrp, 'process_id'):
        process_id = obj_in.router_eigrp.process_id
    if hasattr(obj_in.router_eigrp, 'vrf_name'):
        vrf = obj_in.router_eigrp.vrf_name
        if util.isEmpty(vrf):
            if entity == 'cpe':
                obj = getLocalObject(sdata, 'single-cpe-site-services')
                if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_site_services.cpe.vrf_name
            elif entity == 'cpe_dual':
                obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
            elif entity == 'cpe_primary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
            elif entity == 'cpe_secondary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'

    if entity == 'cpe':
        obj = getLocalObject(sdata, 'single-cpe-site-services')
        if hasattr(obj.single_cpe_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_site_services.bgp_as
    elif entity == 'cpe_dual':
        obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
        if hasattr(obj.single_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe_primary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
    elif entity == 'cpe_primary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe_primary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
    elif entity == 'cpe_secondary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
    elif entity == 'cpe_secondary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe_secondary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
    elif entity == 'cpe_tertiary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as

    eigrpredisobj1 = vrfs.vrf.router_eigrp.eigrp.redistribute.redistribute()
    eigrpredisobj1.protocol = protocol
    if protocol == 'bgp':
        eigrpredisobj1.as_number = bgpas
    if protocol == 'ospf':
        eigrpredisobj1.ospf_id = ospf_id
    if protocol == 'eigrp':
        eigrpredisobj1.as_number = as_number
    if util.isNotEmpty(route_map):
        eigrpredisobj1.route_map = route_map
        route_maps(route_map, dev, sdata)
    if util.isNotEmpty(bandwidth_metric):
        eigrpredisobj1.bandwidth_metric = bandwidth_metric
    if util.isNotEmpty(delay_metric):
        eigrpredisobj1.delay_metric = delay_metric
    if util.isNotEmpty(reliability_metric):
        eigrpredisobj1.reliability_metric = reliability_metric
    if util.isNotEmpty(load_metric):
        eigrpredisobj1.load_metric = load_metric
    if util.isNotEmpty(mtu):
        eigrpredisobj1.mtu = mtu

    eigrp_red_url = dev.url + '/l3features:vrfs/vrf=%s/router-eigrp/eigrp=%s' % (vrf, process_id)
    yang.Sdk.createData(eigrp_red_url, eigrpredisobj1.getxml(filter=True), sdata.getSession())


def eigrpPassive(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    interface = inputdict['interface']
    passive_interface = inputdict['passive_interface']
    vrf = None
    process_id = None
    obj_in = getLocalObject(sdata, 'router-eigrp')
    if hasattr(obj_in.router_eigrp, 'process_id'):
        process_id = obj_in.router_eigrp.process_id
    if hasattr(obj_in.router_eigrp, 'vrf_name'):
        vrf = obj_in.router_eigrp.vrf_name
        if util.isEmpty(vrf):
            if entity == 'cpe':
                obj = getLocalObject(sdata, 'single-cpe-site-services')
                if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_site_services.cpe.vrf_name
            elif entity == 'cpe_dual':
                obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
            elif entity == 'cpe_primary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
            elif entity == 'cpe_secondary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    '''
    if vrf is None:
        vrf = 'GLOBAL'

    eigrp_passive_obj = vrfs.vrf.router_eigrp.eigrp.passive_interface.passive_interface()
    if util.isNotEmpty(interface):
        eigrp_passive_obj.interface = interface
    if util.isNotEmpty(passive_interface):
        eigrp_passive_obj.passive_interface = passive_interface

    eigrp_passive_url = dev.url + '/l3features:vrfs/vrf=%s/router-eigrp/eigrp=%s' % (vrf,process_id)
    yang.Sdk.createData(eigrp_passive_url, eigrp_passive_obj.getxml(filter=True), sdata.getSession())
    '''
    if vrf is None:
        vrf = 'GLOBAL'
    eigrp_passive_url = dev.url + '/l3features:vrfs/vrf=%s/router-eigrp/eigrp=%s' % (vrf,process_id)

    if interface != 'default':
        passive_url = '/controller:devices/device=%s/l3features:vrfs/vrf=%s/router-eigrp/eigrp=%s/passive-interface=default' % (dev.device.id, vrf, process_id)
        if not yang.Sdk.dataExists(passive_url):
            eigrp_passive_obj = vrfs.vrf.router_eigrp.eigrp.passive_interface.passive_interface()
            eigrp_passive_obj.interface = 'default'
            eigrp_passive_obj.passive_interface = 'true'
            yang.Sdk.createData(eigrp_passive_url, eigrp_passive_obj.getxml(filter=True), sdata.getSession(), False)

    eigrp_passive_obj = vrfs.vrf.router_eigrp.eigrp.passive_interface.passive_interface()

    if util.isNotEmpty(passive_interface):
        if passive_interface == 'false':
            eigrp_passive_obj.passive_interface = passive_interface
            if util.isNotEmpty(interface):
                eigrp_passive_obj.interface = interface
        elif interface == 'default' and passive_interface == 'true':
            eigrp_passive_obj.passive_interface = passive_interface
            if util.isNotEmpty(interface):
                eigrp_passive_obj.interface = interface

    yang.Sdk.createData(eigrp_passive_url, eigrp_passive_obj.getxml(filter=True), sdata.getSession())

def eigrp(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    vrf = inputdict['vrf_name']
    process_id = inputdict['process_id']
    eigrp_stub = inputdict['eigrp_stub']
    router_id = inputdict['router_id']
    distance_internal_routes = inputdict['distance_internal_routes']
    distance_external_routes = inputdict['distance_external_routes']
    nsf = inputdict['nsf']
    default_metric = inputdict['default_metric']
    bandwidth_metric = inputdict['bandwidth_metric']
    delay_metric = inputdict['delay_metric']
    reliability_metric = inputdict['reliability_metric']
    load_metric = inputdict['load_metric']
    mtu_metric = inputdict['mtu_metric']

    '''
    if util.isEmpty(vrf):
        if entity == 'cpe':
            obj = getLocalObject(sdata, 'single-cpe-site-services')
            if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                vrf = obj.single_cpe_site_services.cpe.vrf_name
        elif entity == 'cpe_dual':
            obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
            if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
        elif entity == 'cpe_primary':
            obj = getLocalObject(sdata, 'dual-cpe-site-services')
            if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
        elif entity == 'cpe_secondary':
            obj = getLocalObject(sdata, 'dual-cpe-site-services')
            if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name
        elif entity == 'cpe_primary_dual':
            obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
            if hasattr(obj.dual_cpe_dual_wan_site_services.cpe_primary, 'vrf_name'):
                vrf = obj.dual_cpe_dual_wan_site_services.cpe_primary.vrf_name
        elif entity == 'cpe_secondary_dual':
            obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
            if hasattr(obj.dual_cpe_dual_wan_site_services.cpe_secondary, 'vrf_name'):
                vrf = obj.dual_cpe_dual_wan_site_services.cpe_secondary.vrf_name
    '''
    if util.isEmpty(vrf):
        vrf = 'GLOBAL'

    eigrp_obj = vrfs.vrf.router_eigrp.eigrp.eigrp()
    eigrp_obj.process_id = process_id
    if util.isNotEmpty(eigrp_stub):
        eigrp_obj.eigrp_stub = eigrp_stub
    if util.isNotEmpty(router_id):
        eigrp_obj.router_id = router_id
    if util.isNotEmpty(nsf):
        eigrp_obj.nsf = nsf
    if util.isNotEmpty(distance_internal_routes):
        eigrp_obj.internal_route_distance = distance_internal_routes
    if util.isNotEmpty(distance_external_routes):
        eigrp_obj.external_route_distance = distance_external_routes

    eigrp_url = dev.url + '/l3features:vrfs/vrf=%s/router-eigrp' % (vrf)
    yang.Sdk.createData(eigrp_url, eigrp_obj.getxml(filter=True), sdata.getSession())

    if default_metric == "true":
        from servicemodel.controller.devices.device.vrfs.vrf.router_eigrp.eigrp.default_metric import default_metric

        eigrp_metric_obj = default_metric()
        eigrp_metric_obj.bandwidth_metric = bandwidth_metric
        eigrp_metric_obj.delay_metric = delay_metric
        eigrp_metric_obj.reliability_metric = reliability_metric
        eigrp_metric_obj.load_metric = load_metric
        eigrp_metric_obj.mtu = mtu_metric

        eigrp_proc_url = eigrp_url + '/eigrp=%s' % (process_id)

        yang.Sdk.createData(eigrp_proc_url, eigrp_metric_obj.getxml(filter=True), sdata.getSession())

def eigrp_network(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    prefix_in = inputdict['prefix']
    prefix = util.IPPrefix(prefix_in)
    ip_address = prefix.address
    wildcard = prefix.wildcard
    (addrStr, cidrStr) = prefix_in.split('/')
    addr = addrStr.split('.')
    cidr = int(cidrStr)
    mask = [0, 0, 0, 0]
    for i in range(cidr):
        mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
    #net = []
    #for i in range(4):
        #net.append(int(addr[i]) & mask[i])
    net = [int(addr[i]) & mask[i] for i in xrange(4)]

    network = ".".join(map(str, net))
    vrf = None
    obj_in = getLocalObject(sdata, 'router-eigrp')

    eigrp_net_obj = vrfs.vrf.router_eigrp.eigrp.network.network()
    if util.isNotEmpty(ip_address):
        eigrp_net_obj.ip_address = network
    if wildcard == '255.255.255.255':
        wildcard = '0.0.0.0'
    elif wildcard == '0.0.0.255':
        for x in range(192,224):
            if int(ip_address.split('.')[0]) == int(x):
                wildcard = None
    if util.isNotEmpty(wildcard):
        eigrp_net_obj.wild_card = wildcard

    if hasattr(obj_in.router_eigrp, 'process_id'):
        process_id = obj_in.router_eigrp.process_id
    if hasattr(obj_in.router_eigrp, 'vrf_name'):
        vrf = obj_in.router_eigrp.vrf_name
        if util.isEmpty(vrf):
            if entity == 'cpe':
                obj = getLocalObject(sdata, 'single-cpe-site-services')
                if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_site_services.cpe.vrf_name
            elif entity == 'cpe_dual':
                obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
            elif entity == 'cpe_primary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
            elif entity == 'cpe_secondary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'

    eigrp_net_url = dev.url + '/l3features:vrfs/vrf=%s/router-eigrp/eigrp=%s' % (vrf,process_id)
    yang.Sdk.createData(eigrp_net_url, eigrp_net_obj.getxml(filter=True), sdata.getSession())


def eigrp_on_bgp(entity, smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    redistribute_eigrp_on_bgp = inputdict['redistribute_eigrp_on_bgp']
    route_map = inputdict['route_map']
    vrf = None
    eigrp_process_id = None
    obj_in = getLocalObject(sdata, 'router-eigrp')
    if hasattr(obj_in.router_eigrp, 'process_id'):
        eigrp_process_id = obj_in.router_eigrp.process_id
    if hasattr(obj_in.router_eigrp, 'vrf_name'):
        vrf = obj_in.router_eigrp.vrf_name
        if util.isEmpty(vrf):
            if entity == 'cpe':
                obj = getLocalObject(sdata, 'single-cpe-site-services')
                if hasattr(obj.single_cpe_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_site_services.cpe.vrf_name
            elif entity == 'cpe_dual':
                obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                if hasattr(obj.single_cpe_dual_wan_site_services.cpe, 'vrf_name'):
                    vrf = obj.single_cpe_dual_wan_site_services.cpe.vrf_name
            elif entity == 'cpe_primary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_primary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_primary.vrf_name
            elif entity == 'cpe_secondary':
                obj = getLocalObject(sdata, 'dual-cpe-site-services')
                if hasattr(obj.dual_cpe_site_services.cpe_secondary, 'vrf_name'):
                    vrf = obj.dual_cpe_site_services.cpe_secondary.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'
    rebgpredisobj1 = vrfs.vrf.router_bgp.redistribute.redistribute()
    if redistribute_eigrp_on_bgp == 'true':
        if util.isNotEmpty(eigrp_process_id):
            rebgpredisobj1.protocol = 'eigrp'
            rebgpredisobj1.eigrp_process_id = eigrp_process_id
            if util.isNotEmpty(route_map):
                rebgpredisobj1.route_map = route_map
                route_maps(route_map, dev, sdata)

            router_bgp_redist_url = dev.url + '/l3features:vrfs/vrf=%s/router-bgp' % (vrf)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())


def ospf_redis(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    protocol = inputdict['protocol']
    route_map = inputdict['route_map']
    # key1 = inputdict['key1']
    # key2 = inputdict['key2']
    metric = inputdict['metric']
    metric_type = inputdict['metric_type']
    tag = inputdict['tag']
    process_id_entry = inputdict['process_id']
    vrf = None
    process_id = None
    bgpas = None
    if entity == 'cpe':
        obj = getLocalObject(sdata, 'single-cpe-site-services')
        if hasattr(obj.single_cpe_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_dual':
        obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
        if hasattr(obj.single_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_dual_wan_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_primary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_primary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_primary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_secondary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_secondary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_secondary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    elif entity == 'cpe_tertiary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as
        obj_in = getLocalObject(sdata, 'router-ospf')
        if hasattr(obj_in.router_ospf, 'process_id'):
            process_id = obj_in.router_ospf.process_id
        if hasattr(obj_in.router_ospf, 'vrf_name'):
            vrf = obj_in.router_ospf.vrf_name
    if vrf is None:
        vrf = 'GLOBAL'
    ospfredisobj1 = vrfs.vrf.router_ospf.redistribute.ospf_redistribute.ospf_redistribute()
    ospfredisobj1.protocol = protocol
    if protocol == 'bgp':
        ospfredisobj1.bgp_as_number = bgpas
    if protocol == 'ospf':
        ospfredisobj1.process_id_entry = process_id_entry
    if util.isNotEmpty(route_map):
        ospfredisobj1.route_map = route_map
        route_maps(route_map, device, sdata)
    if util.isNotEmpty(tag):
        ospfredisobj1.tag = tag
    if util.isNotEmpty(metric):
        ospfredisobj1.value1 = metric
    if util.isNotEmpty(metric_type):
        ospfredisobj1.value2 = metric_type

    ospf_red_url1 = device.url + '/l3features:vrfs/vrf=%s/router-ospf=%s' % (vrf, process_id)
    if not yang.Sdk.dataExists(ospf_red_url1 + '/redistribute'):
        yang.Sdk.createData(ospf_red_url1, '<redistribute/>', sdata.getSession(), False)

    ospf_red_url = device.url + '/l3features:vrfs/vrf=%s/router-ospf=%s/redistribute' % (vrf, process_id)
    yang.Sdk.createData(ospf_red_url, ospfredisobj1.getxml(filter=True), sdata.getSession())


def ospf_on_bgp(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    redistribute_ospf_on_bgp = inputdict['redistribute_ospf_on_bgp']
    ospf_internal = inputdict['ospf_internal']
    ospf_external1 = inputdict['ospf_external1']
    ospf_external2 = inputdict['ospf_external2']
    route_map = inputdict['route_map']
    vrf = None
    process_id = None
    obj_in = getLocalObject(sdata, 'router-ospf')
    if hasattr(obj_in.router_ospf, 'process_id'):
        process_id = obj_in.router_ospf.process_id
    if hasattr(obj_in.router_ospf, 'vrf_name'):
        vrf = obj_in.router_ospf.vrf_name

    if vrf is None:
        vrf = 'GLOBAL'
    rebgpredisobj1 = vrfs.vrf.router_bgp.redistribute.redistribute()
    if redistribute_ospf_on_bgp == 'true':
        rebgpredisobj1.protocol = 'ospf'
        if util.isNotEmpty(process_id):
            rebgpredisobj1.ospf_process_id = process_id
            if ospf_internal == 'true':
                rebgpredisobj1.ospf_internal = ospf_internal
            if ospf_external1 == 'true':
                rebgpredisobj1.ospf_external1 = "1"
            if ospf_external2 == 'true':
                rebgpredisobj1.ospf_external2 = "2"
            if util.isNotEmpty(route_map):
                rebgpredisobj1.route_map = route_map
                route_maps(route_map, device, sdata)

            router_bgp_redist_url = device.url + '/l3features:vrfs/vrf=%s/router-bgp' % (vrf)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())


def ospf(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    process_id = inputdict['process_id']
    vrf = inputdict['vrf_name']
    router_id = inputdict['router_id']
    reference_bandwidth = inputdict['reference_bandwidth']
    snmp = inputdict['snmp']
    context = inputdict['context']
    community = inputdict['community']
    access = inputdict['access']
    global_acl_name = inputdict['global_acl_name']
    site_acl_name = inputdict['site_acl_name']
    maximum_paths = inputdict['maximum_paths']
    default_information = inputdict['default_information']
    # default_inf_key1 = inputdict['default_inf_key1']
    # default_inf_key2 = inputdict['default_inf_key2']
    # default_inf_key3 = inputdict['default_inf_key3']
    default_inf_metric = inputdict['default_inf_metric']
    default_inf_metric_type = inputdict['default_inf_metric_type']
    default_inf_route_map = inputdict['default_inf_route_map']
    distribute_list = inputdict['distribute_list']
    dis_list_route_map = inputdict['dis_list_route_map']
    dis_list_route_update = inputdict['dis_list_route_update']
    default_inf_always = inputdict["default_inf_always"]

    if util.isEmpty(vrf):
        vrf = 'GLOBAL'

    ospf_obj = vrfs.vrf.router_ospf.router_ospf()
    ospf_obj.process_id = process_id
    if util.isNotEmpty(router_id):
        ospf_obj.router_id = router_id
    if util.isNotEmpty(reference_bandwidth):
        ospf_obj.reference_bandwidth = reference_bandwidth
    if snmp == 'true':
        if util.isNotEmpty(context):
            ospf_obj.context = context
        else:
            raise Exception("Please provide context")
        if util.isNotEmpty(community):
            ospf_obj.community = community
        if util.isNotEmpty(access):
            ospf_obj.access = access
        if util.isNotEmpty(global_acl_name):
            ospf_obj.acl_name = global_acl_name
        if util.isNotEmpty(site_acl_name):
            ospf_obj.acl_name = site_acl_name
    if util.isNotEmpty(maximum_paths):
        ospf_obj.maximum_paths = maximum_paths
    '''
    if default_information == 'true':
        ospf_obj.default_information = default_information
        if util.isNotEmpty(default_inf_metric):
            ospf_obj.default_inf_value = default_inf_metric
        if util.isNotEmpty(default_inf_metric_type):
            ospf_obj.default_inf_value1 = default_inf_metric_type
        if util.isNotEmpty(default_inf_route_map):
            ospf_obj.default_inf_value2 = default_inf_route_map
    '''
    if distribute_list == 'true':
        if util.isNotEmpty(dis_list_route_map) and util.isNotEmpty(dis_list_route_update):
            route_maps(dis_list_route_map, device, sdata, None, entity)
            ospf_obj.dis_list_route_map = dis_list_route_map
            ospf_obj.dis_list_route_update = dis_list_route_update
    ospf_url = device.url + '/l3features:vrfs/vrf=%s' % (vrf)
    yang.Sdk.createData(ospf_url, ospf_obj.getxml(filter=True), sdata.getSession())

    if default_information == 'true':
        ospf_obj_def = vrfs.vrf.router_ospf.inject_default_route.inject_default_route()
        if util.isNotEmpty(default_inf_metric):
            ospf_obj_def.metric = default_inf_metric
        if util.isNotEmpty(default_inf_metric_type):
            if default_inf_metric_type != "2":
                ospf_obj_def.metric_type = default_inf_metric_type
        if util.isNotEmpty(default_inf_route_map):
            route_maps(default_inf_route_map, device, sdata, None, entity)
            ospf_obj_def.route_map = default_inf_route_map
        if util.isNotEmpty(default_inf_always):
            ospf_obj_def.always = default_inf_always
        ospf_def_url = device.url + '/l3features:vrfs/vrf=%s/router-ospf=%s' % (vrf, process_id)
        yang.Sdk.createData(ospf_def_url, ospf_obj_def.getxml(filter=True), sdata.getSession())


def ospf_networks(entity, vrf, smodelctx, sdata, device_ip, **kwargs):
    key = 'deviceid.%s' % (device_ip)
    device = sdata.getSessionItem(key)
    if device == None:
      log('ospf_networks:cache-miss key=%s' % (key))
      device = devicemgr.getDeviceById(device_ip)
      sdata.setSessionItem(key, device, True)
    else:
      log('ospf_networks:cache-hit key=%s' % (key))
      
    inputdict = kwargs['inputdict']
    prefix_in = inputdict['prefix']
    prefix = util.IPPrefix(prefix_in)
    ip_address = prefix.address
    wildcard = prefix.wildcard
    (addrStr, cidrStr) = prefix_in.split('/')
    addr = addrStr.split('.')
    cidr = int(cidrStr)
    mask = [0, 0, 0, 0]
    for i in range(cidr):
        mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
    #net = []
    #for i in range(4):
        #net.append(int(addr[i]) & mask[i])
    net = [int(addr[i]) & mask[i] for i in xrange(4)]

    network = ".".join(map(str, net))
    area = inputdict['area']
    nssa = inputdict['nssa']
    ospf_net_obj = vrfs.vrf.router_ospf.network.network()
    ospf_net_obj.ip_address = network
    ospf_net_obj.wild_card = wildcard
    if util.isNotEmpty(area):
        ospf_net_obj.area = area
    if nssa == 'true':
        ospf_net_obj.nssa = 'true'
    if entity == 'cpe_primary':
        ospf_net_obj.translate = 'true'
    else:
        ospf_net_obj.translate = 'false'

    # ospf_networks_url1 = device.url + '/vrfs/vrf=%s' % (vrf)
    # yang.Sdk.createData(ospf_networks_url1, '<router-ospf/>', sdata.getSession())

    ospf_net_url = device.url + '/l3features:vrfs/vrf=%s/router-ospf=%s' % (vrf, inputdict['ospf_id'])
    yang.Sdk.createData(ospf_net_url, ospf_net_obj.getxml(filter=True), sdata.getSession())


def access_list(smodelctx, sdata, dev, **kwargs):
    inputdict = kwargs['inputdict']
    name = inputdict['name']
    access_list_entry = inputdict['access_list_entry']
    if access_list_entry == 'extended':
        access_obj = access_lists.access_list.access_list()
        access_obj.acl_type = access_list_entry
        if name is not None:
            access_obj.name = name
    elif access_list_entry == 'standard':
        access_obj = access_lists.access_list.access_list()
        access_obj.acl_type = access_list_entry
        if name is not None:
            access_obj.name = name
    
    '''
    try:
        get_access_list_obj = dev.url+"/acl:access-lists/access-list=%s"%(inputdict['name'])
        access_list_obj = yang.Sdk.getData(get_access_list_obj, '', sdata.getTaskId())
        access_list = util.parseXmlString(access_list_obj)
    except DataNodeNotFoundException:
        yang.Sdk.createData(dev.url, '<access-lists/>', sdata.getSession(), False)
        access_obj_url = dev.url + '/acl:access-lists'
        yang.Sdk.createData(access_obj_url, access_obj.getxml(filter=True), sdata.getSession())
    if sdata.isServiceDiscoveryEnabled() == True:
        acl_service_discovery(smodelctx, sdata, dev, **kwargs)
    '''
    get_access_list_obj = dev.url+"/acl:access-lists/access-list=%s"%(inputdict['name'])
    if not yang.Sdk.dataExists(get_access_list_obj):
        #yang.Sdk.createData(dev.url, '<access-lists/>', sdata.getSession(), False)
        access_obj_url = dev.url + '/access-lists'
        yang.Sdk.createData(access_obj_url, access_obj.getxml(filter=True), sdata.getSession())

    if sdata.isServiceDiscoveryEnabled() == True:
        acl_service_discovery(smodelctx, sdata, dev, **kwargs)


def acl_service_discovery(smodelctx, sdata, sr_device, **kwargs):
    inputdict = kwargs['inputdict']
    if sdata.isServiceDiscoveryEnabled() == True:
        #access_list_obj = sr_device.url+"/acl:access-lists/access-list=%s"%(inputdict['name'])
        #access_list = yang.Sdk.getData(access_list_obj, '', sdata.getTaskId())
        #obj = util.parseXmlString(access_list)
        #if hasattr(obj.access_list,'acl_rules'):
        acl_rules_obj = sr_device.url+"/acl:access-lists/access-list=%s/acl-rules"%(inputdict['name'])
        if yang.Sdk.dataExists(acl_rules_obj):
            acl_rules = yang.Sdk.getData(acl_rules_obj, '', sdata.getTaskId())
            acl_rule = util.convert_to_list(acl_rules)
            for aclrule in acl_rule:
                rule = util.parseXmlString(aclrule)
                rules_obj = util.convert_to_list(rule.acl_rules.acl_rule)
                for rule_obj in rules_obj:
                    uri = sdata.getRcPath()
                    if util.isEmpty(rule_obj.get_field_value('name')):
                        rule_obj.name = ""
                    if util.isEmpty(rule_obj.get_field_value('action')):
                        rule_obj.action = ""
                    if util.isEmpty(rule_obj.get_field_value('layer4protocol')):
                        rule_obj.layer4protocol = ""
                    if util.isEmpty(rule_obj.get_field_value('source_condition_type')):
                        rule_obj.source_condition_type = ""
                    if util.isEmpty(rule_obj.get_field_value('source_ip')):
                        rule_obj.source_ip = ""
                    else:
                        if rule_obj.source_condition_type == "cidr":
                            wildcard = rule_obj.get_field_value('source_mask')
                            mask = [str(255 - int(i)) for i in wildcard.split('.')]
                            netmask = '.'.join(mask)
                            wildcard_mask = util.netmask2masklen(netmask)
                            rule_obj.source_ip = str(rule_obj.get_field_value('source_ip')) + '/'+ str(wildcard_mask)

                    if util.isEmpty(rule_obj.get_field_value('source_obj_name')):
                        rule_obj.source_obj_name = ""
                    if util.isEmpty(rule_obj.get_field_value('dest_condition_type')):
                        rule_obj.dest_condition_type = ""
                    if util.isEmpty(rule_obj.get_field_value('dest_ip')):
                        rule_obj.dest_ip = ""
                    else:
                        if rule_obj.get_field_value('dest_condition_type') == "cidr":
                            wildcard = rule_obj.get_field_value('dest_mask')
                            mask = [str(255 - int(i)) for i in wildcard.split('.')]
                            netmask = '.'.join(mask)
                            wildcard_mask = util.netmask2masklen(netmask)
                            rule_obj.dest_ip = str(rule_obj.get_field_value('dest_ip')) + '/'+ str(wildcard_mask)
                    if util.isEmpty(rule_obj.get_field_value('dest_obj_name')):
                        rule_obj.dest_obj_name = ""
                    if util.isEmpty(rule_obj.get_field_value('match_packets')):
                        rule_obj.match_packets = ""
                    else:
                        if rule_obj.get_field_value('match_packets') == 'dscp':
                            if not util.isEmpty(rule_obj.get_field_value('precedence')):
                                rule_obj.dscp = rule_obj.get_field_value('precedence')
                                rule_obj.precedence = ""
                    if util.isEmpty(rule_obj.get_field_value('dscp')):
                        rule_obj.dscp = ""
                    if util.isEmpty(rule_obj.get_field_value('precedence')):
                        rule_obj.precedence = ""
                    if util.isEmpty(rule_obj.get_field_value('dest_port')):
                        rule_obj.dest_port = ""
                    if util.isEmpty(rule_obj.get_field_value('source_port')):
                        rule_obj.source_port = ""
                    if util.isEmpty(rule_obj.get_field_value('source_port_operator')):
                        rule_obj.source_port_operator = ""
                    if util.isEmpty(rule_obj.get_field_value('dest_port_operator')):
                        rule_obj.dest_port_operator = ""


                    payload = '''
                                            <access-list-rules>
                                            <name>'''+rule_obj.name+'''</name>
                                            <action>'''+rule_obj.action+'''</action>
                                            <protocol>'''+rule_obj.layer4protocol+'''</protocol>
                                            <source-condition>'''+rule_obj.source_condition_type+'''</source-condition>
                                            <source-object>'''+rule_obj.source_ip+'''</source-object>
                                            <source-object-group>'''+rule_obj.source_obj_name+'''</source-object-group>
                                            <destination-condition>'''+rule_obj.dest_condition_type+'''</destination-condition>
                                            <destination-object>'''+rule_obj.dest_ip+'''</destination-object>
                                            <destination-object-group>'''+rule_obj.dest_obj_name+'''</destination-object-group>
                                            <match-packets>'''+rule_obj.match_packets+'''</match-packets>
                                            <dscp>'''+rule_obj.dscp+'''</dscp>
                                            <precedence>'''+rule_obj.precedence+'''</precedence>
                                            <port-number>'''+rule_obj.dest_port+'''</port-number>
                                            <dest-port-operator>'''+rule_obj.dest_port_operator+'''</dest-port-operator>
                                            <source-port>'''+rule_obj.source_port+'''</source-port>
                                            <source-port-operator>'''+rule_obj.source_port_operator+'''</source-port-operator>
                                            </access-list-rules>
                                          '''

                    yang.Sdk.createData(uri, payload, sdata.getSession(), False)

def object_group_def(source_object_group, dev, sdata):
    uri = sdata.getRcPath()
    uri_list = uri.split('/', 5)
    url = '/'.join(uri_list[0:4])
    xml_output = yang.Sdk.getData(url+"/object-groups/object-group="+str(source_object_group), '', sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    objectgroup_obj = object_groups_acl.object_group.object_group()
    objectgroup_obj.name = obj.object_group.name
    objectgroup_obj.type = obj.object_group.type
    if hasattr(obj.object_group, 'description'):
        if util.isNotEmpty(obj.object_group.description):
            objectgroup_obj.description = obj.object_group.description
    objectgroup_url = dev.url + '/acl:object-groups-acl'
    #yang.Sdk.createData(dev.url, '<object-groups-acl/>', sdata.getSession())
    yang.Sdk.createData(objectgroup_url, objectgroup_obj.getxml(filter=True), sdata.getSession())
    if hasattr(obj.object_group, 'networks'):
        if hasattr(obj.object_group.networks, 'network'):
            for objectgroup in util.convert_to_list(obj.object_group.networks.network):
                net_url = dev.url + '/acl:object-groups-acl/object-group=%s' %(obj.object_group.name)
                if not yang.Sdk.dataExists(net_url + "/networks"):
                    yang.Sdk.createData(net_url, '<networks/>', sdata.getSession(), False)

                if hasattr(objectgroup, 'group_object'):
                    if util.isNotEmpty(objectgroup.group_object):
                        network_obj = object_groups_acl.object_group.networks.network.network()
                        network_obj.group_object = objectgroup.group_object
                        network_obj.name = "group-object" + " " + objectgroup.group_object
                        network_url = dev.url + '/acl:object-groups-acl/object-group=%s/networks' %(obj.object_group.name)
                        yang.Sdk.createData(network_url, network_obj.getxml(filter=True), sdata.getSession())

                if hasattr(objectgroup, 'host'):
                    if util.isNotEmpty(objectgroup.host):
                        network_obj1 = object_groups_acl.object_group.networks.network.network()
                        network_obj1.host = objectgroup.host
                        network_obj1.name = "host" + " " + objectgroup.host
                        network_url = dev.url + '/acl:object-groups-acl/object-group=%s/networks' %(obj.object_group.name)
                        yang.Sdk.createData(network_url, network_obj1.getxml(filter=True), sdata.getSession())

                if hasattr(objectgroup, 'prefix'):
                    if util.isNotEmpty(objectgroup.prefix):
                        network_obj2 = object_groups_acl.object_group.networks.network.network()
                        #Haulotte Specific Dual CPE Sites. Keyword 'GUEST_LAN_PROFILE' to be replaced by GUEST LAN Profile CIDR
                        if objectgroup.prefix == 'HAULOTTE-GUESTS':
                            obj_haulotte_guests = getLocalObject(sdata, 'dual-cpe-site-services')
                            log("haulotte guest obj is: %s" % (obj_haulotte_guests))
                            obj_haulotte_guests.dual_cpe_site_services.cpe_lan.lan_profile = util.convert_to_list(obj_haulotte_guests.dual_cpe_site_services.cpe_lan.lan_profile)
                            for lanprof in obj_haulotte_guests.dual_cpe_site_services.cpe_lan.lan_profile:
                                if lanprof.profile_name == 'GUEST_LAN_PROFILE':
                                    haulotte_guests_prefix = lanprof.get_field_value('cidr')
                                    prefix = util.IPPrefix(haulotte_guests_prefix)
                        else:
                            prefix = util.IPPrefix(objectgroup.prefix)
                        ip_address = prefix.address
                        netmask = prefix.netmask
                        network_obj2.ip_address = ip_address
                        network_obj2.netmask = netmask
                        network_obj2.name = ip_address + " " + netmask
                        network_url = dev.url + '/acl:object-groups-acl/object-group=%s/networks' %(obj.object_group.name)
                        yang.Sdk.createData(network_url, network_obj2.getxml(filter=True), sdata.getSession())

    if hasattr(obj.object_group, 'services'):
        if hasattr(obj.object_group.services, 'service'):

            port_dict = { '179': 'bgp', '19': 'chargen', '514': 'cmd', '13': 'daytime', '9': 'discard', '53': 'domain',
                          '3949': 'drip', '7': 'echo', '512': 'exec', '79': 'finger', '21': 'ftp', '20': 'ftp-data',
                          '70': 'gopher', '101': 'hostname', '113': 'ident', '194': 'irc', '543': 'klogin', '544': 'kshell',
                          '513': 'login', '515': 'lpd', '119': 'nntp', '15001': 'onep-plain', '15002': 'onep-tls', '496': 'pim-auto-rp',
                          '109': 'pop2', '110': 'pop3', '25': 'smtp', '111': 'sunrpc', '49': 'tacacs', '517': 'talk', '23': 'telnet',
                          '37': 'time', '540': 'uucp', '43': 'whois', '80': 'www', '135': 'msrpc'
                          }
            udp_port_dict = { '512': 'biff', '68': 'bootpc', '67': 'bootps', '9': 'discard', '195': 'dnsix',
                          '53': 'domain', '7': 'echo', '500': 'isakmp', '434': 'mobile-ip', '42': 'nameserver', '138': 'netbios-dgm',
                          '137': 'netbios-ns', '139': 'netbios-ss', '4500': 'non500-isakmp', '123': 'ntp', '496': 'pim-auto-rp',
                          '520': 'rip', '161': 'snmp', '162': 'snmptrap', '111': 'sunrpc', '514': 'syslog', '49': 'tacacs',
                          '517': 'talk', '69': 'tftp', '37': 'time', '513': 'who', '177': 'xdmcp', '135': 'msrpc'
                          }
            ip_prot_dict = { '47': 'gre', '1': 'icmp', '6': 'tcp', '17': 'udp', '51': 'ahp', '50': 'esp', '89': 'ospf',
                             '4': 'ipinip', '88': 'eigrp', '2': 'igmp', '94': 'nos', '103': 'pim'
                            }

            service_url = dev.url + '/acl:object-groups-acl/object-group=%s/services' %(obj.object_group.name)

            for objectgroup in util.convert_to_list(obj.object_group.services.service):
                if hasattr(objectgroup, 'group_object'):
                    if util.isNotEmpty(objectgroup.group_object):
                        service_obj = object_groups_acl.object_group.services.service.service()
                        service_obj.group_object = objectgroup.group_object
                        service_obj.name = "group-object" + " " + objectgroup.group_object
                        
                        yang.Sdk.createData(service_url, service_obj.getxml(filter=True), sdata.getSession())

                if hasattr(objectgroup, 'protocol_type'):
                    if util.isNotEmpty(objectgroup.protocol_type):
                        if objectgroup.protocol_type == "IP-Protocol-Number":
                            service_obj1 = object_groups_acl.object_group.services.service.service()
                            if util.isNotEmpty(objectgroup.ip_protocol):
                                
                                ip_prot_num = objectgroup.ip_protocol
                                if ip_prot_num in ip_prot_dict:
                                    ip_prot_num = ip_prot_dict[ip_prot_num]
                                    service_obj1.protocol = ip_prot_num
                                    service_obj1.name = ip_prot_num
                                else:
                                    service_obj1.ip_protocol = ip_prot_num
                                    service_obj1.name = ip_prot_num

                                yang.Sdk.createData(service_url, service_obj1.getxml(filter=True), sdata.getSession())
                        
                        if  objectgroup.protocol_type == "Protocol-Name":
                            service_obj_name_list = []
                            service_obj2 = object_groups_acl.object_group.services.service.service()
                            if util.isNotEmpty(objectgroup.protocol_name):
                                service_obj2.protocol = objectgroup.protocol_name
                                service_obj_name_list.append(objectgroup.protocol_name)

                            if hasattr(objectgroup, 'port_operation'):
                                if util.isNotEmpty(objectgroup.port_operation):
                                    service_obj2.operation = objectgroup.port_operation
                                    service_obj_name_list.append(objectgroup.port_operation)

                            if hasattr(objectgroup, 'operator'):
                                if util.isNotEmpty(objectgroup.operator):
                                    service_obj2.compare = objectgroup.operator
                                    service_obj_name_list.append(objectgroup.operator)

                            if hasattr(objectgroup, 'port_number'):
                                if util.isNotEmpty(objectgroup.port_number):
                                    port_num = objectgroup.port_number
                                    if objectgroup.protocol_name == "tcp":
                                        if port_num in port_dict:
                                            port_num = port_dict[port_num]
                                    elif objectgroup.protocol_name == "udp":
                                        if port_num in udp_port_dict:
                                            port_num = udp_port_dict[port_num]

                                    service_obj2.port = port_num
                                    service_obj_name_list.append(port_num)

                            if hasattr(objectgroup, 'end_port'):
                                if util.isNotEmpty(objectgroup.end_port):
                                    end_port_num = objectgroup.end_port
                                    if objectgroup.protocol_name == "tcp":
                                        if end_port_num in port_dict:
                                            end_port_num = port_dict[end_port_num]
                                    elif objectgroup.protocol_name == "udp":
                                        if end_port_num in udp_port_dict:
                                            end_port_num = udp_port_dict[end_port_num]
                                            
                                    service_obj2.end_port = end_port_num
                                    service_obj_name_list.append(end_port_num)

                            service_obj_name = ' '.join(service_obj_name_list)

                            service_obj2.name = service_obj_name

                            yang.Sdk.createData(service_url, service_obj2.getxml(filter=True), sdata.getSession())

def access_list_rule(smodelctx, sdata, dev, access_list_name, **kwargs):
    inputdict = kwargs['inputdict']
    acl_sequence_num = inputdict['acl_sequence_num']
    action = inputdict['action']
    protocol = inputdict['protocol']
    source_condition = inputdict['source_condition']
    source_object = inputdict['source_object']
    source_port = inputdict['source_port']
    destination_condition = inputdict['destination_condition']
    destination_object = inputdict['destination_object']
    port_number = inputdict['port_number']
    match_packets = inputdict['match_packets']
    precedence = inputdict['precedence']
    dscp = inputdict['dscp']
    source_object_group = inputdict['source_object_group']
    destination_object_group = inputdict['destination_object_group']
    service_obj_name = inputdict['service_obj_name']
    dest_port_operator = inputdict['dest_port_operator']
    source_port_operator = inputdict['source_port_operator']
    port_dict = { '179': 'bgp', '19': 'chargen', '514': 'cmd', '13': 'daytime', '9': 'discard', '53': 'domain',
                  '3949': 'drip', '7': 'echo', '512': 'exec', '79': 'finger', '21': 'ftp', '20': 'ftp-data',
                  '70': 'gopher', '101': 'hostname', '113': 'ident', '194': 'irc', '543': 'klogin', '544': 'kshell',
                  '513': 'login', '515': 'lpd', '119': 'nntp', '15001': 'onep-plain', '15002': 'onep-tls', '496': 'pim-auto-rp',
                  '109': 'pop2', '110': 'pop3', '25': 'smtp', '111': 'sunrpc', '49': 'tacacs', '517': 'talk', '23': 'telnet',
                  '37': 'time', '540': 'uucp', '43': 'whois', '80': 'www', '135': 'msrpc'
                  }
    udp_port_dict = { '512': 'biff', '68': 'bootpc', '67': 'bootps', '9': 'discard', '195': 'dnsix',
                      '53': 'domain', '7': 'echo', '500': 'isakmp', '434': 'mobile-ip', '42': 'nameserver', '138': 'netbios-dgm',
                      '137': 'netbios-ns', '139': 'netbios-ss', '4500': 'non500-isakmp', '123': 'ntp', '496': 'pim-auto-rp',
                      '520': 'rip', '161': 'snmp', '162': 'snmptrap', '111': 'sunrpc', '514': 'syslog', '49': 'tacacs',
                      '517': 'talk', '69': 'tftp', '37': 'time', '513': 'who', '177': 'xdmcp', '135': 'msrpc'
                      }
    #name = inputdict['name']
    access_rule_obj = access_lists.access_list.acl_rules.acl_rule.acl_rule()
    access_rule_obj.action = action
    access_rule_obj.layer4protocol = protocol
    name_rule = []
    if util.isNotEmpty(acl_sequence_num):
        access_rule_obj.linenumber = acl_sequence_num
        #name_rule = acl_sequence_num + ' ' + action + ' ' + protocol
        #name_rule = action + ' ' + protocol
    if util.isNotEmpty(protocol):
        #name_rule = action + ' ' + protocol
        name_rule.append(action)
        name_rule.append(protocol)
    else:
        #name_rule = action
        name_rule.append(action)
    if util.isNotEmpty(service_obj_name):
        object_group_def(service_obj_name, dev, sdata)
        access_rule_obj.service_obj_name = service_obj_name
        #name_rule += ' ' + service_obj_name
        name_rule.append(service_obj_name)
    access_rule_obj.source_condition_type = source_condition
    if source_condition == 'cidr':
        cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
        if util.isEmpty(source_object):
            raise Exception ("Please provide valid CIDR for source-object in access-list")
        if re.match(cidr_pattern,source_object) == None:
            raise Exception ("Please provide valid CIDR for source-object in access-list")
        prefix = util.IPPrefix(source_object)
        ip_address = prefix.address
        netmask = prefix.wildcard
        access_rule_obj.source_mask = netmask
        (addrStr, cidrStr) = source_object.split('/')
        addr = addrStr.split('.')
        cidr = int(cidrStr)
        mask = [0, 0, 0, 0]
        for i in range(cidr):
            mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
        #net = []
        #for i in range(4):
        #net.append(int(addr[i]) & mask[i])
        net = [int(addr[i]) & mask[i] for i in xrange(4)]

        network = ".".join(map(str, net))
        #name_rule += ' ' + network + ' ' + netmask
        name_rule.append(network)
        name_rule.append(netmask)
        access_rule_obj.source_ip = network
    if source_condition == 'host':
        host_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$';
	if util.isEmpty(source_object):
            raise Exception ("Please provide valid ip-address for source-object in access-list")
        if re.match(host_pattern,source_object) == None:
            raise Exception ("Please provide valid ip-address for source-object in access-list")
        access_rule_obj.source_ip = source_object
        #name_rule += ' ' + 'host' + ' ' + source_object
        name_rule.append('host')
        name_rule.append(source_object)
    if source_condition == 'objectgroup':
        if util.isNotEmpty(source_object_group):
            object_group_def(source_object_group, dev, sdata)
            access_rule_obj.source_obj_name = source_object_group
            #name_rule += ' ' + 'object-group' + ' ' + source_object_group
            name_rule.append('object-group')
            name_rule.append(source_object_group)
    if source_condition == 'any':
        #name_rule += ' ' + 'any'
        name_rule.append('any')
    if util.isNotEmpty(source_port):
        if util.isEmpty(source_port_operator):
            raise Exception("Please provide Source Port Operator in acl")
        access_rule_obj.source_port_operator = source_port_operator
        each_port = source_port.split(' ')
        if protocol == 'tcp':
            each_port = ([port_dict[each] if each in port_dict else each for each in each_port])
        elif protocol == 'udp':
            each_port = ([udp_port_dict[each] if each in udp_port_dict else each for each in each_port])
        source_port = ' '.join(each_port)
        access_rule_obj.source_port = source_port
        #name_rule += ' ' + source_port_operator + ' ' + source_port
        name_rule.append(source_port_operator)
        name_rule.append(source_port)
    access_rule_obj.dest_condition_type = destination_condition
    if destination_condition == 'cidr':
        cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
	if util.isEmpty(destination_object):
            raise Exception ("Please provide valid CIDR for destination-object in access-list")
        if re.match(cidr_pattern,destination_object) == None:
            raise Exception ("Please provide valid CIDR for destination-object in access-list")
        prefix = util.IPPrefix(destination_object)
        ip_address = prefix.address
        netmask = prefix.wildcard
        access_rule_obj.dest_mask = netmask
        (addrStr, cidrStr) = destination_object.split('/')
        addr = addrStr.split('.')
        cidr = int(cidrStr)
        mask = [0, 0, 0, 0]
        for i in range(cidr):
            mask[i/8] = mask[i/8] + (1 << (7 - i % 8))
        #net = []
        #for i in range(4):
        #net.append(int(addr[i]) & mask[i])
        net = [int(addr[i]) & mask[i] for i in xrange(4)]

        network = ".".join(map(str, net))
        #name_rule += ' ' + network + ' ' + netmask
        name_rule.append(network)
        name_rule.append(netmask)
        access_rule_obj.dest_ip = network
    if destination_condition == 'host':
        host_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$';
	if util.isEmpty(destination_object):
            raise Exception ("Please provide valid ip-address for destination-object in access-list")
        if re.match(host_pattern,destination_object) == None:
            raise Exception ("Please provide valid ip-address for destination-object in access-list")
        access_rule_obj.dest_ip = destination_object
        #name_rule += ' ' + 'host' + ' ' + destination_object
        name_rule.append('host')
        name_rule.append(destination_object)
    if destination_condition == 'objectgroup':
        if util.isNotEmpty(destination_object_group):
            object_group_def(destination_object_group, dev, sdata)
            access_rule_obj.dest_obj_name = destination_object_group
            #name_rule += ' ' + 'object-group' + ' ' + destination_object_group
            name_rule.append('object-group')
            name_rule.append(destination_object_group)
    if destination_condition == 'any':
        #name_rule += ' ' + 'any'
        name_rule.append('any')
    if util.isNotEmpty(port_number):
        if util.isEmpty(dest_port_operator):
            raise Exception("Please provide Destination Port Operator in acl")
        access_rule_obj.dest_port_operator = dest_port_operator
        each_port = port_number.split(' ')
        if protocol == 'tcp':
            each_port = ([port_dict[each] if each in port_dict else each for each in each_port])
        elif protocol == 'udp':
            each_port = ([udp_port_dict[each] if each in udp_port_dict else each for each in each_port])
        port_number = ' '.join(each_port)
        access_rule_obj.dest_port = port_number
        #name_rule += ' ' + dest_port_operator + ' ' + port_number
        name_rule.append(dest_port_operator)
        name_rule.append(port_number)
    if util.isNotEmpty(match_packets):
        access_rule_obj.match_packets = match_packets
        #name_rule += ' ' + match_packets
        name_rule.append(match_packets)
    if match_packets == 'precedence':
        if util.isNotEmpty(precedence):
            access_rule_obj.precedence = precedence
            #name_rule += ' ' + precedence
            name_rule.append(precedence)
    else:
        if util.isNotEmpty(dscp):
            access_rule_obj.precedence = dscp
            #name_rule += ' ' + dscp
            name_rule.append(dscp)
    #print "ACL_RULE_NAME: ", name_rule
    access_rule_obj.name = ' '.join(name_rule)
    #access_rules_url = dev.url + "/access-lists/access-list=%s" %(access_list_name)
    #yang.Sdk.createData(access_rules_url, '<acl-rules/>', sdata.getSession(), False)

    access_rule_url = dev.url + '/acl:access-lists/access-list=%s/acl-rules' %(access_list_name)
    yang.Sdk.createData(access_rule_url, access_rule_obj.getxml(filter=True), sdata.getSession())


def route_maps(redistroutepolicy, device, sdata, int_name=None, entity=None):
    device.addRouteMapsContainer(sdata.getSession())
    '''
    obj = getLocalObject(sdata, 'customer')
    log("obj of routemap is: %s" % (obj))
    log("xml of route map obj: %s" % (obj.toXml()))
    log("route map obj is: %s" % (obj.customer.route_maps))
    if hasattr(obj.customer.route_maps, 'route_map'):
        
        obj.customer.route_maps.route_map = util.convert_to_list(obj.customer.route_maps.route_map)
        #util.log_debug( "route map obj is:",obj.customer.route_maps.route_map)
        for route_map_obj in obj.customer.route_maps.route_map:
            route_map_name = route_map_obj.get_field_value('route_map_name')
            if redistroutepolicy == route_map_name :
        '''
                
    uri = sdata.getRcPath()
    uri_list = uri.split('/',5)
    url = '/'.join(uri_list[0:4])
    route_map_url = url+"/route-maps/route-map=%s" % (redistroutepolicy)
    if yang.Sdk.dataExists(route_map_url):
        route_maps_url = device.url + '/l3features:route-maps'
        from servicemodel.controller.devices.device import route_maps
        routemap_obj = route_maps.route_map.route_map()
        #if route_map_name is not None:
        routemap_obj.name = redistroutepolicy
        yang.Sdk.createData(route_maps_url, routemap_obj.getxml(filter=True), sdata.getSession())
        route_map_output = yang.Sdk.getData(route_map_url, '', sdata.getTaskId())
        route_map_obj = util.parseXmlString(route_map_output)
        if hasattr(route_map_obj.route_map,'route_map_entries'):
            route_map_entries = util.convert_to_list(route_map_obj.route_map.route_map_entries)
            for route_map_entry in route_map_entries:
                route_map(redistroutepolicy, route_map_entry, device, sdata, int_name, entity)
    

def prefix_list_gen(smodelctx, sdata, device, entity=None, **kwarg):
    '''
    :param smodelctx:
    :param sdata:
    :param device:
    :param vrf_name:
    :param kwarg:
    :return:
    '''
    prefixlist_name = kwarg['inputdict']['prefix_list_name']
    if prefixlist_name is not None:
        device.addIpPrefixListListsContainer(sdata.getSession())
        '''
        obj = getLocalObject(sdata, 'customer')
        if hasattr(obj.customer.prefix_lists, 'prefix_list'):
            obj.customer.prefix_lists.prefix_list = util.convert_to_list(obj.customer.prefix_lists.prefix_list)
            for prefixlist_obj in obj.customer.prefix_lists.prefix_list:
                prefix_list_name = prefixlist_obj.get_field_value('prefix_list_name')
                if prefixlist_name == prefix_list_name :
        '''
        uri = sdata.getRcPath()
        uri_list = uri.split('/',5)
        url = '/'.join(uri_list[0:4])
        prefix_list_url = url+"/prefix-lists/prefix-list=%s" % (prefixlist_name)
        if yang.Sdk.dataExists(prefix_list_url):
            ip_prefixlist_lists_url = device.url + '/l3features:ip-prefixlist-list'
            ip_prefixlist_lists_obj = ip_prefixlist_list.ip_prefixlist.ip_prefixlist()
            ip_prefixlist_lists_obj.name = prefixlist_name
            yang.Sdk.createData(ip_prefixlist_lists_url, ip_prefixlist_lists_obj.getxml(filter=True), sdata.getSession())
            prefix_list_output = yang.Sdk.getData(prefix_list_url, '', sdata.getTaskId())
            prefix_list_obj = util.parseXmlString(prefix_list_output)
            if hasattr(prefix_list_obj.prefix_list, 'prefix'):
                prefixs = util.convert_to_list(prefix_list_obj.prefix_list.prefix)
                for prefix in prefixs:
                    prefix_gen(prefixlist_name, prefix, device, sdata, entity)
        


def prefix_gen(prefix_list_name, prefix, device, sdata, entity=None):
    '''

    :param smodelctx:
    :param sdata:
    :param device:
    :param vrf_name:
    :param kwarg:
    :return:
    '''

    prefix_obj = ip_prefixlist_list.ip_prefixlist.ip_prefixlist_entries.ip_prefixlist_entry.ip_prefixlist_entry()

    prefix_name = prefix.get_field_value('prefix_name')
    if util.isNotEmpty(prefix_name):
        prefix_obj.prefix_name = prefix_name
    rule_num = prefix.get_field_value('rule_num')
    if util.isNotEmpty(rule_num):
        prefix_obj.rule_num = rule_num
    ipv4_prefix = prefix.get_field_value('ipv4_prefix')
    if util.isNotEmpty(ipv4_prefix):
        #Replace Keyword DPS-LOOPBACK in prefix list rules by DPS Loopback100 IP /32 prefix
        if ipv4_prefix == 'DPS-LOOPBACK':
            if entity == 'cpe' or entity == 'cpe_dual':
                obj_loopback = getLocalObject(sdata, 'cpe')
                log("cpe obj is: %s" % (obj_loopback))
                obj_loopback.cpe.loopback.loopback = util.convert_to_list(obj_loopback.cpe.loopback.loopback)
                for loopback_obj in obj_loopback.cpe.loopback.loopback:
                    dps_loopback_id = loopback_obj.get_field_value('loopback_interface_id')
                    if dps_loopback_id == '100':
                        dps_loopback_prefix = loopback_obj.get_field_value('ip')
                        dps_loopback_prefix = dps_loopback_prefix + "/32"
                        prefix_obj.subnet = dps_loopback_prefix
            elif entity == 'cpe_primary' or entity == 'cpe_secondary':
                obj_loopback = getLocalObject(sdata, 'dual-cpe-site-services')
                log("cpe obj is: %s" % (obj_loopback))
                obj_loopback.dual_cpe_site_services.cpe_secondary.loopback.loopback = util.convert_to_list(obj_loopback.dual_cpe_site_services.cpe_secondary.loopback.loopback)
                for loopback_obj in obj_loopback.dual_cpe_site_services.cpe_secondary.loopback.loopback:
                    dps_loopback_id = loopback_obj.get_field_value('loopback_interface_id')
                    if dps_loopback_id == '100':
                        dps_loopback_prefix = loopback_obj.get_field_value('ip')
                        dps_loopback_prefix = dps_loopback_prefix + "/32"
                        prefix_obj.subnet = dps_loopback_prefix
            elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
                obj_loopback = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
                log("cpe obj is: %s" % (obj_loopback))
                obj_loopback.dual_cpe_dual_wan_site_services.cpe_secondary.loopback.loopback = util.convert_to_list(obj_loopback.dual_cpe_dual_wan_site_services.cpe_secondary.loopback.loopback)
                for loopback_obj in obj_loopback.dual_cpe_dual_wan_site_services.cpe_secondary.loopback.loopback:
                    dps_loopback_id = loopback_obj.get_field_value('loopback_interface_id')
                    if dps_loopback_id == '100':
                        dps_loopback_prefix = loopback_obj.get_field_value('ip')
                        dps_loopback_prefix = dps_loopback_prefix + "/32"
                        prefix_obj.subnet = dps_loopback_prefix

        #Haulotte Replace Keyword in prefix-list by GUESTS LAN subnet
        elif ipv4_prefix == 'HAULOTTE-GUESTS':
            if entity == 'cpe':
                obj_haulotte_guests = getLocalObject(sdata, 'single-cpe-site-services')
                log("haulotte guest obj is: %s" % (obj_haulotte_guests))
                obj_haulotte_guests.single_cpe_site_services.cpe_lan.lan_profile = util.convert_to_list(obj_haulotte_guests.single_cpe_site_services.cpe_lan.lan_profile)
                for lanprof in obj_haulotte_guests.single_cpe_site_services.cpe_lan.lan_profile:
                    if lanprof.profile_name == 'GUEST_LAN_PROFILE':
                        haulotte_guests_prefix = lanprof.get_field_value('cidr')
                        prefix_obj.subnet = haulotte_guests_prefix
            elif entity == 'cpe_dual':
                obj_haulotte_guests = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                log("haulotte guest obj is: %s" % (obj_haulotte_guests))
                obj_haulotte_guests.single_cpe_dual_wan_site_services.cpe_lan.lan_profile = util.convert_to_list(obj_haulotte_guests.single_cpe_dual_wan_site_services.cpe_lan.lan_profile)
                for lanprof in obj_haulotte_guests.single_cpe_dual_wan_site_services.cpe_lan.lan_profile:
                    if lanprof.profile_name == 'GUEST_LAN_PROFILE':
                        haulotte_guests_prefix = lanprof.get_field_value('cidr')
                        prefix_obj.subnet = haulotte_guests_prefix
            elif entity == 'cpe_primary' or entity == 'cpe_secondary':
                obj_haulotte_guests = getLocalObject(sdata, 'dual-cpe-site-services')
                log("haulotte guest obj is: %s" % (obj_haulotte_guests))
                obj_haulotte_guests.dual_cpe_site_services.cpe_lan.lan_profile = util.convert_to_list(obj_haulotte_guests.dual_cpe_site_services.cpe_lan.lan_profile)
                for lanprof in obj_haulotte_guests.dual_cpe_site_services.cpe_lan.lan_profile:
                    if lanprof.profile_name == 'GUEST_LAN_PROFILE':
                        haulotte_guests_prefix = lanprof.get_field_value('cidr')
                        prefix_obj.subnet = haulotte_guests_prefix
            elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
                obj_haulotte_guests = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
                log("haulotte guest obj is: %s" % (obj_haulotte_guests))
                obj_haulotte_guests.dual_cpe_dual_wan_site_services.cpe_lan.lan_profile = util.convert_to_list(obj_haulotte_guests.dual_cpe_dual_wan_site_services.cpe_lan.lan_profile)
                for lanprof in obj_haulotte_guests.dual_cpe_dual_wan_site_services.cpe_lan.lan_profile:
                    if lanprof.profile_name == 'GUEST_LAN_PROFILE':
                        haulotte_guests_prefix = lanprof.get_field_value('cidr')
                        prefix_obj.subnet = haulotte_guests_prefix
        else:
            prefix_obj.subnet = ipv4_prefix
    condition = prefix.get_field_value('condition')
    if util.isNotEmpty(condition):
        prefix_obj.condition = condition
    exact_matching_prefix_length = prefix.get_field_value('exact_matching_prefix_length')
    if util.isNotEmpty(exact_matching_prefix_length):
        prefix_obj.num = exact_matching_prefix_length
    minimum_matching_prefix_length = prefix.get_field_value('minimum_matching_prefix_length')
    if util.isNotEmpty(minimum_matching_prefix_length):
        prefix_obj.num = minimum_matching_prefix_length
        prefix_obj.compare = 'ge'
    maximum_matching_prefix_length = prefix.get_field_value('maximum_matching_prefix_length')
    if util.isNotEmpty(maximum_matching_prefix_length):
        prefix_obj.num = maximum_matching_prefix_length
        prefix_obj.compare = 'le'
    device.addIpPrefixListEntriesContainer(prefix_list_name, sdata.getSession())

    prefix_list_url = device.url + '/l3features:ip-prefixlist-list/ip-prefixlist=%s/ip-prefixlist-entries' % (prefix_list_name)
    yang.Sdk.createData(prefix_list_url, prefix_obj.getxml(filter=True), sdata.getSession())


def route_map(route_map_name, route_map_entries, device, sdata, int_name=None, entity=None):
    #print "Entering into Route map"
    from servicemodel.controller.devices.device import route_maps
    routemapentry_obj = route_maps.route_map.route_map_entries.route_map_entries()
    action = route_map_entries.get_field_value('action')
    if action is not None:
        routemapentry_obj.action = action
    seq = route_map_entries.get_field_value('sequence_number')
    if seq is not None:
        routemapentry_obj.seq = seq
    routemap_entry_url = device.url + '/l3features:route-maps/route-map=%s' % (route_map_name)
    yang.Sdk.createData(routemap_entry_url, routemapentry_obj.getxml(filter=True), sdata.getSession())
    if hasattr(route_map_entries,'match_condition'):
        for match_obj in util.convert_to_list(route_map_entries.match_condition):
            matchcondition_obj = route_maps.route_map.route_map_entries.match_condition.match_condition()
            condition_type = match_obj.get_field_value('condition_type')
            if condition_type is not None:
                matchcondition_obj.condition_type = condition_type
            condition_value = match_obj.get_field_value('value')
            if condition_value is not None:
                if condition_value == 'LAN-INTERFACE' and condition_type == 'interface':
                    matchcondition_obj.value = int_name

                # Added for SQS 01/06/2018
                elif condition_value == 'SQS-OSPF-TAG' and condition_type == 'tag':
                    # Construct dotted-decimal tag value from local Loopback0 IP
                    uri = sdata.getRcPath()
                    uri_list = uri.split('/',7)
                    url = '/'.join(uri_list[0:6])

                    # For SQS - Tag Value should always be primary-cpe loopback IP in case of dual/triple CPE sites
                    entity_map = {
                                  "cpe": "cpe",
                                  "cpe_dual": "cpe",
                                  "cpe_primary": "cpe-primary",
                                  "cpe_secondary": "cpe-primary",
                                  "cpe_primary_dual": "cpe-primary",
                                  "cpe_secondary_dual": "cpe-primary",
                                  "cpe_primary_triple": "cpe-primary",
                                  "cpe_secondary_triple": "cpe-primary",
                                  "cpe_tertiary_triple": "cpe-primary"
                    }
                    
                    mgmt_loopback_url = url + '/' + entity_map[entity] + '/loopback/loopback=0'
                    if yang.Sdk.dataExists(mgmt_loopback_url):
                        loopback_output = yang.Sdk.getData(mgmt_loopback_url, '', sdata.getTaskId())
                        loopback_obj = util.parseXmlString(loopback_output)
                        
                        if hasattr(loopback_obj, 'loopback'):
                            if hasattr(loopback_obj.loopback, 'ip'):
                                if util.isNotEmpty(loopback_obj.loopback.ip):
                                    matchcondition_obj.value = loopback_obj.loopback.ip
                                else:
                                    raise Exception("No Valid IP Address found in Loopback0. Cannot proceed with OSPF TAG dotted-decimal generation.")
                    else:
                        raise Exception("No Loopback0 interface found in site service. Cannot proceed with OSPF TAG dotted-decimal generation.")

                else:
                    matchcondition_obj.value = condition_value
            if condition_type == 'as-path' and condition_value is not None:
                as_path_acl(condition_value, device, sdata)
            if condition_type == 'community' and condition_value is not None:
                community_lists(condition_value, device, sdata)
           

            if condition_type == 'address' and condition_value is not None:
                from endpoint_lib import access_group_def
                uri = sdata.getRcPath()
                uri_list = uri.split('/',5)
                url = '/'.join(uri_list[0:4])
                acl_url = url+"/access-lists/access-list=%s" % (condition_value)
                if yang.Sdk.dataExists(acl_url):
                    access_group_def(url, condition_value, device, sdata)
            if condition_type == 'prefix-list' and condition_value is not None:
                prefix_dict = {"prefix_list_name": condition_value}
                prefix_list_gen(None, sdata, device, entity, inputdict=prefix_dict)
                '''
                from endpoint_lib import access_group_def
                uri = sdata.getRcPath()
                uri_list = uri.split('/',5)
                url = '/'.join(uri_list[0:4])

                acl_output = yang.Sdk.getData(url+"/access-lists", '', sdata.getTaskId())
                acl_obj = util.parseXmlString(acl_output)
                if hasattr(acl_obj, 'access_lists'):
                    if hasattr(acl_obj.access_lists, 'access_list'):
                        for acl_name in util.convert_to_list(acl_obj.access_lists.access_list):
                            if hasattr(acl_name, 'name'):
                                if acl_name.name == condition_value:
                                    access_group_def(url, condition_value, device, sdata)
                '''
            match_condition_url = device.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (route_map_name,seq)
            if util.isNotEmpty(matchcondition_obj.value):
                yang.Sdk.createData(match_condition_url, matchcondition_obj.getxml(filter=True), sdata.getSession())
    if hasattr(route_map_entries,'set_action'):
        for set_obj in util.convert_to_list(route_map_entries.set_action):
            set_ip = None
            set_obj1 = route_maps.route_map.route_map_entries.set_action.set_action()
            set_type = set_obj.get_field_value('set_type')
            if set_type is not None:
                set_obj1.set_type = set_type
                if set_type == 'ip':
                    set_ip = set_obj.get_field_value('ip')
                    if set_ip is None:
                        raise Exception("Please provide ip precedence/df/next-hop")
                    else:
                        set_obj1.ip = set_ip
            set_value = set_obj.get_field_value('value')
            bgp_as_regex = re.match(r'\bAS\b', set_value)
            if set_value is not None:
                if set_value == 'IP' and set_ip == 'next-hop':
                    obj = modifiedGetLocalObject(sdata, 'cpe-name')
                    if hasattr(obj.cpe_name, "next_hop_ip"):
                        set_obj1.value = obj.cpe_name.next_hop_ip
                #Handle Keywork 'AS' in Route-Map for AS-Path Prepending
                elif bgp_as_regex is not None and set_type == 'as-path prepend':
                    if entity == 'cpe':
                        obj_bgp_as = getLocalObject(sdata, 'single-cpe-site-services')
                        if hasattr(obj_bgp_as.single_cpe_site_services, 'bgp_as'):
                            bgpas = obj_bgp_as.single_cpe_site_services.bgp_as
                            set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
                    elif entity == 'cpe_dual':
                        obj_bgp_as = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                        if hasattr(obj_bgp_as.single_cpe_dual_wan_site_services, 'bgp_as'):
                            bgpas = obj_bgp_as.single_cpe_dual_wan_site_services.bgp_as
                            set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
                    elif entity == 'cpe_primary' or entity == 'cpe_secondary':
                        obj_bgp_as = getLocalObject(sdata, 'dual-cpe-site-services')
                        if hasattr(obj_bgp_as.dual_cpe_site_services, 'bgp_as'):
                            bgpas = obj_bgp_as.dual_cpe_site_services.bgp_as
                            set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
                    elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
                        obj_bgp_as = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
                        if hasattr(obj_bgp_as.dual_cpe_dual_wan_site_services, 'bgp_as'):
                            bgpas = obj_bgp_as.dual_cpe_dual_wan_site_services.bgp_as
                            set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
                    elif entity == 'cpe_primary_triple' or entity == 'cpe_secondary_triple' or entity == 'cpe_tertiary_triple':
                        obj_bgp_as = getLocalObject(sdata, 'triple-cpe-site-services')
                        if hasattr(obj_bgp_as.triple_cpe_site_services, 'bgp_as'):
                            bgpas = obj_bgp_as.triple_cpe_site_services.bgp_as
                            set_obj1.value = re.sub(r'\bAS\b', bgpas, set_value)
                #Handle Local-AS for Set Community
                elif "local-AS" in set_value and set_type == 'community':
                    set_obj1.value = set_value
                #Handle AS keyword for Set Community and replace by site service AS number
                elif 'AS' in set_value and set_type == 'community':
                    if entity == 'cpe':
                            obj_bgp_as = getLocalObject(sdata, 'single-cpe-site-services')
                            if hasattr(obj_bgp_as.single_cpe_site_services, 'bgp_as'):
                                bgpas = obj_bgp_as.single_cpe_site_services.bgp_as
                                set_obj1.value = set_value.replace('AS', bgpas)
                    elif entity == 'cpe_dual':
                            obj_bgp_as = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
                            if hasattr(obj_bgp_as.single_cpe_dual_wan_site_services, 'bgp_as'):
                                bgpas = obj_bgp_as.single_cpe_dual_wan_site_services.bgp_as
                                set_obj1.value = set_value.replace('AS', bgpas)
                    elif entity == 'cpe_primary' or entity == 'cpe_secondary':
                            obj_bgp_as = getLocalObject(sdata, 'dual-cpe-site-services')
                            if hasattr(obj_bgp_as.dual_cpe_site_services, 'bgp_as'):
                                bgpas = obj_bgp_as.dual_cpe_site_services.bgp_as
                                set_obj1.value = set_value.replace('AS', bgpas)
                    elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
                            obj_bgp_as = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
                            if hasattr(obj_bgp_as.dual_cpe_dual_wan_site_services, 'bgp_as'):
                                bgpas = obj_bgp_as.dual_cpe_dual_wan_site_services.bgp_as
                                set_obj1.value = set_value.replace('AS', bgpas)
                    elif entity == 'cpe_primary_triple' or entity == 'cpe_secondary_triple' or entity == 'cpe_tertiary_triple':
                            obj_bgp_as = getLocalObject(sdata, 'triple-cpe-site-services')
                            if hasattr(obj_bgp_as.triple_cpe_site_services, 'bgp_as'):
                                bgpas = obj_bgp_as.triple_cpe_site_services.bgp_as
                                set_obj1.value = set_value.replace('AS', bgpas)

                elif 'FLEX-COMMUNITY-LOCAL' in set_value and set_type == 'community':
                    # Construct community value from local Loopback0 last two octets
                    uri = sdata.getRcPath()
                    uri_list = uri.split('/',7)
                    url = '/'.join(uri_list[0:6])

                    # Quick  fix 16/05/2018
                    entity_map = {
                                  "cpe": "cpe",
                                  "cpe_dual": "cpe",
                                  "cpe_primary": "cpe-primary",
                                  "cpe_secondary": "cpe-secondary",
                                  "cpe_primary_dual": "cpe-primary",
                                  "cpe_secondary_dual": "cpe-secondary",
                                  "cpe_primary_triple": "cpe-primary",
                                  "cpe_secondary_triple": "cpe-secondary",
                                  "cpe_tertiary_triple": "cpe-tertiary"
                    }
                    
                    mgmt_loopback_url = url + '/' + entity_map[entity] + '/loopback/loopback=0'
                    if yang.Sdk.dataExists(mgmt_loopback_url):
                        loopback_output = yang.Sdk.getData(mgmt_loopback_url, '', sdata.getTaskId())
                        loopback_obj = util.parseXmlString(loopback_output)
                        
                        if hasattr(loopback_obj, 'loopback'):
                            if hasattr(loopback_obj.loopback, 'ip'):
                                if util.isNotEmpty(loopback_obj.loopback.ip):
                                    loopback_mgmt_ip = loopback_obj.loopback.ip
                                    loopback_mgmt_list = loopback_mgmt_ip.split('.')
                                    flex_com_value = ':'.join(loopback_mgmt_list[2:4])
                                    set_obj1.value = set_value.replace('FLEX-COMMUNITY-LOCAL', flex_com_value)
                                else:
                                    raise Exception("No Valid IP Address found in Loopback0. Cannot proceed with FLEX-COMMUNITY generation")
                    else:
                        raise Exception("No Loopback0 interface found in site service. Cannot proceed with FLEX-COMMUNITY generation")

                elif set_type == 'local-preference':
                    set_obj1.value = set_value
                elif set_type == 'comm-list':
                    community_lists(set_value, device, sdata)
                    set_obj1.value = set_value
                else:
                    set_obj1.value = set_value
            
            set_action_url = device.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (route_map_name,seq)
            yang.Sdk.createData(set_action_url, set_obj1.getxml(filter=True), sdata.getSession())


def as_path_acl(condition_value, device, sdata):
    uri = sdata.getRcPath()
    uri_list = uri.split('/',5)
    url = '/'.join(uri_list[0:4])

    xml_output = yang.Sdk.getData(url+"/as-path-acls", '',sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    #util.log_debug( "obj: ",obj)
    if not yang.Sdk.dataExists(device.url + '/l3features:as-path-acls'):
        yang.Sdk.createData(device.url, '<as-path-acls/>', sdata.getSession(), False)

    if hasattr(obj.as_path_acls, 'as_path_acl'):
        obj.as_path_acls.as_path_acl = util.convert_to_list(obj.as_path_acls.as_path_acl)
        for as_path_acl_obj in obj.as_path_acls.as_path_acl:
            number = as_path_acl_obj.get_field_value('number')
            if condition_value == number:
                condition = as_path_acl_obj.get_field_value('condition')
                expression = as_path_acl_obj.get_field_value('expression')
                as_path_obj = as_path_acls.as_path_acl.as_path_acl()
                as_path_obj.number = number
                as_path_obj.condition = condition
                as_path_obj.expression = expression

                as_path_url = device.url + '/l3features:as-path-acls'
                yang.Sdk.createData(as_path_url, as_path_obj.getxml(filter=True), sdata.getSession())


def adv_networks(entity, smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    prefix = inputdict['prefix']
    route_map = inputdict['route_map']
    vrf = inputdict['vrf_name']
    prefix = util.IPPrefix(prefix)
    ip_address = prefix.address
    netmask = prefix.netmask
    if netmask == '255.255.255.0':
        for x in range(192,224):
            if int(ip_address.split('.')[0]) == int(x):
                netmask = None
    adv_networks_obj = vrfs.vrf.router_bgp.network.network()
    adv_networks_obj.ip_address = ip_address
    if str(netmask) != "0.0.0.0":
        adv_networks_obj.netmask = netmask
    if util.isNotEmpty(route_map):
        route_maps(route_map, device, sdata)
        adv_networks_obj.route_map = route_map

    if util.isEmpty(vrf):
        vrf = 'GLOBAL'
    adv_networks_url1 = device.url + '/l3features:vrfs/vrf=%s' % (vrf)
    # is_router_bgp_xml_output = yang.Sdk.getData(adv_networks_url1, '', sdata.getTaskId())
    # is_router_bgp_obj = util.parseXmlString(is_router_bgp_xml_output)
    # util.log_debug( "is_router_bgp_obj is:", is_router_bgp_obj)
    # if not hasattr(is_router_bgp_obj.vrf, 'router_bgp'):
    if not yang.Sdk.dataExists(adv_networks_url1 + "/router-bgp"):
        yang.Sdk.createData(adv_networks_url1, '<router-bgp/>', sdata.getSession(), False)

    adv_networks_url = device.url + '/vrfs/vrf=%s/router-bgp' % (vrf)
    yang.Sdk.createData(adv_networks_url, adv_networks_obj.getxml(filter=True), sdata.getSession())

def sla_responder(smodelctx, sdata, device, **kwargs):
    from servicemodel.controller.devices.device.ip_sla import responder
    inputdict = kwargs['inputdict']
    
    sla_responder_obj = responder.responder()

    if util.isNotEmpty(inputdict['enable_responder']) and inputdict['enable_responder'] == "true" :
        sla_responder_obj.is_responder = inputdict['enable_responder']

    if util.isNotEmpty(inputdict['sla_logging_traps']) and inputdict['sla_logging_traps'] == "true":
        sla_responder_obj.is_logging_traps = inputdict['sla_logging_traps']

    if util.isNotEmpty(inputdict['server_twamp']) and inputdict['server_twamp'] == "true":
        sla_responder_obj.is_server_twamp = inputdict['server_twamp']

    if util.isNotEmpty(inputdict['server_twamp_port']) and util.isNotEmpty(inputdict['server_twamp_port']):
        sla_responder_obj.port = inputdict['server_twamp_port']

    yang.Sdk.createData(device.url + '/l3features:ip-sla', sla_responder_obj.getxml(filter=True), sdata.getSession())

    if util.isNotEmpty(inputdict['responder_twamp']) and inputdict['responder_twamp'] == "true":
        from servicemodel.controller.devices.device.ip_sla.responder import responder_options
        sla_responder_options_obj = responder_options.responder_options()

        sla_responder_options_obj.operation_type = "twamp"
        #yang.Sdk.createData(device.url + '/l3features:ip-sla/responder', '<responder-options/>', sdata.getSession(), False)
        yang.Sdk.createData(device.url + '/l3features:ip-sla/responder', sla_responder_options_obj.getxml(filter=True), sdata.getSession())
        yang.Sdk.append_taskdetail(sdata.getTaskId(), "Enabling IP SLA TWAMP Responder")


def ip_sla(smodelctx, sdata, device, **kwargs):
    inputdict = kwargs['inputdict']
    vrf_name = inputdict["vrf_name"]
    entry_number = inputdict['entry_number']
    operation_type = inputdict['operation_type']
    destination = inputdict['destination']
    source = inputdict['source']
    source_interface_name = None
    source_interface_ip = None
    if source == 'source-interface':
        source_interface_name = inputdict['source_interface_name']
    elif source == 'source-ip':
        source_interface_ip = inputdict['source_interface_ip']
    data_size = inputdict['data_size']
    frequency = inputdict['frequency']
    timeout = inputdict['timeout']
    threshold = inputdict['threshold']
    track_number = inputdict['track_number']
    response_data_size = inputdict['response_data_size']
    destination_port = inputdict['destination_port']
    source_port = inputdict['source_port']
    interval = inputdict['interval']
    tos = inputdict['tos']
    tag = inputdict['tag']
    history_interval = inputdict['history_interval']
    buckets_size = inputdict['buckets_size']
    http_request_type = inputdict['http_request_type']
    http_url = inputdict['http_url']
    http_raw_request = inputdict['http_raw_request']
    num_packets = inputdict['num_packets']
    track_delay_down_time = inputdict['track_delay_down_time']
    track_delay_up_time = inputdict['track_delay_up_time']
    from servicemodel.controller.devices.device import ip_sla
    from servicemodel.controller.devices.device import ip_sla_schedules
    from servicemodel.controller.devices.device import tracks
    sla_obj = ip_sla.sla.sla()
    sla_obj.vrf_name = vrf_name
    sla_obj.entry_number = entry_number
    sla_obj.operation_type = operation_type
    if operation_type == 'http':
        if util.isNotEmpty(http_request_type):
            sla_obj.http_request_type = http_request_type
        if util.isNotEmpty(http_url):
            sla_obj.http_url = http_url
        if util.isNotEmpty(http_raw_request):
            sla_obj.http_raw_request = http_raw_request
    sla_obj.destination = destination
    sla_obj.source = source
    if util.isNotEmpty(source_interface_name):
        sla_obj.source_interface_name = source_interface_name
    if util.isNotEmpty(source_interface_ip):
        sla_obj.source_interface_ip = source_interface_ip
        if util.isNotEmpty(destination_port):
            sla_obj.destination_port = destination_port
        if util.isNotEmpty(source_port):
            sla_obj.source_port = source_port
        if util.isNotEmpty(interval):
            sla_obj.interval = interval
        if util.isNotEmpty(num_packets):
            sla_obj.num_packets = num_packets
    sla_obj.data_size = data_size
    if util.isNotEmpty(frequency):
        if frequency == "60":
            #Set Frequency to None to avoid reconciliation as it is default value in Cisco IOS
            sla_obj.frequency = None
        else:
            sla_obj.frequency = frequency
        if util.isNotEmpty(history_interval):
            sla_obj.history_interval = history_interval
            if int(history_interval)%int(frequency) != 0:
                raise Exception('History Interval should be a multiple of operation frequency')
        if util.isNotEmpty(buckets_size):
            sla_obj.buckets_size = buckets_size

    sla_obj.timeout = timeout
    sla_obj.threshold = threshold
    if util.isNotEmpty(response_data_size):
        sla_obj.response_data_size = response_data_size
    if util.isNotEmpty(tos):
        if tos == "0":
            sla_obj.tos = None
        else:
            sla_obj.tos = tos
    if util.isNotEmpty(tag):
        sla_obj.tag = tag

    #yang.Sdk.createData(device.url, '<ip-sla/>', sdata.getSession(), False)
    ip_sla_url = device.url + '/l3features:ip-sla'
    yang.Sdk.createData(ip_sla_url, sla_obj.getxml(filter=True), sdata.getSession())

    #yang.Sdk.createData(device.url, '<ip-sla-schedules/>', sdata.getSession(), False)
    schedules_obj = ip_sla_schedules.ip_sla_schedule.ip_sla_schedule()
    schedules_obj.entry_number = entry_number
    ip_sla_schedules_url = device.url + '/l3features:ip-sla-schedules'
    yang.Sdk.createData(ip_sla_schedules_url, schedules_obj.getxml(filter=True), sdata.getSession())

    if util.isNotEmpty(track_number):
        if not yang.Sdk.dataExists(device.url + '/l3features:tracks'):
            yang.Sdk.createData(device.url, '<tracks/>', sdata.getSession(), False)
        tracks_obj = tracks.track.track()
        tracks_obj.track_number = track_number
        tracks_obj.track_type = "ip"
        tracks_obj.ip_type = "sla"
        tracks_obj.delay_down_time = track_delay_down_time
        tracks_obj.delay_up_time = track_delay_up_time
        tracks_obj.entry_number = entry_number
        tracks_url = device.url + '/l3features:tracks'
        yang.Sdk.createData(tracks_url, tracks_obj.getxml(filter=True), sdata.getSession())


def list_entry_def(smodelctx,sdata,device,**kwargs):
    inputdict = kwargs['inputdict']
    track_type = None 
    if inputdict.has_key('list_track_number') and inputdict.has_key('track_type'):
        list_track_number = inputdict['list_track_number']
        track_type = inputdict['track_type']
        list_type = inputdict['list_type']
        boolean_type = inputdict['boolean_type']
    if inputdict.has_key('list_track_number'):
        list_track_number = inputdict['list_track_number']
    else:
        list_track_number = None 
    if inputdict.has_key('object_number'):
        object_number = inputdict['object_number']
    else:
        object_number = None 
    if inputdict.has_key('not'):
        object_not = inputdict['not']
    else:
        object_not = None
    from servicemodel.controller.devices.device import tracks

    if util.isNotEmpty(list_track_number) and util.isNotEmpty(track_type):
        if not yang.Sdk.dataExists(device.url + '/l3features:tracks'):
            yang.Sdk.createData(device.url, '<tracks/>', sdata.getSession(), False)
        tracks_obj = tracks.track.track()
        tracks_obj.track_number = list_track_number
        tracks_obj.track_type = track_type
        tracks_obj.list_type = list_type
        tracks_obj.boolean_type = boolean_type
        tracks_url = device.url + '/l3features:tracks'
        #yang.Sdk.createData(tracks_url, tracks_obj.getxml(filter=True), sdata.getSession())
        payload = tracks_obj.getxml(filter=True)
        fill = '<list-type>' + list_type + '</list-type><boolean-type>' + boolean_type + '</boolean-type></l3features:track>'
        payload = payload.replace('</l3features:track>', fill)
        yang.Sdk.createData(tracks_url, payload, sdata.getSession())

    if util.isNotEmpty(object_number):
        print "Entered in to object_number"
        if not yang.Sdk.dataExists(device.url + '/l3features:tracks'):
            yang.Sdk.createData(device.url, '<tracks/>', sdata.getSession(), False)
        tracks_obj_list = tracks.track.object_list.object_list()
        tracks_obj_list.object_number = object_number
        #tracks_obj_list.not = object_not
        object_list_url = '/l3features:tracks/track=%s' % (list_track_number)
        tracks_url = device.url + object_list_url 
        yang.Sdk.createData(tracks_url, tracks_obj_list.getxml(filter=True), sdata.getSession())

def staticroute(smodelctx, sdata, dev, **kwarg):
    vrf_name = kwarg['inputdict']['vrf']

    if vrf_name is not None:
        list_vrf = []
        obj_vrf = getLocalObject(sdata, 'customer')
        #util.log_debug("obj_vrf: ", obj_vrf)
        if hasattr(obj_vrf.customer.vrfs, 'vrf'):
            obj_vrf.customer.vrfs.vrf = util.convert_to_list(obj_vrf.customer.vrfs.vrf)
            for vrf in obj_vrf.customer.vrfs.vrf:
                if vrf.vrf_name == vrf_name:
                    vrfobj = vrfs.vrf.vrf()
                    vrfobj.name = vrf_name
                    if hasattr(vrf, 'rd'):
                        if util.isNotEmpty(vrf.rd):
                            vrfobj.rd = vrf.rd
                    if hasattr(vrf, 'description'):
                        if util.isNotEmpty(vrf.description):
                            vrfobj.description = vrf.description
                    if util.isNotEmpty(vrf.vrf_definition_mode):
                        vrfobj.vrf_definition_mode = vrf.vrf_definition_mode
                    is_vrf_exists = False
                    is_vrf = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
                    is_vrf_exists_obj = util.parseXmlString(is_vrf)
                    #util.log_debug( "is_vrf_obj is:", is_vrf_exists_obj)
                    if hasattr(is_vrf_exists_obj.device, 'vrfs'):
                        if hasattr(is_vrf_exists_obj.device.vrfs, 'vrf'):
                            vrf_check_all = util.convert_to_list(is_vrf_exists_obj.device.vrfs.vrf)
                            for vrf_check in vrf_check_all:
                                if vrf_check.name == vrf_name:
                                    is_vrf_exists = True
                    if not is_vrf_exists:
                        yang.Sdk.createData(dev.url + '/l3features:vrfs', vrfobj.getxml(filter=True), sdata.getSession())

                list_vrf.append(vrf.vrf_name)
        if vrf_name not in list_vrf:
            raise Exception('VRF is not part of customer')
        is_vrf_xml_output = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
        is_vrf_obj = util.parseXmlString(is_vrf_xml_output)
        #util.log_debug( "is_vrf_obj is:", is_vrf_obj)
        if not hasattr(is_vrf_obj.device, 'vrfs'):
            yang.Sdk.createData(dev.url, '<vrfs/>', sdata.getSession(), False)

        static_routes_url = dev.url + '/l3features:vrfs/vrf=%s' % (vrf_name)
        static_obj1 = vrfs.vrf.routes.route.route()
    else:
        static_routes_url = dev.url
        static_obj1 = routes.route.route()
    if not yang.Sdk.dataExists(static_routes_url + '/l3features:routes'):
        yang.Sdk.createData(static_routes_url, '<routes/>', sdata.getSession(), False)
    obj_local = getLocalObject(sdata, 'static-route=')
    #util.log_debug("static route obj is:",obj_local.static_route)

    static_obj1.dest_ip_address = obj_local.static_route.dest_ip_address
    static_obj1.dest_mask = obj_local.static_route.dest_mask
    if vrf_name is not None:
        static_route_url = dev.url + '/l3features:vrfs/vrf=%s/routes' % (vrf_name)
        static_obj = vrfs.vrf.routes.route.options.options()
        get_static_route_url = dev.url + '/l3features:vrfs/vrf=%s/routes/route=%s,%s' % (vrf_name,obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    else:
        static_route_url = dev.url + '/routes'
        static_obj = routes.route.options.options()
        get_static_route_url = dev.url + '/l3features:routes/route=%s,%s' % (obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    # try:
    #     xml_output = yang.Sdk.getData(get_static_route_url, '', sdata.getTaskId())
    #     obj_get = util.parseXmlString(xml_output)
    #     util.log_debug( "obj of route is: ",obj_get)
    #     #yang.Sdk.createData(static_route_url, static_obj1.getxml(filter=True), sdata.getSession(), False)
    # except DataNodeNotFoundException:
    #     yang.Sdk.createData(static_route_url, static_obj1.getxml(filter=True), sdata.getSession())
    get_static_route_url = get_static_route_url.split("data")[1]
    if not yang.Sdk.dataExists(get_static_route_url):
        yang.Sdk.createData(static_route_url, static_obj1.getxml(filter=True), sdata.getSession())

    id = []
    #id = 'ip route'
    id.append('ip route')
    if vrf_name is not None:
        #id += ' vrf' + ' ' + vrf_name
        id.append('vrf')
        id.append(vrf_name)
    #id += ' ' + obj_local.static_route.dest_ip_address + ' ' + obj_local.static_route.dest_mask
    id.append(obj_local.static_route.dest_ip_address)
    id.append(obj_local.static_route.dest_mask)
    interface_name = kwarg['inputdict']['interface_name']
    if interface_name is not None:
        #id += ' ' + interface_name
        id.append(interface_name)
        static_obj.interface_name = interface_name

    next_hop_ip = kwarg['inputdict']['next_hop_ip']
    if next_hop_ip is not None:
        #id += ' ' + next_hop_ip
        id.append(next_hop_ip)
        static_obj.next_hop_ip = next_hop_ip

    if interface_name is None and next_hop_ip is None:
        raise Exception("Both Interface Name & Next Hop IP can not be empty in static routes")

    if vrf_name is not None:
        global_address = kwarg['inputdict']['global_address']
        if global_address is not None and global_address == 'true':
            #id += ' ' + 'global'
            id.append('global')
            static_obj.global_address = global_address
        elif global_address is not None and global_address == 'false':
            static_obj.global_address = global_address

    metric = kwarg['inputdict']['metric']
    if metric is not None:
        if int(metric) > 1:
            #id += ' ' + metric
            id.append(metric)
            static_obj.metric = metric

    tag = kwarg['inputdict']['tag']
    if tag is not None:
        #id += ' tag ' + tag
        id.append('tag')
        id.append(tag)
        static_obj.tag = tag

    permanent = kwarg['inputdict']['permanent']
    if permanent is not None and permanent == 'true':
        #id += ' permanent'
        id.append('permanent')
        static_obj.permanent = permanent
    elif permanent is not None and permanent == 'false':
        static_obj.permanent = permanent

    name = kwarg['inputdict']['name']
    if name is not None:
        #id += ' name ' + name
        id.append('name')
        id.append(name)
        static_obj.name = name

    track = kwarg['inputdict']['track']
    if track is not None:
        #id += ' track ' + track
        id.append('track')
        id.append(track)
        static_obj.track = track

    description = kwarg['inputdict']['description']
    if description is not None:
        static_obj.description = description
    static_obj.id = ' '.join(id)

    if vrf_name is not None:
        static_url = dev.url + '/l3features:vrfs/vrf=%s/routes/route=%s,%s' % (vrf_name,obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    else:
        static_url = dev.url + '/l3features:routes/route=%s,%s' % (obj_local.static_route.dest_ip_address,obj_local.static_route.dest_mask)
    yang.Sdk.createData(static_url, static_obj.getxml(filter=True), sdata.getSession())


def community_lists(community_list_name_given, device, sdata, **kwargs):

    #yang.Sdk.createData(device.url, '<community-lists/>', sdata.getSession(), False)
    obj = getLocalObject(sdata, 'customer')
    #util.log_debug( "obj of communitylist is: ",obj)
    #util.log_debug( "communitylist obj is:",obj.customer.community_lists)
    if hasattr(obj.customer.community_lists, 'community_list'):
        obj.customer.community_lists.community_list = util.convert_to_list(obj.customer.community_lists.community_list)
        #util.log_debug( "communitylist obj is:",obj.customer.community_lists.community_list)
        for community_list_obj in obj.customer.community_lists.community_list:
            community_list_name = community_list_obj.get_field_value('community_list_name')
            if community_list_name_given == community_list_name:
                if community_list_obj.extcommunity == 'true':
                    extcommunity_list(sdata, device, community_list_obj)
                elif community_list_obj.extcommunity == 'false':
                    community_list(sdata, device, community_list_obj)


def community_list(sdata, device, community_list_obj_given):
    from servicemodel.controller.devices.device import community_lists
    community_list_obj = community_lists.community_list.community_list()
    community_list_entry = community_list_obj_given.community_list_entry
    if util.isNotEmpty(community_list_entry):
        community_list_obj.community_list_entry = community_list_entry
    community_list_name = community_list_obj_given.community_list_name
    if util.isNotEmpty(community_list_name):
        community_list_obj.community_list_name = community_list_name
    condition = community_list_obj_given.condition
    if util.isNotEmpty(condition):
        community_list_obj.condition = condition
    value = community_list_obj_given.value
    if util.isNotEmpty(value):

        # Construct community value from local Loopback0 last two octets
        if value == "FLEX-COMMUNITY-LOCAL":
            
            uri = sdata.getRcPath()
            uri_list = uri.split('/',7)
            url = '/'.join(uri_list[0:6])
            
            mgmt_loopback_url = url + '/cpe/loopback/loopback=0'
            if yang.Sdk.dataExists(mgmt_loopback_url):
                loopback_output = yang.Sdk.getData(mgmt_loopback_url, '', sdata.getTaskId())
                loopback_obj = util.parseXmlString(loopback_output)
                
                if hasattr(loopback_obj, 'loopback'):
                    if hasattr(loopback_obj.loopback, 'ip'):
                        if util.isNotEmpty(loopback_obj.loopback.ip):
                            loopback_mgmt_ip = loopback_obj.loopback.ip
                            loopback_mgmt_list = loopback_mgmt_ip.split('.')
                            flex_com_value = ':'.join(loopback_mgmt_list[2:4])
                            community_list_obj.value = flex_com_value
                        else:
                            raise Exception("No Valid IP Address found in Loopback0. Cannot proceed with FLEX-COMMUNITY generation")

            else:
                raise Exception("No Loopback0 interface found in site service. Cannot proceed with FLEX-COMMUNITY generation")

        # Construct community value from primary CPE Loopback0 last two octets
        elif value == "FLEX-COMMUNITY-PRI":
            
            uri = sdata.getRcPath()
            uri_list = uri.split('/',6)
            url = '/'.join(uri_list[0:6])
            
            mgmt_loopback_url = url + '/cpe-primary/loopback/loopback=0'
            if yang.Sdk.dataExists(mgmt_loopback_url):
                loopback_output = yang.Sdk.getData(mgmt_loopback_url, '', sdata.getTaskId())
                loopback_obj = util.parseXmlString(loopback_output)
                
                if hasattr(loopback_obj, 'loopback'):
                    if hasattr(loopback_obj.loopback, 'ip'):
                        if util.isNotEmpty(loopback_obj.loopback.ip):
                            loopback_mgmt_ip = loopback_obj.loopback.ip
                            loopback_mgmt_list = loopback_mgmt_ip.split('.')
                            flex_com_value = ':'.join(loopback_mgmt_list[2:4])
                            community_list_obj.value = flex_com_value
                        else:
                            raise Exception("No Valid IP Address found in Loopback0. Cannot proceed with FLEX-COMMUNITY generation")

            else:
                raise Exception("No Loopback0 interface found in site service. Cannot proceed with FLEX-COMMUNITY generation")

        # Construct community value from secondary CPE Loopback0 last two octets
        elif value == "FLEX-COMMUNITY-SEC":
            
            uri = sdata.getRcPath()
            uri_list = uri.split('/',6)
            url = '/'.join(uri_list[0:6])
            
            mgmt_loopback_url = url + '/cpe-secondary/loopback/loopback=0'
            if yang.Sdk.dataExists(mgmt_loopback_url):
                loopback_output = yang.Sdk.getData(mgmt_loopback_url, '', sdata.getTaskId())
                loopback_obj = util.parseXmlString(loopback_output)
                
                if hasattr(loopback_obj, 'loopback'):
                    if hasattr(loopback_obj.loopback, 'ip'):
                        if util.isNotEmpty(loopback_obj.loopback.ip):
                            loopback_mgmt_ip = loopback_obj.loopback.ip
                            loopback_mgmt_list = loopback_mgmt_ip.split('.')
                            flex_com_value = ':'.join(loopback_mgmt_list[2:4])
                            community_list_obj.value = flex_com_value
                        else:
                            raise Exception("No Valid IP Address found in Loopback0. Cannot proceed with FLEX-COMMUNITY generation")

            else:
                raise Exception("No Loopback0 interface found in site service. Cannot proceed with FLEX-COMMUNITY generation")

        else:
            community_list_obj.value = value
    community_list_url = device.url + '/l3features:community-lists'
    payload = community_list_obj.getxml()
    if util.isEmpty(community_list_entry):
        payload = payload.replace('<community-list-entry>standard</community-list-entry>', '<community-list-entry></community-list-entry>')

    yang.Sdk.createData(community_list_url, payload, sdata.getSession())


def extcommunity_lists(extcommunity_list_name_given, dev, sdata, **kwargs):
    #yang.Sdk.createData(dev.url, '<extcommunity-lists/>', sdata.getSession(), False)
    obj = getLocalObject(sdata, 'customer')
    #util.log_debug( "extcommunitylist obj is:",obj.customer.extcommunity_lists)
    if hasattr(obj.customer.extcommunity_lists, 'extcommunity_list'):
        obj.customer.extcommunity_lists.extcommunity_list = util.convert_to_list(obj.customer.extcommunity_lists.extcommunity_list)
        #util.log_debug( "extcommunitylist obj is:",obj.customer.extcommunity_lists.extcommunity_list)
        for extcommunity_list_obj in obj.customer.extcommunity_lists.extcommunity_list:
            extcommunity_list_name = extcommunity_list_obj.get_field_value('extcommunity_list_name')
            if extcommunity_list_name_given == extcommunity_list_name :
                print "extcommunity_list_name is:",extcommunity_list_name
                print "extcommunity_list_name_given is:", extcommunity_list_name_given
                extcommunity_list(sdata, dev, extcommunity_list_obj)


def extcommunity_list(sdata, device, extcommunity_list_obj_given):
    from servicemodel.controller.devices.device import extcommunity_lists
    extcommunity_list_obj = extcommunity_lists.extcommunity_list.extcommunity_list()
    extcommunity_list_entry = extcommunity_list_obj_given.community_list_entry
    if util.isNotEmpty(extcommunity_list_entry):
        extcommunity_list_obj.extcommunity_list_entry = extcommunity_list_entry
    extcommunity_list_name = extcommunity_list_obj_given.community_list_name
    if util.isNotEmpty(extcommunity_list_name):
        extcommunity_list_obj.extcommunity_list_name = extcommunity_list_name
    condition = extcommunity_list_obj_given.condition
    if util.isNotEmpty(condition):
        extcommunity_list_obj.condition = condition
    extcomm = extcommunity_list_obj_given.extcomm
    if util.isNotEmpty(extcomm):
        extcommunity_list_obj.extcomm = extcomm
    value = extcommunity_list_obj_given.value
    if util.isNotEmpty(value):
        extcommunity_list_obj.value = value
    extcommunity_list_url = device.url + '/l3features:extcommunity-lists'
    yang.Sdk.createData(extcommunity_list_url, extcommunity_list_obj.getxml(filter=True), sdata.getSession())


def modifiedGetLocalObject(sdata, elem):
    smodelctx = None
    rcpath = sdata.getRcPath() + '/'
    print 'rcpath = %s' % (rcpath)
    pattern = '/controller:services'
    idx = rcpath.find(pattern)
    if idx < 0:
        print 'cant find pattern in rcpath = %s' % (rcpath)
        return rcpath
    idx = rcpath.find(elem, idx)
    if idx < 0:
        print 'cant find pattern in rcpath = %s' % (rcpath)
        return rcpath
    idx = rcpath.find('/', idx)
    print 'idx = %d' % (idx)
    if idx < 0:
        print 'cant find / in rcpath = %s, idx = %d' % (rcpath, idx)
        return rcpath
    print 'rcpath = %s, new = %s' % (rcpath, rcpath[:idx])
    rcpath = rcpath[:idx]
    print 'setting rcpath= %s' % (rcpath)

    xml_output = yang.Sdk.getData(rcpath, '', sdata.getTaskId())
    obj = util.parseXmlString(xml_output)
    return obj


def interface(entity, dev, sdata, **kwarg):
    obj = getLocalObject(sdata, 'vrf=')
    redistconnected = None
    if hasattr(obj.vrf, 'redistribute_connected_route_policy'):
        redistconnected = obj.vrf.redistribute_connected_route_policy
    if util.isEmpty(redistconnected) or redistconnected is None:
        raise Exception("Please provide redistribute connected route policy")
    int_name = kwarg['inputdict']['interface_name']
    seq_num = kwarg['inputdict']['entry_sequence_number']
    value = None
    match_condition_url = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
    route_output = yang.Sdk.getData(match_condition_url, '', sdata.getTaskId())
    route_output = util.parseXmlString(route_output)
    if hasattr(route_output.route_map_entries,'match_condition'):
        for match_obj in util.convert_to_list(route_output.route_map_entries.match_condition):
            if hasattr(match_obj, 'condition_type'):
                if match_obj.condition_type == 'interface':
                    value = match_obj.value

    from servicemodel.controller.devices.device import route_maps
    matchcondition_obj = route_maps.route_map.route_map_entries.match_condition.match_condition()
    matchcondition_obj.condition_type = 'interface'

    intf_obj = interfaces.interface.interface()
    intname = int_name.split(" ")
    for each_int in intname:
        intf_obj.name = each_int
        intf_obj.long_name = each_int
        if not dev.isInterfaceInDeviceExists(each_int):
            yang.Sdk.createData(dev.url+'/interface:interfaces', intf_obj.getxml(filter=True), sdata.getSession(), False)

    if value is None:
        matchcondition_obj.value = int_name
    else:
        #int_name = value + ' ' + int_name
        matchcondition_obj.value = int_name
        value = value.replace(' ', '%20').replace('/', '%2F')
        match_condition_url1 = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (redistconnected,seq_num,value)
        match_condition_rpc = '/controller:devices/device=%s/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (dev.device.id,redistconnected,seq_num,value)
        output = yang.Sdk.invokeRpc('ncxsdk:get-inbound-references', '<input><rc-path>'+match_condition_rpc+'</rc-path></input>')
        ref = util.parseXmlString(output)
        #util.log_debug("xml_op:%s" %(ref))
        if hasattr(ref.output, 'references'):
            if hasattr(ref.output.references, 'reference'):
                if hasattr(ref.output.references.reference, 'src_node'):
                    for each_ref in util.convert_to_list(ref.output.references.reference.src_node):
                        yang.Sdk.removeReference(each_ref, match_condition_rpc)
        yang.Sdk.deleteData(match_condition_url1, '', sdata.getTaskId(), sdata.getSession())
    match_condition_url = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
    yang.Sdk.createData(match_condition_url, matchcondition_obj.getxml(filter=True), sdata.getSession(), False)

def interface_eigrp(entity, dev, sdata, **kwarg):
    obj = getLocalObject(sdata, 'router-eigrp')
    redistconnected = None
    if hasattr(obj.router_eigrp, 'redistribute'):
        if hasattr(obj.router_eigrp.redistribute, 'redistribute_on_eigrp'):
            for eachredist in util.convert_to_list(obj.router_eigrp.redistribute.redistribute_on_eigrp):
                if eachredist.protocol == 'connected':
                    if util.isEmpty(eachredist.route_map) or eachredist.route_map is None:
                        raise Exception("Please provide Redistribute Connected Route-Map Policy")
                    else:
                        redistconnected = eachredist.route_map

                        int_name = kwarg['inputdict']['interface_name']
                        seq_num = kwarg['inputdict']['route_map_connected_sequence_number']
                        value = None
                        match_condition_url = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
                        route_output = yang.Sdk.getData(match_condition_url, '', sdata.getTaskId())
                        route_output = util.parseXmlString(route_output)
                        if hasattr(route_output.route_map_entries,'match_condition'):
                           for match_obj in util.convert_to_list(route_output.route_map_entries.match_condition):
                               if hasattr(match_obj, 'condition_type'):
                                   if match_obj.condition_type == 'interface':
                                       value = match_obj.value

                        from servicemodel.controller.devices.device import route_maps
                        matchcondition_obj = route_maps.route_map.route_map_entries.match_condition.match_condition()
                        matchcondition_obj.condition_type = 'interface'

                        intf_obj = interfaces.interface.interface()
                        intname = int_name.split(" ")
                        for each_int in intname:
                            intf_obj.name = each_int
                            intf_obj.long_name = each_int
                            if not dev.isInterfaceInDeviceExists(each_int):
                                yang.Sdk.createData(dev.url+'/interface:interfaces', intf_obj.getxml(filter=True), sdata.getSession(), False)

                        if value is None:
                            matchcondition_obj.value = int_name
                        else:
                            int_name = value + ' ' + int_name
                            matchcondition_obj.value = int_name
                            value = value.replace(' ', '%20').replace('/', '%2F')
                            match_condition_url1 = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (redistconnected,seq_num,value)
                            match_condition_rpc = '/controller:devices/device=%s/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (dev.device.id,redistconnected,seq_num,value)
                            output = yang.Sdk.invokeRpc('ncxsdk:get-inbound-references', '<input><rc-path>'+match_condition_rpc+'</rc-path></input>')
                            ref = util.parseXmlString(output)
                            #util.log_debug("xml_op:%s" %(ref))
                            if hasattr(ref.output, 'references'):
                               if hasattr(ref.output.references, 'reference'):
                                   if hasattr(ref.output.references.reference, 'src_node'):
                                       for each_ref in util.convert_to_list(ref.output.references.reference.src_node):
                                           yang.Sdk.removeReference(each_ref, match_condition_rpc)
                            yang.Sdk.deleteData(match_condition_url1, '', sdata.getTaskId(), sdata.getSession())
                        match_condition_url = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
                        yang.Sdk.createData(match_condition_url, matchcondition_obj.getxml(filter=True), sdata.getSession(), False)

def interface_ospf(entity, dev, sdata, **kwarg):
    obj = getLocalObject(sdata, 'router-ospf')
    redistconnected = None
    if hasattr(obj.router_ospf, 'redistribute'):
        if hasattr(obj.router_ospf.redistribute, 'redistribute_on_ospf'):
            for eachredist in util.convert_to_list(obj.router_ospf.redistribute.redistribute_on_ospf):
                if eachredist.protocol == 'connected':
                    if util.isEmpty(eachredist.route_map) or eachredist.route_map is None:
                        raise Exception("Please provide Redistribute Connected Route-Map Policy")
                    else:
                        redistconnected = eachredist.route_map

                        int_name = kwarg['inputdict']['interface_name']
                        seq_num = kwarg['inputdict']['route_map_connected_sequence_number']
                        value = None
                        match_condition_url = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
                        route_output = yang.Sdk.getData(match_condition_url, '', sdata.getTaskId())
                        route_output = util.parseXmlString(route_output)
                        if hasattr(route_output.route_map_entries,'match_condition'):
                           for match_obj in util.convert_to_list(route_output.route_map_entries.match_condition):
                               if hasattr(match_obj, 'condition_type'):
                                   if match_obj.condition_type == 'interface':
                                       value = match_obj.value

                        from servicemodel.controller.devices.device import route_maps
                        matchcondition_obj = route_maps.route_map.route_map_entries.match_condition.match_condition()
                        matchcondition_obj.condition_type = 'interface'

                        intf_obj = interfaces.interface.interface()
                        intname = int_name.split(" ")
                        for each_int in intname:
                            intf_obj.name = each_int
                            intf_obj.long_name = each_int
                            if not dev.isInterfaceInDeviceExists(each_int):
                                yang.Sdk.createData(dev.url+'/interface:interfaces', intf_obj.getxml(filter=True), sdata.getSession(), False)

                        if value is None:
                            matchcondition_obj.value = int_name
                        else:
                            int_name = value + ' ' + int_name
                            matchcondition_obj.value = int_name
                            value = value.replace(' ', '%20')
                            match_condition_url1 = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (redistconnected,seq_num,value)
                            match_condition_rpc = '/controller:devices/device=%s/l3features:route-maps/route-map=%s/route-map-entries=%s/match-condition=interface,%s' % (dev.device.id,redistconnected,seq_num,value)
                            output = yang.Sdk.invokeRpc('ncxsdk:get-inbound-references', '<input><rc-path>'+match_condition_rpc+'</rc-path></input>')
                            ref = util.parseXmlString(output)
                            #util.log_debug("xml_op:%s" %(ref))
                            if hasattr(ref.output, 'references'):
                               if hasattr(ref.output.references, 'reference'):
                                   if hasattr(ref.output.references.reference, 'src_node'):
                                       for each_ref in util.convert_to_list(ref.output.references.reference.src_node):
                                           yang.Sdk.removeReference(each_ref, match_condition_rpc)
                            yang.Sdk.deleteData(match_condition_url1, '', sdata.getTaskId(), sdata.getSession())
                        match_condition_url = dev.url + '/l3features:route-maps/route-map=%s/route-map-entries=%s' % (redistconnected,seq_num)
                        yang.Sdk.createData(match_condition_url, matchcondition_obj.getxml(filter=True), sdata.getSession(), False)

def get_device_by_id(sdata, dev_id):
    key = 'deviceid.%s' % (dev_id)
    dev = sdata.getSessionItem(key)
    if dev != None:
        #util.log_debug('get_device_by_id:cache-hit key=%s' % (key))
        return dev
    #util.log_debug('get_device_by_id:cache-miss key=%s' % (key))
    dev = devicemgr.getDeviceById(dev_id)
    if dev != None:
        sdata.setSessionItem(key, dev, True)
    return dev

def update_ip_sla(sdata, entity):
    device = None
    config = util.parseXmlString(sdata.getPayload())
    prevconfig = util.parseXmlString(sdata.getPreviousPayload())
    #util.log_debug( "prevconfig is:", prevconfig)
    if entity == 'cpe':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'single-cpe-site-services')
        dev = obj_cpe.single_cpe_site_services.cpe.device_ip
        device = get_device_by_id(sdata, dev)
    if entity == 'cpe_dual':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
        dev = obj_cpe.single_cpe_dual_wan_site_services.cpe.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_primary':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'dual-cpe-site-services')
        dev = obj_cpe.dual_cpe_site_services.cpe_primary.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_secondary':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'dual-cpe-site-services')
        dev = obj_cpe.dual_cpe_site_services.cpe_secondary.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_primary_dual':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        dev = obj_cpe.dual_cpe_dual_wan_site_services.cpe_primary.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_secondary_dual':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        dev = obj_cpe.dual_cpe_dual_wan_site_services.cpe_secondary.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_primary_triple':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'triple-cpe-site-services')
        dev = obj_cpe.triple_cpe_site_services.cpe_primary.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_secondary_triple':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'triple-cpe-site-services')
        dev = obj_cpe.triple_cpe_site_services.cpe_secondary.device_ip
        device = get_device_by_id(sdata, dev)
    elif entity == 'cpe_tertiary_triple':
        config = config.sla
        prevconfig = prevconfig.sla
        obj_cpe = getLocalObject(sdata, 'triple-cpe-site-services')
        dev = obj_cpe.triple_cpe_site_services.cpe_tertiary.device_ip
        device = get_device_by_id(sdata, dev)

    entry_number = prevconfig.get_field_value('entry_number')

    vrf_name = config.get_field_value('vrf_name')
    operation_type = config.get_field_value('operation_type')
    http_request_type = config.get_field_value('http_request_type')
    http_url = config.get_field_value('http_url')
    http_raw_request = config.get_field_value('http_raw_request')
    destination = config.get_field_value('destination')
    source = config.get_field_value('source')
    source_interface_name = config.get_field_value('source_interface_name')
    source_interface_ip = config.get_field_value('source_interface_ip')
    destination_port = config.get_field_value('destination_port')
    source_port = config.get_field_value('source_port')
    interval = config.get_field_value('interval')
    num_packets = config.get_field_value('num_packets')
    data_size = config.get_field_value('data_size')
    frequency = config.get_field_value('frequency')
    history_interval = config.get_field_value('history_interval')
    buckets_size = config.get_field_value('buckets_size')
    timeout = config.get_field_value('timeout')
    threshold = config.get_field_value('threshold')
    response_data_size = config.get_field_value('response_data_size')
    tos = config.get_field_value('tos')
    tag = config.get_field_value('tag')
    track_number = config.get_field_value('track_number')
    track_delay_down_time = config.get_field_value('track_delay_down_time')
    track_delay_up_time = config.get_field_value('track_delay_up_time')

    prevvrf_name = prevconfig.get_field_value('vrf_name')
    prevoperation_type = prevconfig.get_field_value('operation_type')
    prevhttp_request_type = prevconfig.get_field_value('http_request_type')
    prevhttp_url = prevconfig.get_field_value('http_url')
    prevhttp_raw_request = prevconfig.get_field_value('http_raw_request')
    prevdestination = prevconfig.get_field_value('destination')
    prevsource = prevconfig.get_field_value('source')
    prevsource_interface_name = prevconfig.get_field_value('source_interface_name')
    prevsource_interface_ip = prevconfig.get_field_value('source_interface_ip')
    prevdestination_port = prevconfig.get_field_value('destination_port')
    prevsource_port = prevconfig.get_field_value('source_port')
    previnterval = prevconfig.get_field_value('interval')
    prevnum_packets = prevconfig.get_field_value('num_packets')
    prevdata_size = prevconfig.get_field_value('data_size')
    prevfrequency = prevconfig.get_field_value('frequency')
    prevhistory_interval = prevconfig.get_field_value('history_interval')
    prevbuckets_size = prevconfig.get_field_value('buckets_size')
    prevtimeout = prevconfig.get_field_value('timeout')
    prevthreshold = prevconfig.get_field_value('threshold')
    prevresponse_data_size = prevconfig.get_field_value('response_data_size')
    prevtos = prevconfig.get_field_value('tos')
    prevtag = prevconfig.get_field_value('tag')
    prevtrack_number = prevconfig.get_field_value('track_number')
    
    
    from servicemodel.controller.devices.device import ip_sla
    sla_obj = ip_sla.sla.sla()
    if prevvrf_name != vrf_name:
        sla_obj.vrf_name = vrf_name
    else:
        sla_obj.vrf_name = prevvrf_name

    sla_obj.entry_number = entry_number

    if prevoperation_type != operation_type:
        sla_obj.operation_type = operation_type
        if operation_type == 'http':
            if util.isNotEmpty(http_request_type):
                sla_obj.http_request_type = http_request_type
            if util.isNotEmpty(http_url):
                sla_obj.http_url = http_url
            if util.isNotEmpty(http_raw_request):
                sla_obj.http_raw_request = http_raw_request
    else:
        sla_obj.operation_type = prevoperation_type
        if prevoperation_type == 'http':
            if util.isNotEmpty(prevhttp_request_type):
                sla_obj.http_request_type = prevhttp_request_type
            if util.isNotEmpty(prevhttp_url):
                sla_obj.http_url = prevhttp_url
            if util.isNotEmpty(prevhttp_raw_request):
                sla_obj.http_raw_request = prevhttp_raw_request

    if prevdestination != destination:
        sla_obj.destination = destination
    else:
        sla_obj.destination = prevdestination

    if prevsource != source:
        sla_obj.source = source
    else:
        sla_obj.source = prevsource

    if prevsource_interface_name != source_interface_name and util.isNotEmpty(source_interface_name):
        sla_obj.source_interface_name = source_interface_name
    else:
        sla_obj.source_interface_name = prevsource_interface_name

    if prevsource_interface_ip != source_interface_ip and util.isNotEmpty(source_interface_ip):
        sla_obj.source_interface_ip = source_interface_ip
    else:
        sla_obj.source_interface_ip = prevsource_interface_ip
        
    if prevdestination_port != destination_port and util.isNotEmpty(destination_port):
        sla_obj.destination_port = destination_port
    else:
        sla_obj.destination_port = prevdestination_port

    if prevsource_port != source_port and util.isNotEmpty(source_port):
        sla_obj.source_port = source_port
    else:
        sla_obj.source_port = prevsource_port
            
    if previnterval != interval and util.isNotEmpty(interval):
        sla_obj.interval = interval
    else:
        sla_obj.interval = previnterval

    if prevnum_packets != num_packets and util.isNotEmpty(num_packets):
        sla_obj.num_packets = num_packets
    else:
        sla_obj.num_packets = prevnum_packets
    
    if prevdata_size != data_size:
        sla_obj.data_size = data_size
    else:
        sla_obj.data_size = prevdata_size

    if prevfrequency != frequency and util.isNotEmpty(frequency):
            if frequency == "60":
                #Set Frequency to None to avoid reconciliation as it is default value in Cisco IOS
                sla_obj.frequency = None
            else:
                sla_obj.frequency = frequency
            if util.isNotEmpty(history_interval):
                sla_obj.history_interval = history_interval
                if int(history_interval)%int(frequency) != 0:
                    raise Exception('History Interval should be a multiple of operation frequency')
            if util.isNotEmpty(buckets_size):
                sla_obj.buckets_size = buckets_size
    else:
        if prevfrequency == "60":
            #Set Frequency to None to avoid reconciliation as it is default value in Cisco IOS
            sla_obj.frequency = None
        else:
            sla_obj.frequency = prevfrequency
        if util.isNotEmpty(prevhistory_interval):
            sla_obj.history_interval = prevhistory_interval
            if int(prevhistory_interval)%int(prevfrequency) != 0:
                    raise Exception('History Interval should be a multiple of operation frequency')
        if util.isNotEmpty(prevbuckets_size):
            sla_obj.buckets_size = prevbuckets_size

    if prevtimeout != timeout:
        sla_obj.timeout = timeout
    else:
        sla_obj.timeout = prevtimeout

    if prevthreshold != threshold:
        sla_obj.threshold = threshold
    else:
        sla_obj.threshold = prevthreshold

    if prevresponse_data_size != response_data_size and util.isNotEmpty(response_data_size):
        sla_obj.response_data_size = response_data_size
    else:
        sla_obj.response_data_size = prevresponse_data_size

    if prevtos != tos and util.isNotEmpty(tos):
        sla_obj.tos = tos
    else:
        sla_obj.tos = prevtos

    if prevtag != tag and util.isNotEmpty(tag):
        sla_obj.tag = tag
    else:
        sla_obj.tag = prevtag

    #Patch IP SLA Entry
    ip_sla_url = device.url + '/l3features:ip-sla/sla=%s' % (entry_number)
    yang.Sdk.patchData(ip_sla_url, sla_obj.getxml(filter=True), sdata, add_reference=False)
    
    #Create Track Object if added during IP SLA update
    if util.isNotEmpty(track_number) and util.isEmpty(prevtrack_number):
        from servicemodel.controller.devices.device import tracks
        if not yang.Sdk.dataExists(device.url + '/l3features:tracks'):
            yang.Sdk.createData(device.url, '<tracks/>', sdata.getSession(), False)
        tracks_obj = tracks.track.track()
        tracks_obj.track_number = track_number
        tracks_obj.track_type = "ip"
        tracks_obj.ip_type = "sla"
        tracks_obj.delay_down_time = track_delay_down_time
        tracks_obj.delay_up_time = track_delay_up_time
        tracks_obj.entry_number = entry_number
        tracks_url = device.url + '/l3features:tracks'
        yang.Sdk.createData(tracks_url, tracks_obj.getxml(filter=True), sdata.getSession())

def crypto_isakmp_peer(sdata, device, **kwargs):
    from servicemodel.controller.devices.device import crypto_peers
    
    
    inputdict = kwargs['inputdict']
    attr_name = inputdict['name']
    attr_type = inputdict['attribute_type']
    attr_password = inputdict['password']
    attr_ep_type = inputdict['endpoint_type']
    attr_fqdn = inputdict['fqdn']
    attr_ipv4 = inputdict['ipv4_address']
    attr_user_fqdn = inputdict['user_fqdn']

    #Create ISAKMP Peer
    obj_peer = getLocalObject(sdata, 'peers')
    if hasattr(obj_peer.peers, 'peer_address'):
        peer_address = obj_peer.peers.peer_address
    if hasattr(obj_peer.peers, 'vrf'):
        vrf = obj_peer.peers.vrf
    else:
        vrf = None

    crypto_peer_obj = crypto_peers.crypto_peer.crypto_peer()
    crypto_peer_id = "crypto isakmp peer address %s" % (peer_address)

    crypto_peer_obj.id = crypto_peer_id
    crypto_peer_obj.ike_version = "IKEV1"
    crypto_peer_obj.address = peer_address

    if vrf is not None:
        crypto_peer_id += " vrf %s" % (vrf)
        crypto_peer_obj.id = crypto_peer_id
        crypto_peer_obj.vrf_name = vrf

    yang.Sdk.createData(device.url, '<crypto-peers/>', sdata.getSession(), False)

    yang.Sdk.createData(device.url + '/dmvpn:crypto-peers', crypto_peer_obj.getxml(filter=True), sdata.getSession(), True)

    #Create ISAKMP Peer Attributes
    crypto_peer_obj_attr = crypto_peers.crypto_peer.set_attributes.set_attributes()
    crypto_isakmp_peer_attr_url = device.url + '/dmvpn:crypto-peers/crypto-peer=%s' % (crypto_peer_id.replace(' ', '%20'))
    if util.isNotEmpty(attr_type):
        if attr_type == "password":
            if util.isNotEmpty(attr_password):
                crypto_peer_obj_attr.attribute = "password"
                crypto_peer_obj_attr.password = attr_password

                yang.Sdk.createData(crypto_isakmp_peer_attr_url, crypto_peer_obj_attr.getxml(filter=True), sdata.getSession(), True)                

        elif attr_type == "client-endpoint":
            crypto_peer_obj_attr.attribute = "client-endpoint"
            if util.isNotEmpty(attr_ep_type):
                if attr_ep_type == "fqdn":
                    crypto_peer_obj_attr.endpoint = "fqdn"
                    crypto_peer_obj_attr.fqdn = attr_fqdn
                elif attr_ep_type == "ipv4-address":
                    crypto_peer_obj_attr.endpoint = "ipv4-address"
                    crypto_peer_obj_attr.ipv4_address = attr_ipv4
                elif attr_ep_type == "user-fqdn":
                    crypto_peer_obj_attr.endpoint = "user-fqdn"
                    crypto_peer_obj_attr.user_fqdn = attr_user_fqdn
    
                yang.Sdk.createData(crypto_isakmp_peer_attr_url, crypto_peer_obj_attr.getxml(filter=True), sdata.getSession(), True)

def vrf(entity, dev, sdata, **kwarg):

    print "Entering into vrf creation"

    vrf_name = kwarg['inputdict']['vrf_name']
    if util.isEmpty(vrf_name):
        vrf_name = "GLOBAL"
    #is_vrf_xml_output = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
    #is_vrf_obj = util.parseXmlString(is_vrf_xml_output)
    #if not hasattr(is_vrf_obj.device, 'vrfs'):
    dev_url = dev.url
    #util.log_debug("dev_url:", dev_url)
    dev_url = dev_url.split("data/")[1]
    if not yang.Sdk.dataExists(dev_url + "/l3features:vrfs"):
        yang.Sdk.createData(dev.url, '<vrfs/>', sdata.getSession(), False)
        

    uri = sdata.getRcPath()
    uri_list = uri.split('/',5)
    url = '/'.join(uri_list[0:4])

    if vrf_name != 'GLOBAL':
        xml_output = yang.Sdk.getData(url+"/vrfs", '',sdata.getTaskId())
        obj = util.parseXmlString(xml_output)
        #util.log_debug( "obj: ",obj)

        if hasattr(obj.vrfs, 'vrf'):
            obj.vrfs.vrf = util.convert_to_list(obj.vrfs.vrf)
            for vrf in obj.vrfs.vrf:
                if vrf.vrf_name == vrf_name:
                    vrfobj = vrfs.vrf.vrf()
                    vrfobj.name = vrf_name
                    if hasattr(vrf, 'rd'):
                        if util.isNotEmpty(vrf.rd):
                            vrfobj.rd = vrf.rd
                    if hasattr(vrf, 'description'):
                        if util.isNotEmpty(vrf.description):
                            vrfobj.description = vrf.description
                    if util.isNotEmpty(vrf.vrf_definition_mode):
                        vrfobj.vrf_definition_mode = vrf.vrf_definition_mode
                    is_vrf_exists = False
                    #is_vrf = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
                    #is_vrf_exists_obj = util.parseXmlString(is_vrf)
                    #util.log_debug( "is_vrf_obj is:", is_vrf_exists_obj)
                    #if hasattr(is_vrf_exists_obj.device, 'vrfs'):
                        #if hasattr(is_vrf_exists_obj.device.vrfs, 'vrf'):
                            #vrf_check_all = util.convert_to_list(is_vrf_exists_obj.device.vrfs.vrf)
                            #for vrf_check in vrf_check_all:
                                #if vrf_check.name == vrf_name:
                                    #is_vrf_exists = True
                    if yang.Sdk.dataExists(dev_url + "/vrfs/vrf=%s" % (vrf_name)):
                        is_vrf_exists = True
                    if not is_vrf_exists:
                        yang.Sdk.createData(dev.url + '/l3features:vrfs', vrfobj.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'rt_import'):
                        vrf.rt_import = util.convert_to_list(vrf.rt_import)
                        for rtimport in vrf.rt_import:
                            vrfobj1 = vrfs.vrf.rt_import.rt_import()
                            if util.isNotEmpty(rtimport.rt_import):
                                vrfobj1.rt_import = rtimport.rt_import
                            import_url = dev.url + '/l3features:vrfs/vrf=%s' % (vrf_name)
                            if not is_vrf_exists:
                                yang.Sdk.createData(import_url, vrfobj1.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'rt_export'):
                        vrf.rt_export = util.convert_to_list(vrf.rt_export)
                        for rtexport in vrf.rt_export:
                            vrfobj1 = vrfs.vrf.rt_export.rt_export()
                            if util.isNotEmpty(rtexport.rt_export):
                                vrfobj1.rt_export = rtexport.rt_export
                            export_url = dev.url + '/l3features:vrfs/vrf=%s' % (vrf_name)
                            if not is_vrf_exists:
                                yang.Sdk.createData(export_url, vrfobj1.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'import_map'):
                        vrf.import_map = util.convert_to_list(vrf.import_map)
                        for importmap in vrf.import_map:
                            vrfobj1 = vrfs.vrf.import_map.import_map()
                            if util.isNotEmpty(importmap.import_map):
                                route_maps(importmap.import_map, dev, sdata)
                                vrfobj1.import_map = importmap.import_map
                            if hasattr(importmap, 'ipv4'):
                                vrfobj1.ipv4 = importmap.ipv4
                            if hasattr(importmap, 'traffic'):
                                if util.isNotEmpty(importmap.traffic):
                                    vrfobj1.table = importmap.traffic
                            if hasattr(importmap, 'upper_limit'):
                                if util.isNotEmpty(importmap.upper_limit):
                                    vrfobj1.upper_limit = importmap.upper_limit
                            importmap_url = dev.url + '/l3features:vrfs/vrf=%s' % (vrf_name)
                            if not is_vrf_exists:
                                yang.Sdk.createData(importmap_url, vrfobj1.getxml(filter=True), sdata.getSession())
                    if hasattr(vrf, 'export_map'):
                        vrf.export_map = util.convert_to_list(vrf.export_map)
                        for exportmap in vrf.export_map:
                            vrfobj1 = vrfs.vrf.export_map.export_map()
                            if util.isNotEmpty(exportmap.export_map):
                                route_maps(exportmap.export_map, dev, sdata)
                                vrfobj1.export_map = exportmap.export_map
                            if hasattr(exportmap, 'ipv4'):
                                vrfobj1.ipv4 = exportmap.ipv4
                            if hasattr(exportmap, 'traffic'):
                                if util.isNotEmpty(exportmap.traffic):
                                    vrfobj1.table = exportmap.traffic
                            if hasattr(exportmap, 'upper_limit'):
                                if util.isNotEmpty(exportmap.upper_limit):
                                    vrfobj1.upper_limit = exportmap.upper_limit
                            importmap_url = dev.url + '/l3features:vrfs/vrf=%s' % (vrf_name)
                            if not is_vrf_exists:
                                yang.Sdk.createData(importmap_url, vrfobj1.getxml(filter=True), sdata.getSession())
    else:
        vrfobj = vrfs.vrf.vrf()
        vrfobj.name = vrf_name
        is_vrf_exists = False
        # is_vrf = yang.Sdk.getData(dev.url, '', sdata.getTaskId())
        # is_vrf_exists_obj = util.parseXmlString(is_vrf)
        # util.log_debug( "is_vrf_obj is:", is_vrf_exists_obj)
        # if hasattr(is_vrf_exists_obj.device, 'vrfs'):
        #     if hasattr(is_vrf_exists_obj.device.vrfs, 'vrf'):
        #         vrf_check_all = util.convert_to_list(is_vrf_exists_obj.device.vrfs.vrf)
        #         for vrf_check in vrf_check_all:
        #             if vrf_check.name == vrf_name:
        #                 is_vrf_exists = True
        if yang.Sdk.dataExists(dev.url + "/l3features:vrfs/vrf=%s" % (vrf_name)):
            is_vrf_exists = True
        if not is_vrf_exists:
            yang.Sdk.createData(dev.url + '/l3features:vrfs', vrfobj.getxml(filter=True), sdata.getSession())

    bgpas = None
    if entity == 'cpe_dual':
        obj = getLocalObject(sdata, 'single-cpe-dual-wan-site-services')
        if hasattr(obj.single_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe':
        obj = getLocalObject(sdata, 'single-cpe-site-services')
        if hasattr(obj.single_cpe_site_services, 'bgp_as'):
            bgpas = obj.single_cpe_site_services.bgp_as
    elif entity == 'cpe_primary' or entity == 'cpe_secondary':
        obj = getLocalObject(sdata, 'dual-cpe-site-services')
        if hasattr(obj.dual_cpe_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_site_services.bgp_as
    elif entity == 'cpe_primary_dual' or entity == 'cpe_secondary_dual':
        obj = getLocalObject(sdata, 'dual-cpe-dual-wan-site-services')
        if hasattr(obj.dual_cpe_dual_wan_site_services, 'bgp_as'):
            bgpas = obj.dual_cpe_dual_wan_site_services.bgp_as
    elif entity == 'cpe_primary_triple' or entity == 'cpe_secondary_triple' or entity == 'cpe_tertiary_triple':
        obj = getLocalObject(sdata, 'triple-cpe-site-services')
        if hasattr(obj.triple_cpe_site_services, 'bgp_as'):
            bgpas = obj.triple_cpe_site_services.bgp_as

    bgprouterid = kwarg['inputdict']['bgp_router_id']
    bgpdistanceext = kwarg['inputdict']['bgp_distance_external']
    bgpdistanceint = kwarg['inputdict']['bgp_distance_internal']
    bgpdistanceloc = kwarg['inputdict']['bgp_distance_local']
    bgp_community_new = kwarg['inputdict']['bgp_community_new']
    bgpaddfamily = kwarg['inputdict']['bgp_address_family']
    bgpglobalkeepalive = kwarg['inputdict']['bgp_keepalive_timer']
    bgpglobalholdtime = kwarg['inputdict']['bgp_holdtime_timer']
    default_information_originate = kwarg['inputdict']['default_information_originate']
    peer_group = kwarg['inputdict']['peer_group']
    # listen_cidr = kwarg['inputdict']['listen_cidr']
    bgp_settings = kwarg['inputdict']['bgp_settings']
    bgp_redis_internal = kwarg['inputdict']['bgp_redis_internal']
    if bgp_community_new == "true":
        newobj = bgp.bgp()
        newobj.bgp_community_new = 'true'
        yang.Sdk.createData(dev.url, newobj.getxml(filter=True), sdata.getSession())

    bgpobj = vrfs.vrf.router_bgp.router_bgp()
    if util.isNotEmpty(bgpas) and bgp_settings == "true":
    #if util.isNotEmpty(bgpas):
        bgpobj.as_number = bgpas
        if util.isNotEmpty(bgprouterid) and vrf_name == 'GLOBAL':
            bgpobj.router_id = bgprouterid
        if vrf_name == 'GLOBAL':
            bgpobj.log_neighbor_changes = "true"
        if vrf_name != 'GLOBAL':
            if util.isEmpty(bgpaddfamily):
                raise Exception("Address family should not be empty when vrf is given")
                
        bgpobj.address_family = bgpaddfamily
        if vrf_name == 'GLOBAL':
            bgpobj.bgp_holdtime_timer = bgpglobalholdtime
            bgpobj.bgp_keepalive_timer = bgpglobalkeepalive
        bgpobj.redistribute_internal = bgp_redis_internal
        bgpobj.eroutes = bgpdistanceext
        bgpobj.iroutes = bgpdistanceint
        bgpobj.lroutes = bgpdistanceloc
        #bgpobj.address_family = "ipv4"
        bgpobj.default_information_originate = default_information_originate
        router_bgp_url = dev.url + '/l3features:vrfs/vrf=%s' % (vrf_name)
        yang.Sdk.createData(router_bgp_url, bgpobj.getxml(filter=True), sdata.getSession())

    if util.isNotEmpty(peer_group):

        for pg in util.convert_to_list(peer_group):
            remote_as = peer_description = listen_range = next_hop_self = send_community = import_route_map = None
            export_route_map = soft_reconfiguration = password = default_originate = None
            default_originate_route_map = timers = keepalive_interval = holdtime = None
            advertisement_interval = time_in_sec = ebgp_multihop = update_source = as_override = None

            get_bgp_url = url + "/bgp-peer-groups/bgp-peer-group=%s" % (pg)
            if yang.Sdk.dataExists(get_bgp_url):
                xml_output = yang.Sdk.getData(get_bgp_url, '',sdata.getTaskId())
                peergroup = util.parseXmlString(xml_output)
                #util.log_debug( "obj: ",peergroup)
                peergroup = peergroup.bgp_peer_group
                if hasattr(peergroup, 'remote_as'):
                    remote_as = peergroup.remote_as
                if hasattr(peergroup, 'peer_description'):
                    peer_description = peergroup.peer_description
                if hasattr(peergroup, 'listen_range'):
                    listen_range = peergroup.listen_range
                if hasattr(peergroup, 'next_hop_self'):
                    next_hop_self = peergroup.next_hop_self
                if hasattr(peergroup, 'send_community'):
                    send_community = peergroup.send_community
                if hasattr(peergroup, 'import_route_map'):
                    import_route_map = peergroup.import_route_map
                if hasattr(peergroup, 'export_route_map'):
                    export_route_map = peergroup.export_route_map
                if hasattr(peergroup, 'soft_reconfiguration'):
                    soft_reconfiguration = peergroup.soft_reconfiguration
                if hasattr(peergroup, 'password'):
                    password = peergroup.password
                if hasattr(peergroup, 'default_originate'):
                    default_originate = peergroup.default_originate
                if hasattr(peergroup, 'default_originate_route_map'):
                    default_originate_route_map = peergroup.default_originate_route_map
                if hasattr(peergroup, 'timers'):
                    timers = peergroup.timers
                if hasattr(peergroup, 'keepalive_interval'):
                    keepalive_interval = peergroup.keepalive_interval
                if hasattr(peergroup, 'holdtime'):
                    holdtime = peergroup.holdtime
                if hasattr(peergroup, 'advertisement_interval'):
                    advertisement_interval = peergroup.advertisement_interval
                if hasattr(peergroup, 'time_in_sec'):
                    time_in_sec = peergroup.time_in_sec
                if hasattr(peergroup, 'ebgp_multihop'):
                    ebgp_multihop = peergroup.ebgp_multihop
                if hasattr(peergroup, 'update_source'):
                    update_source = peergroup.update_source
                if hasattr(peergroup, 'as_override'):
                    as_override = peergroup.as_override

            bgp_neighbor_obj = vrfs.vrf.router_bgp.peer_group.peer_group()
            bgp_neighbor_obj.name = pg
            if util.isNotEmpty(remote_as) or remote_as is not None:
                bgp_neighbor_obj.remote_as = remote_as
            if util.isNotEmpty(peer_description) or peer_description is not None:
                bgp_neighbor_obj.description = peer_description
            if util.isNotEmpty(next_hop_self) or next_hop_self is not None:
                bgp_neighbor_obj.next_hop_self = next_hop_self
            if util.isNotEmpty(send_community) or send_community is not None:
                bgp_neighbor_obj.send_community = send_community
            if util.isNotEmpty(import_route_map) or import_route_map is not None:
                route_maps(import_route_map, dev, sdata, None, entity)
                bgp_neighbor_obj.in_route_map = import_route_map
            if util.isNotEmpty(export_route_map) or export_route_map is not None:
                route_maps(export_route_map, dev, sdata, None, entity)
                bgp_neighbor_obj.out_route_map = export_route_map
            if util.isNotEmpty(soft_reconfiguration) or soft_reconfiguration is not None:
                bgp_neighbor_obj.soft_reconfiguration = soft_reconfiguration
            if util.isNotEmpty(password) or password is not None:
                bgp_neighbor_obj.password = password
            if util.isNotEmpty(default_originate) or default_originate is not None:
                bgp_neighbor_obj.default_originate = default_originate
            if util.isNotEmpty(default_originate_route_map) or default_originate_route_map is not None:
                route_maps(default_originate_route_map, dev, sdata)
                bgp_neighbor_obj.def_originate_route_map = default_originate_route_map
            if util.isNotEmpty(ebgp_multihop) or ebgp_multihop is not None:
                bgp_neighbor_obj.ebgp_multihop = ebgp_multihop
            if util.isNotEmpty(update_source) or update_source is not None:
                bgp_neighbor_obj.local_interface = update_source
            if util.isNotEmpty(as_override) or as_override is not None:
                bgp_neighbor_obj.as_override = as_override
            if timers == 'true':
                bgp_neighbor_obj.keepalive_interval = keepalive_interval
                bgp_neighbor_obj.holdtime = holdtime
            if advertisement_interval == 'true':
                bgp_neighbor_obj.advertisement_interval = time_in_sec
            router_bgp_neighbor_url = dev.url + '/l3features:vrfs/vrf=%s/router-bgp' % (vrf_name)
            yang.Sdk.createData(router_bgp_neighbor_url, bgp_neighbor_obj.getxml(filter=True), sdata.getSession())

            if util.isNotEmpty(listen_range) and util.isNotEmpty(pg) and vrf_name == 'GLOBAL':
                bgp_listen_obj = vrfs.vrf.router_bgp.listen_range.listen_range()
                bgp_listen_obj.name = pg
                bgp_listen_obj.cidr = listen_range
                router_bgp_listen_url = dev.url + '/l3features:vrfs/vrf=%s/router-bgp' % (vrf_name)
                yang.Sdk.createData(router_bgp_listen_url, bgp_listen_obj.getxml(filter=True), sdata.getSession())

    redistconnected = kwarg['inputdict']['redistribute_connected']
    if redistconnected == 'true':
        redistroutepolicy = kwarg['inputdict']['redistribute_connected_route_policy']
        if redistroutepolicy is not None:
            route_maps(redistroutepolicy, dev, sdata)

            rebgpredisobj1 = vrfs.vrf.router_bgp.redistribute.redistribute()
            rebgpredisobj1.protocol = 'connected'
            rebgpredisobj1.route_map = redistroutepolicy
            router_bgp_redist_url = dev.url + '/l3features:vrfs/vrf=%s/router-bgp' % (vrf_name)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())

    rediststatic = kwarg['inputdict']['redistribute_static']
    if rediststatic == 'true':
        redistroutepolicy = kwarg['inputdict']['redistribute_static_route_policy']
        if redistroutepolicy is not None:
            route_maps(redistroutepolicy, dev, sdata)
            rebgpredisobj1 = vrfs.vrf.router_bgp.redistribute.redistribute()
            rebgpredisobj1.protocol = 'static'
            rebgpredisobj1.route_map = redistroutepolicy
            router_bgp_redist_url = dev.url + '/l3features:vrfs/vrf=%s/router-bgp' % (vrf_name)
            yang.Sdk.createData(router_bgp_redist_url, rebgpredisobj1.getxml(filter=True), sdata.getSession())

    aggsumnetworks = kwarg['inputdict']['aggregate_summary_networks']
    if aggsumnetworks == 'true':
        if util.isEmpty(kwarg['inputdict']['summary_networks']):
            raise Exception('Aggregate Summary network is empty')
        sumnetworks = util.convert_to_list(kwarg['inputdict']['summary_networks'])
        if len(sumnetworks) > 0:
            if isinstance(sumnetworks, list) is True:
                for sum_network in sumnetworks:
                    if sum_network.__contains__(' '):
                        each_sumnet = sum_network.split(",")
                        for i in range(len(each_sumnet)):
                            net = each_sumnet[i].strip()
                            summaryobj = vrfs.vrf.router_bgp.aggregate_summary_network.aggregate_summary_network()
                            cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
                            ip_net_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + ' (([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$';
                            if re.match(cidr_pattern,net) == None and re.match(ip_net_pattern,net) == None:
                                raise Exception("Please provide CIDR/ IP NETMASK for summary networks")

                            if net.__contains__('/'):
                                netmasklen = net.split("/")[1]
                                prefix = util.IPPrefix(net)
                                ip_address = prefix.address
                                netmask = prefix.netmask
                                summaryobj.network = ip_address + ' ' + netmask
                            else:
                                summaryobj.network = net
                            router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
                            yang.Sdk.createData(router_bgp_redist_url, summaryobj.getxml(filter=True), sdata.getSession())
                    elif sum_network.__contains__(','):
                        each_sumnet = sum_network.split(",")
                        for i in range(len(each_sumnet)):
                            net = each_sumnet[i].strip()
                            summaryobj = vrfs.vrf.router_bgp.aggregate_summary_network.aggregate_summary_network()
                            cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
                            if re.match(cidr_pattern,net) == None:
                                raise Exception("Please provide CIDR for summary networks")

                            netmasklen = net.split("/")[1]
                            prefix = util.IPPrefix(net)
                            ip_address = prefix.address
                            netmask = prefix.netmask
                            summaryobj.network = ip_address + ' ' + netmask
                            router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
                            yang.Sdk.createData(router_bgp_redist_url, summaryobj.getxml(filter=True), sdata.getSession())
                    else:
                        net = sum_network.strip()
                        summaryobj = vrfs.vrf.router_bgp.aggregate_summary_network.aggregate_summary_network()
                        cidr_pattern = '^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}' + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])' + '/(([0-9])|([1-2][0-9])|(3[0-2]))$';
                        if re.match(cidr_pattern,net) == None:
                            raise Exception("Please provide CIDR for summary networks")

                        netmasklen = net.split("/")[1]
                        prefix = util.IPPrefix(net)
                        ip_address = prefix.address
                        netmask = prefix.netmask
                        summaryobj.network = ip_address + ' ' + netmask
                        router_bgp_redist_url = dev.url + '/vrfs/vrf=%s/router-bgp' % (vrf_name)
                        yang.Sdk.createData(router_bgp_redist_url, summaryobj.getxml(filter=True), sdata.getSession())


class ServiceModelContext(yang.ServiceModelContext):
    def __init__(self, id, sdata):
        yang.ServiceModelContext.__init__(self, id, sdata)
        self.load_service_object()

    def load_service_object(self):
        pattern = '/controller:services/cpedeployment:managed-cpe-services'
        key = 'service_object.%s' % (self.service_rcpath)
        obj = self.sdata.getSessionItem(key)
        if obj != None:
          log('load_service_object:cache-hit key=%s' % (key))
          self.service_obj = obj
          log('Getting service object from cache. rcPath = %s' % (self.service_rcpath))
          return obj
        log('load_service_object:cache-miss key=%s' % (key))
        self.service_rcpath = pattern
        log('setting rcpath = %s' % (self.service_rcpath))
        yang.ServiceModelContext.load_service_object(self, self.service_rcpath)
        self.service_obj = self.service_xmlobj
        #log('[ServiceModelContext]service_obj: %s' % (self.service_obj))
        obj = self.service_obj
        self.sdata.setSessionItem(key, obj, True)
        return obj
