#
# This computer program is the confidential information and proprietary trade
# secret of Anuta Networks, Inc. Possessions and use of this program must
# conform strictly to the license agreement between the user and
# Anuta Networks, Inc., and receipt or possession does not convey any rights
# to divulge, reproduce, or allow others to use this program without specific
# written authorization of Anuta Networks, Inc.
#
# Copyright (c) 2015-2016 Anuta Networks, Inc. All Rights Reserved.
#

#
#DO NOT EDIT THIS FILE ITS AUTOGENERATED ONE
#

from servicemodel import util
from servicemodel import yang
from servicemodel import devicemgr
from servicemodel.abstract_dev_mgr import AbstractDeviceMgr

def get_valid_devices(devs):
  vdevs = []
  if isinstance(devs, list):
    for dev in devs:
      drivername = dev.device.get_field_value('driver_name')
      if util.isEmpty(drivername):
        vdevs.append(dev)
  else:
    drivername = devs.device.get_field_value('driver_name')
    if util.isEmpty(drivername):
      vdevs.append(devs)

  return vdevs

#XPATH devices/device/vpls
class vpls(AbstractDeviceMgr):
  key_hints = [[]]
  def getRcpathPayload(self, sdata, dev, mapping_dict):
    dev = get_valid_devices(dev)
    if len(dev) == 0:
      return
    #convert parent keys to list
    rcpath_list = []
    payload_list = []
    ##prepare rcpath
    rcpath = ""
    rcpath_list.append(rcpath)
    mapping_dict = kwargs.get('mapping_dict')

    #validating inputs and get payload object
    vpls_object_list = self.validate_inputs_form_payload(mapping_dict)

    for vpls_object in vpls_object_list:
      #fetch payload
      vpls_payload = vpls_object.getxml(filter=True)
      util.log_debug('vpls_payload %s'%vpls_payload)
      payload_list.append(vpls_payload)

    return rcpath_list, payload_list

  def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
    dev = get_valid_devices(dev)
    if len(dev) == 0:
      return
    #convert parent keys to list
    ##prepare rcpath
    rcpath = ""
    self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

  def create_(self, sdata, dev, **kwargs):
    mapping_dict = kwargs.get('mapping_dict')

    #validating inputs and get payload object
    vpls_object_list = self.validate_inputs_form_payload(mapping_dict)

    for vpls_object in vpls_object_list:
      #fetch payload
      vpls_payload = vpls_object.getxml(filter=True)

      util.log_debug('vpls_payload %s'%vpls_payload)

      #call the base abstract class for createData
      super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vpls_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

  def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
    dev = get_valid_devices(dev)
    if len(dev) == 0:
      return

    ##prepare rcpath
    rcpath = ""
    self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

  def update_(self, sdata, dev, **kwargs):
    mapping_dict = kwargs.get('mapping_dict')

    #validating inputs and get payload object
    vpls_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

    #convert keys to list

    #prepare rcpath
    rcpath = kwargs.get('rcpath')
    rcpath_list = []
    rcpath_tmp =  rcpath+"/vpls"
    rcpath_list.append(rcpath_tmp)
    for rc_counter, vpls_object in enumerate(vpls_object_list):
      #fetch payload
      vpls_payload = vpls_object.getxml(filter=True)

      util.log_debug('update vpls_payload %s'%vpls_payload)

      rcpath = rcpath_list[rc_counter]
      #call the base abstract class for createData
      super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vpls_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

  def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
    dev = get_valid_devices(dev)
    if len(dev) == 0:
      return

    ##prepare rcpath
    rcpath = ""
    self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

  def delete_(self, sdata, dev, **kwargs):
    mapping_dict = kwargs.get('mapping_dict')

    #validating inputs

    #convert keys to list

    #prepare rcpath
    rcpath = kwargs.get('rcpath')
    rcpath_list = []
    rcpath_tmp =  rcpath+"/vpls"
    rcpath_list.append(rcpath_tmp)
    payload = ''

    for rcpath in rcpath_list:
      #call the base abstract class for deleteData
      super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

  def validate_inputs_form_payload(self, mapping_dict, update=False):
    #validating inputs

    #convert keys to list

    #prepare payload
    vpls_object_list = []
    from servicemodel.controller.devices import device
    vpls_object = device.vpls.vpls()
    try:
      if (update == False) or (update == True and str(mapping_dict.get('encapsulation_type', None)) != ''):
        vpls_object.encapsulation_type = mapping_dict.get('encapsulation_type', None)
      else:
        vpls_object.encapsulation_type._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('control_word', None)) != ''):
        vpls_object.control_word = mapping_dict.get('control_word', None)
      else:
        vpls_object.control_word._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('no_control_word', None)) != ''):
        vpls_object.no_control_word = mapping_dict.get('no_control_word', None)
      else:
        vpls_object.no_control_word._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('site_range', None)) != ''):
        vpls_object.site_range = mapping_dict.get('site_range', None)
      else:
        vpls_object.site_range._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('bum_hashing', None)) != ''):
        vpls_object.bum_hashing = mapping_dict.get('bum_hashing', None)
      else:
        vpls_object.bum_hashing._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('enable_mac_move_action', None)) != ''):
        vpls_object.enable_mac_move_action = mapping_dict.get('enable_mac_move_action', None)
      else:
        vpls_object.enable_mac_move_action._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('label_block_size', None)) != ''):
        vpls_object.label_block_size = mapping_dict.get('label_block_size', None)
      else:
        vpls_object.label_block_size._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('mac_table_aging_time', None)) != ''):
        vpls_object.mac_table_aging_time = mapping_dict.get('mac_table_aging_time', None)
      else:
        vpls_object.mac_table_aging_time._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('no_mac_learning', None)) != ''):
        vpls_object.no_mac_learning = mapping_dict.get('no_mac_learning', None)
      else:
        vpls_object.no_mac_learning._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('mac_statistics', None)) != ''):
        vpls_object.mac_statistics = mapping_dict.get('mac_statistics', None)
      else:
        vpls_object.mac_statistics._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('no_tunnel_services', None)) != ''):
        vpls_object.no_tunnel_services = mapping_dict.get('no_tunnel_services', None)
      else:
        vpls_object.no_tunnel_services._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
        vpls_object.community = mapping_dict.get('community', None)
      else:
        vpls_object.community._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('vpls_id', None)) != ''):
        vpls_object.vpls_id = mapping_dict.get('vpls_id', None)
      else:
        vpls_object.vpls_id._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('mtu', None)) != ''):
        vpls_object.mtu = mapping_dict.get('mtu', None)
      else:
        vpls_object.mtu._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('ignore_mtu_mismatch', None)) != ''):
        vpls_object.ignore_mtu_mismatch = mapping_dict.get('ignore_mtu_mismatch', None)
      else:
        vpls_object.ignore_mtu_mismatch._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('ignore_encapsulation_mismatch', None)) != ''):
        vpls_object.ignore_encapsulation_mismatch = mapping_dict.get('ignore_encapsulation_mismatch', None)
      else:
        vpls_object.ignore_encapsulation_mismatch._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('pseudowire_status_tlv', None)) != ''):
        vpls_object.pseudowire_status_tlv = mapping_dict.get('pseudowire_status_tlv', None)
      else:
        vpls_object.pseudowire_status_tlv._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('flow_label_transmit', None)) != ''):
        vpls_object.flow_label_transmit = mapping_dict.get('flow_label_transmit', None)
      else:
        vpls_object.flow_label_transmit._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('flow_label_receive', None)) != ''):
        vpls_object.flow_label_receive = mapping_dict.get('flow_label_receive', None)
      else:
        vpls_object.flow_label_receive._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('connectivity_type', None)) != ''):
        vpls_object.connectivity_type = mapping_dict.get('connectivity_type', None)
      else:
        vpls_object.connectivity_type._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('designated_forwarder_election_hold_time', None)) != ''):
        vpls_object.designated_forwarder_election_hold_time = mapping_dict.get('designated_forwarder_election_hold_time', None)
      else:
        vpls_object.designated_forwarder_election_hold_time._empty_tag = True
    except TypeError:
      pass
    try:
      if (update == False) or (update == True and str(mapping_dict.get('extended_vlan_list', None)) != ''):
        vpls_object.extended_vlan_list = mapping_dict.get('extended_vlan_list', None)
      else:
        vpls_object.extended_vlan_list._empty_tag = True
    except TypeError:
      pass
    vpls_object_list.append(vpls_object)

    return vpls_object_list

  #XPATH devices/device/vpls/static-vpls
  class static_vpls(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      static_vpls_object_list = self.validate_inputs_form_payload(mapping_dict)

      for static_vpls_object in static_vpls_object_list:
        #fetch payload
        static_vpls_payload = static_vpls_object.getxml(filter=True)
        util.log_debug('static_vpls_payload %s'%static_vpls_payload)
        payload_list.append(static_vpls_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      static_vpls_object_list = self.validate_inputs_form_payload(mapping_dict)

      for static_vpls_object in static_vpls_object_list:
        #fetch payload
        static_vpls_payload = static_vpls_object.getxml(filter=True)

        util.log_debug('static_vpls_payload %s'%static_vpls_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_vpls_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      static_vpls_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/static-vpls"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, static_vpls_object in enumerate(static_vpls_object_list):
        #fetch payload
        static_vpls_payload = static_vpls_object.getxml(filter=True)

        util.log_debug('update static_vpls_payload %s'%static_vpls_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_vpls_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/static-vpls"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('no_tunnel_services')):
        raise Exception("'no_tunnel_services' cannot be empty")

      #convert keys to list

      #prepare payload
      static_vpls_object_list = []
      from servicemodel.controller.devices.device import vpls
      static_vpls_object = vpls.static_vpls.static_vpls()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('no_tunnel_services', None)) != ''):
          static_vpls_object.no_tunnel_services = mapping_dict.get('no_tunnel_services', None)
        else:
          static_vpls_object.no_tunnel_services._empty_tag = True
      except TypeError:
        pass
      static_vpls_object_list.append(static_vpls_object)

      return static_vpls_object_list

  #XPATH devices/device/vpls/mac-table-size
  class mac_table_size(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mac_table_size_object_list = self.validate_inputs_form_payload(mapping_dict)

      for mac_table_size_object in mac_table_size_object_list:
        #fetch payload
        mac_table_size_payload = mac_table_size_object.getxml(filter=True)
        util.log_debug('mac_table_size_payload %s'%mac_table_size_payload)
        payload_list.append(mac_table_size_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mac_table_size_object_list = self.validate_inputs_form_payload(mapping_dict)

      for mac_table_size_object in mac_table_size_object_list:
        #fetch payload
        mac_table_size_payload = mac_table_size_object.getxml(filter=True)

        util.log_debug('mac_table_size_payload %s'%mac_table_size_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=mac_table_size_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mac_table_size_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/mac-table-size"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, mac_table_size_object in enumerate(mac_table_size_object_list):
        #fetch payload
        mac_table_size_payload = mac_table_size_object.getxml(filter=True)

        util.log_debug('update mac_table_size_payload %s'%mac_table_size_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=mac_table_size_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/mac-table-size"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs

      #convert keys to list

      #prepare payload
      mac_table_size_object_list = []
      from servicemodel.controller.devices.device import vpls
      mac_table_size_object = vpls.mac_table_size.mac_table_size()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('limit', None)) != ''):
          mac_table_size_object.limit = mapping_dict.get('limit', None)
        else:
          mac_table_size_object.limit._empty_tag = True
      except TypeError:
        pass
      try:
        if (update == False) or (update == True and str(mapping_dict.get('packet_action', None)) != ''):
          mac_table_size_object.packet_action = mapping_dict.get('packet_action', None)
        else:
          mac_table_size_object.packet_action._empty_tag = True
      except TypeError:
        pass
      mac_table_size_object_list.append(mac_table_size_object)

      return mac_table_size_object_list

  #XPATH devices/device/vpls/interface-mac-limit
  class interface_mac_limit(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict)

      for interface_mac_limit_object in interface_mac_limit_object_list:
        #fetch payload
        interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)
        util.log_debug('interface_mac_limit_payload %s'%interface_mac_limit_payload)
        payload_list.append(interface_mac_limit_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict)

      for interface_mac_limit_object in interface_mac_limit_object_list:
        #fetch payload
        interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)

        util.log_debug('interface_mac_limit_payload %s'%interface_mac_limit_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_mac_limit_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/interface-mac-limit"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, interface_mac_limit_object in enumerate(interface_mac_limit_object_list):
        #fetch payload
        interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)

        util.log_debug('update interface_mac_limit_payload %s'%interface_mac_limit_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_mac_limit_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/interface-mac-limit"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs

      #convert keys to list

      #prepare payload
      interface_mac_limit_object_list = []
      from servicemodel.controller.devices.device import vpls
      interface_mac_limit_object = vpls.interface_mac_limit.interface_mac_limit()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('limit', None)) != ''):
          interface_mac_limit_object.limit = mapping_dict.get('limit', None)
        else:
          interface_mac_limit_object.limit._empty_tag = True
      except TypeError:
        pass
      try:
        if (update == False) or (update == True and str(mapping_dict.get('packet_action', None)) != ''):
          interface_mac_limit_object.packet_action = mapping_dict.get('packet_action', None)
        else:
          interface_mac_limit_object.packet_action._empty_tag = True
      except TypeError:
        pass
      interface_mac_limit_object_list.append(interface_mac_limit_object)

      return interface_mac_limit_object_list

  #XPATH devices/device/vpls/interface
  class interface(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      interface_object_list = self.validate_inputs_form_payload(mapping_dict)

      for interface_object in interface_object_list:
        #fetch payload
        interface_payload = interface_object.getxml(filter=True)
        util.log_debug('interface_payload %s'%interface_payload)
        payload_list.append(interface_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      interface_object_list = self.validate_inputs_form_payload(mapping_dict)

      for interface_object in interface_object_list:
        #fetch payload
        interface_payload = interface_object.getxml(filter=True)

        util.log_debug('interface_payload %s'%interface_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list
      name = mapping_dict.get('name')
      if not isinstance(name, list):
        name = [name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for name_iterator in name:
        rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(name_iterator))
        rcpath_list.append(rcpath_tmp)
      for rc_counter, interface_object in enumerate(interface_object_list):
        #fetch payload
        interface_payload = interface_object.getxml(filter=True)

        util.log_debug('update interface_payload %s'%interface_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs
      if util.isEmpty(mapping_dict.get('name')):
        raise Exception("'name' cannot be empty")

      #convert keys to list
      name = mapping_dict.get('name')
      if not isinstance(name, list):
        name = [name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for name_iterator in name:
        rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(name_iterator))
        rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('name')):
        raise Exception("'name' cannot be empty")

      #convert keys to list
      name = mapping_dict.get('name')
      if not isinstance(name, list):
        name = [name]

      #prepare payload
      interface_object_list = []
      for name_iterator in name:
        from servicemodel.controller.devices.device import vpls
        interface_object = vpls.interface.interface()
        interface_object.name = name_iterator
        try:
          if (update == False) or (update == True and str(mapping_dict.get('action_priority', None)) != ''):
            interface_object.action_priority = mapping_dict.get('action_priority', None)
          else:
            interface_object.action_priority._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('remote_site_id', None)) != ''):
            interface_object.remote_site_id = mapping_dict.get('remote_site_id', None)
          else:
            interface_object.remote_site_id._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('target_attachment_identifier', None)) != ''):
            interface_object.target_attachment_identifier = mapping_dict.get('target_attachment_identifier', None)
          else:
            interface_object.target_attachment_identifier._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('flow_label_transmit', None)) != ''):
            interface_object.flow_label_transmit = mapping_dict.get('flow_label_transmit', None)
          else:
            interface_object.flow_label_transmit._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('flow_label_receive', None)) != ''):
            interface_object.flow_label_receive = mapping_dict.get('flow_label_receive', None)
          else:
            interface_object.flow_label_receive._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('encapsulation_type', None)) != ''):
            interface_object.encapsulation_type = mapping_dict.get('encapsulation_type', None)
          else:
            interface_object.encapsulation_type._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ignore_encapsulation_mismatch', None)) != ''):
            interface_object.ignore_encapsulation_mismatch = mapping_dict.get('ignore_encapsulation_mismatch', None)
          else:
            interface_object.ignore_encapsulation_mismatch._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('mtu', None)) != ''):
            interface_object.mtu = mapping_dict.get('mtu', None)
          else:
            interface_object.mtu._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ignore_mtu_mismatch', None)) != ''):
            interface_object.ignore_mtu_mismatch = mapping_dict.get('ignore_mtu_mismatch', None)
          else:
            interface_object.ignore_mtu_mismatch._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('control_word', None)) != ''):
            interface_object.control_word = mapping_dict.get('control_word', None)
          else:
            interface_object.control_word._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('no_control_word', None)) != ''):
            interface_object.no_control_word = mapping_dict.get('no_control_word', None)
          else:
            interface_object.no_control_word._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('pseudowire_status_tlv', None)) != ''):
            interface_object.pseudowire_status_tlv = mapping_dict.get('pseudowire_status_tlv', None)
          else:
            interface_object.pseudowire_status_tlv._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
            interface_object.community = mapping_dict.get('community', None)
          else:
            interface_object.community._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('no_mac_learning', None)) != ''):
            interface_object.no_mac_learning = mapping_dict.get('no_mac_learning', None)
          else:
            interface_object.no_mac_learning._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
            interface_object.description = mapping_dict.get('description', None)
          else:
            interface_object.description._empty_tag = True
        except TypeError:
          pass
        interface_object_list.append(interface_object)

      return interface_object_list

    #XPATH devices/device/vpls/interface/interface-mac-limit
    class interface_mac_limit(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, interface_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict)

        for interface_mac_limit_object in interface_mac_limit_object_list:
          #fetch payload
          interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)
          util.log_debug('interface_mac_limit_payload %s'%interface_mac_limit_payload)
          payload_list.append(interface_mac_limit_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)

        #convert parent keys to list
        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict)

        for interface_mac_limit_object in interface_mac_limit_object_list:
          #fetch payload
          interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)

          util.log_debug('interface_mac_limit_payload %s'%interface_mac_limit_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_mac_limit_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/interface-mac-limit"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, interface_mac_limit_object in enumerate(interface_mac_limit_object_list):
          #fetch payload
          interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)

          util.log_debug('update interface_mac_limit_payload %s'%interface_mac_limit_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_mac_limit_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)


        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/interface-mac-limit"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, interface_name):
        #Parent Key Validations
        if util.isEmpty(interface_name):
          raise Exception("'interface_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        interface_mac_limit_object_list = []
        from servicemodel.controller.devices.device.vpls import interface
        interface_mac_limit_object = interface.interface_mac_limit.interface_mac_limit()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('limit', None)) != ''):
            interface_mac_limit_object.limit = mapping_dict.get('limit', None)
          else:
            interface_mac_limit_object.limit._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('packet_action', None)) != ''):
            interface_mac_limit_object.packet_action = mapping_dict.get('packet_action', None)
          else:
            interface_mac_limit_object.packet_action._empty_tag = True
        except TypeError:
          pass
        interface_mac_limit_object_list.append(interface_mac_limit_object)

        return interface_mac_limit_object_list

    #XPATH devices/device/vpls/interface/oam
    class oam(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, interface_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict)

        for oam_object in oam_object_list:
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)
          util.log_debug('oam_payload %s'%oam_payload)
          payload_list.append(oam_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)

        #convert parent keys to list
        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict)

        for oam_object in oam_object_list:
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)

          util.log_debug('oam_payload %s'%oam_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/oam"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, oam_object in enumerate(oam_object_list):
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)

          util.log_debug('update oam_payload %s'%oam_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)


        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/oam"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, interface_name):
        #Parent Key Validations
        if util.isEmpty(interface_name):
          raise Exception("'interface_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        oam_object_list = []
        from servicemodel.controller.devices.device.vpls import interface
        oam_object = interface.oam.oam()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ping_interval', None)) != ''):
            oam_object.ping_interval = mapping_dict.get('ping_interval', None)
          else:
            oam_object.ping_interval._empty_tag = True
        except TypeError:
          pass
        oam_object_list.append(oam_object)

        return oam_object_list

      #XPATH devices/device/vpls/interface/oam/bfd-liveness-detection
      class bfd_liveness_detection(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, interface_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for interface_name in interface_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/interface=%s/oam"%(util.make_interfacename(interface_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

          for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)
            util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)
            payload_list.append(bfd_liveness_detection_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name)

          #convert parent keys to list
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for interface_name in interface_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/interface=%s/oam"%(util.make_interfacename(interface_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

          for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

            util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s/oam"%(util.make_interfacename(interface_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/bfd-liveness-detection"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, bfd_liveness_detection_object in enumerate(bfd_liveness_detection_object_list):
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

            util.log_debug('update bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name)


          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for interface_name in interface_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/interface=%s/oam"%(util.make_interfacename(interface_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/bfd-liveness-detection"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, interface_name):
          #Parent Key Validations
          if util.isEmpty(interface_name):
            raise Exception("'interface_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          bfd_liveness_detection_object_list = []
          from servicemodel.controller.devices.device.vpls.interface import oam
          bfd_liveness_detection_object = oam.bfd_liveness_detection.bfd_liveness_detection()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('version', None)) != ''):
              bfd_liveness_detection_object.version = mapping_dict.get('version', None)
            else:
              bfd_liveness_detection_object.version._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
              bfd_liveness_detection_object.minimum_interval = mapping_dict.get('minimum_interval', None)
            else:
              bfd_liveness_detection_object.minimum_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_receive_interval', None)) != ''):
              bfd_liveness_detection_object.minimum_receive_interval = mapping_dict.get('minimum_receive_interval', None)
            else:
              bfd_liveness_detection_object.minimum_receive_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('multiplier', None)) != ''):
              bfd_liveness_detection_object.multiplier = mapping_dict.get('multiplier', None)
            else:
              bfd_liveness_detection_object.multiplier._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('no_adaptation', None)) != ''):
              bfd_liveness_detection_object.no_adaptation = mapping_dict.get('no_adaptation', None)
            else:
              bfd_liveness_detection_object.no_adaptation._empty_tag = True
          except TypeError:
            pass
          bfd_liveness_detection_object_list.append(bfd_liveness_detection_object)

          return bfd_liveness_detection_object_list

        #XPATH devices/device/vpls/interface/oam/bfd-liveness-detection/transmit-interval
        class transmit_interval(AbstractDeviceMgr):
          key_hints = [['name']]
          def getRcpathPayload(self, sdata, dev, interface_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

            for transmit_interval_object in transmit_interval_object_list:
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)
              util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)
              payload_list.append(transmit_interval_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)

            #convert parent keys to list
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

            for transmit_interval_object in transmit_interval_object_list:
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)

              util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)


            ##prepare rcpath
            rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/transmit-interval"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, transmit_interval_object in enumerate(transmit_interval_object_list):
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)

              util.log_debug('update transmit_interval_payload %s'%transmit_interval_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)


            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/transmit-interval"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, interface_name):
            #Parent Key Validations
            if util.isEmpty(interface_name):
              raise Exception("'interface_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            transmit_interval_object_list = []
            from servicemodel.controller.devices.device.vpls.interface.oam import bfd_liveness_detection
            transmit_interval_object = bfd_liveness_detection.transmit_interval.transmit_interval()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                transmit_interval_object.minimum_interval = mapping_dict.get('minimum_interval', None)
              else:
                transmit_interval_object.minimum_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                transmit_interval_object.threshold = mapping_dict.get('threshold', None)
              else:
                transmit_interval_object.threshold._empty_tag = True
            except TypeError:
              pass
            transmit_interval_object_list.append(transmit_interval_object)

            return transmit_interval_object_list

        #XPATH devices/device/vpls/interface/oam/bfd-liveness-detection/detection-time
        class detection_time(AbstractDeviceMgr):
          key_hints = [['name']]
          def getRcpathPayload(self, sdata, dev, interface_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

            for detection_time_object in detection_time_object_list:
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)
              util.log_debug('detection_time_payload %s'%detection_time_payload)
              payload_list.append(detection_time_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)

            #convert parent keys to list
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

            for detection_time_object in detection_time_object_list:
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)

              util.log_debug('detection_time_payload %s'%detection_time_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)


            ##prepare rcpath
            rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/detection-time"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, detection_time_object in enumerate(detection_time_object_list):
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)

              util.log_debug('update detection_time_payload %s'%detection_time_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( interface_name)


            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(interface_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/detection-time"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, interface_name):
            #Parent Key Validations
            if util.isEmpty(interface_name):
              raise Exception("'interface_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            detection_time_object_list = []
            from servicemodel.controller.devices.device.vpls.interface.oam import bfd_liveness_detection
            detection_time_object = bfd_liveness_detection.detection_time.detection_time()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                detection_time_object.threshold = mapping_dict.get('threshold', None)
              else:
                detection_time_object.threshold._empty_tag = True
            except TypeError:
              pass
            detection_time_object_list.append(detection_time_object)

            return detection_time_object_list

    #XPATH devices/device/vpls/interface/static-mac
    class static_mac(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, interface_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        static_mac_object_list = self.validate_inputs_form_payload(mapping_dict)

        for static_mac_object in static_mac_object_list:
          #fetch payload
          static_mac_payload = static_mac_object.getxml(filter=True)
          util.log_debug('static_mac_payload %s'%static_mac_payload)
          payload_list.append(static_mac_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)

        #convert parent keys to list
        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        static_mac_object_list = self.validate_inputs_form_payload(mapping_dict)

        for static_mac_object in static_mac_object_list:
          #fetch payload
          static_mac_payload = static_mac_object.getxml(filter=True)

          util.log_debug('static_mac_payload %s'%static_mac_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_mac_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, interface_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        static_mac_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        address = mapping_dict.get('address')
        if not isinstance(address, list):
          address = [address]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for address_iterator in address:
          rcpath_tmp =  rcpath+"/static-mac=%s"%(util.make_interfacename(address_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, static_mac_object in enumerate(static_mac_object_list):
          #fetch payload
          static_mac_payload = static_mac_object.getxml(filter=True)

          util.log_debug('update static_mac_payload %s'%static_mac_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_mac_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( interface_name)


        if not isinstance(interface_name, list):
          interface_name_list = [interface_name]
        else:
          interface_name_list = interface_name

        for interface_name in interface_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s"%(util.make_interfacename(interface_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('address')):
          raise Exception("'address' cannot be empty")

        #convert keys to list
        address = mapping_dict.get('address')
        if not isinstance(address, list):
          address = [address]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for address_iterator in address:
          rcpath_tmp =  rcpath+"/static-mac=%s"%(util.make_interfacename(address_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, interface_name):
        #Parent Key Validations
        if util.isEmpty(interface_name):
          raise Exception("'interface_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('address')):
          raise Exception("'address' cannot be empty")

        #convert keys to list
        address = mapping_dict.get('address')
        if not isinstance(address, list):
          address = [address]

        #prepare payload
        static_mac_object_list = []
        for address_iterator in address:
          from servicemodel.controller.devices.device.vpls import interface
          static_mac_object = interface.static_mac.static_mac()
          static_mac_object.address = address_iterator
          static_mac_object_list.append(static_mac_object)

        return static_mac_object_list

      #XPATH devices/device/vpls/interface/static-mac/vlan-id
      class vlan_id(AbstractDeviceMgr):
        key_hints = [['name'],['address']]
        def getRcpathPayload(self, sdata, dev, interface_name, static_mac_address, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name, static_mac_address)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name
          if not isinstance(static_mac_address, list):
            static_mac_address_list = [static_mac_address]
          else:
            static_mac_address_list = static_mac_address

          for interface_name in interface_name_list:
            for static_mac_address in static_mac_address_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/static-mac=%s"%(util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          vlan_id_object_list = self.validate_inputs_form_payload(mapping_dict)

          for vlan_id_object in vlan_id_object_list:
            #fetch payload
            vlan_id_payload = vlan_id_object.getxml(filter=True)
            util.log_debug('vlan_id_payload %s'%vlan_id_payload)
            payload_list.append(vlan_id_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, interface_name, static_mac_address, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name, static_mac_address)

          #convert parent keys to list
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name
          if not isinstance(static_mac_address, list):
            static_mac_address_list = [static_mac_address]
          else:
            static_mac_address_list = static_mac_address

          for interface_name in interface_name_list:
            for static_mac_address in static_mac_address_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/static-mac=%s"%(util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          vlan_id_object_list = self.validate_inputs_form_payload(mapping_dict)

          for vlan_id_object in vlan_id_object_list:
            #fetch payload
            vlan_id_payload = vlan_id_object.getxml(filter=True)

            util.log_debug('vlan_id_payload %s'%vlan_id_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vlan_id_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, interface_name, static_mac_address, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name, static_mac_address)


          ##prepare rcpath
          rcpath = "vpls:vpls/interface=%s/static-mac=%s"%(util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          vlan_id_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          id = mapping_dict.get('id')
          if not isinstance(id, list):
            id = [id]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for id_iterator in id:
            rcpath_tmp =  rcpath+"/vlan-id=%s"%(util.make_interfacename(id_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, vlan_id_object in enumerate(vlan_id_object_list):
            #fetch payload
            vlan_id_payload = vlan_id_object.getxml(filter=True)

            util.log_debug('update vlan_id_payload %s'%vlan_id_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vlan_id_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, interface_name, static_mac_address, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( interface_name, static_mac_address)


          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name
          if not isinstance(static_mac_address, list):
            static_mac_address_list = [static_mac_address]
          else:
            static_mac_address_list = static_mac_address

          for interface_name in interface_name_list:
            for static_mac_address in static_mac_address_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/interface=%s/static-mac=%s"%(util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('id')):
            raise Exception("'id' cannot be empty")

          #convert keys to list
          id = mapping_dict.get('id')
          if not isinstance(id, list):
            id = [id]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for id_iterator in id:
            rcpath_tmp =  rcpath+"/vlan-id=%s"%(util.make_interfacename(id_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, interface_name, static_mac_address):
          #Parent Key Validations
          if util.isEmpty(interface_name):
            raise Exception("'interface_name' cannot be empty")
          if util.isEmpty(static_mac_address):
            raise Exception("'static_mac_address' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('id')):
            raise Exception("'id' cannot be empty")

          #convert keys to list
          id = mapping_dict.get('id')
          if not isinstance(id, list):
            id = [id]

          #prepare payload
          vlan_id_object_list = []
          for id_iterator in id:
            from servicemodel.controller.devices.device.vpls.interface import static_mac
            vlan_id_object = static_mac.vlan_id.vlan_id()
            vlan_id_object.id = id_iterator
            vlan_id_object_list.append(vlan_id_object)

          return vlan_id_object_list

  #XPATH devices/device/vpls/tunnel-services
  class tunnel_services(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      tunnel_services_object_list = self.validate_inputs_form_payload(mapping_dict)

      for tunnel_services_object in tunnel_services_object_list:
        #fetch payload
        tunnel_services_payload = tunnel_services_object.getxml(filter=True)
        util.log_debug('tunnel_services_payload %s'%tunnel_services_payload)
        payload_list.append(tunnel_services_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      tunnel_services_object_list = self.validate_inputs_form_payload(mapping_dict)

      for tunnel_services_object in tunnel_services_object_list:
        #fetch payload
        tunnel_services_payload = tunnel_services_object.getxml(filter=True)

        util.log_debug('tunnel_services_payload %s'%tunnel_services_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=tunnel_services_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      tunnel_services_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/tunnel-services"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, tunnel_services_object in enumerate(tunnel_services_object_list):
        #fetch payload
        tunnel_services_payload = tunnel_services_object.getxml(filter=True)

        util.log_debug('update tunnel_services_payload %s'%tunnel_services_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=tunnel_services_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/tunnel-services"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs

      #convert keys to list

      #prepare payload
      tunnel_services_object_list = []
      from servicemodel.controller.devices.device import vpls
      tunnel_services_object = vpls.tunnel_services.tunnel_services()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('devices', None)) != ''):
          tunnel_services_object.devices = mapping_dict.get('devices', None)
        else:
          tunnel_services_object.devices._empty_tag = True
      except TypeError:
        pass
      try:
        if (update == False) or (update == True and str(mapping_dict.get('primary', None)) != ''):
          tunnel_services_object.primary = mapping_dict.get('primary', None)
        else:
          tunnel_services_object.primary._empty_tag = True
      except TypeError:
        pass
      tunnel_services_object_list.append(tunnel_services_object)

      return tunnel_services_object_list

  #XPATH devices/device/vpls/site
  class site(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      site_object_list = self.validate_inputs_form_payload(mapping_dict)

      for site_object in site_object_list:
        #fetch payload
        site_payload = site_object.getxml(filter=True)
        util.log_debug('site_payload %s'%site_payload)
        payload_list.append(site_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      site_object_list = self.validate_inputs_form_payload(mapping_dict)

      for site_object in site_object_list:
        #fetch payload
        site_payload = site_object.getxml(filter=True)

        util.log_debug('site_payload %s'%site_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=site_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      site_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list
      site_name = mapping_dict.get('site_name')
      if not isinstance(site_name, list):
        site_name = [site_name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for site_name_iterator in site_name:
        rcpath_tmp =  rcpath+"/site=%s"%(util.make_interfacename(site_name_iterator))
        rcpath_list.append(rcpath_tmp)
      for rc_counter, site_object in enumerate(site_object_list):
        #fetch payload
        site_payload = site_object.getxml(filter=True)

        util.log_debug('update site_payload %s'%site_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=site_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs
      if util.isEmpty(mapping_dict.get('site_name')):
        raise Exception("'site_name' cannot be empty")

      #convert keys to list
      site_name = mapping_dict.get('site_name')
      if not isinstance(site_name, list):
        site_name = [site_name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for site_name_iterator in site_name:
        rcpath_tmp =  rcpath+"/site=%s"%(util.make_interfacename(site_name_iterator))
        rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('site_name')):
        raise Exception("'site_name' cannot be empty")

      #convert keys to list
      site_name = mapping_dict.get('site_name')
      if not isinstance(site_name, list):
        site_name = [site_name]

      #prepare payload
      site_object_list = []
      for site_name_iterator in site_name:
        from servicemodel.controller.devices.device import vpls
        site_object = vpls.site.site()
        site_object.site_name = site_name_iterator
        try:
          if (update == False) or (update == True and str(mapping_dict.get('site_identifier', None)) != ''):
            site_object.site_identifier = mapping_dict.get('site_identifier', None)
          else:
            site_object.site_identifier._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('source_attachment_identifier', None)) != ''):
            site_object.source_attachment_identifier = mapping_dict.get('source_attachment_identifier', None)
          else:
            site_object.source_attachment_identifier._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('flow_label_transmit', None)) != ''):
            site_object.flow_label_transmit = mapping_dict.get('flow_label_transmit', None)
          else:
            site_object.flow_label_transmit._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('flow_label_receive', None)) != ''):
            site_object.flow_label_receive = mapping_dict.get('flow_label_receive', None)
          else:
            site_object.flow_label_receive._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('encapsulation_type', None)) != ''):
            site_object.encapsulation_type = mapping_dict.get('encapsulation_type', None)
          else:
            site_object.encapsulation_type._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ignore_encapsulation_mismatch', None)) != ''):
            site_object.ignore_encapsulation_mismatch = mapping_dict.get('ignore_encapsulation_mismatch', None)
          else:
            site_object.ignore_encapsulation_mismatch._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('control_word', None)) != ''):
            site_object.control_word = mapping_dict.get('control_word', None)
          else:
            site_object.control_word._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('no_control_word', None)) != ''):
            site_object.no_control_word = mapping_dict.get('no_control_word', None)
          else:
            site_object.no_control_word._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('pseudowire_status_tlv', None)) != ''):
            site_object.pseudowire_status_tlv = mapping_dict.get('pseudowire_status_tlv', None)
          else:
            site_object.pseudowire_status_tlv._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
            site_object.community = mapping_dict.get('community', None)
          else:
            site_object.community._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('site_preference', None)) != ''):
            site_object.site_preference = mapping_dict.get('site_preference', None)
          else:
            site_object.site_preference._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('hot_standby', None)) != ''):
            site_object.hot_standby = mapping_dict.get('hot_standby', None)
          else:
            site_object.hot_standby._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('mtu', None)) != ''):
            site_object.mtu = mapping_dict.get('mtu', None)
          else:
            site_object.mtu._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ignore_mtu_mismatch', None)) != ''):
            site_object.ignore_mtu_mismatch = mapping_dict.get('ignore_mtu_mismatch', None)
          else:
            site_object.ignore_mtu_mismatch._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('best_site', None)) != ''):
            site_object.best_site = mapping_dict.get('best_site', None)
          else:
            site_object.best_site._empty_tag = True
        except TypeError:
          pass
        site_object_list.append(site_object)

      return site_object_list

    #XPATH devices/device/vpls/site/automatic-site-id
    class automatic_site_id(AbstractDeviceMgr):
      key_hints = [['site_name']]
      def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        automatic_site_id_object_list = self.validate_inputs_form_payload(mapping_dict)

        for automatic_site_id_object in automatic_site_id_object_list:
          #fetch payload
          automatic_site_id_payload = automatic_site_id_object.getxml(filter=True)
          util.log_debug('automatic_site_id_payload %s'%automatic_site_id_payload)
          payload_list.append(automatic_site_id_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        automatic_site_id_object_list = self.validate_inputs_form_payload(mapping_dict)

        for automatic_site_id_object in automatic_site_id_object_list:
          #fetch payload
          automatic_site_id_payload = automatic_site_id_object.getxml(filter=True)

          util.log_debug('automatic_site_id_payload %s'%automatic_site_id_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=automatic_site_id_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        automatic_site_id_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/automatic-site-id"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, automatic_site_id_object in enumerate(automatic_site_id_object_list):
          #fetch payload
          automatic_site_id_payload = automatic_site_id_object.getxml(filter=True)

          util.log_debug('update automatic_site_id_payload %s'%automatic_site_id_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=automatic_site_id_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/automatic-site-id"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, site_site_name):
        #Parent Key Validations
        if util.isEmpty(site_site_name):
          raise Exception("'site_site_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        automatic_site_id_object_list = []
        from servicemodel.controller.devices.device.vpls import site
        automatic_site_id_object = site.automatic_site_id.automatic_site_id()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('startup_wait_time', None)) != ''):
            automatic_site_id_object.startup_wait_time = mapping_dict.get('startup_wait_time', None)
          else:
            automatic_site_id_object.startup_wait_time._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('new_site_wait_time', None)) != ''):
            automatic_site_id_object.new_site_wait_time = mapping_dict.get('new_site_wait_time', None)
          else:
            automatic_site_id_object.new_site_wait_time._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('collision_detect_time', None)) != ''):
            automatic_site_id_object.collision_detect_time = mapping_dict.get('collision_detect_time', None)
          else:
            automatic_site_id_object.collision_detect_time._empty_tag = True
        except TypeError:
          pass
        automatic_site_id_object_list.append(automatic_site_id_object)

        return automatic_site_id_object_list

      #XPATH devices/device/vpls/site/automatic-site-id/reclaim-wait-time
      class reclaim_wait_time(AbstractDeviceMgr):
        key_hints = [['site_name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/automatic-site-id"%(util.make_interfacename(site_site_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          reclaim_wait_time_object_list = self.validate_inputs_form_payload(mapping_dict)

          for reclaim_wait_time_object in reclaim_wait_time_object_list:
            #fetch payload
            reclaim_wait_time_payload = reclaim_wait_time_object.getxml(filter=True)
            util.log_debug('reclaim_wait_time_payload %s'%reclaim_wait_time_payload)
            payload_list.append(reclaim_wait_time_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/automatic-site-id"%(util.make_interfacename(site_site_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          reclaim_wait_time_object_list = self.validate_inputs_form_payload(mapping_dict)

          for reclaim_wait_time_object in reclaim_wait_time_object_list:
            #fetch payload
            reclaim_wait_time_payload = reclaim_wait_time_object.getxml(filter=True)

            util.log_debug('reclaim_wait_time_payload %s'%reclaim_wait_time_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=reclaim_wait_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s/automatic-site-id"%(util.make_interfacename(site_site_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          reclaim_wait_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/reclaim-wait-time"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, reclaim_wait_time_object in enumerate(reclaim_wait_time_object_list):
            #fetch payload
            reclaim_wait_time_payload = reclaim_wait_time_object.getxml(filter=True)

            util.log_debug('update reclaim_wait_time_payload %s'%reclaim_wait_time_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=reclaim_wait_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/automatic-site-id"%(util.make_interfacename(site_site_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/reclaim-wait-time"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('minimum')):
            raise Exception("'minimum' cannot be empty")
          if util.isEmpty(mapping_dict.get('maximum')):
            raise Exception("'maximum' cannot be empty")

          #convert keys to list

          #prepare payload
          reclaim_wait_time_object_list = []
          from servicemodel.controller.devices.device.vpls.site import automatic_site_id
          reclaim_wait_time_object = automatic_site_id.reclaim_wait_time.reclaim_wait_time()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum', None)) != ''):
              reclaim_wait_time_object.minimum = mapping_dict.get('minimum', None)
            else:
              reclaim_wait_time_object.minimum._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('maximum', None)) != ''):
              reclaim_wait_time_object.maximum = mapping_dict.get('maximum', None)
            else:
              reclaim_wait_time_object.maximum._empty_tag = True
          except TypeError:
            pass
          reclaim_wait_time_object_list.append(reclaim_wait_time_object)

          return reclaim_wait_time_object_list

    #XPATH devices/device/vpls/site/oam
    class oam(AbstractDeviceMgr):
      key_hints = [['site_name']]
      def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict)

        for oam_object in oam_object_list:
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)
          util.log_debug('oam_payload %s'%oam_payload)
          payload_list.append(oam_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict)

        for oam_object in oam_object_list:
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)

          util.log_debug('oam_payload %s'%oam_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/oam"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, oam_object in enumerate(oam_object_list):
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)

          util.log_debug('update oam_payload %s'%oam_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/oam"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, site_site_name):
        #Parent Key Validations
        if util.isEmpty(site_site_name):
          raise Exception("'site_site_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        oam_object_list = []
        from servicemodel.controller.devices.device.vpls import site
        oam_object = site.oam.oam()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ping_interval', None)) != ''):
            oam_object.ping_interval = mapping_dict.get('ping_interval', None)
          else:
            oam_object.ping_interval._empty_tag = True
        except TypeError:
          pass
        oam_object_list.append(oam_object)

        return oam_object_list

      #XPATH devices/device/vpls/site/oam/bfd-liveness-detection
      class bfd_liveness_detection(AbstractDeviceMgr):
        key_hints = [['site_name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/oam"%(util.make_interfacename(site_site_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

          for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)
            util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)
            payload_list.append(bfd_liveness_detection_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/oam"%(util.make_interfacename(site_site_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

          for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

            util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s/oam"%(util.make_interfacename(site_site_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/bfd-liveness-detection"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, bfd_liveness_detection_object in enumerate(bfd_liveness_detection_object_list):
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

            util.log_debug('update bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/oam"%(util.make_interfacename(site_site_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/bfd-liveness-detection"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          bfd_liveness_detection_object_list = []
          from servicemodel.controller.devices.device.vpls.site import oam
          bfd_liveness_detection_object = oam.bfd_liveness_detection.bfd_liveness_detection()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('version', None)) != ''):
              bfd_liveness_detection_object.version = mapping_dict.get('version', None)
            else:
              bfd_liveness_detection_object.version._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
              bfd_liveness_detection_object.minimum_interval = mapping_dict.get('minimum_interval', None)
            else:
              bfd_liveness_detection_object.minimum_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_receive_interval', None)) != ''):
              bfd_liveness_detection_object.minimum_receive_interval = mapping_dict.get('minimum_receive_interval', None)
            else:
              bfd_liveness_detection_object.minimum_receive_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('multiplier', None)) != ''):
              bfd_liveness_detection_object.multiplier = mapping_dict.get('multiplier', None)
            else:
              bfd_liveness_detection_object.multiplier._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('no_adaptation', None)) != ''):
              bfd_liveness_detection_object.no_adaptation = mapping_dict.get('no_adaptation', None)
            else:
              bfd_liveness_detection_object.no_adaptation._empty_tag = True
          except TypeError:
            pass
          bfd_liveness_detection_object_list.append(bfd_liveness_detection_object)

          return bfd_liveness_detection_object_list

        #XPATH devices/device/vpls/site/oam/bfd-liveness-detection/transmit-interval
        class transmit_interval(AbstractDeviceMgr):
          key_hints = [['site_name']]
          def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name

            for site_site_name in site_site_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

            for transmit_interval_object in transmit_interval_object_list:
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)
              util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)
              payload_list.append(transmit_interval_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)

            #convert parent keys to list
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name

            for site_site_name in site_site_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

            for transmit_interval_object in transmit_interval_object_list:
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)

              util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)


            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/transmit-interval"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, transmit_interval_object in enumerate(transmit_interval_object_list):
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)

              util.log_debug('update transmit_interval_payload %s'%transmit_interval_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)


            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name

            for site_site_name in site_site_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/transmit-interval"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, site_site_name):
            #Parent Key Validations
            if util.isEmpty(site_site_name):
              raise Exception("'site_site_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            transmit_interval_object_list = []
            from servicemodel.controller.devices.device.vpls.site.oam import bfd_liveness_detection
            transmit_interval_object = bfd_liveness_detection.transmit_interval.transmit_interval()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                transmit_interval_object.minimum_interval = mapping_dict.get('minimum_interval', None)
              else:
                transmit_interval_object.minimum_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                transmit_interval_object.threshold = mapping_dict.get('threshold', None)
              else:
                transmit_interval_object.threshold._empty_tag = True
            except TypeError:
              pass
            transmit_interval_object_list.append(transmit_interval_object)

            return transmit_interval_object_list

        #XPATH devices/device/vpls/site/oam/bfd-liveness-detection/detection-time
        class detection_time(AbstractDeviceMgr):
          key_hints = [['site_name']]
          def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name

            for site_site_name in site_site_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

            for detection_time_object in detection_time_object_list:
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)
              util.log_debug('detection_time_payload %s'%detection_time_payload)
              payload_list.append(detection_time_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)

            #convert parent keys to list
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name

            for site_site_name in site_site_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

            for detection_time_object in detection_time_object_list:
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)

              util.log_debug('detection_time_payload %s'%detection_time_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)


            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/detection-time"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, detection_time_object in enumerate(detection_time_object_list):
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)

              util.log_debug('update detection_time_payload %s'%detection_time_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name)


            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name

            for site_site_name in site_site_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/detection-time"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, site_site_name):
            #Parent Key Validations
            if util.isEmpty(site_site_name):
              raise Exception("'site_site_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            detection_time_object_list = []
            from servicemodel.controller.devices.device.vpls.site.oam import bfd_liveness_detection
            detection_time_object = bfd_liveness_detection.detection_time.detection_time()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                detection_time_object.threshold = mapping_dict.get('threshold', None)
              else:
                detection_time_object.threshold._empty_tag = True
            except TypeError:
              pass
            detection_time_object_list.append(detection_time_object)

            return detection_time_object_list

    #XPATH devices/device/vpls/site/multi-homing
    class multi_homing(AbstractDeviceMgr):
      key_hints = [['site_name']]
      def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        multi_homing_object_list = self.validate_inputs_form_payload(mapping_dict)

        for multi_homing_object in multi_homing_object_list:
          #fetch payload
          multi_homing_payload = multi_homing_object.getxml(filter=True)
          util.log_debug('multi_homing_payload %s'%multi_homing_payload)
          payload_list.append(multi_homing_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        multi_homing_object_list = self.validate_inputs_form_payload(mapping_dict)

        for multi_homing_object in multi_homing_object_list:
          #fetch payload
          multi_homing_payload = multi_homing_object.getxml(filter=True)

          util.log_debug('multi_homing_payload %s'%multi_homing_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=multi_homing_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        multi_homing_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/multi-homing"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, multi_homing_object in enumerate(multi_homing_object_list):
          #fetch payload
          multi_homing_payload = multi_homing_object.getxml(filter=True)

          util.log_debug('update multi_homing_payload %s'%multi_homing_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=multi_homing_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/multi-homing"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, site_site_name):
        #Parent Key Validations
        if util.isEmpty(site_site_name):
          raise Exception("'site_site_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        multi_homing_object_list = []
        from servicemodel.controller.devices.device.vpls import site
        multi_homing_object = site.multi_homing.multi_homing()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('hold_time', None)) != ''):
            multi_homing_object.hold_time = mapping_dict.get('hold_time', None)
          else:
            multi_homing_object.hold_time._empty_tag = True
        except TypeError:
          pass
        multi_homing_object_list.append(multi_homing_object)

        return multi_homing_object_list

    #XPATH devices/device/vpls/site/mesh-group
    class mesh_group(AbstractDeviceMgr):
      key_hints = [['site_name']]
      def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mesh_group_object_list = self.validate_inputs_form_payload(mapping_dict)

        for mesh_group_object in mesh_group_object_list:
          #fetch payload
          mesh_group_payload = mesh_group_object.getxml(filter=True)
          util.log_debug('mesh_group_payload %s'%mesh_group_payload)
          payload_list.append(mesh_group_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mesh_group_object_list = self.validate_inputs_form_payload(mapping_dict)

        for mesh_group_object in mesh_group_object_list:
          #fetch payload
          mesh_group_payload = mesh_group_object.getxml(filter=True)

          util.log_debug('mesh_group_payload %s'%mesh_group_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=mesh_group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mesh_group_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        mesh_group_name = mapping_dict.get('mesh_group_name')
        if not isinstance(mesh_group_name, list):
          mesh_group_name = [mesh_group_name]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for mesh_group_name_iterator in mesh_group_name:
          rcpath_tmp =  rcpath+"/mesh-group=%s"%(util.make_interfacename(mesh_group_name_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, mesh_group_object in enumerate(mesh_group_object_list):
          #fetch payload
          mesh_group_payload = mesh_group_object.getxml(filter=True)

          util.log_debug('update mesh_group_payload %s'%mesh_group_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=mesh_group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('mesh_group_name')):
          raise Exception("'mesh_group_name' cannot be empty")

        #convert keys to list
        mesh_group_name = mapping_dict.get('mesh_group_name')
        if not isinstance(mesh_group_name, list):
          mesh_group_name = [mesh_group_name]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for mesh_group_name_iterator in mesh_group_name:
          rcpath_tmp =  rcpath+"/mesh-group=%s"%(util.make_interfacename(mesh_group_name_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, site_site_name):
        #Parent Key Validations
        if util.isEmpty(site_site_name):
          raise Exception("'site_site_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('mesh_group_name')):
          raise Exception("'mesh_group_name' cannot be empty")

        #convert keys to list
        mesh_group_name = mapping_dict.get('mesh_group_name')
        if not isinstance(mesh_group_name, list):
          mesh_group_name = [mesh_group_name]

        #prepare payload
        mesh_group_object_list = []
        for mesh_group_name_iterator in mesh_group_name:
          from servicemodel.controller.devices.device.vpls import site
          mesh_group_object = site.mesh_group.mesh_group()
          mesh_group_object.mesh_group_name = mesh_group_name_iterator
          mesh_group_object_list.append(mesh_group_object)

        return mesh_group_object_list

    #XPATH devices/device/vpls/site/active-interface
    class active_interface(AbstractDeviceMgr):
      key_hints = [['site_name']]
      def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        active_interface_object_list = self.validate_inputs_form_payload(mapping_dict)

        for active_interface_object in active_interface_object_list:
          #fetch payload
          active_interface_payload = active_interface_object.getxml(filter=True)
          util.log_debug('active_interface_payload %s'%active_interface_payload)
          payload_list.append(active_interface_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        active_interface_object_list = self.validate_inputs_form_payload(mapping_dict)

        for active_interface_object in active_interface_object_list:
          #fetch payload
          active_interface_payload = active_interface_object.getxml(filter=True)

          util.log_debug('active_interface_payload %s'%active_interface_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=active_interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        active_interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/active-interface"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, active_interface_object in enumerate(active_interface_object_list):
          #fetch payload
          active_interface_payload = active_interface_object.getxml(filter=True)

          util.log_debug('update active_interface_payload %s'%active_interface_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=active_interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/active-interface"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, site_site_name):
        #Parent Key Validations
        if util.isEmpty(site_site_name):
          raise Exception("'site_site_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        active_interface_object_list = []
        from servicemodel.controller.devices.device.vpls import site
        active_interface_object = site.active_interface.active_interface()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('any', None)) != ''):
            active_interface_object.any = mapping_dict.get('any', None)
          else:
            active_interface_object.any._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('primary', None)) != ''):
            active_interface_object.primary = mapping_dict.get('primary', None)
          else:
            active_interface_object.primary._empty_tag = True
        except TypeError:
          pass
        active_interface_object_list.append(active_interface_object)

        return active_interface_object_list

    #XPATH devices/device/vpls/site/interface
    class interface(AbstractDeviceMgr):
      key_hints = [['site_name']]
      def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        interface_object_list = self.validate_inputs_form_payload(mapping_dict)

        for interface_object in interface_object_list:
          #fetch payload
          interface_payload = interface_object.getxml(filter=True)
          util.log_debug('interface_payload %s'%interface_payload)
          payload_list.append(interface_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)

        #convert parent keys to list
        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        interface_object_list = self.validate_inputs_form_payload(mapping_dict)

        for interface_object in interface_object_list:
          #fetch payload
          interface_payload = interface_object.getxml(filter=True)

          util.log_debug('interface_payload %s'%interface_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        name = mapping_dict.get('name')
        if not isinstance(name, list):
          name = [name]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for name_iterator in name:
          rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(name_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, interface_object in enumerate(interface_object_list):
          #fetch payload
          interface_payload = interface_object.getxml(filter=True)

          util.log_debug('update interface_payload %s'%interface_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( site_site_name)


        if not isinstance(site_site_name, list):
          site_site_name_list = [site_site_name]
        else:
          site_site_name_list = site_site_name

        for site_site_name in site_site_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s"%(util.make_interfacename(site_site_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('name')):
          raise Exception("'name' cannot be empty")

        #convert keys to list
        name = mapping_dict.get('name')
        if not isinstance(name, list):
          name = [name]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for name_iterator in name:
          rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(name_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, site_site_name):
        #Parent Key Validations
        if util.isEmpty(site_site_name):
          raise Exception("'site_site_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('name')):
          raise Exception("'name' cannot be empty")

        #convert keys to list
        name = mapping_dict.get('name')
        if not isinstance(name, list):
          name = [name]

        #prepare payload
        interface_object_list = []
        for name_iterator in name:
          from servicemodel.controller.devices.device.vpls import site
          interface_object = site.interface.interface()
          interface_object.name = name_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('action_priority', None)) != ''):
              interface_object.action_priority = mapping_dict.get('action_priority', None)
            else:
              interface_object.action_priority._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('remote_site_id', None)) != ''):
              interface_object.remote_site_id = mapping_dict.get('remote_site_id', None)
            else:
              interface_object.remote_site_id._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('target_attachment_identifier', None)) != ''):
              interface_object.target_attachment_identifier = mapping_dict.get('target_attachment_identifier', None)
            else:
              interface_object.target_attachment_identifier._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('flow_label_transmit', None)) != ''):
              interface_object.flow_label_transmit = mapping_dict.get('flow_label_transmit', None)
            else:
              interface_object.flow_label_transmit._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('flow_label_receive', None)) != ''):
              interface_object.flow_label_receive = mapping_dict.get('flow_label_receive', None)
            else:
              interface_object.flow_label_receive._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('encapsulation_type', None)) != ''):
              interface_object.encapsulation_type = mapping_dict.get('encapsulation_type', None)
            else:
              interface_object.encapsulation_type._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ignore_encapsulation_mismatch', None)) != ''):
              interface_object.ignore_encapsulation_mismatch = mapping_dict.get('ignore_encapsulation_mismatch', None)
            else:
              interface_object.ignore_encapsulation_mismatch._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('mtu', None)) != ''):
              interface_object.mtu = mapping_dict.get('mtu', None)
            else:
              interface_object.mtu._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ignore_mtu_mismatch', None)) != ''):
              interface_object.ignore_mtu_mismatch = mapping_dict.get('ignore_mtu_mismatch', None)
            else:
              interface_object.ignore_mtu_mismatch._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('control_word', None)) != ''):
              interface_object.control_word = mapping_dict.get('control_word', None)
            else:
              interface_object.control_word._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('no_control_word', None)) != ''):
              interface_object.no_control_word = mapping_dict.get('no_control_word', None)
            else:
              interface_object.no_control_word._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('pseudowire_status_tlv', None)) != ''):
              interface_object.pseudowire_status_tlv = mapping_dict.get('pseudowire_status_tlv', None)
            else:
              interface_object.pseudowire_status_tlv._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
              interface_object.community = mapping_dict.get('community', None)
            else:
              interface_object.community._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('no_mac_learning', None)) != ''):
              interface_object.no_mac_learning = mapping_dict.get('no_mac_learning', None)
            else:
              interface_object.no_mac_learning._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
              interface_object.description = mapping_dict.get('description', None)
            else:
              interface_object.description._empty_tag = True
          except TypeError:
            pass
          interface_object_list.append(interface_object)

        return interface_object_list

      #XPATH devices/device/vpls/site/interface/interface-mac-limit
      class interface_mac_limit(AbstractDeviceMgr):
        key_hints = [['site_name'],['name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict)

          for interface_mac_limit_object in interface_mac_limit_object_list:
            #fetch payload
            interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)
            util.log_debug('interface_mac_limit_payload %s'%interface_mac_limit_payload)
            payload_list.append(interface_mac_limit_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict)

          for interface_mac_limit_object in interface_mac_limit_object_list:
            #fetch payload
            interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)

            util.log_debug('interface_mac_limit_payload %s'%interface_mac_limit_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_mac_limit_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_mac_limit_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/interface-mac-limit"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, interface_mac_limit_object in enumerate(interface_mac_limit_object_list):
            #fetch payload
            interface_mac_limit_payload = interface_mac_limit_object.getxml(filter=True)

            util.log_debug('update interface_mac_limit_payload %s'%interface_mac_limit_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_mac_limit_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/interface-mac-limit"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name, interface_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")
          if util.isEmpty(interface_name):
            raise Exception("'interface_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          interface_mac_limit_object_list = []
          from servicemodel.controller.devices.device.vpls.site import interface
          interface_mac_limit_object = interface.interface_mac_limit.interface_mac_limit()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('limit', None)) != ''):
              interface_mac_limit_object.limit = mapping_dict.get('limit', None)
            else:
              interface_mac_limit_object.limit._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('packet_action', None)) != ''):
              interface_mac_limit_object.packet_action = mapping_dict.get('packet_action', None)
            else:
              interface_mac_limit_object.packet_action._empty_tag = True
          except TypeError:
            pass
          interface_mac_limit_object_list.append(interface_mac_limit_object)

          return interface_mac_limit_object_list

      #XPATH devices/device/vpls/site/interface/oam
      class oam(AbstractDeviceMgr):
        key_hints = [['site_name'],['name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          oam_object_list = self.validate_inputs_form_payload(mapping_dict)

          for oam_object in oam_object_list:
            #fetch payload
            oam_payload = oam_object.getxml(filter=True)
            util.log_debug('oam_payload %s'%oam_payload)
            payload_list.append(oam_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          oam_object_list = self.validate_inputs_form_payload(mapping_dict)

          for oam_object in oam_object_list:
            #fetch payload
            oam_payload = oam_object.getxml(filter=True)

            util.log_debug('oam_payload %s'%oam_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          oam_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/oam"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, oam_object in enumerate(oam_object_list):
            #fetch payload
            oam_payload = oam_object.getxml(filter=True)

            util.log_debug('update oam_payload %s'%oam_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/oam"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name, interface_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")
          if util.isEmpty(interface_name):
            raise Exception("'interface_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          oam_object_list = []
          from servicemodel.controller.devices.device.vpls.site import interface
          oam_object = interface.oam.oam()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ping_interval', None)) != ''):
              oam_object.ping_interval = mapping_dict.get('ping_interval', None)
            else:
              oam_object.ping_interval._empty_tag = True
          except TypeError:
            pass
          oam_object_list.append(oam_object)

          return oam_object_list

        #XPATH devices/device/vpls/site/interface/oam/bfd-liveness-detection
        class bfd_liveness_detection(AbstractDeviceMgr):
          key_hints = [['site_name'],['name']]
          def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for site_site_name in site_site_name_list:
              for interface_name in interface_name_list:
                ##prepare rcpath
                rcpath = "vpls:vpls/site=%s/interface=%s/oam"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

            for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
              #fetch payload
              bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)
              util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)
              payload_list.append(bfd_liveness_detection_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name)

            #convert parent keys to list
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for site_site_name in site_site_name_list:
              for interface_name in interface_name_list:
                ##prepare rcpath
                rcpath = "vpls:vpls/site=%s/interface=%s/oam"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

            for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
              #fetch payload
              bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

              util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name)


            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/interface=%s/oam"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/bfd-liveness-detection"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, bfd_liveness_detection_object in enumerate(bfd_liveness_detection_object_list):
              #fetch payload
              bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

              util.log_debug('update bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, site_site_name, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name)


            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name

            for site_site_name in site_site_name_list:
              for interface_name in interface_name_list:
                ##prepare rcpath
                rcpath = "vpls:vpls/site=%s/interface=%s/oam"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/bfd-liveness-detection"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, site_site_name, interface_name):
            #Parent Key Validations
            if util.isEmpty(site_site_name):
              raise Exception("'site_site_name' cannot be empty")
            if util.isEmpty(interface_name):
              raise Exception("'interface_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            bfd_liveness_detection_object_list = []
            from servicemodel.controller.devices.device.vpls.site.interface import oam
            bfd_liveness_detection_object = oam.bfd_liveness_detection.bfd_liveness_detection()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('version', None)) != ''):
                bfd_liveness_detection_object.version = mapping_dict.get('version', None)
              else:
                bfd_liveness_detection_object.version._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                bfd_liveness_detection_object.minimum_interval = mapping_dict.get('minimum_interval', None)
              else:
                bfd_liveness_detection_object.minimum_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_receive_interval', None)) != ''):
                bfd_liveness_detection_object.minimum_receive_interval = mapping_dict.get('minimum_receive_interval', None)
              else:
                bfd_liveness_detection_object.minimum_receive_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('multiplier', None)) != ''):
                bfd_liveness_detection_object.multiplier = mapping_dict.get('multiplier', None)
              else:
                bfd_liveness_detection_object.multiplier._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('no_adaptation', None)) != ''):
                bfd_liveness_detection_object.no_adaptation = mapping_dict.get('no_adaptation', None)
              else:
                bfd_liveness_detection_object.no_adaptation._empty_tag = True
            except TypeError:
              pass
            bfd_liveness_detection_object_list.append(bfd_liveness_detection_object)

            return bfd_liveness_detection_object_list

          #XPATH devices/device/vpls/site/interface/oam/bfd-liveness-detection/transmit-interval
          class transmit_interval(AbstractDeviceMgr):
            key_hints = [['site_name'],['name']]
            def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(site_site_name, list):
                site_site_name_list = [site_site_name]
              else:
                site_site_name_list = site_site_name
              if not isinstance(interface_name, list):
                interface_name_list = [interface_name]
              else:
                interface_name_list = interface_name

              for site_site_name in site_site_name_list:
                for interface_name in interface_name_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                  rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

              for transmit_interval_object in transmit_interval_object_list:
                #fetch payload
                transmit_interval_payload = transmit_interval_object.getxml(filter=True)
                util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)
                payload_list.append(transmit_interval_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)

              #convert parent keys to list
              if not isinstance(site_site_name, list):
                site_site_name_list = [site_site_name]
              else:
                site_site_name_list = site_site_name
              if not isinstance(interface_name, list):
                interface_name_list = [interface_name]
              else:
                interface_name_list = interface_name

              for site_site_name in site_site_name_list:
                for interface_name in interface_name_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

              for transmit_interval_object in transmit_interval_object_list:
                #fetch payload
                transmit_interval_payload = transmit_interval_object.getxml(filter=True)

                util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)


              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/transmit-interval"
              rcpath_list.append(rcpath_tmp)
              for rc_counter, transmit_interval_object in enumerate(transmit_interval_object_list):
                #fetch payload
                transmit_interval_payload = transmit_interval_object.getxml(filter=True)

                util.log_debug('update transmit_interval_payload %s'%transmit_interval_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, site_site_name, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)


              if not isinstance(site_site_name, list):
                site_site_name_list = [site_site_name]
              else:
                site_site_name_list = site_site_name
              if not isinstance(interface_name, list):
                interface_name_list = [interface_name]
              else:
                interface_name_list = interface_name

              for site_site_name in site_site_name_list:
                for interface_name in interface_name_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/transmit-interval"
              rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, site_site_name, interface_name):
              #Parent Key Validations
              if util.isEmpty(site_site_name):
                raise Exception("'site_site_name' cannot be empty")
              if util.isEmpty(interface_name):
                raise Exception("'interface_name' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs

              #convert keys to list

              #prepare payload
              transmit_interval_object_list = []
              from servicemodel.controller.devices.device.vpls.site.interface.oam import bfd_liveness_detection
              transmit_interval_object = bfd_liveness_detection.transmit_interval.transmit_interval()
              try:
                if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                  transmit_interval_object.minimum_interval = mapping_dict.get('minimum_interval', None)
                else:
                  transmit_interval_object.minimum_interval._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                  transmit_interval_object.threshold = mapping_dict.get('threshold', None)
                else:
                  transmit_interval_object.threshold._empty_tag = True
              except TypeError:
                pass
              transmit_interval_object_list.append(transmit_interval_object)

              return transmit_interval_object_list

          #XPATH devices/device/vpls/site/interface/oam/bfd-liveness-detection/detection-time
          class detection_time(AbstractDeviceMgr):
            key_hints = [['site_name'],['name']]
            def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(site_site_name, list):
                site_site_name_list = [site_site_name]
              else:
                site_site_name_list = site_site_name
              if not isinstance(interface_name, list):
                interface_name_list = [interface_name]
              else:
                interface_name_list = interface_name

              for site_site_name in site_site_name_list:
                for interface_name in interface_name_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                  rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

              for detection_time_object in detection_time_object_list:
                #fetch payload
                detection_time_payload = detection_time_object.getxml(filter=True)
                util.log_debug('detection_time_payload %s'%detection_time_payload)
                payload_list.append(detection_time_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)

              #convert parent keys to list
              if not isinstance(site_site_name, list):
                site_site_name_list = [site_site_name]
              else:
                site_site_name_list = site_site_name
              if not isinstance(interface_name, list):
                interface_name_list = [interface_name]
              else:
                interface_name_list = interface_name

              for site_site_name in site_site_name_list:
                for interface_name in interface_name_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

              for detection_time_object in detection_time_object_list:
                #fetch payload
                detection_time_payload = detection_time_object.getxml(filter=True)

                util.log_debug('detection_time_payload %s'%detection_time_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)


              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              detection_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/detection-time"
              rcpath_list.append(rcpath_tmp)
              for rc_counter, detection_time_object in enumerate(detection_time_object_list):
                #fetch payload
                detection_time_payload = detection_time_object.getxml(filter=True)

                util.log_debug('update detection_time_payload %s'%detection_time_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, site_site_name, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( site_site_name, interface_name)


              if not isinstance(site_site_name, list):
                site_site_name_list = [site_site_name]
              else:
                site_site_name_list = site_site_name
              if not isinstance(interface_name, list):
                interface_name_list = [interface_name]
              else:
                interface_name_list = interface_name

              for site_site_name in site_site_name_list:
                for interface_name in interface_name_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/oam/bfd-liveness-detection"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/detection-time"
              rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, site_site_name, interface_name):
              #Parent Key Validations
              if util.isEmpty(site_site_name):
                raise Exception("'site_site_name' cannot be empty")
              if util.isEmpty(interface_name):
                raise Exception("'interface_name' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs

              #convert keys to list

              #prepare payload
              detection_time_object_list = []
              from servicemodel.controller.devices.device.vpls.site.interface.oam import bfd_liveness_detection
              detection_time_object = bfd_liveness_detection.detection_time.detection_time()
              try:
                if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                  detection_time_object.threshold = mapping_dict.get('threshold', None)
                else:
                  detection_time_object.threshold._empty_tag = True
              except TypeError:
                pass
              detection_time_object_list.append(detection_time_object)

              return detection_time_object_list

      #XPATH devices/device/vpls/site/interface/static-mac
      class static_mac(AbstractDeviceMgr):
        key_hints = [['site_name'],['name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_mac_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_mac_object in static_mac_object_list:
            #fetch payload
            static_mac_payload = static_mac_object.getxml(filter=True)
            util.log_debug('static_mac_payload %s'%static_mac_payload)
            payload_list.append(static_mac_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_mac_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_mac_object in static_mac_object_list:
            #fetch payload
            static_mac_payload = static_mac_object.getxml(filter=True)

            util.log_debug('static_mac_payload %s'%static_mac_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_mac_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, interface_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_mac_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          address = mapping_dict.get('address')
          if not isinstance(address, list):
            address = [address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for address_iterator in address:
            rcpath_tmp =  rcpath+"/static-mac=%s"%(util.make_interfacename(address_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, static_mac_object in enumerate(static_mac_object_list):
            #fetch payload
            static_mac_payload = static_mac_object.getxml(filter=True)

            util.log_debug('update static_mac_payload %s'%static_mac_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_mac_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, interface_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name, interface_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name
          if not isinstance(interface_name, list):
            interface_name_list = [interface_name]
          else:
            interface_name_list = interface_name

          for site_site_name in site_site_name_list:
            for interface_name in interface_name_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/site=%s/interface=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('address')):
            raise Exception("'address' cannot be empty")

          #convert keys to list
          address = mapping_dict.get('address')
          if not isinstance(address, list):
            address = [address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for address_iterator in address:
            rcpath_tmp =  rcpath+"/static-mac=%s"%(util.make_interfacename(address_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name, interface_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")
          if util.isEmpty(interface_name):
            raise Exception("'interface_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('address')):
            raise Exception("'address' cannot be empty")

          #convert keys to list
          address = mapping_dict.get('address')
          if not isinstance(address, list):
            address = [address]

          #prepare payload
          static_mac_object_list = []
          for address_iterator in address:
            from servicemodel.controller.devices.device.vpls.site import interface
            static_mac_object = interface.static_mac.static_mac()
            static_mac_object.address = address_iterator
            static_mac_object_list.append(static_mac_object)

          return static_mac_object_list

        #XPATH devices/device/vpls/site/interface/static-mac/vlan-id
        class vlan_id(AbstractDeviceMgr):
          key_hints = [['site_name'],['name'],['address']]
          def getRcpathPayload(self, sdata, dev, site_site_name, interface_name, static_mac_address, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name, static_mac_address)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name
            if not isinstance(static_mac_address, list):
              static_mac_address_list = [static_mac_address]
            else:
              static_mac_address_list = static_mac_address

            for site_site_name in site_site_name_list:
              for interface_name in interface_name_list:
                for static_mac_address in static_mac_address_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/static-mac=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
                  rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            vlan_id_object_list = self.validate_inputs_form_payload(mapping_dict)

            for vlan_id_object in vlan_id_object_list:
              #fetch payload
              vlan_id_payload = vlan_id_object.getxml(filter=True)
              util.log_debug('vlan_id_payload %s'%vlan_id_payload)
              payload_list.append(vlan_id_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, site_site_name, interface_name, static_mac_address, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name, static_mac_address)

            #convert parent keys to list
            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name
            if not isinstance(static_mac_address, list):
              static_mac_address_list = [static_mac_address]
            else:
              static_mac_address_list = static_mac_address

            for site_site_name in site_site_name_list:
              for interface_name in interface_name_list:
                for static_mac_address in static_mac_address_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/static-mac=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            vlan_id_object_list = self.validate_inputs_form_payload(mapping_dict)

            for vlan_id_object in vlan_id_object_list:
              #fetch payload
              vlan_id_payload = vlan_id_object.getxml(filter=True)

              util.log_debug('vlan_id_payload %s'%vlan_id_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vlan_id_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, site_site_name, interface_name, static_mac_address, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name, static_mac_address)


            ##prepare rcpath
            rcpath = "vpls:vpls/site=%s/interface=%s/static-mac=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            vlan_id_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            id = mapping_dict.get('id')
            if not isinstance(id, list):
              id = [id]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for id_iterator in id:
              rcpath_tmp =  rcpath+"/vlan-id=%s"%(util.make_interfacename(id_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, vlan_id_object in enumerate(vlan_id_object_list):
              #fetch payload
              vlan_id_payload = vlan_id_object.getxml(filter=True)

              util.log_debug('update vlan_id_payload %s'%vlan_id_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vlan_id_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, site_site_name, interface_name, static_mac_address, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( site_site_name, interface_name, static_mac_address)


            if not isinstance(site_site_name, list):
              site_site_name_list = [site_site_name]
            else:
              site_site_name_list = site_site_name
            if not isinstance(interface_name, list):
              interface_name_list = [interface_name]
            else:
              interface_name_list = interface_name
            if not isinstance(static_mac_address, list):
              static_mac_address_list = [static_mac_address]
            else:
              static_mac_address_list = static_mac_address

            for site_site_name in site_site_name_list:
              for interface_name in interface_name_list:
                for static_mac_address in static_mac_address_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/site=%s/interface=%s/static-mac=%s"%(util.make_interfacename(site_site_name),util.make_interfacename(interface_name),util.make_interfacename(static_mac_address))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('id')):
              raise Exception("'id' cannot be empty")

            #convert keys to list
            id = mapping_dict.get('id')
            if not isinstance(id, list):
              id = [id]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for id_iterator in id:
              rcpath_tmp =  rcpath+"/vlan-id=%s"%(util.make_interfacename(id_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, site_site_name, interface_name, static_mac_address):
            #Parent Key Validations
            if util.isEmpty(site_site_name):
              raise Exception("'site_site_name' cannot be empty")
            if util.isEmpty(interface_name):
              raise Exception("'interface_name' cannot be empty")
            if util.isEmpty(static_mac_address):
              raise Exception("'static_mac_address' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('id')):
              raise Exception("'id' cannot be empty")

            #convert keys to list
            id = mapping_dict.get('id')
            if not isinstance(id, list):
              id = [id]

            #prepare payload
            vlan_id_object_list = []
            for id_iterator in id:
              from servicemodel.controller.devices.device.vpls.site.interface import static_mac
              vlan_id_object = static_mac.vlan_id.vlan_id()
              vlan_id_object.id = id_iterator
              vlan_id_object_list.append(vlan_id_object)

            return vlan_id_object_list

  #XPATH devices/device/vpls/mac-flush
  class mac_flush(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mac_flush_object_list = self.validate_inputs_form_payload(mapping_dict)

      for mac_flush_object in mac_flush_object_list:
        #fetch payload
        mac_flush_payload = mac_flush_object.getxml(filter=True)
        util.log_debug('mac_flush_payload %s'%mac_flush_payload)
        payload_list.append(mac_flush_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mac_flush_object_list = self.validate_inputs_form_payload(mapping_dict)

      for mac_flush_object in mac_flush_object_list:
        #fetch payload
        mac_flush_payload = mac_flush_object.getxml(filter=True)

        util.log_debug('mac_flush_payload %s'%mac_flush_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=mac_flush_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mac_flush_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/mac-flush"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, mac_flush_object in enumerate(mac_flush_object_list):
        #fetch payload
        mac_flush_payload = mac_flush_object.getxml(filter=True)

        util.log_debug('update mac_flush_payload %s'%mac_flush_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=mac_flush_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/mac-flush"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs

      #convert keys to list

      #prepare payload
      mac_flush_object_list = []
      from servicemodel.controller.devices.device import vpls
      mac_flush_object = vpls.mac_flush.mac_flush()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('any_interface', None)) != ''):
          mac_flush_object.any_interface = mapping_dict.get('any_interface', None)
        else:
          mac_flush_object.any_interface._empty_tag = True
      except TypeError:
        pass
      try:
        if (update == False) or (update == True and str(mapping_dict.get('any_spoke', None)) != ''):
          mac_flush_object.any_spoke = mapping_dict.get('any_spoke', None)
        else:
          mac_flush_object.any_spoke._empty_tag = True
      except TypeError:
        pass
      try:
        if (update == False) or (update == True and str(mapping_dict.get('propagate', None)) != ''):
          mac_flush_object.propagate = mapping_dict.get('propagate', None)
        else:
          mac_flush_object.propagate._empty_tag = True
      except TypeError:
        pass
      mac_flush_object_list.append(mac_flush_object)

      return mac_flush_object_list

  #XPATH devices/device/vpls/neighbor
  class neighbor(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

      for neighbor_object in neighbor_object_list:
        #fetch payload
        neighbor_payload = neighbor_object.getxml(filter=True)
        util.log_debug('neighbor_payload %s'%neighbor_payload)
        payload_list.append(neighbor_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

      for neighbor_object in neighbor_object_list:
        #fetch payload
        neighbor_payload = neighbor_object.getxml(filter=True)

        util.log_debug('neighbor_payload %s'%neighbor_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list
      neighbor_id = mapping_dict.get('neighbor_id')
      if not isinstance(neighbor_id, list):
        neighbor_id = [neighbor_id]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for neighbor_id_iterator in neighbor_id:
        rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
        rcpath_list.append(rcpath_tmp)
      for rc_counter, neighbor_object in enumerate(neighbor_object_list):
        #fetch payload
        neighbor_payload = neighbor_object.getxml(filter=True)

        util.log_debug('update neighbor_payload %s'%neighbor_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs
      if util.isEmpty(mapping_dict.get('neighbor_id')):
        raise Exception("'neighbor_id' cannot be empty")

      #convert keys to list
      neighbor_id = mapping_dict.get('neighbor_id')
      if not isinstance(neighbor_id, list):
        neighbor_id = [neighbor_id]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for neighbor_id_iterator in neighbor_id:
        rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
        rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('neighbor_id')):
        raise Exception("'neighbor_id' cannot be empty")

      #convert keys to list
      neighbor_id = mapping_dict.get('neighbor_id')
      if not isinstance(neighbor_id, list):
        neighbor_id = [neighbor_id]

      #prepare payload
      neighbor_object_list = []
      for neighbor_id_iterator in neighbor_id:
        from servicemodel.controller.devices.device import vpls
        neighbor_object = vpls.neighbor.neighbor()
        neighbor_object.neighbor_id = neighbor_id_iterator
        try:
          if (update == False) or (update == True and str(mapping_dict.get('psn_tunnel_endpoint', None)) != ''):
            neighbor_object.psn_tunnel_endpoint = mapping_dict.get('psn_tunnel_endpoint', None)
          else:
            neighbor_object.psn_tunnel_endpoint._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
            neighbor_object.community = mapping_dict.get('community', None)
          else:
            neighbor_object.community._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('encapsulation_type', None)) != ''):
            neighbor_object.encapsulation_type = mapping_dict.get('encapsulation_type', None)
          else:
            neighbor_object.encapsulation_type._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ignore_encapsulation_mismatch', None)) != ''):
            neighbor_object.ignore_encapsulation_mismatch = mapping_dict.get('ignore_encapsulation_mismatch', None)
          else:
            neighbor_object.ignore_encapsulation_mismatch._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('pseudowire_status_tlv', None)) != ''):
            neighbor_object.pseudowire_status_tlv = mapping_dict.get('pseudowire_status_tlv', None)
          else:
            neighbor_object.pseudowire_status_tlv._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('switchover_delay', None)) != ''):
            neighbor_object.switchover_delay = mapping_dict.get('switchover_delay', None)
          else:
            neighbor_object.switchover_delay._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('revert_time', None)) != ''):
            neighbor_object.revert_time = mapping_dict.get('revert_time', None)
          else:
            neighbor_object.revert_time._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('connection_protection', None)) != ''):
            neighbor_object.connection_protection = mapping_dict.get('connection_protection', None)
          else:
            neighbor_object.connection_protection._empty_tag = True
        except TypeError:
          pass
        neighbor_object_list.append(neighbor_object)

      return neighbor_object_list

    #XPATH devices/device/vpls/neighbor/static
    class static(AbstractDeviceMgr):
      key_hints = [['neighbor_id']]
      def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        static_object_list = self.validate_inputs_form_payload(mapping_dict)

        for static_object in static_object_list:
          #fetch payload
          static_payload = static_object.getxml(filter=True)
          util.log_debug('static_payload %s'%static_payload)
          payload_list.append(static_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        static_object_list = self.validate_inputs_form_payload(mapping_dict)

        for static_object in static_object_list:
          #fetch payload
          static_payload = static_object.getxml(filter=True)

          util.log_debug('static_payload %s'%static_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        ##prepare rcpath
        rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        static_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/static"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, static_object in enumerate(static_object_list):
          #fetch payload
          static_payload = static_object.getxml(filter=True)

          util.log_debug('update static_payload %s'%static_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/static"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, neighbor_neighbor_id):
        #Parent Key Validations
        if util.isEmpty(neighbor_neighbor_id):
          raise Exception("'neighbor_neighbor_id' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('incoming_label')):
          raise Exception("'incoming_label' cannot be empty")
        if util.isEmpty(mapping_dict.get('outgoing_label')):
          raise Exception("'outgoing_label' cannot be empty")

        #convert keys to list

        #prepare payload
        static_object_list = []
        from servicemodel.controller.devices.device.vpls import neighbor
        static_object = neighbor.static.static()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('incoming_label', None)) != ''):
            static_object.incoming_label = mapping_dict.get('incoming_label', None)
          else:
            static_object.incoming_label._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('outgoing_label', None)) != ''):
            static_object.outgoing_label = mapping_dict.get('outgoing_label', None)
          else:
            static_object.outgoing_label._empty_tag = True
        except TypeError:
          pass
        static_object_list.append(static_object)

        return static_object_list

    #XPATH devices/device/vpls/neighbor/associate-profile
    class associate_profile(AbstractDeviceMgr):
      key_hints = [['neighbor_id']]
      def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

        for associate_profile_object in associate_profile_object_list:
          #fetch payload
          associate_profile_payload = associate_profile_object.getxml(filter=True)
          util.log_debug('associate_profile_payload %s'%associate_profile_payload)
          payload_list.append(associate_profile_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

        for associate_profile_object in associate_profile_object_list:
          #fetch payload
          associate_profile_payload = associate_profile_object.getxml(filter=True)

          util.log_debug('associate_profile_payload %s'%associate_profile_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        ##prepare rcpath
        rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/associate-profile"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, associate_profile_object in enumerate(associate_profile_object_list):
          #fetch payload
          associate_profile_payload = associate_profile_object.getxml(filter=True)

          util.log_debug('update associate_profile_payload %s'%associate_profile_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/associate-profile"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, neighbor_neighbor_id):
        #Parent Key Validations
        if util.isEmpty(neighbor_neighbor_id):
          raise Exception("'neighbor_neighbor_id' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('profile_name')):
          raise Exception("'profile_name' cannot be empty")

        #convert keys to list

        #prepare payload
        associate_profile_object_list = []
        from servicemodel.controller.devices.device.vpls import neighbor
        associate_profile_object = neighbor.associate_profile.associate_profile()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('profile_name', None)) != ''):
            associate_profile_object.profile_name = mapping_dict.get('profile_name', None)
          else:
            associate_profile_object.profile_name._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('profile_variable_set', None)) != ''):
            associate_profile_object.profile_variable_set = mapping_dict.get('profile_variable_set', None)
          else:
            associate_profile_object.profile_variable_set._empty_tag = True
        except TypeError:
          pass
        associate_profile_object_list.append(associate_profile_object)

        return associate_profile_object_list

    #XPATH devices/device/vpls/neighbor/backup-neighbor
    class backup_neighbor(AbstractDeviceMgr):
      key_hints = [['neighbor_id']]
      def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        backup_neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

        for backup_neighbor_object in backup_neighbor_object_list:
          #fetch payload
          backup_neighbor_payload = backup_neighbor_object.getxml(filter=True)
          util.log_debug('backup_neighbor_payload %s'%backup_neighbor_payload)
          payload_list.append(backup_neighbor_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        backup_neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

        for backup_neighbor_object in backup_neighbor_object_list:
          #fetch payload
          backup_neighbor_payload = backup_neighbor_object.getxml(filter=True)

          util.log_debug('backup_neighbor_payload %s'%backup_neighbor_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=backup_neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        ##prepare rcpath
        rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        backup_neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        neighbor_id = mapping_dict.get('neighbor_id')
        if not isinstance(neighbor_id, list):
          neighbor_id = [neighbor_id]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for neighbor_id_iterator in neighbor_id:
          rcpath_tmp =  rcpath+"/backup-neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, backup_neighbor_object in enumerate(backup_neighbor_object_list):
          #fetch payload
          backup_neighbor_payload = backup_neighbor_object.getxml(filter=True)

          util.log_debug('update backup_neighbor_payload %s'%backup_neighbor_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=backup_neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('neighbor_id')):
          raise Exception("'neighbor_id' cannot be empty")

        #convert keys to list
        neighbor_id = mapping_dict.get('neighbor_id')
        if not isinstance(neighbor_id, list):
          neighbor_id = [neighbor_id]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for neighbor_id_iterator in neighbor_id:
          rcpath_tmp =  rcpath+"/backup-neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, neighbor_neighbor_id):
        #Parent Key Validations
        if util.isEmpty(neighbor_neighbor_id):
          raise Exception("'neighbor_neighbor_id' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('neighbor_id')):
          raise Exception("'neighbor_id' cannot be empty")

        #convert keys to list
        neighbor_id = mapping_dict.get('neighbor_id')
        if not isinstance(neighbor_id, list):
          neighbor_id = [neighbor_id]

        #prepare payload
        backup_neighbor_object_list = []
        for neighbor_id_iterator in neighbor_id:
          from servicemodel.controller.devices.device.vpls import neighbor
          backup_neighbor_object = neighbor.backup_neighbor.backup_neighbor()
          backup_neighbor_object.neighbor_id = neighbor_id_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
              backup_neighbor_object.community = mapping_dict.get('community', None)
            else:
              backup_neighbor_object.community._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('psn_tunnel_endpoint', None)) != ''):
              backup_neighbor_object.psn_tunnel_endpoint = mapping_dict.get('psn_tunnel_endpoint', None)
            else:
              backup_neighbor_object.psn_tunnel_endpoint._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('standby', None)) != ''):
              backup_neighbor_object.standby = mapping_dict.get('standby', None)
            else:
              backup_neighbor_object.standby._empty_tag = True
          except TypeError:
            pass
          backup_neighbor_object_list.append(backup_neighbor_object)

        return backup_neighbor_object_list

      #XPATH devices/device/vpls/neighbor/backup-neighbor/static
      class static(AbstractDeviceMgr):
        key_hints = [['neighbor_id'],['neighbor_id']]
        def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id, backup_neighbor_neighbor_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id
          if not isinstance(backup_neighbor_neighbor_id, list):
            backup_neighbor_neighbor_id_list = [backup_neighbor_neighbor_id]
          else:
            backup_neighbor_neighbor_id_list = backup_neighbor_neighbor_id

          for neighbor_neighbor_id in neighbor_neighbor_id_list:
            for backup_neighbor_neighbor_id in backup_neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_object in static_object_list:
            #fetch payload
            static_payload = static_object.getxml(filter=True)
            util.log_debug('static_payload %s'%static_payload)
            payload_list.append(static_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id, backup_neighbor_neighbor_id)

          #convert parent keys to list
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id
          if not isinstance(backup_neighbor_neighbor_id, list):
            backup_neighbor_neighbor_id_list = [backup_neighbor_neighbor_id]
          else:
            backup_neighbor_neighbor_id_list = backup_neighbor_neighbor_id

          for neighbor_neighbor_id in neighbor_neighbor_id_list:
            for backup_neighbor_neighbor_id in backup_neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_object in static_object_list:
            #fetch payload
            static_payload = static_object.getxml(filter=True)

            util.log_debug('static_payload %s'%static_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id, backup_neighbor_neighbor_id)


          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/static"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, static_object in enumerate(static_object_list):
            #fetch payload
            static_payload = static_object.getxml(filter=True)

            util.log_debug('update static_payload %s'%static_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id, backup_neighbor_neighbor_id)


          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id
          if not isinstance(backup_neighbor_neighbor_id, list):
            backup_neighbor_neighbor_id_list = [backup_neighbor_neighbor_id]
          else:
            backup_neighbor_neighbor_id_list = backup_neighbor_neighbor_id

          for neighbor_neighbor_id in neighbor_neighbor_id_list:
            for backup_neighbor_neighbor_id in backup_neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/static"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, neighbor_neighbor_id, backup_neighbor_neighbor_id):
          #Parent Key Validations
          if util.isEmpty(neighbor_neighbor_id):
            raise Exception("'neighbor_neighbor_id' cannot be empty")
          if util.isEmpty(backup_neighbor_neighbor_id):
            raise Exception("'backup_neighbor_neighbor_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('incoming_label')):
            raise Exception("'incoming_label' cannot be empty")
          if util.isEmpty(mapping_dict.get('outgoing_label')):
            raise Exception("'outgoing_label' cannot be empty")

          #convert keys to list

          #prepare payload
          static_object_list = []
          from servicemodel.controller.devices.device.vpls.neighbor import backup_neighbor
          static_object = backup_neighbor.static.static()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('incoming_label', None)) != ''):
              static_object.incoming_label = mapping_dict.get('incoming_label', None)
            else:
              static_object.incoming_label._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('outgoing_label', None)) != ''):
              static_object.outgoing_label = mapping_dict.get('outgoing_label', None)
            else:
              static_object.outgoing_label._empty_tag = True
          except TypeError:
            pass
          static_object_list.append(static_object)

          return static_object_list

    #XPATH devices/device/vpls/neighbor/oam
    class oam(AbstractDeviceMgr):
      key_hints = [['neighbor_id']]
      def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict)

        for oam_object in oam_object_list:
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)
          util.log_debug('oam_payload %s'%oam_payload)
          payload_list.append(oam_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)

        #convert parent keys to list
        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict)

        for oam_object in oam_object_list:
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)

          util.log_debug('oam_payload %s'%oam_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        ##prepare rcpath
        rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        oam_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/oam"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, oam_object in enumerate(oam_object_list):
          #fetch payload
          oam_payload = oam_object.getxml(filter=True)

          util.log_debug('update oam_payload %s'%oam_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( neighbor_neighbor_id)


        if not isinstance(neighbor_neighbor_id, list):
          neighbor_neighbor_id_list = [neighbor_neighbor_id]
        else:
          neighbor_neighbor_id_list = neighbor_neighbor_id

        for neighbor_neighbor_id in neighbor_neighbor_id_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s"%(util.make_interfacename(neighbor_neighbor_id))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/oam"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, neighbor_neighbor_id):
        #Parent Key Validations
        if util.isEmpty(neighbor_neighbor_id):
          raise Exception("'neighbor_neighbor_id' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        oam_object_list = []
        from servicemodel.controller.devices.device.vpls import neighbor
        oam_object = neighbor.oam.oam()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('ping_interval', None)) != ''):
            oam_object.ping_interval = mapping_dict.get('ping_interval', None)
          else:
            oam_object.ping_interval._empty_tag = True
        except TypeError:
          pass
        oam_object_list.append(oam_object)

        return oam_object_list

      #XPATH devices/device/vpls/neighbor/oam/bfd-liveness-detection
      class bfd_liveness_detection(AbstractDeviceMgr):
        key_hints = [['neighbor_id']]
        def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for neighbor_neighbor_id in neighbor_neighbor_id_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/neighbor=%s/oam"%(util.make_interfacename(neighbor_neighbor_id))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

          for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)
            util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)
            payload_list.append(bfd_liveness_detection_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id)

          #convert parent keys to list
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for neighbor_neighbor_id in neighbor_neighbor_id_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/neighbor=%s/oam"%(util.make_interfacename(neighbor_neighbor_id))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

          for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

            util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id)


          ##prepare rcpath
          rcpath = "vpls:vpls/neighbor=%s/oam"%(util.make_interfacename(neighbor_neighbor_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/bfd-liveness-detection"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, bfd_liveness_detection_object in enumerate(bfd_liveness_detection_object_list):
            #fetch payload
            bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

            util.log_debug('update bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( neighbor_neighbor_id)


          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for neighbor_neighbor_id in neighbor_neighbor_id_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/neighbor=%s/oam"%(util.make_interfacename(neighbor_neighbor_id))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/bfd-liveness-detection"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, neighbor_neighbor_id):
          #Parent Key Validations
          if util.isEmpty(neighbor_neighbor_id):
            raise Exception("'neighbor_neighbor_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          bfd_liveness_detection_object_list = []
          from servicemodel.controller.devices.device.vpls.neighbor import oam
          bfd_liveness_detection_object = oam.bfd_liveness_detection.bfd_liveness_detection()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('version', None)) != ''):
              bfd_liveness_detection_object.version = mapping_dict.get('version', None)
            else:
              bfd_liveness_detection_object.version._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
              bfd_liveness_detection_object.minimum_interval = mapping_dict.get('minimum_interval', None)
            else:
              bfd_liveness_detection_object.minimum_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_receive_interval', None)) != ''):
              bfd_liveness_detection_object.minimum_receive_interval = mapping_dict.get('minimum_receive_interval', None)
            else:
              bfd_liveness_detection_object.minimum_receive_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('multiplier', None)) != ''):
              bfd_liveness_detection_object.multiplier = mapping_dict.get('multiplier', None)
            else:
              bfd_liveness_detection_object.multiplier._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('no_adaptation', None)) != ''):
              bfd_liveness_detection_object.no_adaptation = mapping_dict.get('no_adaptation', None)
            else:
              bfd_liveness_detection_object.no_adaptation._empty_tag = True
          except TypeError:
            pass
          bfd_liveness_detection_object_list.append(bfd_liveness_detection_object)

          return bfd_liveness_detection_object_list

        #XPATH devices/device/vpls/neighbor/oam/bfd-liveness-detection/transmit-interval
        class transmit_interval(AbstractDeviceMgr):
          key_hints = [['neighbor_id']]
          def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

            for transmit_interval_object in transmit_interval_object_list:
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)
              util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)
              payload_list.append(transmit_interval_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)

            #convert parent keys to list
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

            for transmit_interval_object in transmit_interval_object_list:
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)

              util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)


            ##prepare rcpath
            rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/transmit-interval"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, transmit_interval_object in enumerate(transmit_interval_object_list):
              #fetch payload
              transmit_interval_payload = transmit_interval_object.getxml(filter=True)

              util.log_debug('update transmit_interval_payload %s'%transmit_interval_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)


            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/transmit-interval"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, neighbor_neighbor_id):
            #Parent Key Validations
            if util.isEmpty(neighbor_neighbor_id):
              raise Exception("'neighbor_neighbor_id' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            transmit_interval_object_list = []
            from servicemodel.controller.devices.device.vpls.neighbor.oam import bfd_liveness_detection
            transmit_interval_object = bfd_liveness_detection.transmit_interval.transmit_interval()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                transmit_interval_object.minimum_interval = mapping_dict.get('minimum_interval', None)
              else:
                transmit_interval_object.minimum_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                transmit_interval_object.threshold = mapping_dict.get('threshold', None)
              else:
                transmit_interval_object.threshold._empty_tag = True
            except TypeError:
              pass
            transmit_interval_object_list.append(transmit_interval_object)

            return transmit_interval_object_list

        #XPATH devices/device/vpls/neighbor/oam/bfd-liveness-detection/detection-time
        class detection_time(AbstractDeviceMgr):
          key_hints = [['neighbor_id']]
          def getRcpathPayload(self, sdata, dev, neighbor_neighbor_id, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

            for detection_time_object in detection_time_object_list:
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)
              util.log_debug('detection_time_payload %s'%detection_time_payload)
              payload_list.append(detection_time_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)

            #convert parent keys to list
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

            for detection_time_object in detection_time_object_list:
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)

              util.log_debug('detection_time_payload %s'%detection_time_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)


            ##prepare rcpath
            rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            detection_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/detection-time"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, detection_time_object in enumerate(detection_time_object_list):
              #fetch payload
              detection_time_payload = detection_time_object.getxml(filter=True)

              util.log_debug('update detection_time_payload %s'%detection_time_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( neighbor_neighbor_id)


            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/detection-time"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, neighbor_neighbor_id):
            #Parent Key Validations
            if util.isEmpty(neighbor_neighbor_id):
              raise Exception("'neighbor_neighbor_id' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            detection_time_object_list = []
            from servicemodel.controller.devices.device.vpls.neighbor.oam import bfd_liveness_detection
            detection_time_object = bfd_liveness_detection.detection_time.detection_time()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                detection_time_object.threshold = mapping_dict.get('threshold', None)
              else:
                detection_time_object.threshold._empty_tag = True
            except TypeError:
              pass
            detection_time_object_list.append(detection_time_object)

            return detection_time_object_list

  #XPATH devices/device/vpls/associate-profile
  class associate_profile(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

      for associate_profile_object in associate_profile_object_list:
        #fetch payload
        associate_profile_payload = associate_profile_object.getxml(filter=True)
        util.log_debug('associate_profile_payload %s'%associate_profile_payload)
        payload_list.append(associate_profile_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

      for associate_profile_object in associate_profile_object_list:
        #fetch payload
        associate_profile_payload = associate_profile_object.getxml(filter=True)

        util.log_debug('associate_profile_payload %s'%associate_profile_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/associate-profile"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, associate_profile_object in enumerate(associate_profile_object_list):
        #fetch payload
        associate_profile_payload = associate_profile_object.getxml(filter=True)

        util.log_debug('update associate_profile_payload %s'%associate_profile_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/associate-profile"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('profile_name')):
        raise Exception("'profile_name' cannot be empty")

      #convert keys to list

      #prepare payload
      associate_profile_object_list = []
      from servicemodel.controller.devices.device import vpls
      associate_profile_object = vpls.associate_profile.associate_profile()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('profile_name', None)) != ''):
          associate_profile_object.profile_name = mapping_dict.get('profile_name', None)
        else:
          associate_profile_object.profile_name._empty_tag = True
      except TypeError:
        pass
      try:
        if (update == False) or (update == True and str(mapping_dict.get('profile_variable_set', None)) != ''):
          associate_profile_object.profile_variable_set = mapping_dict.get('profile_variable_set', None)
        else:
          associate_profile_object.profile_variable_set._empty_tag = True
      except TypeError:
        pass
      associate_profile_object_list.append(associate_profile_object)

      return associate_profile_object_list

  #XPATH devices/device/vpls/mesh-group
  class mesh_group(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mesh_group_object_list = self.validate_inputs_form_payload(mapping_dict)

      for mesh_group_object in mesh_group_object_list:
        #fetch payload
        mesh_group_payload = mesh_group_object.getxml(filter=True)
        util.log_debug('mesh_group_payload %s'%mesh_group_payload)
        payload_list.append(mesh_group_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mesh_group_object_list = self.validate_inputs_form_payload(mapping_dict)

      for mesh_group_object in mesh_group_object_list:
        #fetch payload
        mesh_group_payload = mesh_group_object.getxml(filter=True)

        util.log_debug('mesh_group_payload %s'%mesh_group_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=mesh_group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      mesh_group_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list
      mesh_group_name = mapping_dict.get('mesh_group_name')
      if not isinstance(mesh_group_name, list):
        mesh_group_name = [mesh_group_name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for mesh_group_name_iterator in mesh_group_name:
        rcpath_tmp =  rcpath+"/mesh-group=%s"%(util.make_interfacename(mesh_group_name_iterator))
        rcpath_list.append(rcpath_tmp)
      for rc_counter, mesh_group_object in enumerate(mesh_group_object_list):
        #fetch payload
        mesh_group_payload = mesh_group_object.getxml(filter=True)

        util.log_debug('update mesh_group_payload %s'%mesh_group_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=mesh_group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs
      if util.isEmpty(mapping_dict.get('mesh_group_name')):
        raise Exception("'mesh_group_name' cannot be empty")

      #convert keys to list
      mesh_group_name = mapping_dict.get('mesh_group_name')
      if not isinstance(mesh_group_name, list):
        mesh_group_name = [mesh_group_name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for mesh_group_name_iterator in mesh_group_name:
        rcpath_tmp =  rcpath+"/mesh-group=%s"%(util.make_interfacename(mesh_group_name_iterator))
        rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('mesh_group_name')):
        raise Exception("'mesh_group_name' cannot be empty")

      #convert keys to list
      mesh_group_name = mapping_dict.get('mesh_group_name')
      if not isinstance(mesh_group_name, list):
        mesh_group_name = [mesh_group_name]

      #prepare payload
      mesh_group_object_list = []
      for mesh_group_name_iterator in mesh_group_name:
        from servicemodel.controller.devices.device import vpls
        mesh_group_object = vpls.mesh_group.mesh_group()
        mesh_group_object.mesh_group_name = mesh_group_name_iterator
        try:
          if (update == False) or (update == True and str(mapping_dict.get('vpls_id', None)) != ''):
            mesh_group_object.vpls_id = mapping_dict.get('vpls_id', None)
          else:
            mesh_group_object.vpls_id._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('vrf_import', None)) != ''):
            mesh_group_object.vrf_import = mapping_dict.get('vrf_import', None)
          else:
            mesh_group_object.vrf_import._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('vrf_export', None)) != ''):
            mesh_group_object.vrf_export = mapping_dict.get('vrf_export', None)
          else:
            mesh_group_object.vrf_export._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('local_switching', None)) != ''):
            mesh_group_object.local_switching = mapping_dict.get('local_switching', None)
          else:
            mesh_group_object.local_switching._empty_tag = True
        except TypeError:
          pass
        mesh_group_object_list.append(mesh_group_object)

      return mesh_group_object_list

    #XPATH devices/device/vpls/mesh-group/associate-profile
    class associate_profile(AbstractDeviceMgr):
      key_hints = [['mesh_group_name']]
      def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

        for associate_profile_object in associate_profile_object_list:
          #fetch payload
          associate_profile_payload = associate_profile_object.getxml(filter=True)
          util.log_debug('associate_profile_payload %s'%associate_profile_payload)
          payload_list.append(associate_profile_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

        for associate_profile_object in associate_profile_object_list:
          #fetch payload
          associate_profile_payload = associate_profile_object.getxml(filter=True)

          util.log_debug('associate_profile_payload %s'%associate_profile_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/associate-profile"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, associate_profile_object in enumerate(associate_profile_object_list):
          #fetch payload
          associate_profile_payload = associate_profile_object.getxml(filter=True)

          util.log_debug('update associate_profile_payload %s'%associate_profile_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/associate-profile"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, mesh_group_mesh_group_name):
        #Parent Key Validations
        if util.isEmpty(mesh_group_mesh_group_name):
          raise Exception("'mesh_group_mesh_group_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('profile_name')):
          raise Exception("'profile_name' cannot be empty")

        #convert keys to list

        #prepare payload
        associate_profile_object_list = []
        from servicemodel.controller.devices.device.vpls import mesh_group
        associate_profile_object = mesh_group.associate_profile.associate_profile()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('profile_name', None)) != ''):
            associate_profile_object.profile_name = mapping_dict.get('profile_name', None)
          else:
            associate_profile_object.profile_name._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('profile_variable_set', None)) != ''):
            associate_profile_object.profile_variable_set = mapping_dict.get('profile_variable_set', None)
          else:
            associate_profile_object.profile_variable_set._empty_tag = True
        except TypeError:
          pass
        associate_profile_object_list.append(associate_profile_object)

        return associate_profile_object_list

    #XPATH devices/device/vpls/mesh-group/peer-as
    class peer_as(AbstractDeviceMgr):
      key_hints = [['mesh_group_name']]
      def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        peer_as_object_list = self.validate_inputs_form_payload(mapping_dict)

        for peer_as_object in peer_as_object_list:
          #fetch payload
          peer_as_payload = peer_as_object.getxml(filter=True)
          util.log_debug('peer_as_payload %s'%peer_as_payload)
          payload_list.append(peer_as_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        peer_as_object_list = self.validate_inputs_form_payload(mapping_dict)

        for peer_as_object in peer_as_object_list:
          #fetch payload
          peer_as_payload = peer_as_object.getxml(filter=True)

          util.log_debug('peer_as_payload %s'%peer_as_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=peer_as_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        peer_as_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/peer-as"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, peer_as_object in enumerate(peer_as_object_list):
          #fetch payload
          peer_as_payload = peer_as_object.getxml(filter=True)

          util.log_debug('update peer_as_payload %s'%peer_as_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=peer_as_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/peer-as"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, mesh_group_mesh_group_name):
        #Parent Key Validations
        if util.isEmpty(mesh_group_mesh_group_name):
          raise Exception("'mesh_group_mesh_group_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        peer_as_object_list = []
        from servicemodel.controller.devices.device.vpls import mesh_group
        peer_as_object = mesh_group.peer_as.peer_as()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('all', None)) != ''):
            peer_as_object.all = mapping_dict.get('all', None)
          else:
            peer_as_object.all._empty_tag = True
        except TypeError:
          pass
        peer_as_object_list.append(peer_as_object)

        return peer_as_object_list

    #XPATH devices/device/vpls/mesh-group/vrf-target
    class vrf_target(AbstractDeviceMgr):
      key_hints = [['mesh_group_name']]
      def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_target_object_list = self.validate_inputs_form_payload(mapping_dict)

        for vrf_target_object in vrf_target_object_list:
          #fetch payload
          vrf_target_payload = vrf_target_object.getxml(filter=True)
          util.log_debug('vrf_target_payload %s'%vrf_target_payload)
          payload_list.append(vrf_target_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_target_object_list = self.validate_inputs_form_payload(mapping_dict)

        for vrf_target_object in vrf_target_object_list:
          #fetch payload
          vrf_target_payload = vrf_target_object.getxml(filter=True)

          util.log_debug('vrf_target_payload %s'%vrf_target_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vrf_target_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_target_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/vrf-target"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, vrf_target_object in enumerate(vrf_target_object_list):
          #fetch payload
          vrf_target_payload = vrf_target_object.getxml(filter=True)

          util.log_debug('update vrf_target_payload %s'%vrf_target_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vrf_target_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/vrf-target"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, mesh_group_mesh_group_name):
        #Parent Key Validations
        if util.isEmpty(mesh_group_mesh_group_name):
          raise Exception("'mesh_group_mesh_group_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        vrf_target_object_list = []
        from servicemodel.controller.devices.device.vpls import mesh_group
        vrf_target_object = mesh_group.vrf_target.vrf_target()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
            vrf_target_object.community = mapping_dict.get('community', None)
          else:
            vrf_target_object.community._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('import_', None)) != ''):
            vrf_target_object.import_ = mapping_dict.get('import_', None)
          else:
            vrf_target_object.import_._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('export', None)) != ''):
            vrf_target_object.export = mapping_dict.get('export', None)
          else:
            vrf_target_object.export._empty_tag = True
        except TypeError:
          pass
        vrf_target_object_list.append(vrf_target_object)

        return vrf_target_object_list

    #XPATH devices/device/vpls/mesh-group/mac-flush
    class mac_flush(AbstractDeviceMgr):
      key_hints = [['mesh_group_name']]
      def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mac_flush_object_list = self.validate_inputs_form_payload(mapping_dict)

        for mac_flush_object in mac_flush_object_list:
          #fetch payload
          mac_flush_payload = mac_flush_object.getxml(filter=True)
          util.log_debug('mac_flush_payload %s'%mac_flush_payload)
          payload_list.append(mac_flush_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mac_flush_object_list = self.validate_inputs_form_payload(mapping_dict)

        for mac_flush_object in mac_flush_object_list:
          #fetch payload
          mac_flush_payload = mac_flush_object.getxml(filter=True)

          util.log_debug('mac_flush_payload %s'%mac_flush_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=mac_flush_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mac_flush_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/mac-flush"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, mac_flush_object in enumerate(mac_flush_object_list):
          #fetch payload
          mac_flush_payload = mac_flush_object.getxml(filter=True)

          util.log_debug('update mac_flush_payload %s'%mac_flush_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=mac_flush_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/mac-flush"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, mesh_group_mesh_group_name):
        #Parent Key Validations
        if util.isEmpty(mesh_group_mesh_group_name):
          raise Exception("'mesh_group_mesh_group_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        mac_flush_object_list = []
        from servicemodel.controller.devices.device.vpls import mesh_group
        mac_flush_object = mesh_group.mac_flush.mac_flush()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('any_interface', None)) != ''):
            mac_flush_object.any_interface = mapping_dict.get('any_interface', None)
          else:
            mac_flush_object.any_interface._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('any_spoke', None)) != ''):
            mac_flush_object.any_spoke = mapping_dict.get('any_spoke', None)
          else:
            mac_flush_object.any_spoke._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('propagate', None)) != ''):
            mac_flush_object.propagate = mapping_dict.get('propagate', None)
          else:
            mac_flush_object.propagate._empty_tag = True
        except TypeError:
          pass
        mac_flush_object_list.append(mac_flush_object)

        return mac_flush_object_list

    #XPATH devices/device/vpls/mesh-group/neighbor
    class neighbor(AbstractDeviceMgr):
      key_hints = [['mesh_group_name']]
      def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

        for neighbor_object in neighbor_object_list:
          #fetch payload
          neighbor_payload = neighbor_object.getxml(filter=True)
          util.log_debug('neighbor_payload %s'%neighbor_payload)
          payload_list.append(neighbor_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

        for neighbor_object in neighbor_object_list:
          #fetch payload
          neighbor_payload = neighbor_object.getxml(filter=True)

          util.log_debug('neighbor_payload %s'%neighbor_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        neighbor_id = mapping_dict.get('neighbor_id')
        if not isinstance(neighbor_id, list):
          neighbor_id = [neighbor_id]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for neighbor_id_iterator in neighbor_id:
          rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, neighbor_object in enumerate(neighbor_object_list):
          #fetch payload
          neighbor_payload = neighbor_object.getxml(filter=True)

          util.log_debug('update neighbor_payload %s'%neighbor_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('neighbor_id')):
          raise Exception("'neighbor_id' cannot be empty")

        #convert keys to list
        neighbor_id = mapping_dict.get('neighbor_id')
        if not isinstance(neighbor_id, list):
          neighbor_id = [neighbor_id]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for neighbor_id_iterator in neighbor_id:
          rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, mesh_group_mesh_group_name):
        #Parent Key Validations
        if util.isEmpty(mesh_group_mesh_group_name):
          raise Exception("'mesh_group_mesh_group_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('neighbor_id')):
          raise Exception("'neighbor_id' cannot be empty")

        #convert keys to list
        neighbor_id = mapping_dict.get('neighbor_id')
        if not isinstance(neighbor_id, list):
          neighbor_id = [neighbor_id]

        #prepare payload
        neighbor_object_list = []
        for neighbor_id_iterator in neighbor_id:
          from servicemodel.controller.devices.device.vpls import mesh_group
          neighbor_object = mesh_group.neighbor.neighbor()
          neighbor_object.neighbor_id = neighbor_id_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('psn_tunnel_endpoint', None)) != ''):
              neighbor_object.psn_tunnel_endpoint = mapping_dict.get('psn_tunnel_endpoint', None)
            else:
              neighbor_object.psn_tunnel_endpoint._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
              neighbor_object.community = mapping_dict.get('community', None)
            else:
              neighbor_object.community._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('encapsulation_type', None)) != ''):
              neighbor_object.encapsulation_type = mapping_dict.get('encapsulation_type', None)
            else:
              neighbor_object.encapsulation_type._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ignore_encapsulation_mismatch', None)) != ''):
              neighbor_object.ignore_encapsulation_mismatch = mapping_dict.get('ignore_encapsulation_mismatch', None)
            else:
              neighbor_object.ignore_encapsulation_mismatch._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('pseudowire_status_tlv', None)) != ''):
              neighbor_object.pseudowire_status_tlv = mapping_dict.get('pseudowire_status_tlv', None)
            else:
              neighbor_object.pseudowire_status_tlv._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('switchover_delay', None)) != ''):
              neighbor_object.switchover_delay = mapping_dict.get('switchover_delay', None)
            else:
              neighbor_object.switchover_delay._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('revert_time', None)) != ''):
              neighbor_object.revert_time = mapping_dict.get('revert_time', None)
            else:
              neighbor_object.revert_time._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('connection_protection', None)) != ''):
              neighbor_object.connection_protection = mapping_dict.get('connection_protection', None)
            else:
              neighbor_object.connection_protection._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('vpls_id_list', None)) != ''):
              neighbor_object.vpls_id_list = mapping_dict.get('vpls_id_list', None)
            else:
              neighbor_object.vpls_id_list._empty_tag = True
          except TypeError:
            pass
          neighbor_object_list.append(neighbor_object)

        return neighbor_object_list

      #XPATH devices/device/vpls/mesh-group/neighbor/static
      class static(AbstractDeviceMgr):
        key_hints = [['mesh_group_name'],['neighbor_id']]
        def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_object in static_object_list:
            #fetch payload
            static_payload = static_object.getxml(filter=True)
            util.log_debug('static_payload %s'%static_payload)
            payload_list.append(static_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_object in static_object_list:
            #fetch payload
            static_payload = static_object.getxml(filter=True)

            util.log_debug('static_payload %s'%static_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/static"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, static_object in enumerate(static_object_list):
            #fetch payload
            static_payload = static_object.getxml(filter=True)

            util.log_debug('update static_payload %s'%static_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/static"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
          #Parent Key Validations
          if util.isEmpty(mesh_group_mesh_group_name):
            raise Exception("'mesh_group_mesh_group_name' cannot be empty")
          if util.isEmpty(neighbor_neighbor_id):
            raise Exception("'neighbor_neighbor_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('incoming_label')):
            raise Exception("'incoming_label' cannot be empty")
          if util.isEmpty(mapping_dict.get('outgoing_label')):
            raise Exception("'outgoing_label' cannot be empty")

          #convert keys to list

          #prepare payload
          static_object_list = []
          from servicemodel.controller.devices.device.vpls.mesh_group import neighbor
          static_object = neighbor.static.static()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('incoming_label', None)) != ''):
              static_object.incoming_label = mapping_dict.get('incoming_label', None)
            else:
              static_object.incoming_label._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('outgoing_label', None)) != ''):
              static_object.outgoing_label = mapping_dict.get('outgoing_label', None)
            else:
              static_object.outgoing_label._empty_tag = True
          except TypeError:
            pass
          static_object_list.append(static_object)

          return static_object_list

      #XPATH devices/device/vpls/mesh-group/neighbor/associate-profile
      class associate_profile(AbstractDeviceMgr):
        key_hints = [['mesh_group_name'],['neighbor_id']]
        def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

          for associate_profile_object in associate_profile_object_list:
            #fetch payload
            associate_profile_payload = associate_profile_object.getxml(filter=True)
            util.log_debug('associate_profile_payload %s'%associate_profile_payload)
            payload_list.append(associate_profile_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict)

          for associate_profile_object in associate_profile_object_list:
            #fetch payload
            associate_profile_payload = associate_profile_object.getxml(filter=True)

            util.log_debug('associate_profile_payload %s'%associate_profile_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          associate_profile_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/associate-profile"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, associate_profile_object in enumerate(associate_profile_object_list):
            #fetch payload
            associate_profile_payload = associate_profile_object.getxml(filter=True)

            util.log_debug('update associate_profile_payload %s'%associate_profile_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=associate_profile_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/associate-profile"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
          #Parent Key Validations
          if util.isEmpty(mesh_group_mesh_group_name):
            raise Exception("'mesh_group_mesh_group_name' cannot be empty")
          if util.isEmpty(neighbor_neighbor_id):
            raise Exception("'neighbor_neighbor_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('profile_name')):
            raise Exception("'profile_name' cannot be empty")

          #convert keys to list

          #prepare payload
          associate_profile_object_list = []
          from servicemodel.controller.devices.device.vpls.mesh_group import neighbor
          associate_profile_object = neighbor.associate_profile.associate_profile()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('profile_name', None)) != ''):
              associate_profile_object.profile_name = mapping_dict.get('profile_name', None)
            else:
              associate_profile_object.profile_name._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('profile_variable_set', None)) != ''):
              associate_profile_object.profile_variable_set = mapping_dict.get('profile_variable_set', None)
            else:
              associate_profile_object.profile_variable_set._empty_tag = True
          except TypeError:
            pass
          associate_profile_object_list.append(associate_profile_object)

          return associate_profile_object_list

      #XPATH devices/device/vpls/mesh-group/neighbor/backup-neighbor
      class backup_neighbor(AbstractDeviceMgr):
        key_hints = [['mesh_group_name'],['neighbor_id']]
        def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          backup_neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

          for backup_neighbor_object in backup_neighbor_object_list:
            #fetch payload
            backup_neighbor_payload = backup_neighbor_object.getxml(filter=True)
            util.log_debug('backup_neighbor_payload %s'%backup_neighbor_payload)
            payload_list.append(backup_neighbor_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          backup_neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

          for backup_neighbor_object in backup_neighbor_object_list:
            #fetch payload
            backup_neighbor_payload = backup_neighbor_object.getxml(filter=True)

            util.log_debug('backup_neighbor_payload %s'%backup_neighbor_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=backup_neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          backup_neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          neighbor_id = mapping_dict.get('neighbor_id')
          if not isinstance(neighbor_id, list):
            neighbor_id = [neighbor_id]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for neighbor_id_iterator in neighbor_id:
            rcpath_tmp =  rcpath+"/backup-neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, backup_neighbor_object in enumerate(backup_neighbor_object_list):
            #fetch payload
            backup_neighbor_payload = backup_neighbor_object.getxml(filter=True)

            util.log_debug('update backup_neighbor_payload %s'%backup_neighbor_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=backup_neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('neighbor_id')):
            raise Exception("'neighbor_id' cannot be empty")

          #convert keys to list
          neighbor_id = mapping_dict.get('neighbor_id')
          if not isinstance(neighbor_id, list):
            neighbor_id = [neighbor_id]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for neighbor_id_iterator in neighbor_id:
            rcpath_tmp =  rcpath+"/backup-neighbor=%s"%(util.make_interfacename(neighbor_id_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
          #Parent Key Validations
          if util.isEmpty(mesh_group_mesh_group_name):
            raise Exception("'mesh_group_mesh_group_name' cannot be empty")
          if util.isEmpty(neighbor_neighbor_id):
            raise Exception("'neighbor_neighbor_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('neighbor_id')):
            raise Exception("'neighbor_id' cannot be empty")

          #convert keys to list
          neighbor_id = mapping_dict.get('neighbor_id')
          if not isinstance(neighbor_id, list):
            neighbor_id = [neighbor_id]

          #prepare payload
          backup_neighbor_object_list = []
          for neighbor_id_iterator in neighbor_id:
            from servicemodel.controller.devices.device.vpls.mesh_group import neighbor
            backup_neighbor_object = neighbor.backup_neighbor.backup_neighbor()
            backup_neighbor_object.neighbor_id = neighbor_id_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
                backup_neighbor_object.community = mapping_dict.get('community', None)
              else:
                backup_neighbor_object.community._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('psn_tunnel_endpoint', None)) != ''):
                backup_neighbor_object.psn_tunnel_endpoint = mapping_dict.get('psn_tunnel_endpoint', None)
              else:
                backup_neighbor_object.psn_tunnel_endpoint._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('standby', None)) != ''):
                backup_neighbor_object.standby = mapping_dict.get('standby', None)
              else:
                backup_neighbor_object.standby._empty_tag = True
            except TypeError:
              pass
            backup_neighbor_object_list.append(backup_neighbor_object)

          return backup_neighbor_object_list

        #XPATH devices/device/vpls/mesh-group/neighbor/backup-neighbor/static
        class static(AbstractDeviceMgr):
          key_hints = [['mesh_group_name'],['neighbor_id'],['neighbor_id']]
          def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(mesh_group_mesh_group_name, list):
              mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
            else:
              mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id
            if not isinstance(backup_neighbor_neighbor_id, list):
              backup_neighbor_neighbor_id_list = [backup_neighbor_neighbor_id]
            else:
              backup_neighbor_neighbor_id_list = backup_neighbor_neighbor_id

            for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
              for neighbor_neighbor_id in neighbor_neighbor_id_list:
                for backup_neighbor_neighbor_id in backup_neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
                  rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            static_object_list = self.validate_inputs_form_payload(mapping_dict)

            for static_object in static_object_list:
              #fetch payload
              static_payload = static_object.getxml(filter=True)
              util.log_debug('static_payload %s'%static_payload)
              payload_list.append(static_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id)

            #convert parent keys to list
            if not isinstance(mesh_group_mesh_group_name, list):
              mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
            else:
              mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id
            if not isinstance(backup_neighbor_neighbor_id, list):
              backup_neighbor_neighbor_id_list = [backup_neighbor_neighbor_id]
            else:
              backup_neighbor_neighbor_id_list = backup_neighbor_neighbor_id

            for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
              for neighbor_neighbor_id in neighbor_neighbor_id_list:
                for backup_neighbor_neighbor_id in backup_neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            static_object_list = self.validate_inputs_form_payload(mapping_dict)

            for static_object in static_object_list:
              #fetch payload
              static_payload = static_object.getxml(filter=True)

              util.log_debug('static_payload %s'%static_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id)


            ##prepare rcpath
            rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            static_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/static"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, static_object in enumerate(static_object_list):
              #fetch payload
              static_payload = static_object.getxml(filter=True)

              util.log_debug('update static_payload %s'%static_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id)


            if not isinstance(mesh_group_mesh_group_name, list):
              mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
            else:
              mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id
            if not isinstance(backup_neighbor_neighbor_id, list):
              backup_neighbor_neighbor_id_list = [backup_neighbor_neighbor_id]
            else:
              backup_neighbor_neighbor_id_list = backup_neighbor_neighbor_id

            for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
              for neighbor_neighbor_id in neighbor_neighbor_id_list:
                for backup_neighbor_neighbor_id in backup_neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/backup-neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id),util.make_interfacename(backup_neighbor_neighbor_id))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/static"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id, backup_neighbor_neighbor_id):
            #Parent Key Validations
            if util.isEmpty(mesh_group_mesh_group_name):
              raise Exception("'mesh_group_mesh_group_name' cannot be empty")
            if util.isEmpty(neighbor_neighbor_id):
              raise Exception("'neighbor_neighbor_id' cannot be empty")
            if util.isEmpty(backup_neighbor_neighbor_id):
              raise Exception("'backup_neighbor_neighbor_id' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('incoming_label')):
              raise Exception("'incoming_label' cannot be empty")
            if util.isEmpty(mapping_dict.get('outgoing_label')):
              raise Exception("'outgoing_label' cannot be empty")

            #convert keys to list

            #prepare payload
            static_object_list = []
            from servicemodel.controller.devices.device.vpls.mesh_group.neighbor import backup_neighbor
            static_object = backup_neighbor.static.static()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('incoming_label', None)) != ''):
                static_object.incoming_label = mapping_dict.get('incoming_label', None)
              else:
                static_object.incoming_label._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('outgoing_label', None)) != ''):
                static_object.outgoing_label = mapping_dict.get('outgoing_label', None)
              else:
                static_object.outgoing_label._empty_tag = True
            except TypeError:
              pass
            static_object_list.append(static_object)

            return static_object_list

      #XPATH devices/device/vpls/mesh-group/neighbor/oam
      class oam(AbstractDeviceMgr):
        key_hints = [['mesh_group_name'],['neighbor_id']]
        def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          oam_object_list = self.validate_inputs_form_payload(mapping_dict)

          for oam_object in oam_object_list:
            #fetch payload
            oam_payload = oam_object.getxml(filter=True)
            util.log_debug('oam_payload %s'%oam_payload)
            payload_list.append(oam_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

          #convert parent keys to list
          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          oam_object_list = self.validate_inputs_form_payload(mapping_dict)

          for oam_object in oam_object_list:
            #fetch payload
            oam_payload = oam_object.getxml(filter=True)

            util.log_debug('oam_payload %s'%oam_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          oam_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/oam"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, oam_object in enumerate(oam_object_list):
            #fetch payload
            oam_payload = oam_object.getxml(filter=True)

            util.log_debug('update oam_payload %s'%oam_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


          if not isinstance(mesh_group_mesh_group_name, list):
            mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
          else:
            mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
          if not isinstance(neighbor_neighbor_id, list):
            neighbor_neighbor_id_list = [neighbor_neighbor_id]
          else:
            neighbor_neighbor_id_list = neighbor_neighbor_id

          for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
            for neighbor_neighbor_id in neighbor_neighbor_id_list:
              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/oam"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
          #Parent Key Validations
          if util.isEmpty(mesh_group_mesh_group_name):
            raise Exception("'mesh_group_mesh_group_name' cannot be empty")
          if util.isEmpty(neighbor_neighbor_id):
            raise Exception("'neighbor_neighbor_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          oam_object_list = []
          from servicemodel.controller.devices.device.vpls.mesh_group import neighbor
          oam_object = neighbor.oam.oam()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ping_interval', None)) != ''):
              oam_object.ping_interval = mapping_dict.get('ping_interval', None)
            else:
              oam_object.ping_interval._empty_tag = True
          except TypeError:
            pass
          oam_object_list.append(oam_object)

          return oam_object_list

        #XPATH devices/device/vpls/mesh-group/neighbor/oam/bfd-liveness-detection
        class bfd_liveness_detection(AbstractDeviceMgr):
          key_hints = [['mesh_group_name'],['neighbor_id']]
          def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(mesh_group_mesh_group_name, list):
              mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
            else:
              mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
              for neighbor_neighbor_id in neighbor_neighbor_id_list:
                ##prepare rcpath
                rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

            for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
              #fetch payload
              bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)
              util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)
              payload_list.append(bfd_liveness_detection_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

            #convert parent keys to list
            if not isinstance(mesh_group_mesh_group_name, list):
              mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
            else:
              mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
              for neighbor_neighbor_id in neighbor_neighbor_id_list:
                ##prepare rcpath
                rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

            for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
              #fetch payload
              bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

              util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


            ##prepare rcpath
            rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/bfd-liveness-detection"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, bfd_liveness_detection_object in enumerate(bfd_liveness_detection_object_list):
              #fetch payload
              bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

              util.log_debug('update bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


            if not isinstance(mesh_group_mesh_group_name, list):
              mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
            else:
              mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
            if not isinstance(neighbor_neighbor_id, list):
              neighbor_neighbor_id_list = [neighbor_neighbor_id]
            else:
              neighbor_neighbor_id_list = neighbor_neighbor_id

            for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
              for neighbor_neighbor_id in neighbor_neighbor_id_list:
                ##prepare rcpath
                rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/bfd-liveness-detection"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
            #Parent Key Validations
            if util.isEmpty(mesh_group_mesh_group_name):
              raise Exception("'mesh_group_mesh_group_name' cannot be empty")
            if util.isEmpty(neighbor_neighbor_id):
              raise Exception("'neighbor_neighbor_id' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            bfd_liveness_detection_object_list = []
            from servicemodel.controller.devices.device.vpls.mesh_group.neighbor import oam
            bfd_liveness_detection_object = oam.bfd_liveness_detection.bfd_liveness_detection()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('version', None)) != ''):
                bfd_liveness_detection_object.version = mapping_dict.get('version', None)
              else:
                bfd_liveness_detection_object.version._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                bfd_liveness_detection_object.minimum_interval = mapping_dict.get('minimum_interval', None)
              else:
                bfd_liveness_detection_object.minimum_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('minimum_receive_interval', None)) != ''):
                bfd_liveness_detection_object.minimum_receive_interval = mapping_dict.get('minimum_receive_interval', None)
              else:
                bfd_liveness_detection_object.minimum_receive_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('multiplier', None)) != ''):
                bfd_liveness_detection_object.multiplier = mapping_dict.get('multiplier', None)
              else:
                bfd_liveness_detection_object.multiplier._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('no_adaptation', None)) != ''):
                bfd_liveness_detection_object.no_adaptation = mapping_dict.get('no_adaptation', None)
              else:
                bfd_liveness_detection_object.no_adaptation._empty_tag = True
            except TypeError:
              pass
            bfd_liveness_detection_object_list.append(bfd_liveness_detection_object)

            return bfd_liveness_detection_object_list

          #XPATH devices/device/vpls/mesh-group/neighbor/oam/bfd-liveness-detection/transmit-interval
          class transmit_interval(AbstractDeviceMgr):
            key_hints = [['mesh_group_name'],['neighbor_id']]
            def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(mesh_group_mesh_group_name, list):
                mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
              else:
                mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
              if not isinstance(neighbor_neighbor_id, list):
                neighbor_neighbor_id_list = [neighbor_neighbor_id]
              else:
                neighbor_neighbor_id_list = neighbor_neighbor_id

              for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
                for neighbor_neighbor_id in neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                  rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

              for transmit_interval_object in transmit_interval_object_list:
                #fetch payload
                transmit_interval_payload = transmit_interval_object.getxml(filter=True)
                util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)
                payload_list.append(transmit_interval_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

              #convert parent keys to list
              if not isinstance(mesh_group_mesh_group_name, list):
                mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
              else:
                mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
              if not isinstance(neighbor_neighbor_id, list):
                neighbor_neighbor_id_list = [neighbor_neighbor_id]
              else:
                neighbor_neighbor_id_list = neighbor_neighbor_id

              for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
                for neighbor_neighbor_id in neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

              for transmit_interval_object in transmit_interval_object_list:
                #fetch payload
                transmit_interval_payload = transmit_interval_object.getxml(filter=True)

                util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/transmit-interval"
              rcpath_list.append(rcpath_tmp)
              for rc_counter, transmit_interval_object in enumerate(transmit_interval_object_list):
                #fetch payload
                transmit_interval_payload = transmit_interval_object.getxml(filter=True)

                util.log_debug('update transmit_interval_payload %s'%transmit_interval_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


              if not isinstance(mesh_group_mesh_group_name, list):
                mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
              else:
                mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
              if not isinstance(neighbor_neighbor_id, list):
                neighbor_neighbor_id_list = [neighbor_neighbor_id]
              else:
                neighbor_neighbor_id_list = neighbor_neighbor_id

              for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
                for neighbor_neighbor_id in neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/transmit-interval"
              rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
              #Parent Key Validations
              if util.isEmpty(mesh_group_mesh_group_name):
                raise Exception("'mesh_group_mesh_group_name' cannot be empty")
              if util.isEmpty(neighbor_neighbor_id):
                raise Exception("'neighbor_neighbor_id' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs

              #convert keys to list

              #prepare payload
              transmit_interval_object_list = []
              from servicemodel.controller.devices.device.vpls.mesh_group.neighbor.oam import bfd_liveness_detection
              transmit_interval_object = bfd_liveness_detection.transmit_interval.transmit_interval()
              try:
                if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
                  transmit_interval_object.minimum_interval = mapping_dict.get('minimum_interval', None)
                else:
                  transmit_interval_object.minimum_interval._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                  transmit_interval_object.threshold = mapping_dict.get('threshold', None)
                else:
                  transmit_interval_object.threshold._empty_tag = True
              except TypeError:
                pass
              transmit_interval_object_list.append(transmit_interval_object)

              return transmit_interval_object_list

          #XPATH devices/device/vpls/mesh-group/neighbor/oam/bfd-liveness-detection/detection-time
          class detection_time(AbstractDeviceMgr):
            key_hints = [['mesh_group_name'],['neighbor_id']]
            def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(mesh_group_mesh_group_name, list):
                mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
              else:
                mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
              if not isinstance(neighbor_neighbor_id, list):
                neighbor_neighbor_id_list = [neighbor_neighbor_id]
              else:
                neighbor_neighbor_id_list = neighbor_neighbor_id

              for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
                for neighbor_neighbor_id in neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                  rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

              for detection_time_object in detection_time_object_list:
                #fetch payload
                detection_time_payload = detection_time_object.getxml(filter=True)
                util.log_debug('detection_time_payload %s'%detection_time_payload)
                payload_list.append(detection_time_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)

              #convert parent keys to list
              if not isinstance(mesh_group_mesh_group_name, list):
                mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
              else:
                mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
              if not isinstance(neighbor_neighbor_id, list):
                neighbor_neighbor_id_list = [neighbor_neighbor_id]
              else:
                neighbor_neighbor_id_list = neighbor_neighbor_id

              for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
                for neighbor_neighbor_id in neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

              for detection_time_object in detection_time_object_list:
                #fetch payload
                detection_time_payload = detection_time_object.getxml(filter=True)

                util.log_debug('detection_time_payload %s'%detection_time_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


              ##prepare rcpath
              rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              detection_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/detection-time"
              rcpath_list.append(rcpath_tmp)
              for rc_counter, detection_time_object in enumerate(detection_time_object_list):
                #fetch payload
                detection_time_payload = detection_time_object.getxml(filter=True)

                util.log_debug('update detection_time_payload %s'%detection_time_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, mesh_group_mesh_group_name, neighbor_neighbor_id, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( mesh_group_mesh_group_name, neighbor_neighbor_id)


              if not isinstance(mesh_group_mesh_group_name, list):
                mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
              else:
                mesh_group_mesh_group_name_list = mesh_group_mesh_group_name
              if not isinstance(neighbor_neighbor_id, list):
                neighbor_neighbor_id_list = [neighbor_neighbor_id]
              else:
                neighbor_neighbor_id_list = neighbor_neighbor_id

              for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
                for neighbor_neighbor_id in neighbor_neighbor_id_list:
                  ##prepare rcpath
                  rcpath = "vpls:vpls/mesh-group=%s/neighbor=%s/oam/bfd-liveness-detection"%(util.make_interfacename(mesh_group_mesh_group_name),util.make_interfacename(neighbor_neighbor_id))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs

              #convert keys to list

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              rcpath_tmp =  rcpath+"/detection-time"
              rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, mesh_group_mesh_group_name, neighbor_neighbor_id):
              #Parent Key Validations
              if util.isEmpty(mesh_group_mesh_group_name):
                raise Exception("'mesh_group_mesh_group_name' cannot be empty")
              if util.isEmpty(neighbor_neighbor_id):
                raise Exception("'neighbor_neighbor_id' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs

              #convert keys to list

              #prepare payload
              detection_time_object_list = []
              from servicemodel.controller.devices.device.vpls.mesh_group.neighbor.oam import bfd_liveness_detection
              detection_time_object = bfd_liveness_detection.detection_time.detection_time()
              try:
                if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
                  detection_time_object.threshold = mapping_dict.get('threshold', None)
                else:
                  detection_time_object.threshold._empty_tag = True
              except TypeError:
                pass
              detection_time_object_list.append(detection_time_object)

              return detection_time_object_list

    #XPATH devices/device/vpls/mesh-group/route-distinguisher
    class route_distinguisher(AbstractDeviceMgr):
      key_hints = [['mesh_group_name']]
      def getRcpathPayload(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        route_distinguisher_object_list = self.validate_inputs_form_payload(mapping_dict)

        for route_distinguisher_object in route_distinguisher_object_list:
          #fetch payload
          route_distinguisher_payload = route_distinguisher_object.getxml(filter=True)
          util.log_debug('route_distinguisher_payload %s'%route_distinguisher_payload)
          payload_list.append(route_distinguisher_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)

        #convert parent keys to list
        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        route_distinguisher_object_list = self.validate_inputs_form_payload(mapping_dict)

        for route_distinguisher_object in route_distinguisher_object_list:
          #fetch payload
          route_distinguisher_payload = route_distinguisher_object.getxml(filter=True)

          util.log_debug('route_distinguisher_payload %s'%route_distinguisher_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=route_distinguisher_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        ##prepare rcpath
        rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        route_distinguisher_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/route-distinguisher"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, route_distinguisher_object in enumerate(route_distinguisher_object_list):
          #fetch payload
          route_distinguisher_payload = route_distinguisher_object.getxml(filter=True)

          util.log_debug('update route_distinguisher_payload %s'%route_distinguisher_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=route_distinguisher_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mesh_group_mesh_group_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( mesh_group_mesh_group_name)


        if not isinstance(mesh_group_mesh_group_name, list):
          mesh_group_mesh_group_name_list = [mesh_group_mesh_group_name]
        else:
          mesh_group_mesh_group_name_list = mesh_group_mesh_group_name

        for mesh_group_mesh_group_name in mesh_group_mesh_group_name_list:
          ##prepare rcpath
          rcpath = "vpls:vpls/mesh-group=%s"%(util.make_interfacename(mesh_group_mesh_group_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/route-distinguisher"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, mesh_group_mesh_group_name):
        #Parent Key Validations
        if util.isEmpty(mesh_group_mesh_group_name):
          raise Exception("'mesh_group_mesh_group_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        route_distinguisher_object_list = []
        from servicemodel.controller.devices.device.vpls import mesh_group
        route_distinguisher_object = mesh_group.route_distinguisher.route_distinguisher()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('rd_type', None)) != ''):
            route_distinguisher_object.rd_type = mapping_dict.get('rd_type', None)
          else:
            route_distinguisher_object.rd_type._empty_tag = True
        except TypeError:
          pass
        route_distinguisher_object_list.append(route_distinguisher_object)

        return route_distinguisher_object_list

  #XPATH devices/device/vpls/oam
  class oam(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      oam_object_list = self.validate_inputs_form_payload(mapping_dict)

      for oam_object in oam_object_list:
        #fetch payload
        oam_payload = oam_object.getxml(filter=True)
        util.log_debug('oam_payload %s'%oam_payload)
        payload_list.append(oam_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      oam_object_list = self.validate_inputs_form_payload(mapping_dict)

      for oam_object in oam_object_list:
        #fetch payload
        oam_payload = oam_object.getxml(filter=True)

        util.log_debug('oam_payload %s'%oam_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      oam_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/oam"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, oam_object in enumerate(oam_object_list):
        #fetch payload
        oam_payload = oam_object.getxml(filter=True)

        util.log_debug('update oam_payload %s'%oam_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=oam_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/oam"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs

      #convert keys to list

      #prepare payload
      oam_object_list = []
      from servicemodel.controller.devices.device import vpls
      oam_object = vpls.oam.oam()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('ping_interval', None)) != ''):
          oam_object.ping_interval = mapping_dict.get('ping_interval', None)
        else:
          oam_object.ping_interval._empty_tag = True
      except TypeError:
        pass
      oam_object_list.append(oam_object)

      return oam_object_list

    #XPATH devices/device/vpls/oam/bfd-liveness-detection
    class bfd_liveness_detection(AbstractDeviceMgr):
      key_hints = [[]]
      def getRcpathPayload(self, sdata, dev, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

        for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
          #fetch payload
          bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)
          util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)
          payload_list.append(bfd_liveness_detection_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #convert parent keys to list
        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict)

        for bfd_liveness_detection_object in bfd_liveness_detection_object_list:
          #fetch payload
          bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

          util.log_debug('bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return

        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        bfd_liveness_detection_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/bfd-liveness-detection"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, bfd_liveness_detection_object in enumerate(bfd_liveness_detection_object_list):
          #fetch payload
          bfd_liveness_detection_payload = bfd_liveness_detection_object.getxml(filter=True)

          util.log_debug('update bfd_liveness_detection_payload %s'%bfd_liveness_detection_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bfd_liveness_detection_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return

        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/bfd-liveness-detection"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        bfd_liveness_detection_object_list = []
        from servicemodel.controller.devices.device.vpls import oam
        bfd_liveness_detection_object = oam.bfd_liveness_detection.bfd_liveness_detection()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('version', None)) != ''):
            bfd_liveness_detection_object.version = mapping_dict.get('version', None)
          else:
            bfd_liveness_detection_object.version._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
            bfd_liveness_detection_object.minimum_interval = mapping_dict.get('minimum_interval', None)
          else:
            bfd_liveness_detection_object.minimum_interval._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('minimum_receive_interval', None)) != ''):
            bfd_liveness_detection_object.minimum_receive_interval = mapping_dict.get('minimum_receive_interval', None)
          else:
            bfd_liveness_detection_object.minimum_receive_interval._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('multiplier', None)) != ''):
            bfd_liveness_detection_object.multiplier = mapping_dict.get('multiplier', None)
          else:
            bfd_liveness_detection_object.multiplier._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('no_adaptation', None)) != ''):
            bfd_liveness_detection_object.no_adaptation = mapping_dict.get('no_adaptation', None)
          else:
            bfd_liveness_detection_object.no_adaptation._empty_tag = True
        except TypeError:
          pass
        bfd_liveness_detection_object_list.append(bfd_liveness_detection_object)

        return bfd_liveness_detection_object_list

      #XPATH devices/device/vpls/oam/bfd-liveness-detection/transmit-interval
      class transmit_interval(AbstractDeviceMgr):
        key_hints = [[]]
        def getRcpathPayload(self, sdata, dev, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

          for transmit_interval_object in transmit_interval_object_list:
            #fetch payload
            transmit_interval_payload = transmit_interval_object.getxml(filter=True)
            util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)
            payload_list.append(transmit_interval_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #convert parent keys to list
          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict)

          for transmit_interval_object in transmit_interval_object_list:
            #fetch payload
            transmit_interval_payload = transmit_interval_object.getxml(filter=True)

            util.log_debug('transmit_interval_payload %s'%transmit_interval_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return

          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          transmit_interval_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/transmit-interval"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, transmit_interval_object in enumerate(transmit_interval_object_list):
            #fetch payload
            transmit_interval_payload = transmit_interval_object.getxml(filter=True)

            util.log_debug('update transmit_interval_payload %s'%transmit_interval_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=transmit_interval_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return

          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/transmit-interval"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          transmit_interval_object_list = []
          from servicemodel.controller.devices.device.vpls.oam import bfd_liveness_detection
          transmit_interval_object = bfd_liveness_detection.transmit_interval.transmit_interval()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('minimum_interval', None)) != ''):
              transmit_interval_object.minimum_interval = mapping_dict.get('minimum_interval', None)
            else:
              transmit_interval_object.minimum_interval._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
              transmit_interval_object.threshold = mapping_dict.get('threshold', None)
            else:
              transmit_interval_object.threshold._empty_tag = True
          except TypeError:
            pass
          transmit_interval_object_list.append(transmit_interval_object)

          return transmit_interval_object_list

      #XPATH devices/device/vpls/oam/bfd-liveness-detection/detection-time
      class detection_time(AbstractDeviceMgr):
        key_hints = [[]]
        def getRcpathPayload(self, sdata, dev, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

          for detection_time_object in detection_time_object_list:
            #fetch payload
            detection_time_payload = detection_time_object.getxml(filter=True)
            util.log_debug('detection_time_payload %s'%detection_time_payload)
            payload_list.append(detection_time_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #convert parent keys to list
          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          detection_time_object_list = self.validate_inputs_form_payload(mapping_dict)

          for detection_time_object in detection_time_object_list:
            #fetch payload
            detection_time_payload = detection_time_object.getxml(filter=True)

            util.log_debug('detection_time_payload %s'%detection_time_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return

          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          detection_time_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/detection-time"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, detection_time_object in enumerate(detection_time_object_list):
            #fetch payload
            detection_time_payload = detection_time_object.getxml(filter=True)

            util.log_debug('update detection_time_payload %s'%detection_time_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=detection_time_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return

          ##prepare rcpath
          rcpath = "vpls:vpls/oam/bfd-liveness-detection"
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/detection-time"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          detection_time_object_list = []
          from servicemodel.controller.devices.device.vpls.oam import bfd_liveness_detection
          detection_time_object = bfd_liveness_detection.detection_time.detection_time()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('threshold', None)) != ''):
              detection_time_object.threshold = mapping_dict.get('threshold', None)
            else:
              detection_time_object.threshold._empty_tag = True
          except TypeError:
            pass
          detection_time_object_list.append(detection_time_object)

          return detection_time_object_list

    #XPATH devices/device/vpls/oam/control-channel
    class control_channel(AbstractDeviceMgr):
      key_hints = [[]]
      def getRcpathPayload(self, sdata, dev, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        control_channel_object_list = self.validate_inputs_form_payload(mapping_dict)

        for control_channel_object in control_channel_object_list:
          #fetch payload
          control_channel_payload = control_channel_object.getxml(filter=True)
          util.log_debug('control_channel_payload %s'%control_channel_payload)
          payload_list.append(control_channel_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #convert parent keys to list
        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        control_channel_object_list = self.validate_inputs_form_payload(mapping_dict)

        for control_channel_object in control_channel_object_list:
          #fetch payload
          control_channel_payload = control_channel_object.getxml(filter=True)

          util.log_debug('control_channel_payload %s'%control_channel_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=control_channel_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return

        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        control_channel_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/control-channel"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, control_channel_object in enumerate(control_channel_object_list):
          #fetch payload
          control_channel_payload = control_channel_object.getxml(filter=True)

          util.log_debug('update control_channel_payload %s'%control_channel_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=control_channel_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return

        ##prepare rcpath
        rcpath = "vpls:vpls/oam"
        self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/control-channel"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        control_channel_object_list = []
        from servicemodel.controller.devices.device.vpls import oam
        control_channel_object = oam.control_channel.control_channel()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('pwe3_control_word', None)) != ''):
            control_channel_object.pwe3_control_word = mapping_dict.get('pwe3_control_word', None)
          else:
            control_channel_object.pwe3_control_word._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('router_alert_label', None)) != ''):
            control_channel_object.router_alert_label = mapping_dict.get('router_alert_label', None)
          else:
            control_channel_object.router_alert_label._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('pw_label_ttl_1', None)) != ''):
            control_channel_object.pw_label_ttl_1 = mapping_dict.get('pw_label_ttl_1', None)
          else:
            control_channel_object.pw_label_ttl_1._empty_tag = True
        except TypeError:
          pass
        control_channel_object_list.append(control_channel_object)

        return control_channel_object_list

  #XPATH devices/device/vpls/multi-homing
  class multi_homing(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "vpls:vpls"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      multi_homing_object_list = self.validate_inputs_form_payload(mapping_dict)

      for multi_homing_object in multi_homing_object_list:
        #fetch payload
        multi_homing_payload = multi_homing_object.getxml(filter=True)
        util.log_debug('multi_homing_payload %s'%multi_homing_payload)
        payload_list.append(multi_homing_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      multi_homing_object_list = self.validate_inputs_form_payload(mapping_dict)

      for multi_homing_object in multi_homing_object_list:
        #fetch payload
        multi_homing_payload = multi_homing_object.getxml(filter=True)

        util.log_debug('multi_homing_payload %s'%multi_homing_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=multi_homing_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      multi_homing_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/multi-homing"
      rcpath_list.append(rcpath_tmp)
      for rc_counter, multi_homing_object in enumerate(multi_homing_object_list):
        #fetch payload
        multi_homing_payload = multi_homing_object.getxml(filter=True)

        util.log_debug('update multi_homing_payload %s'%multi_homing_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=multi_homing_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "vpls:vpls"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs

      #convert keys to list

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      rcpath_tmp =  rcpath+"/multi-homing"
      rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs

      #convert keys to list

      #prepare payload
      multi_homing_object_list = []
      from servicemodel.controller.devices.device import vpls
      multi_homing_object = vpls.multi_homing.multi_homing()
      try:
        if (update == False) or (update == True and str(mapping_dict.get('peer_active', None)) != ''):
          multi_homing_object.peer_active = mapping_dict.get('peer_active', None)
        else:
          multi_homing_object.peer_active._empty_tag = True
      except TypeError:
        pass
      multi_homing_object_list.append(multi_homing_object)

      return multi_homing_object_list

    #XPATH devices/device/vpls/multi-homing/site
    class site(AbstractDeviceMgr):
      key_hints = [[]]
      def getRcpathPayload(self, sdata, dev, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        ##prepare rcpath
        rcpath = "vpls:vpls/multi-homing"
        rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        site_object_list = self.validate_inputs_form_payload(mapping_dict)

        for site_object in site_object_list:
          #fetch payload
          site_payload = site_object.getxml(filter=True)
          util.log_debug('site_payload %s'%site_payload)
          payload_list.append(site_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #convert parent keys to list
        ##prepare rcpath
        rcpath = "vpls:vpls/multi-homing"
        self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        site_object_list = self.validate_inputs_form_payload(mapping_dict)

        for site_object in site_object_list:
          #fetch payload
          site_payload = site_object.getxml(filter=True)

          util.log_debug('site_payload %s'%site_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=site_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return

        ##prepare rcpath
        rcpath = "vpls:vpls/multi-homing"
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        site_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        site_name = mapping_dict.get('site_name')
        if not isinstance(site_name, list):
          site_name = [site_name]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for site_name_iterator in site_name:
          rcpath_tmp =  rcpath+"/site=%s"%(util.make_interfacename(site_name_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, site_object in enumerate(site_object_list):
          #fetch payload
          site_payload = site_object.getxml(filter=True)

          util.log_debug('update site_payload %s'%site_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=site_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return

        ##prepare rcpath
        rcpath = "vpls:vpls/multi-homing"
        self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('site_name')):
          raise Exception("'site_name' cannot be empty")

        #convert keys to list
        site_name = mapping_dict.get('site_name')
        if not isinstance(site_name, list):
          site_name = [site_name]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for site_name_iterator in site_name:
          rcpath_tmp =  rcpath+"/site=%s"%(util.make_interfacename(site_name_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('site_name')):
          raise Exception("'site_name' cannot be empty")

        #convert keys to list
        site_name = mapping_dict.get('site_name')
        if not isinstance(site_name, list):
          site_name = [site_name]

        #prepare payload
        site_object_list = []
        for site_name_iterator in site_name:
          from servicemodel.controller.devices.device.vpls import multi_homing
          site_object = multi_homing.site.site()
          site_object.site_name = site_name_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('identifier', None)) != ''):
              site_object.identifier = mapping_dict.get('identifier', None)
            else:
              site_object.identifier._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('preference', None)) != ''):
              site_object.preference = mapping_dict.get('preference', None)
            else:
              site_object.preference._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('peer_active', None)) != ''):
              site_object.peer_active = mapping_dict.get('peer_active', None)
            else:
              site_object.peer_active._empty_tag = True
          except TypeError:
            pass
          site_object_list.append(site_object)

        return site_object_list

      #XPATH devices/device/vpls/multi-homing/site/active-interface
      class active_interface(AbstractDeviceMgr):
        key_hints = [['site_name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          active_interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for active_interface_object in active_interface_object_list:
            #fetch payload
            active_interface_payload = active_interface_object.getxml(filter=True)
            util.log_debug('active_interface_payload %s'%active_interface_payload)
            payload_list.append(active_interface_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          active_interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for active_interface_object in active_interface_object_list:
            #fetch payload
            active_interface_payload = active_interface_object.getxml(filter=True)

            util.log_debug('active_interface_payload %s'%active_interface_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=active_interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          active_interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/active-interface"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, active_interface_object in enumerate(active_interface_object_list):
            #fetch payload
            active_interface_payload = active_interface_object.getxml(filter=True)

            util.log_debug('update active_interface_payload %s'%active_interface_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=active_interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/active-interface"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          active_interface_object_list = []
          from servicemodel.controller.devices.device.vpls.multi_homing import site
          active_interface_object = site.active_interface.active_interface()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('any', None)) != ''):
              active_interface_object.any = mapping_dict.get('any', None)
            else:
              active_interface_object.any._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('primary', None)) != ''):
              active_interface_object.primary = mapping_dict.get('primary', None)
            else:
              active_interface_object.primary._empty_tag = True
          except TypeError:
            pass
          active_interface_object_list.append(active_interface_object)

          return active_interface_object_list

      #XPATH devices/device/vpls/multi-homing/site/interface
      class interface(AbstractDeviceMgr):
        key_hints = [['site_name']]
        def getRcpathPayload(self, sdata, dev, site_site_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for interface_object in interface_object_list:
            #fetch payload
            interface_payload = interface_object.getxml(filter=True)
            util.log_debug('interface_payload %s'%interface_payload)
            payload_list.append(interface_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)

          #convert parent keys to list
          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for interface_object in interface_object_list:
            #fetch payload
            interface_payload = interface_object.getxml(filter=True)

            util.log_debug('interface_payload %s'%interface_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, site_site_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          ##prepare rcpath
          rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, interface_object in enumerate(interface_object_list):
            #fetch payload
            interface_payload = interface_object.getxml(filter=True)

            util.log_debug('update interface_payload %s'%interface_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, site_site_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( site_site_name)


          if not isinstance(site_site_name, list):
            site_site_name_list = [site_site_name]
          else:
            site_site_name_list = site_site_name

          for site_site_name in site_site_name_list:
            ##prepare rcpath
            rcpath = "vpls:vpls/multi-homing/site=%s"%(util.make_interfacename(site_site_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, site_site_name):
          #Parent Key Validations
          if util.isEmpty(site_site_name):
            raise Exception("'site_site_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare payload
          interface_object_list = []
          for name_iterator in name:
            from servicemodel.controller.devices.device.vpls.multi_homing import site
            interface_object = site.interface.interface()
            interface_object.name = name_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('preference', None)) != ''):
                interface_object.preference = mapping_dict.get('preference', None)
              else:
                interface_object.preference._empty_tag = True
            except TypeError:
              pass
            interface_object_list.append(interface_object)

          return interface_object_list

