#
# This computer program is the confidential information and proprietary trade
# secret of Anuta Networks, Inc. Possessions and use of this program must
# conform strictly to the license agreement between the user and
# Anuta Networks, Inc., and receipt or possession does not convey any rights
# to divulge, reproduce, or allow others to use this program without specific
# written authorization of Anuta Networks, Inc.
#
# Copyright (c) 2015-2016 Anuta Networks, Inc. All Rights Reserved.
#

#
#DO NOT EDIT THIS FILE ITS AUTOGENERATED ONE
#

from servicemodel import util
from servicemodel import yang
from servicemodel import devicemgr
from servicemodel.abstract_dev_mgr import AbstractDeviceMgr

def get_valid_devices(devs):
  vdevs = []
  if isinstance(devs, list):
    for dev in devs:
      drivername = dev.device.get_field_value('driver_name')
      if util.isEmpty(drivername):
        vdevs.append(dev)
  else:
    drivername = devs.device.get_field_value('driver_name')
    if util.isEmpty(drivername):
      vdevs.append(devs)

  return vdevs

class vrfs(object):
  #XPATH devices/device/vrfs/vrf
  class vrf(AbstractDeviceMgr):
    key_hints = [[]]
    def getRcpathPayload(self, sdata, dev, mapping_dict):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      rcpath_list = []
      payload_list = []
      ##prepare rcpath
      rcpath = "l3features:vrfs"
      rcpath_list.append(rcpath)
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      vrf_object_list = self.validate_inputs_form_payload(mapping_dict)

      for vrf_object in vrf_object_list:
        #fetch payload
        vrf_payload = vrf_object.getxml(filter=True)
        util.log_debug('vrf_payload %s'%vrf_payload)
        payload_list.append(vrf_payload)

      return rcpath_list, payload_list

    def create(self, sdata, dev, mapping_dict, addref=True, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return
      #convert parent keys to list
      ##prepare rcpath
      rcpath = "l3features:vrfs"
      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def create_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      vrf_object_list = self.validate_inputs_form_payload(mapping_dict)

      for vrf_object in vrf_object_list:
        #fetch payload
        vrf_payload = vrf_object.getxml(filter=True)

        util.log_debug('vrf_payload %s'%vrf_payload)

        #call the base abstract class for createData
        super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vrf_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def update(self, sdata, dev, mapping_dict, addref=False, autocommit=True):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "l3features:vrfs"
      self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

    def update_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs and get payload object
      vrf_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

      #convert keys to list
      name = mapping_dict.get('name')
      if not isinstance(name, list):
        name = [name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for name_iterator in name:
        rcpath_tmp =  rcpath+"/vrf=%s"%(util.make_interfacename(name_iterator))
        rcpath_list.append(rcpath_tmp)
      for rc_counter, vrf_object in enumerate(vrf_object_list):
        #fetch payload
        vrf_payload = vrf_object.getxml(filter=True)

        util.log_debug('update vrf_payload %s'%vrf_payload)

        rcpath = rcpath_list[rc_counter]
        #call the base abstract class for createData
        super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vrf_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

    def delete(self, sdata, dev, mapping_dict, fail_silently=False, remove_reference=False):
      dev = get_valid_devices(dev)
      if len(dev) == 0:
        return

      ##prepare rcpath
      rcpath = "l3features:vrfs"
      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

    def delete_(self, sdata, dev, **kwargs):
      mapping_dict = kwargs.get('mapping_dict')

      #validating inputs
      if util.isEmpty(mapping_dict.get('name')):
        raise Exception("'name' cannot be empty")

      #convert keys to list
      name = mapping_dict.get('name')
      if not isinstance(name, list):
        name = [name]

      #prepare rcpath
      rcpath = kwargs.get('rcpath')
      rcpath_list = []
      for name_iterator in name:
        rcpath_tmp =  rcpath+"/vrf=%s"%(util.make_interfacename(name_iterator))
        rcpath_list.append(rcpath_tmp)
      payload = ''

      for rcpath in rcpath_list:
        #call the base abstract class for deleteData
        super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

    def validate_inputs_form_payload(self, mapping_dict, update=False):
      #validating inputs
      if util.isEmpty(mapping_dict.get('name')):
        raise Exception("'name' cannot be empty")

      #convert keys to list
      name = mapping_dict.get('name')
      if not isinstance(name, list):
        name = [name]

      #prepare payload
      vrf_object_list = []
      for name_iterator in name:
        from servicemodel.controller.devices.device import vrfs
        vrf_object = vrfs.vrf.vrf()
        vrf_object.name = name_iterator
        try:
          if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
            vrf_object.description = mapping_dict.get('description', None)
          else:
            vrf_object.description._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('rd', None)) != ''):
            vrf_object.rd = mapping_dict.get('rd', None)
          else:
            vrf_object.rd._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('vrf_definition_mode', None)) != ''):
            vrf_object.vrf_definition_mode = mapping_dict.get('vrf_definition_mode', None)
          else:
            vrf_object.vrf_definition_mode._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('maximum_prefixes_ipv4', None)) != ''):
            vrf_object.maximum_prefixes_ipv4 = mapping_dict.get('maximum_prefixes_ipv4', None)
          else:
            vrf_object.maximum_prefixes_ipv4._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('import_route_policy', None)) != ''):
            vrf_object.import_route_policy = mapping_dict.get('import_route_policy', None)
          else:
            vrf_object.import_route_policy._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('export_route_policy', None)) != ''):
            vrf_object.export_route_policy = mapping_dict.get('export_route_policy', None)
          else:
            vrf_object.export_route_policy._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('vrf_table_label', None)) != ''):
            vrf_object.vrf_table_label = mapping_dict.get('vrf_table_label', None)
          else:
            vrf_object.vrf_table_label._empty_tag = True
        except TypeError:
          pass
        vrf_object_list.append(vrf_object)

      return vrf_object_list

    #XPATH devices/device/vrfs/vrf/rt-import
    class rt_import(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        rt_import_object_list = self.validate_inputs_form_payload(mapping_dict)

        for rt_import_object in rt_import_object_list:
          #fetch payload
          rt_import_payload = rt_import_object.getxml(filter=True)
          util.log_debug('rt_import_payload %s'%rt_import_payload)
          payload_list.append(rt_import_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        rt_import_object_list = self.validate_inputs_form_payload(mapping_dict)

        for rt_import_object in rt_import_object_list:
          #fetch payload
          rt_import_payload = rt_import_object.getxml(filter=True)

          util.log_debug('rt_import_payload %s'%rt_import_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=rt_import_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        rt_import_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        rt_import = mapping_dict.get('rt_import')
        if not isinstance(rt_import, list):
          rt_import = [rt_import]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for rt_import_iterator in rt_import:
          rcpath_tmp =  rcpath+"/rt-import=%s"%(util.make_interfacename(rt_import_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, rt_import_object in enumerate(rt_import_object_list):
          #fetch payload
          rt_import_payload = rt_import_object.getxml(filter=True)

          util.log_debug('update rt_import_payload %s'%rt_import_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=rt_import_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('rt_import')):
          raise Exception("'rt_import' cannot be empty")

        #convert keys to list
        rt_import = mapping_dict.get('rt_import')
        if not isinstance(rt_import, list):
          rt_import = [rt_import]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for rt_import_iterator in rt_import:
          rcpath_tmp =  rcpath+"/rt-import=%s"%(util.make_interfacename(rt_import_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('rt_import')):
          raise Exception("'rt_import' cannot be empty")

        #convert keys to list
        rt_import = mapping_dict.get('rt_import')
        if not isinstance(rt_import, list):
          rt_import = [rt_import]

        #prepare payload
        rt_import_object_list = []
        for rt_import_iterator in rt_import:
          from servicemodel.controller.devices.device.vrfs import vrf
          rt_import_object = vrf.rt_import.rt_import()
          rt_import_object.rt_import = rt_import_iterator
          rt_import_object_list.append(rt_import_object)

        return rt_import_object_list

    #XPATH devices/device/vrfs/vrf/rt-export
    class rt_export(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        rt_export_object_list = self.validate_inputs_form_payload(mapping_dict)

        for rt_export_object in rt_export_object_list:
          #fetch payload
          rt_export_payload = rt_export_object.getxml(filter=True)
          util.log_debug('rt_export_payload %s'%rt_export_payload)
          payload_list.append(rt_export_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        rt_export_object_list = self.validate_inputs_form_payload(mapping_dict)

        for rt_export_object in rt_export_object_list:
          #fetch payload
          rt_export_payload = rt_export_object.getxml(filter=True)

          util.log_debug('rt_export_payload %s'%rt_export_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=rt_export_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        rt_export_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        rt_export = mapping_dict.get('rt_export')
        if not isinstance(rt_export, list):
          rt_export = [rt_export]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for rt_export_iterator in rt_export:
          rcpath_tmp =  rcpath+"/rt-export=%s"%(util.make_interfacename(rt_export_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, rt_export_object in enumerate(rt_export_object_list):
          #fetch payload
          rt_export_payload = rt_export_object.getxml(filter=True)

          util.log_debug('update rt_export_payload %s'%rt_export_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=rt_export_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('rt_export')):
          raise Exception("'rt_export' cannot be empty")

        #convert keys to list
        rt_export = mapping_dict.get('rt_export')
        if not isinstance(rt_export, list):
          rt_export = [rt_export]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for rt_export_iterator in rt_export:
          rcpath_tmp =  rcpath+"/rt-export=%s"%(util.make_interfacename(rt_export_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('rt_export')):
          raise Exception("'rt_export' cannot be empty")

        #convert keys to list
        rt_export = mapping_dict.get('rt_export')
        if not isinstance(rt_export, list):
          rt_export = [rt_export]

        #prepare payload
        rt_export_object_list = []
        for rt_export_iterator in rt_export:
          from servicemodel.controller.devices.device.vrfs import vrf
          rt_export_object = vrf.rt_export.rt_export()
          rt_export_object.rt_export = rt_export_iterator
          rt_export_object_list.append(rt_export_object)

        return rt_export_object_list

    #XPATH devices/device/vrfs/vrf/import-map
    class import_map(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        import_map_object_list = self.validate_inputs_form_payload(mapping_dict)

        for import_map_object in import_map_object_list:
          #fetch payload
          import_map_payload = import_map_object.getxml(filter=True)
          util.log_debug('import_map_payload %s'%import_map_payload)
          payload_list.append(import_map_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        import_map_object_list = self.validate_inputs_form_payload(mapping_dict)

        for import_map_object in import_map_object_list:
          #fetch payload
          import_map_payload = import_map_object.getxml(filter=True)

          util.log_debug('import_map_payload %s'%import_map_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=import_map_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        import_map_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        import_map = mapping_dict.get('import_map')
        if not isinstance(import_map, list):
          import_map = [import_map]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for import_map_iterator in import_map:
          rcpath_tmp =  rcpath+"/import-map=%s"%(util.make_interfacename(import_map_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, import_map_object in enumerate(import_map_object_list):
          #fetch payload
          import_map_payload = import_map_object.getxml(filter=True)

          util.log_debug('update import_map_payload %s'%import_map_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=import_map_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('import_map')):
          raise Exception("'import_map' cannot be empty")

        #convert keys to list
        import_map = mapping_dict.get('import_map')
        if not isinstance(import_map, list):
          import_map = [import_map]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for import_map_iterator in import_map:
          rcpath_tmp =  rcpath+"/import-map=%s"%(util.make_interfacename(import_map_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('import_map')):
          raise Exception("'import_map' cannot be empty")

        #convert keys to list
        import_map = mapping_dict.get('import_map')
        if not isinstance(import_map, list):
          import_map = [import_map]

        #prepare payload
        import_map_object_list = []
        for import_map_iterator in import_map:
          from servicemodel.controller.devices.device.vrfs import vrf
          import_map_object = vrf.import_map.import_map()
          import_map_object.import_map = import_map_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ipv4', None)) != ''):
              import_map_object.ipv4 = mapping_dict.get('ipv4', None)
            else:
              import_map_object.ipv4._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('table', None)) != ''):
              import_map_object.table = mapping_dict.get('table', None)
            else:
              import_map_object.table._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('upper_limit', None)) != ''):
              import_map_object.upper_limit = mapping_dict.get('upper_limit', None)
            else:
              import_map_object.upper_limit._empty_tag = True
          except TypeError:
            pass
          import_map_object_list.append(import_map_object)

        return import_map_object_list

    #XPATH devices/device/vrfs/vrf/export-map
    class export_map(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        export_map_object_list = self.validate_inputs_form_payload(mapping_dict)

        for export_map_object in export_map_object_list:
          #fetch payload
          export_map_payload = export_map_object.getxml(filter=True)
          util.log_debug('export_map_payload %s'%export_map_payload)
          payload_list.append(export_map_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        export_map_object_list = self.validate_inputs_form_payload(mapping_dict)

        for export_map_object in export_map_object_list:
          #fetch payload
          export_map_payload = export_map_object.getxml(filter=True)

          util.log_debug('export_map_payload %s'%export_map_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=export_map_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        export_map_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        export_map = mapping_dict.get('export_map')
        if not isinstance(export_map, list):
          export_map = [export_map]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for export_map_iterator in export_map:
          rcpath_tmp =  rcpath+"/export-map=%s"%(util.make_interfacename(export_map_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, export_map_object in enumerate(export_map_object_list):
          #fetch payload
          export_map_payload = export_map_object.getxml(filter=True)

          util.log_debug('update export_map_payload %s'%export_map_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=export_map_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('export_map')):
          raise Exception("'export_map' cannot be empty")

        #convert keys to list
        export_map = mapping_dict.get('export_map')
        if not isinstance(export_map, list):
          export_map = [export_map]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for export_map_iterator in export_map:
          rcpath_tmp =  rcpath+"/export-map=%s"%(util.make_interfacename(export_map_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('export_map')):
          raise Exception("'export_map' cannot be empty")

        #convert keys to list
        export_map = mapping_dict.get('export_map')
        if not isinstance(export_map, list):
          export_map = [export_map]

        #prepare payload
        export_map_object_list = []
        for export_map_iterator in export_map:
          from servicemodel.controller.devices.device.vrfs import vrf
          export_map_object = vrf.export_map.export_map()
          export_map_object.export_map = export_map_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ipv4', None)) != ''):
              export_map_object.ipv4 = mapping_dict.get('ipv4', None)
            else:
              export_map_object.ipv4._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('table', None)) != ''):
              export_map_object.table = mapping_dict.get('table', None)
            else:
              export_map_object.table._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('upper_limit', None)) != ''):
              export_map_object.upper_limit = mapping_dict.get('upper_limit', None)
            else:
              export_map_object.upper_limit._empty_tag = True
          except TypeError:
            pass
          export_map_object_list.append(export_map_object)

        return export_map_object_list

    #XPATH devices/device/vrfs/vrf/vrf-import
    class vrf_import(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_import_object_list = self.validate_inputs_form_payload(mapping_dict)

        for vrf_import_object in vrf_import_object_list:
          #fetch payload
          vrf_import_payload = vrf_import_object.getxml(filter=True)
          util.log_debug('vrf_import_payload %s'%vrf_import_payload)
          payload_list.append(vrf_import_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_import_object_list = self.validate_inputs_form_payload(mapping_dict)

        for vrf_import_object in vrf_import_object_list:
          #fetch payload
          vrf_import_payload = vrf_import_object.getxml(filter=True)

          util.log_debug('vrf_import_payload %s'%vrf_import_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vrf_import_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_import_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        vrf_import = mapping_dict.get('vrf_import')
        if not isinstance(vrf_import, list):
          vrf_import = [vrf_import]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for vrf_import_iterator in vrf_import:
          rcpath_tmp =  rcpath+"/vrf-import=%s"%(util.make_interfacename(vrf_import_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, vrf_import_object in enumerate(vrf_import_object_list):
          #fetch payload
          vrf_import_payload = vrf_import_object.getxml(filter=True)

          util.log_debug('update vrf_import_payload %s'%vrf_import_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vrf_import_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('vrf_import')):
          raise Exception("'vrf_import' cannot be empty")

        #convert keys to list
        vrf_import = mapping_dict.get('vrf_import')
        if not isinstance(vrf_import, list):
          vrf_import = [vrf_import]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for vrf_import_iterator in vrf_import:
          rcpath_tmp =  rcpath+"/vrf-import=%s"%(util.make_interfacename(vrf_import_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('vrf_import')):
          raise Exception("'vrf_import' cannot be empty")

        #convert keys to list
        vrf_import = mapping_dict.get('vrf_import')
        if not isinstance(vrf_import, list):
          vrf_import = [vrf_import]

        #prepare payload
        vrf_import_object_list = []
        for vrf_import_iterator in vrf_import:
          from servicemodel.controller.devices.device.vrfs import vrf
          vrf_import_object = vrf.vrf_import.vrf_import()
          vrf_import_object.vrf_import = vrf_import_iterator
          vrf_import_object_list.append(vrf_import_object)

        return vrf_import_object_list

    #XPATH devices/device/vrfs/vrf/vrf-export
    class vrf_export(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_export_object_list = self.validate_inputs_form_payload(mapping_dict)

        for vrf_export_object in vrf_export_object_list:
          #fetch payload
          vrf_export_payload = vrf_export_object.getxml(filter=True)
          util.log_debug('vrf_export_payload %s'%vrf_export_payload)
          payload_list.append(vrf_export_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_export_object_list = self.validate_inputs_form_payload(mapping_dict)

        for vrf_export_object in vrf_export_object_list:
          #fetch payload
          vrf_export_payload = vrf_export_object.getxml(filter=True)

          util.log_debug('vrf_export_payload %s'%vrf_export_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=vrf_export_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        vrf_export_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        vrf_export = mapping_dict.get('vrf_export')
        if not isinstance(vrf_export, list):
          vrf_export = [vrf_export]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for vrf_export_iterator in vrf_export:
          rcpath_tmp =  rcpath+"/vrf-export=%s"%(util.make_interfacename(vrf_export_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, vrf_export_object in enumerate(vrf_export_object_list):
          #fetch payload
          vrf_export_payload = vrf_export_object.getxml(filter=True)

          util.log_debug('update vrf_export_payload %s'%vrf_export_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=vrf_export_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('vrf_export')):
          raise Exception("'vrf_export' cannot be empty")

        #convert keys to list
        vrf_export = mapping_dict.get('vrf_export')
        if not isinstance(vrf_export, list):
          vrf_export = [vrf_export]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for vrf_export_iterator in vrf_export:
          rcpath_tmp =  rcpath+"/vrf-export=%s"%(util.make_interfacename(vrf_export_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('vrf_export')):
          raise Exception("'vrf_export' cannot be empty")

        #convert keys to list
        vrf_export = mapping_dict.get('vrf_export')
        if not isinstance(vrf_export, list):
          vrf_export = [vrf_export]

        #prepare payload
        vrf_export_object_list = []
        for vrf_export_iterator in vrf_export:
          from servicemodel.controller.devices.device.vrfs import vrf
          vrf_export_object = vrf.vrf_export.vrf_export()
          vrf_export_object.vrf_export = vrf_export_iterator
          vrf_export_object_list.append(vrf_export_object)

        return vrf_export_object_list

    #XPATH devices/device/vrfs/vrf/router-bgp
    class router_bgp(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_bgp_object_list = self.validate_inputs_form_payload(mapping_dict)

        for router_bgp_object in router_bgp_object_list:
          #fetch payload
          router_bgp_payload = router_bgp_object.getxml(filter=True)
          util.log_debug('router_bgp_payload %s'%router_bgp_payload)
          payload_list.append(router_bgp_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_bgp_object_list = self.validate_inputs_form_payload(mapping_dict)

        for router_bgp_object in router_bgp_object_list:
          #fetch payload
          router_bgp_payload = router_bgp_object.getxml(filter=True)

          util.log_debug('router_bgp_payload %s'%router_bgp_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=router_bgp_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_bgp_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/router-bgp"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, router_bgp_object in enumerate(router_bgp_object_list):
          #fetch payload
          router_bgp_payload = router_bgp_object.getxml(filter=True)

          util.log_debug('update router_bgp_payload %s'%router_bgp_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=router_bgp_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/router-bgp"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        router_bgp_object_list = []
        from servicemodel.controller.devices.device.vrfs import vrf
        router_bgp_object = vrf.router_bgp.router_bgp()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('as_number', None)) != ''):
            router_bgp_object.as_number = mapping_dict.get('as_number', None)
          else:
            router_bgp_object.as_number._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('router_id', None)) != ''):
            router_bgp_object.router_id = mapping_dict.get('router_id', None)
          else:
            router_bgp_object.router_id._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('default_information_originate', None)) != ''):
            router_bgp_object.default_information_originate = mapping_dict.get('default_information_originate', None)
          else:
            router_bgp_object.default_information_originate._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('address_family', None)) != ''):
            router_bgp_object.address_family = mapping_dict.get('address_family', None)
          else:
            router_bgp_object.address_family._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('log_neighbor_changes', None)) != ''):
            router_bgp_object.log_neighbor_changes = mapping_dict.get('log_neighbor_changes', None)
          else:
            router_bgp_object.log_neighbor_changes._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('qppb_policy', None)) != ''):
            router_bgp_object.qppb_policy = mapping_dict.get('qppb_policy', None)
          else:
            router_bgp_object.qppb_policy._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('trigger_delay', None)) != ''):
            router_bgp_object.trigger_delay = mapping_dict.get('trigger_delay', None)
          else:
            router_bgp_object.trigger_delay._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('listen_limit', None)) != ''):
            router_bgp_object.listen_limit = mapping_dict.get('listen_limit', None)
          else:
            router_bgp_object.listen_limit._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('maximum_paths', None)) != ''):
            router_bgp_object.maximum_paths = mapping_dict.get('maximum_paths', None)
          else:
            router_bgp_object.maximum_paths._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('eroutes', None)) != ''):
            router_bgp_object.eroutes = mapping_dict.get('eroutes', None)
          else:
            router_bgp_object.eroutes._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('iroutes', None)) != ''):
            router_bgp_object.iroutes = mapping_dict.get('iroutes', None)
          else:
            router_bgp_object.iroutes._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('lroutes', None)) != ''):
            router_bgp_object.lroutes = mapping_dict.get('lroutes', None)
          else:
            router_bgp_object.lroutes._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('redistribute_internal', None)) != ''):
            router_bgp_object.redistribute_internal = mapping_dict.get('redistribute_internal', None)
          else:
            router_bgp_object.redistribute_internal._empty_tag = True
        except TypeError:
          pass
        router_bgp_object_list.append(router_bgp_object)

        return router_bgp_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/listen-range
      class listen_range(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          listen_range_object_list = self.validate_inputs_form_payload(mapping_dict)

          for listen_range_object in listen_range_object_list:
            #fetch payload
            listen_range_payload = listen_range_object.getxml(filter=True)
            util.log_debug('listen_range_payload %s'%listen_range_payload)
            payload_list.append(listen_range_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          listen_range_object_list = self.validate_inputs_form_payload(mapping_dict)

          for listen_range_object in listen_range_object_list:
            #fetch payload
            listen_range_payload = listen_range_object.getxml(filter=True)

            util.log_debug('listen_range_payload %s'%listen_range_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=listen_range_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          listen_range_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]
          cidr = mapping_dict.get('cidr')
          if not isinstance(cidr, list):
            cidr = [cidr]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            for cidr_iterator in cidr:
              rcpath_tmp =  rcpath+"/listen-range=%s,%s"%(util.make_interfacename(name_iterator),util.make_interfacename(cidr_iterator))
              rcpath_list.append(rcpath_tmp)
          for rc_counter, listen_range_object in enumerate(listen_range_object_list):
            #fetch payload
            listen_range_payload = listen_range_object.getxml(filter=True)

            util.log_debug('update listen_range_payload %s'%listen_range_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=listen_range_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")
          if util.isEmpty(mapping_dict.get('cidr')):
            raise Exception("'cidr' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]
          cidr = mapping_dict.get('cidr')
          if not isinstance(cidr, list):
            cidr = [cidr]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            for cidr_iterator in cidr:
              rcpath_tmp =  rcpath+"/listen-range=%s,%s"%(util.make_interfacename(name_iterator),util.make_interfacename(cidr_iterator))
              rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")
          if util.isEmpty(mapping_dict.get('cidr')):
            raise Exception("'cidr' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]
          cidr = mapping_dict.get('cidr')
          if not isinstance(cidr, list):
            cidr = [cidr]

          #prepare payload
          listen_range_object_list = []
          for name_iterator in name:
            for cidr_iterator in cidr:
              from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
              listen_range_object = router_bgp.listen_range.listen_range()
              listen_range_object.name = name_iterator
              listen_range_object.cidr = cidr_iterator
              listen_range_object_list.append(listen_range_object)

          return listen_range_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/peer-group
      class peer_group(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          peer_group_object_list = self.validate_inputs_form_payload(mapping_dict)

          for peer_group_object in peer_group_object_list:
            #fetch payload
            peer_group_payload = peer_group_object.getxml(filter=True)
            util.log_debug('peer_group_payload %s'%peer_group_payload)
            payload_list.append(peer_group_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          peer_group_object_list = self.validate_inputs_form_payload(mapping_dict)

          for peer_group_object in peer_group_object_list:
            #fetch payload
            peer_group_payload = peer_group_object.getxml(filter=True)

            util.log_debug('peer_group_payload %s'%peer_group_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=peer_group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          peer_group_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/peer-group=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, peer_group_object in enumerate(peer_group_object_list):
            #fetch payload
            peer_group_payload = peer_group_object.getxml(filter=True)

            util.log_debug('update peer_group_payload %s'%peer_group_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=peer_group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/peer-group=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare payload
          peer_group_object_list = []
          for name_iterator in name:
            from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
            peer_group_object = router_bgp.peer_group.peer_group()
            peer_group_object.name = name_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('cidr', None)) != ''):
                peer_group_object._set_cidr(mapping_dict.get('cidr', None))
              else:
                peer_group_object._unset_cidr()
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('remote_as', None)) != ''):
                peer_group_object.remote_as = mapping_dict.get('remote_as', None)
              else:
                peer_group_object.remote_as._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('as_override', None)) != ''):
                peer_group_object.as_override = mapping_dict.get('as_override', None)
              else:
                peer_group_object.as_override._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('next_hop_self', None)) != ''):
                peer_group_object.next_hop_self = mapping_dict.get('next_hop_self', None)
              else:
                peer_group_object.next_hop_self._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('soft_reconfiguration', None)) != ''):
                peer_group_object.soft_reconfiguration = mapping_dict.get('soft_reconfiguration', None)
              else:
                peer_group_object.soft_reconfiguration._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('encryption', None)) != ''):
                peer_group_object.encryption = mapping_dict.get('encryption', None)
              else:
                peer_group_object.encryption._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('password', None)) != ''):
                peer_group_object.password = mapping_dict.get('password', None)
              else:
                peer_group_object.password._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_reflector_client', None)) != ''):
                peer_group_object.route_reflector_client = mapping_dict.get('route_reflector_client', None)
              else:
                peer_group_object.route_reflector_client._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('next_hop_unchanged', None)) != ''):
                peer_group_object.next_hop_unchanged = mapping_dict.get('next_hop_unchanged', None)
              else:
                peer_group_object.next_hop_unchanged._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('default_originate', None)) != ''):
                peer_group_object.default_originate = mapping_dict.get('default_originate', None)
              else:
                peer_group_object.default_originate._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('def_originate_route_map', None)) != ''):
                peer_group_object.def_originate_route_map = mapping_dict.get('def_originate_route_map', None)
              else:
                peer_group_object.def_originate_route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('weight', None)) != ''):
                peer_group_object.weight = mapping_dict.get('weight', None)
              else:
                peer_group_object.weight._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('allowas_in', None)) != ''):
                peer_group_object.allowas_in = mapping_dict.get('allowas_in', None)
              else:
                peer_group_object.allowas_in._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('allowas_in_value', None)) != ''):
                peer_group_object.allowas_in_value = mapping_dict.get('allowas_in_value', None)
              else:
                peer_group_object.allowas_in_value._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('maximum_prefix', None)) != ''):
                peer_group_object.maximum_prefix = mapping_dict.get('maximum_prefix', None)
              else:
                peer_group_object.maximum_prefix._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('in_route_map', None)) != ''):
                peer_group_object.in_route_map = mapping_dict.get('in_route_map', None)
              else:
                peer_group_object.in_route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('out_route_map', None)) != ''):
                peer_group_object.out_route_map = mapping_dict.get('out_route_map', None)
              else:
                peer_group_object.out_route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ebgp_multihop', None)) != ''):
                peer_group_object.ebgp_multihop = mapping_dict.get('ebgp_multihop', None)
              else:
                peer_group_object.ebgp_multihop._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('keepalive_interval', None)) != ''):
                peer_group_object.keepalive_interval = mapping_dict.get('keepalive_interval', None)
              else:
                peer_group_object.keepalive_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('holdtime', None)) != ''):
                peer_group_object.holdtime = mapping_dict.get('holdtime', None)
              else:
                peer_group_object.holdtime._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('advertisement_interval', None)) != ''):
                peer_group_object.advertisement_interval = mapping_dict.get('advertisement_interval', None)
              else:
                peer_group_object.advertisement_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
                peer_group_object.description = mapping_dict.get('description', None)
              else:
                peer_group_object.description._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('local_as_number', None)) != ''):
                peer_group_object.local_as_number = mapping_dict.get('local_as_number', None)
              else:
                peer_group_object.local_as_number._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('send_community', None)) != ''):
                peer_group_object.send_community = mapping_dict.get('send_community', None)
              else:
                peer_group_object.send_community._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('local_interface', None)) != ''):
                peer_group_object.local_interface = mapping_dict.get('local_interface', None)
              else:
                peer_group_object.local_interface._empty_tag = True
            except TypeError:
              pass
            peer_group_object_list.append(peer_group_object)

          return peer_group_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/neighbor
      class neighbor(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

          for neighbor_object in neighbor_object_list:
            #fetch payload
            neighbor_payload = neighbor_object.getxml(filter=True)
            util.log_debug('neighbor_payload %s'%neighbor_payload)
            payload_list.append(neighbor_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

          for neighbor_object in neighbor_object_list:
            #fetch payload
            neighbor_payload = neighbor_object.getxml(filter=True)

            util.log_debug('neighbor_payload %s'%neighbor_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, neighbor_object in enumerate(neighbor_object_list):
            #fetch payload
            neighbor_payload = neighbor_object.getxml(filter=True)

            util.log_debug('update neighbor_payload %s'%neighbor_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare payload
          neighbor_object_list = []
          for ip_address_iterator in ip_address:
            from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
            neighbor_object = router_bgp.neighbor.neighbor()
            neighbor_object.ip_address = ip_address_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ipv6_address', None)) != ''):
                neighbor_object.ipv6_address = mapping_dict.get('ipv6_address', None)
              else:
                neighbor_object.ipv6_address._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
                neighbor_object.netmask = mapping_dict.get('netmask', None)
              else:
                neighbor_object.netmask._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('local_interface', None)) != ''):
                neighbor_object.local_interface = mapping_dict.get('local_interface', None)
              else:
                neighbor_object.local_interface._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_limit', None)) != ''):
                neighbor_object.route_limit = mapping_dict.get('route_limit', None)
              else:
                neighbor_object.route_limit._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('neighbor_tag', None)) != ''):
                neighbor_object.neighbor_tag = mapping_dict.get('neighbor_tag', None)
              else:
                neighbor_object.neighbor_tag._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('peer_group', None)) != ''):
                neighbor_object.peer_group = mapping_dict.get('peer_group', None)
              else:
                neighbor_object.peer_group._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('inbound_routepolicy', None)) != ''):
                neighbor_object.inbound_routepolicy = mapping_dict.get('inbound_routepolicy', None)
              else:
                neighbor_object.inbound_routepolicy._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('outbound_routepolicy', None)) != ''):
                neighbor_object.outbound_routepolicy = mapping_dict.get('outbound_routepolicy', None)
              else:
                neighbor_object.outbound_routepolicy._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('group', None)) != ''):
                neighbor_object.group = mapping_dict.get('group', None)
              else:
                neighbor_object.group._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('auth_key', None)) != ''):
                neighbor_object.auth_key = mapping_dict.get('auth_key', None)
              else:
                neighbor_object.auth_key._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('type', None)) != ''):
                neighbor_object.type = mapping_dict.get('type', None)
              else:
                neighbor_object.type._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
                neighbor_object.route_map = mapping_dict.get('route_map', None)
              else:
                neighbor_object.route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_map_type', None)) != ''):
                neighbor_object.route_map_type = mapping_dict.get('route_map_type', None)
              else:
                neighbor_object.route_map_type._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('advertise_community', None)) != ''):
                neighbor_object.advertise_community = mapping_dict.get('advertise_community', None)
              else:
                neighbor_object.advertise_community._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('advertise_ext_community', None)) != ''):
                neighbor_object.advertise_ext_community = mapping_dict.get('advertise_ext_community', None)
              else:
                neighbor_object.advertise_ext_community._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('bfd', None)) != ''):
                neighbor_object.bfd = mapping_dict.get('bfd', None)
              else:
                neighbor_object.bfd._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('remote_as', None)) != ''):
                neighbor_object.remote_as = mapping_dict.get('remote_as', None)
              else:
                neighbor_object.remote_as._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('as_override', None)) != ''):
                neighbor_object.as_override = mapping_dict.get('as_override', None)
              else:
                neighbor_object.as_override._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('next_hop_self', None)) != ''):
                neighbor_object.next_hop_self = mapping_dict.get('next_hop_self', None)
              else:
                neighbor_object.next_hop_self._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('soft_reconfiguration', None)) != ''):
                neighbor_object.soft_reconfiguration = mapping_dict.get('soft_reconfiguration', None)
              else:
                neighbor_object.soft_reconfiguration._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('encryption', None)) != ''):
                neighbor_object.encryption = mapping_dict.get('encryption', None)
              else:
                neighbor_object.encryption._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('password', None)) != ''):
                neighbor_object.password = mapping_dict.get('password', None)
              else:
                neighbor_object.password._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_reflector_client', None)) != ''):
                neighbor_object.route_reflector_client = mapping_dict.get('route_reflector_client', None)
              else:
                neighbor_object.route_reflector_client._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('next_hop_unchanged', None)) != ''):
                neighbor_object.next_hop_unchanged = mapping_dict.get('next_hop_unchanged', None)
              else:
                neighbor_object.next_hop_unchanged._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('default_originate', None)) != ''):
                neighbor_object.default_originate = mapping_dict.get('default_originate', None)
              else:
                neighbor_object.default_originate._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('def_originate_route_map', None)) != ''):
                neighbor_object.def_originate_route_map = mapping_dict.get('def_originate_route_map', None)
              else:
                neighbor_object.def_originate_route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('weight', None)) != ''):
                neighbor_object.weight = mapping_dict.get('weight', None)
              else:
                neighbor_object.weight._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('allowas_in', None)) != ''):
                neighbor_object.allowas_in = mapping_dict.get('allowas_in', None)
              else:
                neighbor_object.allowas_in._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('allowas_in_value', None)) != ''):
                neighbor_object.allowas_in_value = mapping_dict.get('allowas_in_value', None)
              else:
                neighbor_object.allowas_in_value._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('maximum_prefix', None)) != ''):
                neighbor_object.maximum_prefix = mapping_dict.get('maximum_prefix', None)
              else:
                neighbor_object.maximum_prefix._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('in_route_map', None)) != ''):
                neighbor_object.in_route_map = mapping_dict.get('in_route_map', None)
              else:
                neighbor_object.in_route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('out_route_map', None)) != ''):
                neighbor_object.out_route_map = mapping_dict.get('out_route_map', None)
              else:
                neighbor_object.out_route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ebgp_multihop', None)) != ''):
                neighbor_object.ebgp_multihop = mapping_dict.get('ebgp_multihop', None)
              else:
                neighbor_object.ebgp_multihop._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('keepalive_interval', None)) != ''):
                neighbor_object.keepalive_interval = mapping_dict.get('keepalive_interval', None)
              else:
                neighbor_object.keepalive_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('holdtime', None)) != ''):
                neighbor_object.holdtime = mapping_dict.get('holdtime', None)
              else:
                neighbor_object.holdtime._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('advertisement_interval', None)) != ''):
                neighbor_object.advertisement_interval = mapping_dict.get('advertisement_interval', None)
              else:
                neighbor_object.advertisement_interval._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
                neighbor_object.description = mapping_dict.get('description', None)
              else:
                neighbor_object.description._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('local_as_number', None)) != ''):
                neighbor_object.local_as_number = mapping_dict.get('local_as_number', None)
              else:
                neighbor_object.local_as_number._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('send_community', None)) != ''):
                neighbor_object.send_community = mapping_dict.get('send_community', None)
              else:
                neighbor_object.send_community._empty_tag = True
            except TypeError:
              pass
            neighbor_object_list.append(neighbor_object)

          return neighbor_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/aggregate-summary-network
      class aggregate_summary_network(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          aggregate_summary_network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for aggregate_summary_network_object in aggregate_summary_network_object_list:
            #fetch payload
            aggregate_summary_network_payload = aggregate_summary_network_object.getxml(filter=True)
            util.log_debug('aggregate_summary_network_payload %s'%aggregate_summary_network_payload)
            payload_list.append(aggregate_summary_network_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          aggregate_summary_network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for aggregate_summary_network_object in aggregate_summary_network_object_list:
            #fetch payload
            aggregate_summary_network_payload = aggregate_summary_network_object.getxml(filter=True)

            util.log_debug('aggregate_summary_network_payload %s'%aggregate_summary_network_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=aggregate_summary_network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          aggregate_summary_network_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          network = mapping_dict.get('network')
          if not isinstance(network, list):
            network = [network]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for network_iterator in network:
            rcpath_tmp =  rcpath+"/aggregate-summary-network=%s"%(util.make_interfacename(network_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, aggregate_summary_network_object in enumerate(aggregate_summary_network_object_list):
            #fetch payload
            aggregate_summary_network_payload = aggregate_summary_network_object.getxml(filter=True)

            util.log_debug('update aggregate_summary_network_payload %s'%aggregate_summary_network_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=aggregate_summary_network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('network')):
            raise Exception("'network' cannot be empty")

          #convert keys to list
          network = mapping_dict.get('network')
          if not isinstance(network, list):
            network = [network]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for network_iterator in network:
            rcpath_tmp =  rcpath+"/aggregate-summary-network=%s"%(util.make_interfacename(network_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('network')):
            raise Exception("'network' cannot be empty")

          #convert keys to list
          network = mapping_dict.get('network')
          if not isinstance(network, list):
            network = [network]

          #prepare payload
          aggregate_summary_network_object_list = []
          for network_iterator in network:
            from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
            aggregate_summary_network_object = router_bgp.aggregate_summary_network.aggregate_summary_network()
            aggregate_summary_network_object.network = network_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('aggregate_summary_only', None)) != ''):
                aggregate_summary_network_object.aggregate_summary_only = mapping_dict.get('aggregate_summary_only', None)
              else:
                aggregate_summary_network_object.aggregate_summary_only._empty_tag = True
            except TypeError:
              pass
            aggregate_summary_network_object_list.append(aggregate_summary_network_object)

          return aggregate_summary_network_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/network
      class network(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for network_object in network_object_list:
            #fetch payload
            network_payload = network_object.getxml(filter=True)
            util.log_debug('network_payload %s'%network_payload)
            payload_list.append(network_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for network_object in network_object_list:
            #fetch payload
            network_payload = network_object.getxml(filter=True)

            util.log_debug('network_payload %s'%network_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/network=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, network_object in enumerate(network_object_list):
            #fetch payload
            network_payload = network_object.getxml(filter=True)

            util.log_debug('update network_payload %s'%network_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/network=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare payload
          network_object_list = []
          for ip_address_iterator in ip_address:
            from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
            network_object = router_bgp.network.network()
            network_object.ip_address = ip_address_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
                network_object.netmask = mapping_dict.get('netmask', None)
              else:
                network_object.netmask._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
                network_object.route_map = mapping_dict.get('route_map', None)
              else:
                network_object.route_map._empty_tag = True
            except TypeError:
              pass
            network_object_list.append(network_object)

          return network_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/redistribute
      class redistribute(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          redistribute_object_list = self.validate_inputs_form_payload(mapping_dict)

          for redistribute_object in redistribute_object_list:
            #fetch payload
            redistribute_payload = redistribute_object.getxml(filter=True)
            util.log_debug('redistribute_payload %s'%redistribute_payload)
            payload_list.append(redistribute_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          redistribute_object_list = self.validate_inputs_form_payload(mapping_dict)

          for redistribute_object in redistribute_object_list:
            #fetch payload
            redistribute_payload = redistribute_object.getxml(filter=True)

            util.log_debug('redistribute_payload %s'%redistribute_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=redistribute_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          redistribute_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          protocol = mapping_dict.get('protocol')
          if not isinstance(protocol, list):
            protocol = [protocol]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for protocol_iterator in protocol:
            rcpath_tmp =  rcpath+"/redistribute=%s"%(util.make_interfacename(protocol_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, redistribute_object in enumerate(redistribute_object_list):
            #fetch payload
            redistribute_payload = redistribute_object.getxml(filter=True)

            util.log_debug('update redistribute_payload %s'%redistribute_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=redistribute_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('protocol')):
            raise Exception("'protocol' cannot be empty")

          #convert keys to list
          protocol = mapping_dict.get('protocol')
          if not isinstance(protocol, list):
            protocol = [protocol]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for protocol_iterator in protocol:
            rcpath_tmp =  rcpath+"/redistribute=%s"%(util.make_interfacename(protocol_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('protocol')):
            raise Exception("'protocol' cannot be empty")

          #convert keys to list
          protocol = mapping_dict.get('protocol')
          if not isinstance(protocol, list):
            protocol = [protocol]

          #prepare payload
          redistribute_object_list = []
          for protocol_iterator in protocol:
            from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
            redistribute_object = router_bgp.redistribute.redistribute()
            redistribute_object.protocol = protocol_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ospf_process_id', None)) != ''):
                redistribute_object.ospf_process_id = mapping_dict.get('ospf_process_id', None)
              else:
                redistribute_object.ospf_process_id._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('eigrp_process_id', None)) != ''):
                redistribute_object.eigrp_process_id = mapping_dict.get('eigrp_process_id', None)
              else:
                redistribute_object.eigrp_process_id._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('metric', None)) != ''):
                redistribute_object.metric = mapping_dict.get('metric', None)
              else:
                redistribute_object.metric._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
                redistribute_object.route_map = mapping_dict.get('route_map', None)
              else:
                redistribute_object.route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('disable_sync', None)) != ''):
                redistribute_object.disable_sync = mapping_dict.get('disable_sync', None)
              else:
                redistribute_object.disable_sync._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('graceful_restart', None)) != ''):
                redistribute_object.graceful_restart = mapping_dict.get('graceful_restart', None)
              else:
                redistribute_object.graceful_restart._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('redistribute_connected', None)) != ''):
                redistribute_object.redistribute_connected = mapping_dict.get('redistribute_connected', None)
              else:
                redistribute_object.redistribute_connected._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ospf_internal', None)) != ''):
                redistribute_object.ospf_internal = mapping_dict.get('ospf_internal', None)
              else:
                redistribute_object.ospf_internal._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ospf_external1', None)) != ''):
                redistribute_object.ospf_external1 = mapping_dict.get('ospf_external1', None)
              else:
                redistribute_object.ospf_external1._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ospf_external2', None)) != ''):
                redistribute_object.ospf_external2 = mapping_dict.get('ospf_external2', None)
              else:
                redistribute_object.ospf_external2._empty_tag = True
            except TypeError:
              pass
            redistribute_object_list.append(redistribute_object)

          return redistribute_object_list

      #XPATH devices/device/vrfs/vrf/router-bgp/group
      class group(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          group_object_list = self.validate_inputs_form_payload(mapping_dict)

          for group_object in group_object_list:
            #fetch payload
            group_payload = group_object.getxml(filter=True)
            util.log_debug('group_payload %s'%group_payload)
            payload_list.append(group_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          group_object_list = self.validate_inputs_form_payload(mapping_dict)

          for group_object in group_object_list:
            #fetch payload
            group_payload = group_object.getxml(filter=True)

            util.log_debug('group_payload %s'%group_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          group_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/group=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, group_object in enumerate(group_object_list):
            #fetch payload
            group_payload = group_object.getxml(filter=True)

            util.log_debug('update group_payload %s'%group_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=group_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/group=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare payload
          group_object_list = []
          for name_iterator in name:
            from servicemodel.controller.devices.device.vrfs.vrf import router_bgp
            group_object = router_bgp.group.group()
            group_object.name = name_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('family', None)) != ''):
                group_object.family = mapping_dict.get('family', None)
              else:
                group_object.family._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('auth_key', None)) != ''):
                group_object.auth_key = mapping_dict.get('auth_key', None)
              else:
                group_object.auth_key._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('type', None)) != ''):
                group_object.type = mapping_dict.get('type', None)
              else:
                group_object.type._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('remote_as', None)) != ''):
                group_object.remote_as = mapping_dict.get('remote_as', None)
              else:
                group_object.remote_as._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('metric_out', None)) != ''):
                group_object.metric_out = mapping_dict.get('metric_out', None)
              else:
                group_object.metric_out._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('hold_time', None)) != ''):
                group_object.hold_time = mapping_dict.get('hold_time', None)
              else:
                group_object.hold_time._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('prefix_limit_max', None)) != ''):
                group_object.prefix_limit_max = mapping_dict.get('prefix_limit_max', None)
              else:
                group_object.prefix_limit_max._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('tear_down', None)) != ''):
                group_object.tear_down = mapping_dict.get('tear_down', None)
              else:
                group_object.tear_down._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('idle_timeout', None)) != ''):
                group_object.idle_timeout = mapping_dict.get('idle_timeout', None)
              else:
                group_object.idle_timeout._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('advertise_inactive', None)) != ''):
                group_object.advertise_inactive = mapping_dict.get('advertise_inactive', None)
              else:
                group_object.advertise_inactive._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('remove_private', None)) != ''):
                group_object.remove_private = mapping_dict.get('remove_private', None)
              else:
                group_object.remove_private._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('graceful_restart', None)) != ''):
                group_object.graceful_restart = mapping_dict.get('graceful_restart', None)
              else:
                group_object.graceful_restart._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('log_updown', None)) != ''):
                group_object.log_updown = mapping_dict.get('log_updown', None)
              else:
                group_object.log_updown._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('rib_group', None)) != ''):
                group_object.rib_group = mapping_dict.get('rib_group', None)
              else:
                group_object.rib_group._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('cluster_id', None)) != ''):
                group_object.cluster_id = mapping_dict.get('cluster_id', None)
              else:
                group_object.cluster_id._empty_tag = True
            except TypeError:
              pass
            group_object_list.append(group_object)

          return group_object_list

        #XPATH devices/device/vrfs/vrf/router-bgp/group/neighbor
        class neighbor(AbstractDeviceMgr):
          key_hints = [['name'],['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, group_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

            for neighbor_object in neighbor_object_list:
              #fetch payload
              neighbor_payload = neighbor_object.getxml(filter=True)
              util.log_debug('neighbor_payload %s'%neighbor_payload)
              payload_list.append(neighbor_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

            for neighbor_object in neighbor_object_list:
              #fetch payload
              neighbor_payload = neighbor_object.getxml(filter=True)

              util.log_debug('neighbor_payload %s'%neighbor_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            ip_address = mapping_dict.get('ip_address')
            if not isinstance(ip_address, list):
              ip_address = [ip_address]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for ip_address_iterator in ip_address:
              rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(ip_address_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, neighbor_object in enumerate(neighbor_object_list):
              #fetch payload
              neighbor_payload = neighbor_object.getxml(filter=True)

              util.log_debug('update neighbor_payload %s'%neighbor_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, group_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('ip_address')):
              raise Exception("'ip_address' cannot be empty")

            #convert keys to list
            ip_address = mapping_dict.get('ip_address')
            if not isinstance(ip_address, list):
              ip_address = [ip_address]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for ip_address_iterator in ip_address:
              rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(ip_address_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, group_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(group_name):
              raise Exception("'group_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('ip_address')):
              raise Exception("'ip_address' cannot be empty")

            #convert keys to list
            ip_address = mapping_dict.get('ip_address')
            if not isinstance(ip_address, list):
              ip_address = [ip_address]

            #prepare payload
            neighbor_object_list = []
            for ip_address_iterator in ip_address:
              from servicemodel.controller.devices.device.vrfs.vrf.router_bgp import group
              neighbor_object = group.neighbor.neighbor()
              neighbor_object.ip_address = ip_address_iterator
              neighbor_object_list.append(neighbor_object)

            return neighbor_object_list

        #XPATH devices/device/vrfs/vrf/router-bgp/group/neighbor-ipv6
        class neighbor_ipv6(AbstractDeviceMgr):
          key_hints = [['name'],['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, group_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            neighbor_ipv6_object_list = self.validate_inputs_form_payload(mapping_dict)

            for neighbor_ipv6_object in neighbor_ipv6_object_list:
              #fetch payload
              neighbor_ipv6_payload = neighbor_ipv6_object.getxml(filter=True)
              util.log_debug('neighbor_ipv6_payload %s'%neighbor_ipv6_payload)
              payload_list.append(neighbor_ipv6_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            neighbor_ipv6_object_list = self.validate_inputs_form_payload(mapping_dict)

            for neighbor_ipv6_object in neighbor_ipv6_object_list:
              #fetch payload
              neighbor_ipv6_payload = neighbor_ipv6_object.getxml(filter=True)

              util.log_debug('neighbor_ipv6_payload %s'%neighbor_ipv6_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=neighbor_ipv6_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            neighbor_ipv6_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            ipv6_address = mapping_dict.get('ipv6_address')
            if not isinstance(ipv6_address, list):
              ipv6_address = [ipv6_address]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for ipv6_address_iterator in ipv6_address:
              rcpath_tmp =  rcpath+"/neighbor-ipv6=%s"%(util.make_interfacename(ipv6_address_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, neighbor_ipv6_object in enumerate(neighbor_ipv6_object_list):
              #fetch payload
              neighbor_ipv6_payload = neighbor_ipv6_object.getxml(filter=True)

              util.log_debug('update neighbor_ipv6_payload %s'%neighbor_ipv6_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=neighbor_ipv6_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, group_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('ipv6_address')):
              raise Exception("'ipv6_address' cannot be empty")

            #convert keys to list
            ipv6_address = mapping_dict.get('ipv6_address')
            if not isinstance(ipv6_address, list):
              ipv6_address = [ipv6_address]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for ipv6_address_iterator in ipv6_address:
              rcpath_tmp =  rcpath+"/neighbor-ipv6=%s"%(util.make_interfacename(ipv6_address_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, group_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(group_name):
              raise Exception("'group_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('ipv6_address')):
              raise Exception("'ipv6_address' cannot be empty")

            #convert keys to list
            ipv6_address = mapping_dict.get('ipv6_address')
            if not isinstance(ipv6_address, list):
              ipv6_address = [ipv6_address]

            #prepare payload
            neighbor_ipv6_object_list = []
            for ipv6_address_iterator in ipv6_address:
              from servicemodel.controller.devices.device.vrfs.vrf.router_bgp import group
              neighbor_ipv6_object = group.neighbor_ipv6.neighbor_ipv6()
              neighbor_ipv6_object.ipv6_address = ipv6_address_iterator
              neighbor_ipv6_object_list.append(neighbor_ipv6_object)

            return neighbor_ipv6_object_list

        #XPATH devices/device/vrfs/vrf/router-bgp/group/import-policy
        class import_policy(AbstractDeviceMgr):
          key_hints = [['name'],['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, group_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            import_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

            for import_policy_object in import_policy_object_list:
              #fetch payload
              import_policy_payload = import_policy_object.getxml(filter=True)
              util.log_debug('import_policy_payload %s'%import_policy_payload)
              payload_list.append(import_policy_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            import_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

            for import_policy_object in import_policy_object_list:
              #fetch payload
              import_policy_payload = import_policy_object.getxml(filter=True)

              util.log_debug('import_policy_payload %s'%import_policy_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=import_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            import_policy_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for name_iterator in name:
              rcpath_tmp =  rcpath+"/import-policy=%s"%(util.make_interfacename(name_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, import_policy_object in enumerate(import_policy_object_list):
              #fetch payload
              import_policy_payload = import_policy_object.getxml(filter=True)

              util.log_debug('update import_policy_payload %s'%import_policy_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=import_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, group_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('name')):
              raise Exception("'name' cannot be empty")

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for name_iterator in name:
              rcpath_tmp =  rcpath+"/import-policy=%s"%(util.make_interfacename(name_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, group_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(group_name):
              raise Exception("'group_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('name')):
              raise Exception("'name' cannot be empty")

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare payload
            import_policy_object_list = []
            for name_iterator in name:
              from servicemodel.controller.devices.device.vrfs.vrf.router_bgp import group
              import_policy_object = group.import_policy.import_policy()
              import_policy_object.name = name_iterator
              import_policy_object_list.append(import_policy_object)

            return import_policy_object_list

        #XPATH devices/device/vrfs/vrf/router-bgp/group/export-policy
        class export_policy(AbstractDeviceMgr):
          key_hints = [['name'],['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, group_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            export_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

            for export_policy_object in export_policy_object_list:
              #fetch payload
              export_policy_payload = export_policy_object.getxml(filter=True)
              util.log_debug('export_policy_payload %s'%export_policy_payload)
              payload_list.append(export_policy_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            export_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

            for export_policy_object in export_policy_object_list:
              #fetch payload
              export_policy_payload = export_policy_object.getxml(filter=True)

              util.log_debug('export_policy_payload %s'%export_policy_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=export_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, group_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            export_policy_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for name_iterator in name:
              rcpath_tmp =  rcpath+"/export-policy=%s"%(util.make_interfacename(name_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, export_policy_object in enumerate(export_policy_object_list):
              #fetch payload
              export_policy_payload = export_policy_object.getxml(filter=True)

              util.log_debug('update export_policy_payload %s'%export_policy_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=export_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, group_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, group_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(group_name, list):
              group_name_list = [group_name]
            else:
              group_name_list = group_name

            for vrf_name in vrf_name_list:
              for group_name in group_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-bgp/group=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(group_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('name')):
              raise Exception("'name' cannot be empty")

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for name_iterator in name:
              rcpath_tmp =  rcpath+"/export-policy=%s"%(util.make_interfacename(name_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, group_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(group_name):
              raise Exception("'group_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('name')):
              raise Exception("'name' cannot be empty")

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare payload
            export_policy_object_list = []
            for name_iterator in name:
              from servicemodel.controller.devices.device.vrfs.vrf.router_bgp import group
              export_policy_object = group.export_policy.export_policy()
              export_policy_object.name = name_iterator
              export_policy_object_list.append(export_policy_object)

            return export_policy_object_list

    #XPATH devices/device/vrfs/vrf/router-ospf
    class router_ospf(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_ospf_object_list = self.validate_inputs_form_payload(mapping_dict)

        for router_ospf_object in router_ospf_object_list:
          #fetch payload
          router_ospf_payload = router_ospf_object.getxml(filter=True)
          util.log_debug('router_ospf_payload %s'%router_ospf_payload)
          payload_list.append(router_ospf_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_ospf_object_list = self.validate_inputs_form_payload(mapping_dict)

        for router_ospf_object in router_ospf_object_list:
          #fetch payload
          router_ospf_payload = router_ospf_object.getxml(filter=True)

          util.log_debug('router_ospf_payload %s'%router_ospf_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=router_ospf_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_ospf_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list
        process_id = mapping_dict.get('process_id')
        if not isinstance(process_id, list):
          process_id = [process_id]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for process_id_iterator in process_id:
          rcpath_tmp =  rcpath+"/router-ospf=%s"%(util.make_interfacename(process_id_iterator))
          rcpath_list.append(rcpath_tmp)
        for rc_counter, router_ospf_object in enumerate(router_ospf_object_list):
          #fetch payload
          router_ospf_payload = router_ospf_object.getxml(filter=True)

          util.log_debug('update router_ospf_payload %s'%router_ospf_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=router_ospf_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs
        if util.isEmpty(mapping_dict.get('process_id')):
          raise Exception("'process_id' cannot be empty")

        #convert keys to list
        process_id = mapping_dict.get('process_id')
        if not isinstance(process_id, list):
          process_id = [process_id]

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        for process_id_iterator in process_id:
          rcpath_tmp =  rcpath+"/router-ospf=%s"%(util.make_interfacename(process_id_iterator))
          rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs
        if util.isEmpty(mapping_dict.get('process_id')):
          raise Exception("'process_id' cannot be empty")

        #convert keys to list
        process_id = mapping_dict.get('process_id')
        if not isinstance(process_id, list):
          process_id = [process_id]

        #prepare payload
        router_ospf_object_list = []
        for process_id_iterator in process_id:
          from servicemodel.controller.devices.device.vrfs import vrf
          router_ospf_object = vrf.router_ospf.router_ospf()
          router_ospf_object.process_id = process_id_iterator
          try:
            if (update == False) or (update == True and str(mapping_dict.get('router_id', None)) != ''):
              router_ospf_object.router_id = mapping_dict.get('router_id', None)
            else:
              router_ospf_object.router_id._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('vrf_lite', None)) != ''):
              router_ospf_object.vrf_lite = mapping_dict.get('vrf_lite', None)
            else:
              router_ospf_object.vrf_lite._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('reference_bandwidth', None)) != ''):
              router_ospf_object.reference_bandwidth = mapping_dict.get('reference_bandwidth', None)
            else:
              router_ospf_object.reference_bandwidth._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('context', None)) != ''):
              router_ospf_object.context = mapping_dict.get('context', None)
            else:
              router_ospf_object.context._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('community', None)) != ''):
              router_ospf_object.community = mapping_dict.get('community', None)
            else:
              router_ospf_object.community._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('access', None)) != ''):
              router_ospf_object.access = mapping_dict.get('access', None)
            else:
              router_ospf_object.access._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('acl_name', None)) != ''):
              router_ospf_object.acl_name = mapping_dict.get('acl_name', None)
            else:
              router_ospf_object.acl_name._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('maximum_paths', None)) != ''):
              router_ospf_object.maximum_paths = mapping_dict.get('maximum_paths', None)
            else:
              router_ospf_object.maximum_paths._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_information', None)) != ''):
              router_ospf_object.default_information = mapping_dict.get('default_information', None)
            else:
              router_ospf_object.default_information._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_inf_metric', None)) != ''):
              router_ospf_object._set_default_inf_metric(mapping_dict.get('default_inf_metric', None))
            else:
              router_ospf_object._unset_default_inf_metric()
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_inf_metric1', None)) != ''):
              router_ospf_object._set_default_inf_metric1(mapping_dict.get('default_inf_metric1', None))
            else:
              router_ospf_object._unset_default_inf_metric1()
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_inf_metric2', None)) != ''):
              router_ospf_object._set_default_inf_metric2(mapping_dict.get('default_inf_metric2', None))
            else:
              router_ospf_object._unset_default_inf_metric2()
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_inf_value', None)) != ''):
              router_ospf_object.default_inf_value = mapping_dict.get('default_inf_value', None)
            else:
              router_ospf_object.default_inf_value._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_inf_value1', None)) != ''):
              router_ospf_object.default_inf_value1 = mapping_dict.get('default_inf_value1', None)
            else:
              router_ospf_object.default_inf_value1._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('default_inf_value2', None)) != ''):
              router_ospf_object.default_inf_value2 = mapping_dict.get('default_inf_value2', None)
            else:
              router_ospf_object.default_inf_value2._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('dis_list_route_map', None)) != ''):
              router_ospf_object.dis_list_route_map = mapping_dict.get('dis_list_route_map', None)
            else:
              router_ospf_object.dis_list_route_map._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('dis_list_route_update', None)) != ''):
              router_ospf_object.dis_list_route_update = mapping_dict.get('dis_list_route_update', None)
            else:
              router_ospf_object.dis_list_route_update._empty_tag = True
          except TypeError:
            pass
          router_ospf_object_list.append(router_ospf_object)

        return router_ospf_object_list

      #XPATH devices/device/vrfs/vrf/router-ospf/neighbor
      class neighbor(AbstractDeviceMgr):
        key_hints = [['name'],['process_id']]
        def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

          for neighbor_object in neighbor_object_list:
            #fetch payload
            neighbor_payload = neighbor_object.getxml(filter=True)
            util.log_debug('neighbor_payload %s'%neighbor_payload)
            payload_list.append(neighbor_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          neighbor_object_list = self.validate_inputs_form_payload(mapping_dict)

          for neighbor_object in neighbor_object_list:
            #fetch payload
            neighbor_payload = neighbor_object.getxml(filter=True)

            util.log_debug('neighbor_payload %s'%neighbor_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          neighbor_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, neighbor_object in enumerate(neighbor_object_list):
            #fetch payload
            neighbor_payload = neighbor_object.getxml(filter=True)

            util.log_debug('update neighbor_payload %s'%neighbor_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=neighbor_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/neighbor=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name, router_ospf_process_id):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")
          if util.isEmpty(router_ospf_process_id):
            raise Exception("'router_ospf_process_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare payload
          neighbor_object_list = []
          for ip_address_iterator in ip_address:
            from servicemodel.controller.devices.device.vrfs.vrf import router_ospf
            neighbor_object = router_ospf.neighbor.neighbor()
            neighbor_object.ip_address = ip_address_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ipv6_address', None)) != ''):
                neighbor_object.ipv6_address = mapping_dict.get('ipv6_address', None)
              else:
                neighbor_object.ipv6_address._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
                neighbor_object.netmask = mapping_dict.get('netmask', None)
              else:
                neighbor_object.netmask._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('local_interface', None)) != ''):
                neighbor_object.local_interface = mapping_dict.get('local_interface', None)
              else:
                neighbor_object.local_interface._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('area', None)) != ''):
                neighbor_object.area = mapping_dict.get('area', None)
              else:
                neighbor_object.area._empty_tag = True
            except TypeError:
              pass
            neighbor_object_list.append(neighbor_object)

          return neighbor_object_list

      #XPATH devices/device/vrfs/vrf/router-ospf/interface
      class interface(AbstractDeviceMgr):
        key_hints = [['name'],['process_id']]
        def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for interface_object in interface_object_list:
            #fetch payload
            interface_payload = interface_object.getxml(filter=True)
            util.log_debug('interface_payload %s'%interface_payload)
            payload_list.append(interface_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for interface_object in interface_object_list:
            #fetch payload
            interface_payload = interface_object.getxml(filter=True)

            util.log_debug('interface_payload %s'%interface_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          interface_name = mapping_dict.get('interface_name')
          if not isinstance(interface_name, list):
            interface_name = [interface_name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for interface_name_iterator in interface_name:
            rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(interface_name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, interface_object in enumerate(interface_object_list):
            #fetch payload
            interface_payload = interface_object.getxml(filter=True)

            util.log_debug('update interface_payload %s'%interface_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('interface_name')):
            raise Exception("'interface_name' cannot be empty")

          #convert keys to list
          interface_name = mapping_dict.get('interface_name')
          if not isinstance(interface_name, list):
            interface_name = [interface_name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for interface_name_iterator in interface_name:
            rcpath_tmp =  rcpath+"/interface=%s"%(util.make_interfacename(interface_name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name, router_ospf_process_id):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")
          if util.isEmpty(router_ospf_process_id):
            raise Exception("'router_ospf_process_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('interface_name')):
            raise Exception("'interface_name' cannot be empty")

          #convert keys to list
          interface_name = mapping_dict.get('interface_name')
          if not isinstance(interface_name, list):
            interface_name = [interface_name]

          #prepare payload
          interface_object_list = []
          for interface_name_iterator in interface_name:
            from servicemodel.controller.devices.device.vrfs.vrf import router_ospf
            interface_object = router_ospf.interface.interface()
            interface_object.interface_name = interface_name_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('interface_mode', None)) != ''):
                interface_object.interface_mode = mapping_dict.get('interface_mode', None)
              else:
                interface_object.interface_mode._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('zone_name', None)) != ''):
                interface_object.zone_name = mapping_dict.get('zone_name', None)
              else:
                interface_object.zone_name._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('area', None)) != ''):
                interface_object.area = mapping_dict.get('area', None)
              else:
                interface_object.area._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('cost', None)) != ''):
                interface_object.cost = mapping_dict.get('cost', None)
              else:
                interface_object.cost._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('mtu', None)) != ''):
                interface_object.mtu = mapping_dict.get('mtu', None)
              else:
                interface_object.mtu._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('priority', None)) != ''):
                interface_object.priority = mapping_dict.get('priority', None)
              else:
                interface_object.priority._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('network_type', None)) != ''):
                interface_object.network_type = mapping_dict.get('network_type', None)
              else:
                interface_object.network_type._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('auth_type', None)) != ''):
                interface_object.auth_type = mapping_dict.get('auth_type', None)
              else:
                interface_object.auth_type._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('md5_key', None)) != ''):
                interface_object.md5_key = mapping_dict.get('md5_key', None)
              else:
                interface_object.md5_key._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('key_id', None)) != ''):
                interface_object.key_id = mapping_dict.get('key_id', None)
              else:
                interface_object.key_id._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('bfd', None)) != ''):
                interface_object.bfd = mapping_dict.get('bfd', None)
              else:
                interface_object.bfd._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('ignore_mtu_check', None)) != ''):
                interface_object.ignore_mtu_check = mapping_dict.get('ignore_mtu_check', None)
              else:
                interface_object.ignore_mtu_check._empty_tag = True
            except TypeError:
              pass
            interface_object_list.append(interface_object)

          return interface_object_list

      #XPATH devices/device/vrfs/vrf/router-ospf/network
      class network(AbstractDeviceMgr):
        key_hints = [['name'],['process_id']]
        def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for network_object in network_object_list:
            #fetch payload
            network_payload = network_object.getxml(filter=True)
            util.log_debug('network_payload %s'%network_payload)
            payload_list.append(network_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for network_object in network_object_list:
            #fetch payload
            network_payload = network_object.getxml(filter=True)

            util.log_debug('network_payload %s'%network_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/network=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, network_object in enumerate(network_object_list):
            #fetch payload
            network_payload = network_object.getxml(filter=True)

            util.log_debug('update network_payload %s'%network_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/network=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name, router_ospf_process_id):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")
          if util.isEmpty(router_ospf_process_id):
            raise Exception("'router_ospf_process_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare payload
          network_object_list = []
          for ip_address_iterator in ip_address:
            from servicemodel.controller.devices.device.vrfs.vrf import router_ospf
            network_object = router_ospf.network.network()
            network_object.ip_address = ip_address_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
                network_object.netmask = mapping_dict.get('netmask', None)
              else:
                network_object.netmask._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
                network_object.route_map = mapping_dict.get('route_map', None)
              else:
                network_object.route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('wild_card', None)) != ''):
                network_object.wild_card = mapping_dict.get('wild_card', None)
              else:
                network_object.wild_card._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('area', None)) != ''):
                network_object.area = mapping_dict.get('area', None)
              else:
                network_object.area._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('nssa', None)) != ''):
                network_object.nssa = mapping_dict.get('nssa', None)
              else:
                network_object.nssa._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('translate', None)) != ''):
                network_object.translate = mapping_dict.get('translate', None)
              else:
                network_object.translate._empty_tag = True
            except TypeError:
              pass
            network_object_list.append(network_object)

          return network_object_list

      class redistribute(object):
        #XPATH devices/device/vrfs/vrf/router-ospf/redistribute/ospf-redistribute
        class ospf_redistribute(AbstractDeviceMgr):
          key_hints = [['name'],['process_id']]
          def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, router_ospf_process_id)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(router_ospf_process_id, list):
              router_ospf_process_id_list = [router_ospf_process_id]
            else:
              router_ospf_process_id_list = router_ospf_process_id

            for vrf_name in vrf_name_list:
              for router_ospf_process_id in router_ospf_process_id_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s/redistribute"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            ospf_redistribute_object_list = self.validate_inputs_form_payload(mapping_dict)

            for ospf_redistribute_object in ospf_redistribute_object_list:
              #fetch payload
              ospf_redistribute_payload = ospf_redistribute_object.getxml(filter=True)
              util.log_debug('ospf_redistribute_payload %s'%ospf_redistribute_payload)
              payload_list.append(ospf_redistribute_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, router_ospf_process_id)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(router_ospf_process_id, list):
              router_ospf_process_id_list = [router_ospf_process_id]
            else:
              router_ospf_process_id_list = router_ospf_process_id

            for vrf_name in vrf_name_list:
              for router_ospf_process_id in router_ospf_process_id_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s/redistribute"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            ospf_redistribute_object_list = self.validate_inputs_form_payload(mapping_dict)

            for ospf_redistribute_object in ospf_redistribute_object_list:
              #fetch payload
              ospf_redistribute_payload = ospf_redistribute_object.getxml(filter=True)

              util.log_debug('ospf_redistribute_payload %s'%ospf_redistribute_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=ospf_redistribute_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, router_ospf_process_id)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s/redistribute"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            ospf_redistribute_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            protocol = mapping_dict.get('protocol')
            if not isinstance(protocol, list):
              protocol = [protocol]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for protocol_iterator in protocol:
              rcpath_tmp =  rcpath+"/ospf-redistribute=%s"%(util.make_interfacename(protocol_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, ospf_redistribute_object in enumerate(ospf_redistribute_object_list):
              #fetch payload
              ospf_redistribute_payload = ospf_redistribute_object.getxml(filter=True)

              util.log_debug('update ospf_redistribute_payload %s'%ospf_redistribute_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=ospf_redistribute_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, router_ospf_process_id)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(router_ospf_process_id, list):
              router_ospf_process_id_list = [router_ospf_process_id]
            else:
              router_ospf_process_id_list = router_ospf_process_id

            for vrf_name in vrf_name_list:
              for router_ospf_process_id in router_ospf_process_id_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s/redistribute"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('protocol')):
              raise Exception("'protocol' cannot be empty")

            #convert keys to list
            protocol = mapping_dict.get('protocol')
            if not isinstance(protocol, list):
              protocol = [protocol]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for protocol_iterator in protocol:
              rcpath_tmp =  rcpath+"/ospf-redistribute=%s"%(util.make_interfacename(protocol_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, router_ospf_process_id):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(router_ospf_process_id):
              raise Exception("'router_ospf_process_id' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('protocol')):
              raise Exception("'protocol' cannot be empty")

            #convert keys to list
            protocol = mapping_dict.get('protocol')
            if not isinstance(protocol, list):
              protocol = [protocol]

            #prepare payload
            ospf_redistribute_object_list = []
            for protocol_iterator in protocol:
              from servicemodel.controller.devices.device.vrfs.vrf.router_ospf import redistribute
              ospf_redistribute_object = redistribute.ospf_redistribute.ospf_redistribute()
              ospf_redistribute_object.protocol = protocol_iterator
              try:
                if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
                  ospf_redistribute_object.route_map = mapping_dict.get('route_map', None)
                else:
                  ospf_redistribute_object.route_map._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('metric1', None)) != ''):
                  ospf_redistribute_object._set_metric1(mapping_dict.get('metric1', None))
                else:
                  ospf_redistribute_object._unset_metric1()
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('metric2', None)) != ''):
                  ospf_redistribute_object._set_metric2(mapping_dict.get('metric2', None))
                else:
                  ospf_redistribute_object._unset_metric2()
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('value1', None)) != ''):
                  ospf_redistribute_object.value1 = mapping_dict.get('value1', None)
                else:
                  ospf_redistribute_object.value1._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('value2', None)) != ''):
                  ospf_redistribute_object.value2 = mapping_dict.get('value2', None)
                else:
                  ospf_redistribute_object.value2._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('bgp_as_number', None)) != ''):
                  ospf_redistribute_object.bgp_as_number = mapping_dict.get('bgp_as_number', None)
                else:
                  ospf_redistribute_object.bgp_as_number._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('process_id_entry', None)) != ''):
                  ospf_redistribute_object.process_id_entry = mapping_dict.get('process_id_entry', None)
                else:
                  ospf_redistribute_object.process_id_entry._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('eigrp_as_number', None)) != ''):
                  ospf_redistribute_object.eigrp_as_number = mapping_dict.get('eigrp_as_number', None)
                else:
                  ospf_redistribute_object.eigrp_as_number._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('metric', None)) != ''):
                  ospf_redistribute_object.metric = mapping_dict.get('metric', None)
                else:
                  ospf_redistribute_object.metric._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('metric_type', None)) != ''):
                  ospf_redistribute_object.metric_type = mapping_dict.get('metric_type', None)
                else:
                  ospf_redistribute_object.metric_type._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('subnet', None)) != ''):
                  ospf_redistribute_object.subnet = mapping_dict.get('subnet', None)
                else:
                  ospf_redistribute_object.subnet._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('tag', None)) != ''):
                  ospf_redistribute_object.tag = mapping_dict.get('tag', None)
                else:
                  ospf_redistribute_object.tag._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('nssa_only', None)) != ''):
                  ospf_redistribute_object.nssa_only = mapping_dict.get('nssa_only', None)
                else:
                  ospf_redistribute_object.nssa_only._empty_tag = True
              except TypeError:
                pass
              ospf_redistribute_object_list.append(ospf_redistribute_object)

            return ospf_redistribute_object_list

      #XPATH devices/device/vrfs/vrf/router-ospf/summary
      class summary(AbstractDeviceMgr):
        key_hints = [['name'],['process_id']]
        def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          summary_object_list = self.validate_inputs_form_payload(mapping_dict)

          for summary_object in summary_object_list:
            #fetch payload
            summary_payload = summary_object.getxml(filter=True)
            util.log_debug('summary_payload %s'%summary_payload)
            payload_list.append(summary_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          summary_object_list = self.validate_inputs_form_payload(mapping_dict)

          for summary_object in summary_object_list:
            #fetch payload
            summary_payload = summary_object.getxml(filter=True)

            util.log_debug('summary_payload %s'%summary_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=summary_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          summary_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/summary"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, summary_object in enumerate(summary_object_list):
            #fetch payload
            summary_payload = summary_object.getxml(filter=True)

            util.log_debug('update summary_payload %s'%summary_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=summary_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/summary"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name, router_ospf_process_id):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")
          if util.isEmpty(router_ospf_process_id):
            raise Exception("'router_ospf_process_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          summary_object_list = []
          from servicemodel.controller.devices.device.vrfs.vrf import router_ospf
          summary_object = router_ospf.summary.summary()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('ip_address', None)) != ''):
              summary_object.ip_address = mapping_dict.get('ip_address', None)
            else:
              summary_object.ip_address._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
              summary_object.netmask = mapping_dict.get('netmask', None)
            else:
              summary_object.netmask._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
              summary_object.route_map = mapping_dict.get('route_map', None)
            else:
              summary_object.route_map._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('not_advertise', None)) != ''):
              summary_object.not_advertise = mapping_dict.get('not_advertise', None)
            else:
              summary_object.not_advertise._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('nssa_only', None)) != ''):
              summary_object.nssa_only = mapping_dict.get('nssa_only', None)
            else:
              summary_object.nssa_only._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('tag', None)) != ''):
              summary_object.tag = mapping_dict.get('tag', None)
            else:
              summary_object.tag._empty_tag = True
          except TypeError:
            pass
          summary_object_list.append(summary_object)

          return summary_object_list

      #XPATH devices/device/vrfs/vrf/router-ospf/passive-interface
      class passive_interface(AbstractDeviceMgr):
        key_hints = [['name'],['process_id']]
        def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          passive_interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for passive_interface_object in passive_interface_object_list:
            #fetch payload
            passive_interface_payload = passive_interface_object.getxml(filter=True)
            util.log_debug('passive_interface_payload %s'%passive_interface_payload)
            payload_list.append(passive_interface_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          passive_interface_object_list = self.validate_inputs_form_payload(mapping_dict)

          for passive_interface_object in passive_interface_object_list:
            #fetch payload
            passive_interface_payload = passive_interface_object.getxml(filter=True)

            util.log_debug('passive_interface_payload %s'%passive_interface_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=passive_interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          passive_interface_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/passive-interface"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, passive_interface_object in enumerate(passive_interface_object_list):
            #fetch payload
            passive_interface_payload = passive_interface_object.getxml(filter=True)

            util.log_debug('update passive_interface_payload %s'%passive_interface_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=passive_interface_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/passive-interface"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name, router_ospf_process_id):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")
          if util.isEmpty(router_ospf_process_id):
            raise Exception("'router_ospf_process_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          passive_interface_object_list = []
          from servicemodel.controller.devices.device.vrfs.vrf import router_ospf
          passive_interface_object = router_ospf.passive_interface.passive_interface()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('passive_interface_default', None)) != ''):
              passive_interface_object.passive_interface_default = mapping_dict.get('passive_interface_default', None)
            else:
              passive_interface_object.passive_interface_default._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('no_passive_interface_name', None)) != ''):
              passive_interface_object.no_passive_interface_name = mapping_dict.get('no_passive_interface_name', None)
            else:
              passive_interface_object.no_passive_interface_name._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('loopback_passive_interface_name', None)) != ''):
              passive_interface_object.loopback_passive_interface_name = mapping_dict.get('loopback_passive_interface_name', None)
            else:
              passive_interface_object.loopback_passive_interface_name._empty_tag = True
          except TypeError:
            pass
          passive_interface_object_list.append(passive_interface_object)

          return passive_interface_object_list

      #XPATH devices/device/vrfs/vrf/router-ospf/inject-default-route
      class inject_default_route(AbstractDeviceMgr):
        key_hints = [['name'],['process_id']]
        def getRcpathPayload(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          inject_default_route_object_list = self.validate_inputs_form_payload(mapping_dict)

          for inject_default_route_object in inject_default_route_object_list:
            #fetch payload
            inject_default_route_payload = inject_default_route_object.getxml(filter=True)
            util.log_debug('inject_default_route_payload %s'%inject_default_route_payload)
            payload_list.append(inject_default_route_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          inject_default_route_object_list = self.validate_inputs_form_payload(mapping_dict)

          for inject_default_route_object in inject_default_route_object_list:
            #fetch payload
            inject_default_route_payload = inject_default_route_object.getxml(filter=True)

            util.log_debug('inject_default_route_payload %s'%inject_default_route_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=inject_default_route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          inject_default_route_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/inject-default-route"
          rcpath_list.append(rcpath_tmp)
          for rc_counter, inject_default_route_object in enumerate(inject_default_route_object_list):
            #fetch payload
            inject_default_route_payload = inject_default_route_object.getxml(filter=True)

            util.log_debug('update inject_default_route_payload %s'%inject_default_route_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=inject_default_route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, router_ospf_process_id, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name, router_ospf_process_id)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name
          if not isinstance(router_ospf_process_id, list):
            router_ospf_process_id_list = [router_ospf_process_id]
          else:
            router_ospf_process_id_list = router_ospf_process_id

          for vrf_name in vrf_name_list:
            for router_ospf_process_id in router_ospf_process_id_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-ospf=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(router_ospf_process_id))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs

          #convert keys to list

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          rcpath_tmp =  rcpath+"/inject-default-route"
          rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name, router_ospf_process_id):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")
          if util.isEmpty(router_ospf_process_id):
            raise Exception("'router_ospf_process_id' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs

          #convert keys to list

          #prepare payload
          inject_default_route_object_list = []
          from servicemodel.controller.devices.device.vrfs.vrf import router_ospf
          inject_default_route_object = router_ospf.inject_default_route.inject_default_route()
          try:
            if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
              inject_default_route_object.route_map = mapping_dict.get('route_map', None)
            else:
              inject_default_route_object.route_map._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('always', None)) != ''):
              inject_default_route_object.always = mapping_dict.get('always', None)
            else:
              inject_default_route_object.always._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('metric', None)) != ''):
              inject_default_route_object.metric = mapping_dict.get('metric', None)
            else:
              inject_default_route_object.metric._empty_tag = True
          except TypeError:
            pass
          try:
            if (update == False) or (update == True and str(mapping_dict.get('metric_type', None)) != ''):
              inject_default_route_object.metric_type = mapping_dict.get('metric_type', None)
            else:
              inject_default_route_object.metric_type._empty_tag = True
          except TypeError:
            pass
          inject_default_route_object_list.append(inject_default_route_object)

          return inject_default_route_object_list

    #XPATH devices/device/vrfs/vrf/router-eigrp
    class router_eigrp(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_eigrp_object_list = self.validate_inputs_form_payload(mapping_dict)

        for router_eigrp_object in router_eigrp_object_list:
          #fetch payload
          router_eigrp_payload = router_eigrp_object.getxml(filter=True)
          util.log_debug('router_eigrp_payload %s'%router_eigrp_payload)
          payload_list.append(router_eigrp_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_eigrp_object_list = self.validate_inputs_form_payload(mapping_dict)

        for router_eigrp_object in router_eigrp_object_list:
          #fetch payload
          router_eigrp_payload = router_eigrp_object.getxml(filter=True)

          util.log_debug('router_eigrp_payload %s'%router_eigrp_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=router_eigrp_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        router_eigrp_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/router-eigrp"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, router_eigrp_object in enumerate(router_eigrp_object_list):
          #fetch payload
          router_eigrp_payload = router_eigrp_object.getxml(filter=True)

          util.log_debug('update router_eigrp_payload %s'%router_eigrp_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=router_eigrp_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/router-eigrp"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        router_eigrp_object_list = []
        from servicemodel.controller.devices.device.vrfs import vrf
        router_eigrp_object = vrf.router_eigrp.router_eigrp()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('process_id', None)) != ''):
            router_eigrp_object.process_id = mapping_dict.get('process_id', None)
          else:
            router_eigrp_object.process_id._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('eigrp_stub', None)) != ''):
            router_eigrp_object.eigrp_stub = mapping_dict.get('eigrp_stub', None)
          else:
            router_eigrp_object.eigrp_stub._empty_tag = True
        except TypeError:
          pass
        router_eigrp_object_list.append(router_eigrp_object)

        return router_eigrp_object_list

      #XPATH devices/device/vrfs/vrf/router-eigrp/network
      class network(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-eigrp"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for network_object in network_object_list:
            #fetch payload
            network_payload = network_object.getxml(filter=True)
            util.log_debug('network_payload %s'%network_payload)
            payload_list.append(network_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-eigrp"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict)

          for network_object in network_object_list:
            #fetch payload
            network_payload = network_object.getxml(filter=True)

            util.log_debug('network_payload %s'%network_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/router-eigrp"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          network_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/network=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, network_object in enumerate(network_object_list):
            #fetch payload
            network_payload = network_object.getxml(filter=True)

            util.log_debug('update network_payload %s'%network_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=network_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-eigrp"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for ip_address_iterator in ip_address:
            rcpath_tmp =  rcpath+"/network=%s"%(util.make_interfacename(ip_address_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('ip_address')):
            raise Exception("'ip_address' cannot be empty")

          #convert keys to list
          ip_address = mapping_dict.get('ip_address')
          if not isinstance(ip_address, list):
            ip_address = [ip_address]

          #prepare payload
          network_object_list = []
          for ip_address_iterator in ip_address:
            from servicemodel.controller.devices.device.vrfs.vrf import router_eigrp
            network_object = router_eigrp.network.network()
            network_object.ip_address = ip_address_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
                network_object.netmask = mapping_dict.get('netmask', None)
              else:
                network_object.netmask._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('route_map', None)) != ''):
                network_object.route_map = mapping_dict.get('route_map', None)
              else:
                network_object.route_map._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('wild_card', None)) != ''):
                network_object.wild_card = mapping_dict.get('wild_card', None)
              else:
                network_object.wild_card._empty_tag = True
            except TypeError:
              pass
            network_object_list.append(network_object)

          return network_object_list

      class match_conditions(object):
        #XPATH devices/device/vrfs/vrf/router-eigrp/match-conditions/match-condition
        class match_condition(AbstractDeviceMgr):
          key_hints = [['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name

            for vrf_name in vrf_name_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-eigrp/match-conditions"%(util.make_interfacename(vrf_name))
              rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            match_condition_object_list = self.validate_inputs_form_payload(mapping_dict)

            for match_condition_object in match_condition_object_list:
              #fetch payload
              match_condition_payload = match_condition_object.getxml(filter=True)
              util.log_debug('match_condition_payload %s'%match_condition_payload)
              payload_list.append(match_condition_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name

            for vrf_name in vrf_name_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-eigrp/match-conditions"%(util.make_interfacename(vrf_name))
              self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            match_condition_object_list = self.validate_inputs_form_payload(mapping_dict)

            for match_condition_object in match_condition_object_list:
              #fetch payload
              match_condition_payload = match_condition_object.getxml(filter=True)

              util.log_debug('match_condition_payload %s'%match_condition_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=match_condition_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/router-eigrp/match-conditions"%(util.make_interfacename(vrf_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            match_condition_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            ip_address = mapping_dict.get('ip_address')
            if not isinstance(ip_address, list):
              ip_address = [ip_address]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for ip_address_iterator in ip_address:
              rcpath_tmp =  rcpath+"/match-condition=%s"%(util.make_interfacename(ip_address_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, match_condition_object in enumerate(match_condition_object_list):
              #fetch payload
              match_condition_payload = match_condition_object.getxml(filter=True)

              util.log_debug('update match_condition_payload %s'%match_condition_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=match_condition_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name

            for vrf_name in vrf_name_list:
              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/router-eigrp/match-conditions"%(util.make_interfacename(vrf_name))
              self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('ip_address')):
              raise Exception("'ip_address' cannot be empty")

            #convert keys to list
            ip_address = mapping_dict.get('ip_address')
            if not isinstance(ip_address, list):
              ip_address = [ip_address]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for ip_address_iterator in ip_address:
              rcpath_tmp =  rcpath+"/match-condition=%s"%(util.make_interfacename(ip_address_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('ip_address')):
              raise Exception("'ip_address' cannot be empty")

            #convert keys to list
            ip_address = mapping_dict.get('ip_address')
            if not isinstance(ip_address, list):
              ip_address = [ip_address]

            #prepare payload
            match_condition_object_list = []
            for ip_address_iterator in ip_address:
              from servicemodel.controller.devices.device.vrfs.vrf.router_eigrp import match_conditions
              match_condition_object = match_conditions.match_condition.match_condition()
              match_condition_object.ip_address = ip_address_iterator
              try:
                if (update == False) or (update == True and str(mapping_dict.get('mask_length', None)) != ''):
                  match_condition_object.mask_length = mapping_dict.get('mask_length', None)
                else:
                  match_condition_object.mask_length._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('min_match_length', None)) != ''):
                  match_condition_object.min_match_length = mapping_dict.get('min_match_length', None)
                else:
                  match_condition_object.min_match_length._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('max_match_length', None)) != ''):
                  match_condition_object.max_match_length = mapping_dict.get('max_match_length', None)
                else:
                  match_condition_object.max_match_length._empty_tag = True
              except TypeError:
                pass
              match_condition_object_list.append(match_condition_object)

            return match_condition_object_list

    #XPATH devices/device/vrfs/vrf/mpls
    class mpls(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mpls_object_list = self.validate_inputs_form_payload(mapping_dict)

        for mpls_object in mpls_object_list:
          #fetch payload
          mpls_payload = mpls_object.getxml(filter=True)
          util.log_debug('mpls_payload %s'%mpls_payload)
          payload_list.append(mpls_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mpls_object_list = self.validate_inputs_form_payload(mapping_dict)

        for mpls_object in mpls_object_list:
          #fetch payload
          mpls_payload = mpls_object.getxml(filter=True)

          util.log_debug('mpls_payload %s'%mpls_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=mpls_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        mpls_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/mpls"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, mpls_object in enumerate(mpls_object_list):
          #fetch payload
          mpls_payload = mpls_object.getxml(filter=True)

          util.log_debug('update mpls_payload %s'%mpls_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=mpls_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/mpls"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        mpls_object_list = []
        from servicemodel.controller.devices.device.vrfs import vrf
        mpls_object = vrf.mpls.mpls()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('loopback_interface', None)) != ''):
            mpls_object.loopback_interface = mapping_dict.get('loopback_interface', None)
          else:
            mpls_object.loopback_interface._empty_tag = True
        except TypeError:
          pass
        mpls_object_list.append(mpls_object)

        return mpls_object_list

    #XPATH devices/device/vrfs/vrf/bgp-advertise-policy
    class bgp_advertise_policy(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        bgp_advertise_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

        for bgp_advertise_policy_object in bgp_advertise_policy_object_list:
          #fetch payload
          bgp_advertise_policy_payload = bgp_advertise_policy_object.getxml(filter=True)
          util.log_debug('bgp_advertise_policy_payload %s'%bgp_advertise_policy_payload)
          payload_list.append(bgp_advertise_policy_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        bgp_advertise_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

        for bgp_advertise_policy_object in bgp_advertise_policy_object_list:
          #fetch payload
          bgp_advertise_policy_payload = bgp_advertise_policy_object.getxml(filter=True)

          util.log_debug('bgp_advertise_policy_payload %s'%bgp_advertise_policy_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=bgp_advertise_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        bgp_advertise_policy_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/bgp-advertise-policy"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, bgp_advertise_policy_object in enumerate(bgp_advertise_policy_object_list):
          #fetch payload
          bgp_advertise_policy_payload = bgp_advertise_policy_object.getxml(filter=True)

          util.log_debug('update bgp_advertise_policy_payload %s'%bgp_advertise_policy_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=bgp_advertise_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/bgp-advertise-policy"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        bgp_advertise_policy_object_list = []
        from servicemodel.controller.devices.device.vrfs import vrf
        bgp_advertise_policy_object = vrf.bgp_advertise_policy.bgp_advertise_policy()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('name', None)) != ''):
            bgp_advertise_policy_object.name = mapping_dict.get('name', None)
          else:
            bgp_advertise_policy_object.name._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('metric_out', None)) != ''):
            bgp_advertise_policy_object.metric_out = mapping_dict.get('metric_out', None)
          else:
            bgp_advertise_policy_object.metric_out._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('hold_time', None)) != ''):
            bgp_advertise_policy_object.hold_time = mapping_dict.get('hold_time', None)
          else:
            bgp_advertise_policy_object.hold_time._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('graceful_restart', None)) != ''):
            bgp_advertise_policy_object.graceful_restart = mapping_dict.get('graceful_restart', None)
          else:
            bgp_advertise_policy_object.graceful_restart._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('log_updown', None)) != ''):
            bgp_advertise_policy_object.log_updown = mapping_dict.get('log_updown', None)
          else:
            bgp_advertise_policy_object.log_updown._empty_tag = True
        except TypeError:
          pass
        try:
          if (update == False) or (update == True and str(mapping_dict.get('local_as', None)) != ''):
            bgp_advertise_policy_object.local_as = mapping_dict.get('local_as', None)
          else:
            bgp_advertise_policy_object.local_as._empty_tag = True
        except TypeError:
          pass
        bgp_advertise_policy_object_list.append(bgp_advertise_policy_object)

        return bgp_advertise_policy_object_list

    class static_routes(object):
      #XPATH devices/device/vrfs/vrf/static-routes/static-route
      class static_route(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/static-routes"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_route_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_route_object in static_route_object_list:
            #fetch payload
            static_route_payload = static_route_object.getxml(filter=True)
            util.log_debug('static_route_payload %s'%static_route_payload)
            payload_list.append(static_route_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/static-routes"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_route_object_list = self.validate_inputs_form_payload(mapping_dict)

          for static_route_object in static_route_object_list:
            #fetch payload
            static_route_payload = static_route_object.getxml(filter=True)

            util.log_debug('static_route_payload %s'%static_route_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/static-routes"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          static_route_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          dest_ip_address = mapping_dict.get('dest_ip_address')
          if not isinstance(dest_ip_address, list):
            dest_ip_address = [dest_ip_address]
          dest_mask = mapping_dict.get('dest_mask')
          if not isinstance(dest_mask, list):
            dest_mask = [dest_mask]
          next_hop_ip = mapping_dict.get('next_hop_ip')
          if not isinstance(next_hop_ip, list):
            next_hop_ip = [next_hop_ip]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for dest_ip_address_iterator in dest_ip_address:
            for dest_mask_iterator in dest_mask:
              for next_hop_ip_iterator in next_hop_ip:
                rcpath_tmp =  rcpath+"/static-route=%s,%s,%s"%(util.make_interfacename(dest_ip_address_iterator),util.make_interfacename(dest_mask_iterator),util.make_interfacename(next_hop_ip_iterator))
                rcpath_list.append(rcpath_tmp)
          for rc_counter, static_route_object in enumerate(static_route_object_list):
            #fetch payload
            static_route_payload = static_route_object.getxml(filter=True)

            util.log_debug('update static_route_payload %s'%static_route_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/static-routes"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('dest_ip_address')):
            raise Exception("'dest_ip_address' cannot be empty")
          if util.isEmpty(mapping_dict.get('dest_mask')):
            raise Exception("'dest_mask' cannot be empty")
          if util.isEmpty(mapping_dict.get('next_hop_ip')):
            raise Exception("'next_hop_ip' cannot be empty")

          #convert keys to list
          dest_ip_address = mapping_dict.get('dest_ip_address')
          if not isinstance(dest_ip_address, list):
            dest_ip_address = [dest_ip_address]
          dest_mask = mapping_dict.get('dest_mask')
          if not isinstance(dest_mask, list):
            dest_mask = [dest_mask]
          next_hop_ip = mapping_dict.get('next_hop_ip')
          if not isinstance(next_hop_ip, list):
            next_hop_ip = [next_hop_ip]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for dest_ip_address_iterator in dest_ip_address:
            for dest_mask_iterator in dest_mask:
              for next_hop_ip_iterator in next_hop_ip:
                rcpath_tmp =  rcpath+"/static-route=%s,%s,%s"%(util.make_interfacename(dest_ip_address_iterator),util.make_interfacename(dest_mask_iterator),util.make_interfacename(next_hop_ip_iterator))
                rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('dest_ip_address')):
            raise Exception("'dest_ip_address' cannot be empty")
          if util.isEmpty(mapping_dict.get('dest_mask')):
            raise Exception("'dest_mask' cannot be empty")
          if util.isEmpty(mapping_dict.get('next_hop_ip')):
            raise Exception("'next_hop_ip' cannot be empty")

          #convert keys to list
          dest_ip_address = mapping_dict.get('dest_ip_address')
          if not isinstance(dest_ip_address, list):
            dest_ip_address = [dest_ip_address]
          dest_mask = mapping_dict.get('dest_mask')
          if not isinstance(dest_mask, list):
            dest_mask = [dest_mask]
          next_hop_ip = mapping_dict.get('next_hop_ip')
          if not isinstance(next_hop_ip, list):
            next_hop_ip = [next_hop_ip]

          #prepare payload
          static_route_object_list = []
          for dest_ip_address_iterator in dest_ip_address:
            for dest_mask_iterator in dest_mask:
              for next_hop_ip_iterator in next_hop_ip:
                from servicemodel.controller.devices.device.vrfs.vrf import static_routes
                static_route_object = static_routes.static_route.static_route()
                static_route_object.dest_ip_address = dest_ip_address_iterator
                static_route_object.dest_mask = dest_mask_iterator
                static_route_object.next_hop_ip = next_hop_ip_iterator
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
                    static_route_object._set_description(mapping_dict.get('description', None))
                  else:
                    static_route_object._unset_description()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('metric', None)) != ''):
                    static_route_object._set_metric(mapping_dict.get('metric', None))
                  else:
                    static_route_object._unset_metric()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('interface_name', None)) != ''):
                    static_route_object._set_interface_name(mapping_dict.get('interface_name', None))
                  else:
                    static_route_object._unset_interface_name()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('next_routing_table', None)) != ''):
                    static_route_object._set_next_routing_table(mapping_dict.get('next_routing_table', None))
                  else:
                    static_route_object._unset_next_routing_table()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('vdom_name', None)) != ''):
                    static_route_object._set_vdom_name(mapping_dict.get('vdom_name', None))
                  else:
                    static_route_object._unset_vdom_name()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('seq_num', None)) != ''):
                    static_route_object._set_seq_num(mapping_dict.get('seq_num', None))
                  else:
                    static_route_object._unset_seq_num()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('user_id_grp_name', None)) != ''):
                    static_route_object._set_user_id_grp_name(mapping_dict.get('user_id_grp_name', None))
                  else:
                    static_route_object._unset_user_id_grp_name()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('name', None)) != ''):
                    static_route_object._set_name(mapping_dict.get('name', None))
                  else:
                    static_route_object._unset_name()
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('tag', None)) != ''):
                    static_route_object._set_tag(mapping_dict.get('tag', None))
                  else:
                    static_route_object._unset_tag()
                except TypeError:
                  pass
                static_route_object_list.append(static_route_object)

          return static_route_object_list

        #XPATH devices/device/vrfs/vrf/static-routes/static-route/prefix-policy
        class prefix_policy(AbstractDeviceMgr):
          key_hints = [['name'],['dest_ip_address','dest_mask','next_hop_ip']]
          def getRcpathPayload(self, sdata, dev, vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(static_route_dest_ip_address, list):
              static_route_dest_ip_address_list = [static_route_dest_ip_address]
            else:
              static_route_dest_ip_address_list = static_route_dest_ip_address
            if not isinstance(static_route_dest_mask, list):
              static_route_dest_mask_list = [static_route_dest_mask]
            else:
              static_route_dest_mask_list = static_route_dest_mask
            if not isinstance(static_route_next_hop_ip, list):
              static_route_next_hop_ip_list = [static_route_next_hop_ip]
            else:
              static_route_next_hop_ip_list = static_route_next_hop_ip

            for vrf_name in vrf_name_list:
              for static_route_dest_ip_address in static_route_dest_ip_address_list:
                for static_route_dest_mask in static_route_dest_mask_list:
                  for static_route_next_hop_ip in static_route_next_hop_ip_list:
                    ##prepare rcpath
                    rcpath = "l3features:vrfs/vrf=%s/static-routes/static-route=%s,%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(static_route_dest_ip_address),util.make_interfacename(static_route_dest_mask),util.make_interfacename(static_route_next_hop_ip))
                    rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

            for prefix_policy_object in prefix_policy_object_list:
              #fetch payload
              prefix_policy_payload = prefix_policy_object.getxml(filter=True)
              util.log_debug('prefix_policy_payload %s'%prefix_policy_payload)
              payload_list.append(prefix_policy_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(static_route_dest_ip_address, list):
              static_route_dest_ip_address_list = [static_route_dest_ip_address]
            else:
              static_route_dest_ip_address_list = static_route_dest_ip_address
            if not isinstance(static_route_dest_mask, list):
              static_route_dest_mask_list = [static_route_dest_mask]
            else:
              static_route_dest_mask_list = static_route_dest_mask
            if not isinstance(static_route_next_hop_ip, list):
              static_route_next_hop_ip_list = [static_route_next_hop_ip]
            else:
              static_route_next_hop_ip_list = static_route_next_hop_ip

            for vrf_name in vrf_name_list:
              for static_route_dest_ip_address in static_route_dest_ip_address_list:
                for static_route_dest_mask in static_route_dest_mask_list:
                  for static_route_next_hop_ip in static_route_next_hop_ip_list:
                    ##prepare rcpath
                    rcpath = "l3features:vrfs/vrf=%s/static-routes/static-route=%s,%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(static_route_dest_ip_address),util.make_interfacename(static_route_dest_mask),util.make_interfacename(static_route_next_hop_ip))
                    self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

            for prefix_policy_object in prefix_policy_object_list:
              #fetch payload
              prefix_policy_payload = prefix_policy_object.getxml(filter=True)

              util.log_debug('prefix_policy_payload %s'%prefix_policy_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=prefix_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/static-routes/static-route=%s,%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(static_route_dest_ip_address),util.make_interfacename(static_route_dest_mask),util.make_interfacename(static_route_next_hop_ip))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for name_iterator in name:
              rcpath_tmp =  rcpath+"/prefix-policy=%s"%(util.make_interfacename(name_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, prefix_policy_object in enumerate(prefix_policy_object_list):
              #fetch payload
              prefix_policy_payload = prefix_policy_object.getxml(filter=True)

              util.log_debug('update prefix_policy_payload %s'%prefix_policy_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=prefix_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(static_route_dest_ip_address, list):
              static_route_dest_ip_address_list = [static_route_dest_ip_address]
            else:
              static_route_dest_ip_address_list = static_route_dest_ip_address
            if not isinstance(static_route_dest_mask, list):
              static_route_dest_mask_list = [static_route_dest_mask]
            else:
              static_route_dest_mask_list = static_route_dest_mask
            if not isinstance(static_route_next_hop_ip, list):
              static_route_next_hop_ip_list = [static_route_next_hop_ip]
            else:
              static_route_next_hop_ip_list = static_route_next_hop_ip

            for vrf_name in vrf_name_list:
              for static_route_dest_ip_address in static_route_dest_ip_address_list:
                for static_route_dest_mask in static_route_dest_mask_list:
                  for static_route_next_hop_ip in static_route_next_hop_ip_list:
                    ##prepare rcpath
                    rcpath = "l3features:vrfs/vrf=%s/static-routes/static-route=%s,%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(static_route_dest_ip_address),util.make_interfacename(static_route_dest_mask),util.make_interfacename(static_route_next_hop_ip))
                    self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('name')):
              raise Exception("'name' cannot be empty")

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for name_iterator in name:
              rcpath_tmp =  rcpath+"/prefix-policy=%s"%(util.make_interfacename(name_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, static_route_dest_ip_address, static_route_dest_mask, static_route_next_hop_ip):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(static_route_dest_ip_address):
              raise Exception("'static_route_dest_ip_address' cannot be empty")
            if util.isEmpty(static_route_dest_mask):
              raise Exception("'static_route_dest_mask' cannot be empty")
            if util.isEmpty(static_route_next_hop_ip):
              raise Exception("'static_route_next_hop_ip' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('name')):
              raise Exception("'name' cannot be empty")

            #convert keys to list
            name = mapping_dict.get('name')
            if not isinstance(name, list):
              name = [name]

            #prepare payload
            prefix_policy_object_list = []
            for name_iterator in name:
              from servicemodel.controller.devices.device.vrfs.vrf.static_routes import static_route
              prefix_policy_object = static_route.prefix_policy.prefix_policy()
              prefix_policy_object.name = name_iterator
              try:
                if (update == False) or (update == True and str(mapping_dict.get('action', None)) != ''):
                  prefix_policy_object._set_action(mapping_dict.get('action', None))
                else:
                  prefix_policy_object._unset_action()
              except TypeError:
                pass
              prefix_policy_object_list.append(prefix_policy_object)

            return prefix_policy_object_list

    class routes(object):
      #XPATH devices/device/vrfs/vrf/routes/route
      class route(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/routes"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          route_object_list = self.validate_inputs_form_payload(mapping_dict)

          for route_object in route_object_list:
            #fetch payload
            route_payload = route_object.getxml(filter=True)
            util.log_debug('route_payload %s'%route_payload)
            payload_list.append(route_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/routes"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          route_object_list = self.validate_inputs_form_payload(mapping_dict)

          for route_object in route_object_list:
            #fetch payload
            route_payload = route_object.getxml(filter=True)

            util.log_debug('route_payload %s'%route_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/routes"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          route_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          dest_ip_address = mapping_dict.get('dest_ip_address')
          if not isinstance(dest_ip_address, list):
            dest_ip_address = [dest_ip_address]
          dest_mask = mapping_dict.get('dest_mask')
          if not isinstance(dest_mask, list):
            dest_mask = [dest_mask]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for dest_ip_address_iterator in dest_ip_address:
            for dest_mask_iterator in dest_mask:
              rcpath_tmp =  rcpath+"/route=%s,%s"%(util.make_interfacename(dest_ip_address_iterator),util.make_interfacename(dest_mask_iterator))
              rcpath_list.append(rcpath_tmp)
          for rc_counter, route_object in enumerate(route_object_list):
            #fetch payload
            route_payload = route_object.getxml(filter=True)

            util.log_debug('update route_payload %s'%route_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/routes"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('dest_ip_address')):
            raise Exception("'dest_ip_address' cannot be empty")
          if util.isEmpty(mapping_dict.get('dest_mask')):
            raise Exception("'dest_mask' cannot be empty")

          #convert keys to list
          dest_ip_address = mapping_dict.get('dest_ip_address')
          if not isinstance(dest_ip_address, list):
            dest_ip_address = [dest_ip_address]
          dest_mask = mapping_dict.get('dest_mask')
          if not isinstance(dest_mask, list):
            dest_mask = [dest_mask]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for dest_ip_address_iterator in dest_ip_address:
            for dest_mask_iterator in dest_mask:
              rcpath_tmp =  rcpath+"/route=%s,%s"%(util.make_interfacename(dest_ip_address_iterator),util.make_interfacename(dest_mask_iterator))
              rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('dest_ip_address')):
            raise Exception("'dest_ip_address' cannot be empty")
          if util.isEmpty(mapping_dict.get('dest_mask')):
            raise Exception("'dest_mask' cannot be empty")

          #convert keys to list
          dest_ip_address = mapping_dict.get('dest_ip_address')
          if not isinstance(dest_ip_address, list):
            dest_ip_address = [dest_ip_address]
          dest_mask = mapping_dict.get('dest_mask')
          if not isinstance(dest_mask, list):
            dest_mask = [dest_mask]

          #prepare payload
          route_object_list = []
          for dest_ip_address_iterator in dest_ip_address:
            for dest_mask_iterator in dest_mask:
              from servicemodel.controller.devices.device.vrfs.vrf import routes
              route_object = routes.route.route()
              route_object.dest_ip_address = dest_ip_address_iterator
              route_object.dest_mask = dest_mask_iterator
              route_object_list.append(route_object)

          return route_object_list

        #XPATH devices/device/vrfs/vrf/routes/route/options
        class options(AbstractDeviceMgr):
          key_hints = [['name'],['dest_ip_address','dest_mask']]
          def getRcpathPayload(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(route_dest_ip_address, list):
              route_dest_ip_address_list = [route_dest_ip_address]
            else:
              route_dest_ip_address_list = route_dest_ip_address
            if not isinstance(route_dest_mask, list):
              route_dest_mask_list = [route_dest_mask]
            else:
              route_dest_mask_list = route_dest_mask

            for vrf_name in vrf_name_list:
              for route_dest_ip_address in route_dest_ip_address_list:
                for route_dest_mask in route_dest_mask_list:
                  ##prepare rcpath
                  rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask))
                  rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            options_object_list = self.validate_inputs_form_payload(mapping_dict)

            for options_object in options_object_list:
              #fetch payload
              options_payload = options_object.getxml(filter=True)
              util.log_debug('options_payload %s'%options_payload)
              payload_list.append(options_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(route_dest_ip_address, list):
              route_dest_ip_address_list = [route_dest_ip_address]
            else:
              route_dest_ip_address_list = route_dest_ip_address
            if not isinstance(route_dest_mask, list):
              route_dest_mask_list = [route_dest_mask]
            else:
              route_dest_mask_list = route_dest_mask

            for vrf_name in vrf_name_list:
              for route_dest_ip_address in route_dest_ip_address_list:
                for route_dest_mask in route_dest_mask_list:
                  ##prepare rcpath
                  rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            options_object_list = self.validate_inputs_form_payload(mapping_dict)

            for options_object in options_object_list:
              #fetch payload
              options_payload = options_object.getxml(filter=True)

              util.log_debug('options_payload %s'%options_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=options_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            options_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            id = mapping_dict.get('id')
            if not isinstance(id, list):
              id = [id]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for id_iterator in id:
              rcpath_tmp =  rcpath+"/options=%s"%(util.make_interfacename(id_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, options_object in enumerate(options_object_list):
              #fetch payload
              options_payload = options_object.getxml(filter=True)

              util.log_debug('update options_payload %s'%options_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=options_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(route_dest_ip_address, list):
              route_dest_ip_address_list = [route_dest_ip_address]
            else:
              route_dest_ip_address_list = route_dest_ip_address
            if not isinstance(route_dest_mask, list):
              route_dest_mask_list = [route_dest_mask]
            else:
              route_dest_mask_list = route_dest_mask

            for vrf_name in vrf_name_list:
              for route_dest_ip_address in route_dest_ip_address_list:
                for route_dest_mask in route_dest_mask_list:
                  ##prepare rcpath
                  rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('id')):
              raise Exception("'id' cannot be empty")

            #convert keys to list
            id = mapping_dict.get('id')
            if not isinstance(id, list):
              id = [id]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for id_iterator in id:
              rcpath_tmp =  rcpath+"/options=%s"%(util.make_interfacename(id_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, route_dest_ip_address, route_dest_mask):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(route_dest_ip_address):
              raise Exception("'route_dest_ip_address' cannot be empty")
            if util.isEmpty(route_dest_mask):
              raise Exception("'route_dest_mask' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('id')):
              raise Exception("'id' cannot be empty")

            #convert keys to list
            id = mapping_dict.get('id')
            if not isinstance(id, list):
              id = [id]

            #prepare payload
            options_object_list = []
            for id_iterator in id:
              from servicemodel.controller.devices.device.vrfs.vrf.routes import route
              options_object = route.options.options()
              options_object.id = id_iterator
              try:
                if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
                  options_object.description = mapping_dict.get('description', None)
                else:
                  options_object.description._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('vrf_name', None)) != ''):
                  options_object.vrf_name = mapping_dict.get('vrf_name', None)
                else:
                  options_object.vrf_name._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('metric', None)) != ''):
                  options_object.metric = mapping_dict.get('metric', None)
                else:
                  options_object.metric._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('next_hop_ip', None)) != ''):
                  options_object.next_hop_ip = mapping_dict.get('next_hop_ip', None)
                else:
                  options_object.next_hop_ip._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('global_address', None)) != ''):
                  options_object.global_address = mapping_dict.get('global_address', None)
                else:
                  options_object.global_address._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('name', None)) != ''):
                  options_object.name = mapping_dict.get('name', None)
                else:
                  options_object.name._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('vdom_name', None)) != ''):
                  options_object.vdom_name = mapping_dict.get('vdom_name', None)
                else:
                  options_object.vdom_name._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('seq_num', None)) != ''):
                  options_object.seq_num = mapping_dict.get('seq_num', None)
                else:
                  options_object.seq_num._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('user_id_grp_name', None)) != ''):
                  options_object.user_id_grp_name = mapping_dict.get('user_id_grp_name', None)
                else:
                  options_object.user_id_grp_name._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('interface_name', None)) != ''):
                  options_object.interface_name = mapping_dict.get('interface_name', None)
                else:
                  options_object.interface_name._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('next_routing_table', None)) != ''):
                  options_object.next_routing_table = mapping_dict.get('next_routing_table', None)
                else:
                  options_object.next_routing_table._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('tag', None)) != ''):
                  options_object.tag = mapping_dict.get('tag', None)
                else:
                  options_object.tag._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('track', None)) != ''):
                  options_object.track = mapping_dict.get('track', None)
                else:
                  options_object.track._empty_tag = True
              except TypeError:
                pass
              options_object_list.append(options_object)

            return options_object_list

          #XPATH devices/device/vrfs/vrf/routes/route/options/prefix-policy
          class prefix_policy(AbstractDeviceMgr):
            key_hints = [['name'],['dest_ip_address','dest_mask'],['id']]
            def getRcpathPayload(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, options_id, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask, options_id)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(route_dest_ip_address, list):
                route_dest_ip_address_list = [route_dest_ip_address]
              else:
                route_dest_ip_address_list = route_dest_ip_address
              if not isinstance(route_dest_mask, list):
                route_dest_mask_list = [route_dest_mask]
              else:
                route_dest_mask_list = route_dest_mask
              if not isinstance(options_id, list):
                options_id_list = [options_id]
              else:
                options_id_list = options_id

              for vrf_name in vrf_name_list:
                for route_dest_ip_address in route_dest_ip_address_list:
                  for route_dest_mask in route_dest_mask_list:
                    for options_id in options_id_list:
                      ##prepare rcpath
                      rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s/options=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask),util.make_interfacename(options_id))
                      rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

              for prefix_policy_object in prefix_policy_object_list:
                #fetch payload
                prefix_policy_payload = prefix_policy_object.getxml(filter=True)
                util.log_debug('prefix_policy_payload %s'%prefix_policy_payload)
                payload_list.append(prefix_policy_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, options_id, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask, options_id)

              #convert parent keys to list
              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(route_dest_ip_address, list):
                route_dest_ip_address_list = [route_dest_ip_address]
              else:
                route_dest_ip_address_list = route_dest_ip_address
              if not isinstance(route_dest_mask, list):
                route_dest_mask_list = [route_dest_mask]
              else:
                route_dest_mask_list = route_dest_mask
              if not isinstance(options_id, list):
                options_id_list = [options_id]
              else:
                options_id_list = options_id

              for vrf_name in vrf_name_list:
                for route_dest_ip_address in route_dest_ip_address_list:
                  for route_dest_mask in route_dest_mask_list:
                    for options_id in options_id_list:
                      ##prepare rcpath
                      rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s/options=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask),util.make_interfacename(options_id))
                      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

              for prefix_policy_object in prefix_policy_object_list:
                #fetch payload
                prefix_policy_payload = prefix_policy_object.getxml(filter=True)

                util.log_debug('prefix_policy_payload %s'%prefix_policy_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=prefix_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, options_id, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask, options_id)


              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s/options=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask),util.make_interfacename(options_id))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list
              name = mapping_dict.get('name')
              if not isinstance(name, list):
                name = [name]

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              for name_iterator in name:
                rcpath_tmp =  rcpath+"/prefix-policy=%s"%(util.make_interfacename(name_iterator))
                rcpath_list.append(rcpath_tmp)
              for rc_counter, prefix_policy_object in enumerate(prefix_policy_object_list):
                #fetch payload
                prefix_policy_payload = prefix_policy_object.getxml(filter=True)

                util.log_debug('update prefix_policy_payload %s'%prefix_policy_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=prefix_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, vrf_name, route_dest_ip_address, route_dest_mask, options_id, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, route_dest_ip_address, route_dest_mask, options_id)


              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(route_dest_ip_address, list):
                route_dest_ip_address_list = [route_dest_ip_address]
              else:
                route_dest_ip_address_list = route_dest_ip_address
              if not isinstance(route_dest_mask, list):
                route_dest_mask_list = [route_dest_mask]
              else:
                route_dest_mask_list = route_dest_mask
              if not isinstance(options_id, list):
                options_id_list = [options_id]
              else:
                options_id_list = options_id

              for vrf_name in vrf_name_list:
                for route_dest_ip_address in route_dest_ip_address_list:
                  for route_dest_mask in route_dest_mask_list:
                    for options_id in options_id_list:
                      ##prepare rcpath
                      rcpath = "l3features:vrfs/vrf=%s/routes/route=%s,%s/options=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(route_dest_ip_address),util.make_interfacename(route_dest_mask),util.make_interfacename(options_id))
                      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs
              if util.isEmpty(mapping_dict.get('name')):
                raise Exception("'name' cannot be empty")

              #convert keys to list
              name = mapping_dict.get('name')
              if not isinstance(name, list):
                name = [name]

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              for name_iterator in name:
                rcpath_tmp =  rcpath+"/prefix-policy=%s"%(util.make_interfacename(name_iterator))
                rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, vrf_name, route_dest_ip_address, route_dest_mask, options_id):
              #Parent Key Validations
              if util.isEmpty(vrf_name):
                raise Exception("'vrf_name' cannot be empty")
              if util.isEmpty(route_dest_ip_address):
                raise Exception("'route_dest_ip_address' cannot be empty")
              if util.isEmpty(route_dest_mask):
                raise Exception("'route_dest_mask' cannot be empty")
              if util.isEmpty(options_id):
                raise Exception("'options_id' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs
              if util.isEmpty(mapping_dict.get('name')):
                raise Exception("'name' cannot be empty")

              #convert keys to list
              name = mapping_dict.get('name')
              if not isinstance(name, list):
                name = [name]

              #prepare payload
              prefix_policy_object_list = []
              for name_iterator in name:
                from servicemodel.controller.devices.device.vrfs.vrf.routes.route import options
                prefix_policy_object = options.prefix_policy.prefix_policy()
                prefix_policy_object.name = name_iterator
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('action', None)) != ''):
                    prefix_policy_object.action = mapping_dict.get('action', None)
                  else:
                    prefix_policy_object.action._empty_tag = True
                except TypeError:
                  pass
                prefix_policy_object_list.append(prefix_policy_object)

              return prefix_policy_object_list

    class prefix_sets(object):
      #XPATH devices/device/vrfs/vrf/prefix-sets/prefix-set
      class prefix_set(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/prefix-sets"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          prefix_set_object_list = self.validate_inputs_form_payload(mapping_dict)

          for prefix_set_object in prefix_set_object_list:
            #fetch payload
            prefix_set_payload = prefix_set_object.getxml(filter=True)
            util.log_debug('prefix_set_payload %s'%prefix_set_payload)
            payload_list.append(prefix_set_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/prefix-sets"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          prefix_set_object_list = self.validate_inputs_form_payload(mapping_dict)

          for prefix_set_object in prefix_set_object_list:
            #fetch payload
            prefix_set_payload = prefix_set_object.getxml(filter=True)

            util.log_debug('prefix_set_payload %s'%prefix_set_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=prefix_set_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/prefix-sets"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          prefix_set_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/prefix-set=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, prefix_set_object in enumerate(prefix_set_object_list):
            #fetch payload
            prefix_set_payload = prefix_set_object.getxml(filter=True)

            util.log_debug('update prefix_set_payload %s'%prefix_set_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=prefix_set_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/prefix-sets"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/prefix-set=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare payload
          prefix_set_object_list = []
          for name_iterator in name:
            from servicemodel.controller.devices.device.vrfs.vrf import prefix_sets
            prefix_set_object = prefix_sets.prefix_set.prefix_set()
            prefix_set_object.name = name_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
                prefix_set_object.description = mapping_dict.get('description', None)
              else:
                prefix_set_object.description._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('netmask', None)) != ''):
                prefix_set_object.netmask = mapping_dict.get('netmask', None)
              else:
                prefix_set_object.netmask._empty_tag = True
            except TypeError:
              pass
            prefix_set_object_list.append(prefix_set_object)

          return prefix_set_object_list

        #XPATH devices/device/vrfs/vrf/prefix-sets/prefix-set/custom-prefix-set
        class custom_prefix_set(AbstractDeviceMgr):
          key_hints = [['name'],['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, prefix_set_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(prefix_set_name, list):
              prefix_set_name_list = [prefix_set_name]
            else:
              prefix_set_name_list = prefix_set_name

            for vrf_name in vrf_name_list:
              for prefix_set_name in prefix_set_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            custom_prefix_set_object_list = self.validate_inputs_form_payload(mapping_dict)

            for custom_prefix_set_object in custom_prefix_set_object_list:
              #fetch payload
              custom_prefix_set_payload = custom_prefix_set_object.getxml(filter=True)
              util.log_debug('custom_prefix_set_payload %s'%custom_prefix_set_payload)
              payload_list.append(custom_prefix_set_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, prefix_set_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(prefix_set_name, list):
              prefix_set_name_list = [prefix_set_name]
            else:
              prefix_set_name_list = prefix_set_name

            for vrf_name in vrf_name_list:
              for prefix_set_name in prefix_set_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            custom_prefix_set_object_list = self.validate_inputs_form_payload(mapping_dict)

            for custom_prefix_set_object in custom_prefix_set_object_list:
              #fetch payload
              custom_prefix_set_payload = custom_prefix_set_object.getxml(filter=True)

              util.log_debug('custom_prefix_set_payload %s'%custom_prefix_set_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=custom_prefix_set_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, prefix_set_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            custom_prefix_set_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/custom-prefix-set"
            rcpath_list.append(rcpath_tmp)
            for rc_counter, custom_prefix_set_object in enumerate(custom_prefix_set_object_list):
              #fetch payload
              custom_prefix_set_payload = custom_prefix_set_object.getxml(filter=True)

              util.log_debug('update custom_prefix_set_payload %s'%custom_prefix_set_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=custom_prefix_set_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, prefix_set_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(prefix_set_name, list):
              prefix_set_name_list = [prefix_set_name]
            else:
              prefix_set_name_list = prefix_set_name

            for vrf_name in vrf_name_list:
              for prefix_set_name in prefix_set_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs

            #convert keys to list

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            rcpath_tmp =  rcpath+"/custom-prefix-set"
            rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, prefix_set_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(prefix_set_name):
              raise Exception("'prefix_set_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs

            #convert keys to list

            #prepare payload
            custom_prefix_set_object_list = []
            from servicemodel.controller.devices.device.vrfs.vrf.prefix_sets import prefix_set
            custom_prefix_set_object = prefix_set.custom_prefix_set.custom_prefix_set()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('prefix_set_buf', None)) != ''):
                custom_prefix_set_object.prefix_set_buf = mapping_dict.get('prefix_set_buf', None)
              else:
                custom_prefix_set_object.prefix_set_buf._empty_tag = True
            except TypeError:
              pass
            custom_prefix_set_object_list.append(custom_prefix_set_object)

            return custom_prefix_set_object_list

        class match_conditions(object):
          #XPATH devices/device/vrfs/vrf/prefix-sets/prefix-set/match-conditions/match-condition
          class match_condition(AbstractDeviceMgr):
            key_hints = [['name'],['name']]
            def getRcpathPayload(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, prefix_set_name)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(prefix_set_name, list):
                prefix_set_name_list = [prefix_set_name]
              else:
                prefix_set_name_list = prefix_set_name

              for vrf_name in vrf_name_list:
                for prefix_set_name in prefix_set_name_list:
                  ##prepare rcpath
                  rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s/match-conditions"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
                  rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              match_condition_object_list = self.validate_inputs_form_payload(mapping_dict)

              for match_condition_object in match_condition_object_list:
                #fetch payload
                match_condition_payload = match_condition_object.getxml(filter=True)
                util.log_debug('match_condition_payload %s'%match_condition_payload)
                payload_list.append(match_condition_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, prefix_set_name)

              #convert parent keys to list
              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(prefix_set_name, list):
                prefix_set_name_list = [prefix_set_name]
              else:
                prefix_set_name_list = prefix_set_name

              for vrf_name in vrf_name_list:
                for prefix_set_name in prefix_set_name_list:
                  ##prepare rcpath
                  rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s/match-conditions"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
                  self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              match_condition_object_list = self.validate_inputs_form_payload(mapping_dict)

              for match_condition_object in match_condition_object_list:
                #fetch payload
                match_condition_payload = match_condition_object.getxml(filter=True)

                util.log_debug('match_condition_payload %s'%match_condition_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=match_condition_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, prefix_set_name)


              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s/match-conditions"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              match_condition_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list
              ip_address = mapping_dict.get('ip_address')
              if not isinstance(ip_address, list):
                ip_address = [ip_address]

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              for ip_address_iterator in ip_address:
                rcpath_tmp =  rcpath+"/match-condition=%s"%(util.make_interfacename(ip_address_iterator))
                rcpath_list.append(rcpath_tmp)
              for rc_counter, match_condition_object in enumerate(match_condition_object_list):
                #fetch payload
                match_condition_payload = match_condition_object.getxml(filter=True)

                util.log_debug('update match_condition_payload %s'%match_condition_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=match_condition_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, vrf_name, prefix_set_name, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, prefix_set_name)


              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(prefix_set_name, list):
                prefix_set_name_list = [prefix_set_name]
              else:
                prefix_set_name_list = prefix_set_name

              for vrf_name in vrf_name_list:
                for prefix_set_name in prefix_set_name_list:
                  ##prepare rcpath
                  rcpath = "l3features:vrfs/vrf=%s/prefix-sets/prefix-set=%s/match-conditions"%(util.make_interfacename(vrf_name),util.make_interfacename(prefix_set_name))
                  self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs
              if util.isEmpty(mapping_dict.get('ip_address')):
                raise Exception("'ip_address' cannot be empty")

              #convert keys to list
              ip_address = mapping_dict.get('ip_address')
              if not isinstance(ip_address, list):
                ip_address = [ip_address]

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              for ip_address_iterator in ip_address:
                rcpath_tmp =  rcpath+"/match-condition=%s"%(util.make_interfacename(ip_address_iterator))
                rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, vrf_name, prefix_set_name):
              #Parent Key Validations
              if util.isEmpty(vrf_name):
                raise Exception("'vrf_name' cannot be empty")
              if util.isEmpty(prefix_set_name):
                raise Exception("'prefix_set_name' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs
              if util.isEmpty(mapping_dict.get('ip_address')):
                raise Exception("'ip_address' cannot be empty")

              #convert keys to list
              ip_address = mapping_dict.get('ip_address')
              if not isinstance(ip_address, list):
                ip_address = [ip_address]

              #prepare payload
              match_condition_object_list = []
              for ip_address_iterator in ip_address:
                from servicemodel.controller.devices.device.vrfs.vrf.prefix_sets.prefix_set import match_conditions
                match_condition_object = match_conditions.match_condition.match_condition()
                match_condition_object.ip_address = ip_address_iterator
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('mask_length', None)) != ''):
                    match_condition_object.mask_length = mapping_dict.get('mask_length', None)
                  else:
                    match_condition_object.mask_length._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('min_match_length', None)) != ''):
                    match_condition_object.min_match_length = mapping_dict.get('min_match_length', None)
                  else:
                    match_condition_object.min_match_length._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('max_match_length', None)) != ''):
                    match_condition_object.max_match_length = mapping_dict.get('max_match_length', None)
                  else:
                    match_condition_object.max_match_length._empty_tag = True
                except TypeError:
                  pass
                match_condition_object_list.append(match_condition_object)

              return match_condition_object_list

    class ribs(object):
      #XPATH devices/device/vrfs/vrf/ribs/rib
      class rib(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/ribs"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          rib_object_list = self.validate_inputs_form_payload(mapping_dict)

          for rib_object in rib_object_list:
            #fetch payload
            rib_payload = rib_object.getxml(filter=True)
            util.log_debug('rib_payload %s'%rib_payload)
            payload_list.append(rib_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/ribs"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          rib_object_list = self.validate_inputs_form_payload(mapping_dict)

          for rib_object in rib_object_list:
            #fetch payload
            rib_payload = rib_object.getxml(filter=True)

            util.log_debug('rib_payload %s'%rib_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=rib_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/ribs"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          rib_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/rib=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, rib_object in enumerate(rib_object_list):
            #fetch payload
            rib_payload = rib_object.getxml(filter=True)

            util.log_debug('update rib_payload %s'%rib_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=rib_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/ribs"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for name_iterator in name:
            rcpath_tmp =  rcpath+"/rib=%s"%(util.make_interfacename(name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('name')):
            raise Exception("'name' cannot be empty")

          #convert keys to list
          name = mapping_dict.get('name')
          if not isinstance(name, list):
            name = [name]

          #prepare payload
          rib_object_list = []
          for name_iterator in name:
            from servicemodel.controller.devices.device.vrfs.vrf import ribs
            rib_object = ribs.rib.rib()
            rib_object.name = name_iterator
            rib_object_list.append(rib_object)

          return rib_object_list

        #XPATH devices/device/vrfs/vrf/ribs/rib/static-route
        class static_route(AbstractDeviceMgr):
          key_hints = [['name'],['name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, rib_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, rib_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(rib_name, list):
              rib_name_list = [rib_name]
            else:
              rib_name_list = rib_name

            for vrf_name in vrf_name_list:
              for rib_name in rib_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            static_route_object_list = self.validate_inputs_form_payload(mapping_dict)

            for static_route_object in static_route_object_list:
              #fetch payload
              static_route_payload = static_route_object.getxml(filter=True)
              util.log_debug('static_route_payload %s'%static_route_payload)
              payload_list.append(static_route_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, rib_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, rib_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(rib_name, list):
              rib_name_list = [rib_name]
            else:
              rib_name_list = rib_name

            for vrf_name in vrf_name_list:
              for rib_name in rib_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            static_route_object_list = self.validate_inputs_form_payload(mapping_dict)

            for static_route_object in static_route_object_list:
              #fetch payload
              static_route_payload = static_route_object.getxml(filter=True)

              util.log_debug('static_route_payload %s'%static_route_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=static_route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, rib_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, rib_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            static_route_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            dest_ipv6_address = mapping_dict.get('dest_ipv6_address')
            if not isinstance(dest_ipv6_address, list):
              dest_ipv6_address = [dest_ipv6_address]
            mask_length = mapping_dict.get('mask_length')
            if not isinstance(mask_length, list):
              mask_length = [mask_length]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for dest_ipv6_address_iterator in dest_ipv6_address:
              for mask_length_iterator in mask_length:
                rcpath_tmp =  rcpath+"/static-route=%s,%s"%(util.make_interfacename(dest_ipv6_address_iterator),util.make_interfacename(mask_length_iterator))
                rcpath_list.append(rcpath_tmp)
            for rc_counter, static_route_object in enumerate(static_route_object_list):
              #fetch payload
              static_route_payload = static_route_object.getxml(filter=True)

              util.log_debug('update static_route_payload %s'%static_route_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=static_route_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, rib_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, rib_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(rib_name, list):
              rib_name_list = [rib_name]
            else:
              rib_name_list = rib_name

            for vrf_name in vrf_name_list:
              for rib_name in rib_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('dest_ipv6_address')):
              raise Exception("'dest_ipv6_address' cannot be empty")
            if util.isEmpty(mapping_dict.get('mask_length')):
              raise Exception("'mask_length' cannot be empty")

            #convert keys to list
            dest_ipv6_address = mapping_dict.get('dest_ipv6_address')
            if not isinstance(dest_ipv6_address, list):
              dest_ipv6_address = [dest_ipv6_address]
            mask_length = mapping_dict.get('mask_length')
            if not isinstance(mask_length, list):
              mask_length = [mask_length]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for dest_ipv6_address_iterator in dest_ipv6_address:
              for mask_length_iterator in mask_length:
                rcpath_tmp =  rcpath+"/static-route=%s,%s"%(util.make_interfacename(dest_ipv6_address_iterator),util.make_interfacename(mask_length_iterator))
                rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, rib_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(rib_name):
              raise Exception("'rib_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('dest_ipv6_address')):
              raise Exception("'dest_ipv6_address' cannot be empty")
            if util.isEmpty(mapping_dict.get('mask_length')):
              raise Exception("'mask_length' cannot be empty")

            #convert keys to list
            dest_ipv6_address = mapping_dict.get('dest_ipv6_address')
            if not isinstance(dest_ipv6_address, list):
              dest_ipv6_address = [dest_ipv6_address]
            mask_length = mapping_dict.get('mask_length')
            if not isinstance(mask_length, list):
              mask_length = [mask_length]

            #prepare payload
            static_route_object_list = []
            for dest_ipv6_address_iterator in dest_ipv6_address:
              for mask_length_iterator in mask_length:
                from servicemodel.controller.devices.device.vrfs.vrf.ribs import rib
                static_route_object = rib.static_route.static_route()
                static_route_object.dest_ipv6_address = dest_ipv6_address_iterator
                static_route_object.mask_length = mask_length_iterator
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('next_hop_ip', None)) != ''):
                    static_route_object.next_hop_ip = mapping_dict.get('next_hop_ip', None)
                  else:
                    static_route_object.next_hop_ip._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('description', None)) != ''):
                    static_route_object.description = mapping_dict.get('description', None)
                  else:
                    static_route_object.description._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('metric', None)) != ''):
                    static_route_object.metric = mapping_dict.get('metric', None)
                  else:
                    static_route_object.metric._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('interface_name', None)) != ''):
                    static_route_object.interface_name = mapping_dict.get('interface_name', None)
                  else:
                    static_route_object.interface_name._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('next_routing_table', None)) != ''):
                    static_route_object.next_routing_table = mapping_dict.get('next_routing_table', None)
                  else:
                    static_route_object.next_routing_table._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('vdom_name', None)) != ''):
                    static_route_object.vdom_name = mapping_dict.get('vdom_name', None)
                  else:
                    static_route_object.vdom_name._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('seq_num', None)) != ''):
                    static_route_object.seq_num = mapping_dict.get('seq_num', None)
                  else:
                    static_route_object.seq_num._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('user_id_grp_name', None)) != ''):
                    static_route_object.user_id_grp_name = mapping_dict.get('user_id_grp_name', None)
                  else:
                    static_route_object.user_id_grp_name._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('name', None)) != ''):
                    static_route_object.name = mapping_dict.get('name', None)
                  else:
                    static_route_object.name._empty_tag = True
                except TypeError:
                  pass
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('tag', None)) != ''):
                    static_route_object.tag = mapping_dict.get('tag', None)
                  else:
                    static_route_object.tag._empty_tag = True
                except TypeError:
                  pass
                static_route_object_list.append(static_route_object)

            return static_route_object_list

          #XPATH devices/device/vrfs/vrf/ribs/rib/static-route/prefix-policy
          class prefix_policy(AbstractDeviceMgr):
            key_hints = [['name'],['name'],['dest_ipv6_address','mask_length']]
            def getRcpathPayload(self, sdata, dev, vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length, mapping_dict):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length)

              #convert parent keys to list
              rcpath_list = []
              payload_list = []
              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(rib_name, list):
                rib_name_list = [rib_name]
              else:
                rib_name_list = rib_name
              if not isinstance(static_route_dest_ipv6_address, list):
                static_route_dest_ipv6_address_list = [static_route_dest_ipv6_address]
              else:
                static_route_dest_ipv6_address_list = static_route_dest_ipv6_address
              if not isinstance(static_route_mask_length, list):
                static_route_mask_length_list = [static_route_mask_length]
              else:
                static_route_mask_length_list = static_route_mask_length

              for vrf_name in vrf_name_list:
                for rib_name in rib_name_list:
                  for static_route_dest_ipv6_address in static_route_dest_ipv6_address_list:
                    for static_route_mask_length in static_route_mask_length_list:
                      ##prepare rcpath
                      rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s/static-route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name),util.make_interfacename(static_route_dest_ipv6_address),util.make_interfacename(static_route_mask_length))
                      rcpath_list.append(rcpath)
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

              for prefix_policy_object in prefix_policy_object_list:
                #fetch payload
                prefix_policy_payload = prefix_policy_object.getxml(filter=True)
                util.log_debug('prefix_policy_payload %s'%prefix_policy_payload)
                payload_list.append(prefix_policy_payload)

              return rcpath_list, payload_list

            def create(self, sdata, dev, vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length)

              #convert parent keys to list
              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(rib_name, list):
                rib_name_list = [rib_name]
              else:
                rib_name_list = rib_name
              if not isinstance(static_route_dest_ipv6_address, list):
                static_route_dest_ipv6_address_list = [static_route_dest_ipv6_address]
              else:
                static_route_dest_ipv6_address_list = static_route_dest_ipv6_address
              if not isinstance(static_route_mask_length, list):
                static_route_mask_length_list = [static_route_mask_length]
              else:
                static_route_mask_length_list = static_route_mask_length

              for vrf_name in vrf_name_list:
                for rib_name in rib_name_list:
                  for static_route_dest_ipv6_address in static_route_dest_ipv6_address_list:
                    for static_route_mask_length in static_route_mask_length_list:
                      ##prepare rcpath
                      rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s/static-route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name),util.make_interfacename(static_route_dest_ipv6_address),util.make_interfacename(static_route_mask_length))
                      self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def create_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict)

              for prefix_policy_object in prefix_policy_object_list:
                #fetch payload
                prefix_policy_payload = prefix_policy_object.getxml(filter=True)

                util.log_debug('prefix_policy_payload %s'%prefix_policy_payload)

                #call the base abstract class for createData
                super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=prefix_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def update(self, sdata, dev, vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length, mapping_dict, addref=True, autocommit=True):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length)


              ##prepare rcpath
              rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s/static-route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name),util.make_interfacename(static_route_dest_ipv6_address),util.make_interfacename(static_route_mask_length))
              self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

            def update_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs and get payload object
              prefix_policy_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

              #convert keys to list
              name = mapping_dict.get('name')
              if not isinstance(name, list):
                name = [name]

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              for name_iterator in name:
                rcpath_tmp =  rcpath+"/prefix-policy=%s"%(util.make_interfacename(name_iterator))
                rcpath_list.append(rcpath_tmp)
              for rc_counter, prefix_policy_object in enumerate(prefix_policy_object_list):
                #fetch payload
                prefix_policy_payload = prefix_policy_object.getxml(filter=True)

                util.log_debug('update prefix_policy_payload %s'%prefix_policy_payload)

                rcpath = rcpath_list[rc_counter]
                #call the base abstract class for createData
                super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=prefix_policy_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

            def delete(self, sdata, dev, vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length, mapping_dict, fail_silently=False, remove_reference=False):
              dev = get_valid_devices(dev)
              if len(dev) == 0:
                return
              #Input Key Validations
              self.validate_parent_keys( vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length)


              if not isinstance(vrf_name, list):
                vrf_name_list = [vrf_name]
              else:
                vrf_name_list = vrf_name
              if not isinstance(rib_name, list):
                rib_name_list = [rib_name]
              else:
                rib_name_list = rib_name
              if not isinstance(static_route_dest_ipv6_address, list):
                static_route_dest_ipv6_address_list = [static_route_dest_ipv6_address]
              else:
                static_route_dest_ipv6_address_list = static_route_dest_ipv6_address
              if not isinstance(static_route_mask_length, list):
                static_route_mask_length_list = [static_route_mask_length]
              else:
                static_route_mask_length_list = static_route_mask_length

              for vrf_name in vrf_name_list:
                for rib_name in rib_name_list:
                  for static_route_dest_ipv6_address in static_route_dest_ipv6_address_list:
                    for static_route_mask_length in static_route_mask_length_list:
                      ##prepare rcpath
                      rcpath = "l3features:vrfs/vrf=%s/ribs/rib=%s/static-route=%s,%s"%(util.make_interfacename(vrf_name),util.make_interfacename(rib_name),util.make_interfacename(static_route_dest_ipv6_address),util.make_interfacename(static_route_mask_length))
                      self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

            def delete_(self, sdata, dev, **kwargs):
              mapping_dict = kwargs.get('mapping_dict')

              #validating inputs
              if util.isEmpty(mapping_dict.get('name')):
                raise Exception("'name' cannot be empty")

              #convert keys to list
              name = mapping_dict.get('name')
              if not isinstance(name, list):
                name = [name]

              #prepare rcpath
              rcpath = kwargs.get('rcpath')
              rcpath_list = []
              for name_iterator in name:
                rcpath_tmp =  rcpath+"/prefix-policy=%s"%(util.make_interfacename(name_iterator))
                rcpath_list.append(rcpath_tmp)
              payload = ''

              for rcpath in rcpath_list:
                #call the base abstract class for deleteData
                super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

            def validate_parent_keys(self, vrf_name, rib_name, static_route_dest_ipv6_address, static_route_mask_length):
              #Parent Key Validations
              if util.isEmpty(vrf_name):
                raise Exception("'vrf_name' cannot be empty")
              if util.isEmpty(rib_name):
                raise Exception("'rib_name' cannot be empty")
              if util.isEmpty(static_route_dest_ipv6_address):
                raise Exception("'static_route_dest_ipv6_address' cannot be empty")
              if util.isEmpty(static_route_mask_length):
                raise Exception("'static_route_mask_length' cannot be empty")

            def validate_inputs_form_payload(self, mapping_dict, update=False):
              #validating inputs
              if util.isEmpty(mapping_dict.get('name')):
                raise Exception("'name' cannot be empty")

              #convert keys to list
              name = mapping_dict.get('name')
              if not isinstance(name, list):
                name = [name]

              #prepare payload
              prefix_policy_object_list = []
              for name_iterator in name:
                from servicemodel.controller.devices.device.vrfs.vrf.ribs.rib import static_route
                prefix_policy_object = static_route.prefix_policy.prefix_policy()
                prefix_policy_object.name = name_iterator
                try:
                  if (update == False) or (update == True and str(mapping_dict.get('action', None)) != ''):
                    prefix_policy_object.action = mapping_dict.get('action', None)
                  else:
                    prefix_policy_object.action._empty_tag = True
                except TypeError:
                  pass
                prefix_policy_object_list.append(prefix_policy_object)

              return prefix_policy_object_list

    #XPATH devices/device/vrfs/vrf/forwarding-options
    class forwarding_options(AbstractDeviceMgr):
      key_hints = [['name']]
      def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        rcpath_list = []
        payload_list = []
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          rcpath_list.append(rcpath)
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        forwarding_options_object_list = self.validate_inputs_form_payload(mapping_dict)

        for forwarding_options_object in forwarding_options_object_list:
          #fetch payload
          forwarding_options_payload = forwarding_options_object.getxml(filter=True)
          util.log_debug('forwarding_options_payload %s'%forwarding_options_payload)
          payload_list.append(forwarding_options_payload)

        return rcpath_list, payload_list

      def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)

        #convert parent keys to list
        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def create_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        forwarding_options_object_list = self.validate_inputs_form_payload(mapping_dict)

        for forwarding_options_object in forwarding_options_object_list:
          #fetch payload
          forwarding_options_payload = forwarding_options_object.getxml(filter=True)

          util.log_debug('forwarding_options_payload %s'%forwarding_options_payload)

          #call the base abstract class for createData
          super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=forwarding_options_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        ##prepare rcpath
        rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
        self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

      def update_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs and get payload object
        forwarding_options_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/forwarding-options"
        rcpath_list.append(rcpath_tmp)
        for rc_counter, forwarding_options_object in enumerate(forwarding_options_object_list):
          #fetch payload
          forwarding_options_payload = forwarding_options_object.getxml(filter=True)

          util.log_debug('update forwarding_options_payload %s'%forwarding_options_payload)

          rcpath = rcpath_list[rc_counter]
          #call the base abstract class for createData
          super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=forwarding_options_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

      def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
        dev = get_valid_devices(dev)
        if len(dev) == 0:
          return
        #Input Key Validations
        self.validate_parent_keys( vrf_name)


        if not isinstance(vrf_name, list):
          vrf_name_list = [vrf_name]
        else:
          vrf_name_list = vrf_name

        for vrf_name in vrf_name_list:
          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s"%(util.make_interfacename(vrf_name))
          self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

      def delete_(self, sdata, dev, **kwargs):
        mapping_dict = kwargs.get('mapping_dict')

        #validating inputs

        #convert keys to list

        #prepare rcpath
        rcpath = kwargs.get('rcpath')
        rcpath_list = []
        rcpath_tmp =  rcpath+"/forwarding-options"
        rcpath_list.append(rcpath_tmp)
        payload = ''

        for rcpath in rcpath_list:
          #call the base abstract class for deleteData
          super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

      def validate_parent_keys(self, vrf_name):
        #Parent Key Validations
        if util.isEmpty(vrf_name):
          raise Exception("'vrf_name' cannot be empty")

      def validate_inputs_form_payload(self, mapping_dict, update=False):
        #validating inputs

        #convert keys to list

        #prepare payload
        forwarding_options_object_list = []
        from servicemodel.controller.devices.device.vrfs import vrf
        forwarding_options_object = vrf.forwarding_options.forwarding_options()
        try:
          if (update == False) or (update == True and str(mapping_dict.get('unicast_rpf', None)) != ''):
            forwarding_options_object.unicast_rpf = mapping_dict.get('unicast_rpf', None)
          else:
            forwarding_options_object.unicast_rpf._empty_tag = True
        except TypeError:
          pass
        forwarding_options_object_list.append(forwarding_options_object)

        return forwarding_options_object_list

      #XPATH devices/device/vrfs/vrf/forwarding-options/rpf-loose-mode-discard
      class rpf_loose_mode_discard(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/forwarding-options"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          rpf_loose_mode_discard_object_list = self.validate_inputs_form_payload(mapping_dict)

          for rpf_loose_mode_discard_object in rpf_loose_mode_discard_object_list:
            #fetch payload
            rpf_loose_mode_discard_payload = rpf_loose_mode_discard_object.getxml(filter=True)
            util.log_debug('rpf_loose_mode_discard_payload %s'%rpf_loose_mode_discard_payload)
            payload_list.append(rpf_loose_mode_discard_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/forwarding-options"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          rpf_loose_mode_discard_object_list = self.validate_inputs_form_payload(mapping_dict)

          for rpf_loose_mode_discard_object in rpf_loose_mode_discard_object_list:
            #fetch payload
            rpf_loose_mode_discard_payload = rpf_loose_mode_discard_object.getxml(filter=True)

            util.log_debug('rpf_loose_mode_discard_payload %s'%rpf_loose_mode_discard_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=rpf_loose_mode_discard_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/forwarding-options"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          rpf_loose_mode_discard_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          family = mapping_dict.get('family')
          if not isinstance(family, list):
            family = [family]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for family_iterator in family:
            rcpath_tmp =  rcpath+"/rpf-loose-mode-discard=%s"%(util.make_interfacename(family_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, rpf_loose_mode_discard_object in enumerate(rpf_loose_mode_discard_object_list):
            #fetch payload
            rpf_loose_mode_discard_payload = rpf_loose_mode_discard_object.getxml(filter=True)

            util.log_debug('update rpf_loose_mode_discard_payload %s'%rpf_loose_mode_discard_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=rpf_loose_mode_discard_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/forwarding-options"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('family')):
            raise Exception("'family' cannot be empty")

          #convert keys to list
          family = mapping_dict.get('family')
          if not isinstance(family, list):
            family = [family]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for family_iterator in family:
            rcpath_tmp =  rcpath+"/rpf-loose-mode-discard=%s"%(util.make_interfacename(family_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('family')):
            raise Exception("'family' cannot be empty")

          #convert keys to list
          family = mapping_dict.get('family')
          if not isinstance(family, list):
            family = [family]

          #prepare payload
          rpf_loose_mode_discard_object_list = []
          for family_iterator in family:
            from servicemodel.controller.devices.device.vrfs.vrf import forwarding_options
            rpf_loose_mode_discard_object = forwarding_options.rpf_loose_mode_discard.rpf_loose_mode_discard()
            rpf_loose_mode_discard_object.family = family_iterator
            rpf_loose_mode_discard_object_list.append(rpf_loose_mode_discard_object)

          return rpf_loose_mode_discard_object_list

    class dhcp_servers(object):
      #XPATH devices/device/vrfs/vrf/dhcp-servers/dhcp-server
      class dhcp_server(AbstractDeviceMgr):
        key_hints = [['name']]
        def getRcpathPayload(self, sdata, dev, vrf_name, mapping_dict):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          rcpath_list = []
          payload_list = []
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/dhcp-servers"%(util.make_interfacename(vrf_name))
            rcpath_list.append(rcpath)
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          dhcp_server_object_list = self.validate_inputs_form_payload(mapping_dict)

          for dhcp_server_object in dhcp_server_object_list:
            #fetch payload
            dhcp_server_payload = dhcp_server_object.getxml(filter=True)
            util.log_debug('dhcp_server_payload %s'%dhcp_server_payload)
            payload_list.append(dhcp_server_payload)

          return rcpath_list, payload_list

        def create(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)

          #convert parent keys to list
          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/dhcp-servers"%(util.make_interfacename(vrf_name))
            self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def create_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          dhcp_server_object_list = self.validate_inputs_form_payload(mapping_dict)

          for dhcp_server_object in dhcp_server_object_list:
            #fetch payload
            dhcp_server_payload = dhcp_server_object.getxml(filter=True)

            util.log_debug('dhcp_server_payload %s'%dhcp_server_payload)

            #call the base abstract class for createData
            super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=dhcp_server_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def update(self, sdata, dev, vrf_name, mapping_dict, addref=True, autocommit=True):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          ##prepare rcpath
          rcpath = "l3features:vrfs/vrf=%s/dhcp-servers"%(util.make_interfacename(vrf_name))
          self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

        def update_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs and get payload object
          dhcp_server_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

          #convert keys to list
          interface_name = mapping_dict.get('interface_name')
          if not isinstance(interface_name, list):
            interface_name = [interface_name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for interface_name_iterator in interface_name:
            rcpath_tmp =  rcpath+"/dhcp-server=%s"%(util.make_interfacename(interface_name_iterator))
            rcpath_list.append(rcpath_tmp)
          for rc_counter, dhcp_server_object in enumerate(dhcp_server_object_list):
            #fetch payload
            dhcp_server_payload = dhcp_server_object.getxml(filter=True)

            util.log_debug('update dhcp_server_payload %s'%dhcp_server_payload)

            rcpath = rcpath_list[rc_counter]
            #call the base abstract class for createData
            super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=dhcp_server_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

        def delete(self, sdata, dev, vrf_name, mapping_dict, fail_silently=False, remove_reference=False):
          dev = get_valid_devices(dev)
          if len(dev) == 0:
            return
          #Input Key Validations
          self.validate_parent_keys( vrf_name)


          if not isinstance(vrf_name, list):
            vrf_name_list = [vrf_name]
          else:
            vrf_name_list = vrf_name

          for vrf_name in vrf_name_list:
            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/dhcp-servers"%(util.make_interfacename(vrf_name))
            self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

        def delete_(self, sdata, dev, **kwargs):
          mapping_dict = kwargs.get('mapping_dict')

          #validating inputs
          if util.isEmpty(mapping_dict.get('interface_name')):
            raise Exception("'interface_name' cannot be empty")

          #convert keys to list
          interface_name = mapping_dict.get('interface_name')
          if not isinstance(interface_name, list):
            interface_name = [interface_name]

          #prepare rcpath
          rcpath = kwargs.get('rcpath')
          rcpath_list = []
          for interface_name_iterator in interface_name:
            rcpath_tmp =  rcpath+"/dhcp-server=%s"%(util.make_interfacename(interface_name_iterator))
            rcpath_list.append(rcpath_tmp)
          payload = ''

          for rcpath in rcpath_list:
            #call the base abstract class for deleteData
            super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

        def validate_parent_keys(self, vrf_name):
          #Parent Key Validations
          if util.isEmpty(vrf_name):
            raise Exception("'vrf_name' cannot be empty")

        def validate_inputs_form_payload(self, mapping_dict, update=False):
          #validating inputs
          if util.isEmpty(mapping_dict.get('pool_name')):
            raise Exception("'pool_name' cannot be empty")
          if util.isEmpty(mapping_dict.get('network')):
            raise Exception("'network' cannot be empty")
          if util.isEmpty(mapping_dict.get('mask')):
            raise Exception("'mask' cannot be empty")
          if util.isEmpty(mapping_dict.get('default_router')):
            raise Exception("'default_router' cannot be empty")
          if util.isEmpty(mapping_dict.get('interface_name')):
            raise Exception("'interface_name' cannot be empty")

          #convert keys to list
          interface_name = mapping_dict.get('interface_name')
          if not isinstance(interface_name, list):
            interface_name = [interface_name]

          #prepare payload
          dhcp_server_object_list = []
          for interface_name_iterator in interface_name:
            from servicemodel.controller.devices.device.vrfs.vrf import dhcp_servers
            dhcp_server_object = dhcp_servers.dhcp_server.dhcp_server()
            try:
              if (update == False) or (update == True and str(mapping_dict.get('pool_name', None)) != ''):
                dhcp_server_object.pool_name = mapping_dict.get('pool_name', None)
              else:
                dhcp_server_object.pool_name._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('pool_vrf', None)) != ''):
                dhcp_server_object.pool_vrf = mapping_dict.get('pool_vrf', None)
              else:
                dhcp_server_object.pool_vrf._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('network', None)) != ''):
                dhcp_server_object.network = mapping_dict.get('network', None)
              else:
                dhcp_server_object.network._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('mask', None)) != ''):
                dhcp_server_object.mask = mapping_dict.get('mask', None)
              else:
                dhcp_server_object.mask._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('domain_name', None)) != ''):
                dhcp_server_object.domain_name = mapping_dict.get('domain_name', None)
              else:
                dhcp_server_object.domain_name._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('dhcp_server_ip', None)) != ''):
                dhcp_server_object.dhcp_server_ip = mapping_dict.get('dhcp_server_ip', None)
              else:
                dhcp_server_object.dhcp_server_ip._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('dns_server_ip', None)) != ''):
                dhcp_server_object.dns_server_ip = mapping_dict.get('dns_server_ip', None)
              else:
                dhcp_server_object.dns_server_ip._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('default_router', None)) != ''):
                dhcp_server_object.default_router = mapping_dict.get('default_router', None)
              else:
                dhcp_server_object.default_router._empty_tag = True
            except TypeError:
              pass
            dhcp_server_object.interface_name = interface_name_iterator
            try:
              if (update == False) or (update == True and str(mapping_dict.get('start_ip', None)) != ''):
                dhcp_server_object.start_ip = mapping_dict.get('start_ip', None)
              else:
                dhcp_server_object.start_ip._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('end_ip', None)) != ''):
                dhcp_server_object.end_ip = mapping_dict.get('end_ip', None)
              else:
                dhcp_server_object.end_ip._empty_tag = True
            except TypeError:
              pass
            try:
              if (update == False) or (update == True and str(mapping_dict.get('lease', None)) != ''):
                dhcp_server_object.lease = mapping_dict.get('lease', None)
              else:
                dhcp_server_object.lease._empty_tag = True
            except TypeError:
              pass
            dhcp_server_object_list.append(dhcp_server_object)

          return dhcp_server_object_list

        #XPATH devices/device/vrfs/vrf/dhcp-servers/dhcp-server/excluded-address
        class excluded_address(AbstractDeviceMgr):
          key_hints = [['name'],['interface_name']]
          def getRcpathPayload(self, sdata, dev, vrf_name, dhcp_server_interface_name, mapping_dict):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, dhcp_server_interface_name)

            #convert parent keys to list
            rcpath_list = []
            payload_list = []
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(dhcp_server_interface_name, list):
              dhcp_server_interface_name_list = [dhcp_server_interface_name]
            else:
              dhcp_server_interface_name_list = dhcp_server_interface_name

            for vrf_name in vrf_name_list:
              for dhcp_server_interface_name in dhcp_server_interface_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/dhcp-servers/dhcp-server=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(dhcp_server_interface_name))
                rcpath_list.append(rcpath)
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            excluded_address_object_list = self.validate_inputs_form_payload(mapping_dict)

            for excluded_address_object in excluded_address_object_list:
              #fetch payload
              excluded_address_payload = excluded_address_object.getxml(filter=True)
              util.log_debug('excluded_address_payload %s'%excluded_address_payload)
              payload_list.append(excluded_address_payload)

            return rcpath_list, payload_list

          def create(self, sdata, dev, vrf_name, dhcp_server_interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, dhcp_server_interface_name)

            #convert parent keys to list
            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(dhcp_server_interface_name, list):
              dhcp_server_interface_name_list = [dhcp_server_interface_name]
            else:
              dhcp_server_interface_name_list = dhcp_server_interface_name

            for vrf_name in vrf_name_list:
              for dhcp_server_interface_name in dhcp_server_interface_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/dhcp-servers/dhcp-server=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(dhcp_server_interface_name))
                self.create_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def create_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            excluded_address_object_list = self.validate_inputs_form_payload(mapping_dict)

            for excluded_address_object in excluded_address_object_list:
              #fetch payload
              excluded_address_payload = excluded_address_object.getxml(filter=True)

              util.log_debug('excluded_address_payload %s'%excluded_address_payload)

              #call the base abstract class for createData
              super(self.__class__, self).create_(sdata, dev, rcpath=kwargs.get('rcpath'), payload=excluded_address_payload, key_hints=self.key_hints, addref=kwargs.get('addref', True), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def update(self, sdata, dev, vrf_name, dhcp_server_interface_name, mapping_dict, addref=True, autocommit=True):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, dhcp_server_interface_name)


            ##prepare rcpath
            rcpath = "l3features:vrfs/vrf=%s/dhcp-servers/dhcp-server=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(dhcp_server_interface_name))
            self.update_(sdata, dev, mapping_dict=mapping_dict, addref=addref, autocommit=autocommit, rcpath=rcpath)

          def update_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs and get payload object
            excluded_address_object_list = self.validate_inputs_form_payload(mapping_dict, update=True)

            #convert keys to list
            low_ipaddress = mapping_dict.get('low_ipaddress')
            if not isinstance(low_ipaddress, list):
              low_ipaddress = [low_ipaddress]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for low_ipaddress_iterator in low_ipaddress:
              rcpath_tmp =  rcpath+"/excluded-address=%s"%(util.make_interfacename(low_ipaddress_iterator))
              rcpath_list.append(rcpath_tmp)
            for rc_counter, excluded_address_object in enumerate(excluded_address_object_list):
              #fetch payload
              excluded_address_payload = excluded_address_object.getxml(filter=True)

              util.log_debug('update excluded_address_payload %s'%excluded_address_payload)

              rcpath = rcpath_list[rc_counter]
              #call the base abstract class for createData
              super(self.__class__, self).update_(sdata, dev, rcpath=rcpath, payload=excluded_address_payload, key_hints=self.key_hints, addref=kwargs.get('addref', False), autocommit=kwargs.get('autocommit', True), mapping_dict=mapping_dict)

          def delete(self, sdata, dev, vrf_name, dhcp_server_interface_name, mapping_dict, fail_silently=False, remove_reference=False):
            dev = get_valid_devices(dev)
            if len(dev) == 0:
              return
            #Input Key Validations
            self.validate_parent_keys( vrf_name, dhcp_server_interface_name)


            if not isinstance(vrf_name, list):
              vrf_name_list = [vrf_name]
            else:
              vrf_name_list = vrf_name
            if not isinstance(dhcp_server_interface_name, list):
              dhcp_server_interface_name_list = [dhcp_server_interface_name]
            else:
              dhcp_server_interface_name_list = dhcp_server_interface_name

            for vrf_name in vrf_name_list:
              for dhcp_server_interface_name in dhcp_server_interface_name_list:
                ##prepare rcpath
                rcpath = "l3features:vrfs/vrf=%s/dhcp-servers/dhcp-server=%s"%(util.make_interfacename(vrf_name),util.make_interfacename(dhcp_server_interface_name))
                self.delete_(sdata, dev, mapping_dict=mapping_dict, fail_silently=fail_silently, remove_reference=remove_reference, rcpath=rcpath)

          def delete_(self, sdata, dev, **kwargs):
            mapping_dict = kwargs.get('mapping_dict')

            #validating inputs
            if util.isEmpty(mapping_dict.get('low_ipaddress')):
              raise Exception("'low_ipaddress' cannot be empty")

            #convert keys to list
            low_ipaddress = mapping_dict.get('low_ipaddress')
            if not isinstance(low_ipaddress, list):
              low_ipaddress = [low_ipaddress]

            #prepare rcpath
            rcpath = kwargs.get('rcpath')
            rcpath_list = []
            for low_ipaddress_iterator in low_ipaddress:
              rcpath_tmp =  rcpath+"/excluded-address=%s"%(util.make_interfacename(low_ipaddress_iterator))
              rcpath_list.append(rcpath_tmp)
            payload = ''

            for rcpath in rcpath_list:
              #call the base abstract class for deleteData
              super(self.__class__, self).delete_(sdata, dev, rcpath=rcpath, payload=payload, fail_silently=kwargs.get('fail_silently', False), remove_reference=kwargs.get('remove_reference', False))

          def validate_parent_keys(self, vrf_name, dhcp_server_interface_name):
            #Parent Key Validations
            if util.isEmpty(vrf_name):
              raise Exception("'vrf_name' cannot be empty")
            if util.isEmpty(dhcp_server_interface_name):
              raise Exception("'dhcp_server_interface_name' cannot be empty")

          def validate_inputs_form_payload(self, mapping_dict, update=False):
            #validating inputs
            if util.isEmpty(mapping_dict.get('low_ipaddress')):
              raise Exception("'low_ipaddress' cannot be empty")

            #convert keys to list
            low_ipaddress = mapping_dict.get('low_ipaddress')
            if not isinstance(low_ipaddress, list):
              low_ipaddress = [low_ipaddress]

            #prepare payload
            excluded_address_object_list = []
            for low_ipaddress_iterator in low_ipaddress:
              from servicemodel.controller.devices.device.vrfs.vrf.dhcp_servers import dhcp_server
              excluded_address_object = dhcp_server.excluded_address.excluded_address()
              excluded_address_object.low_ipaddress = low_ipaddress_iterator
              try:
                if (update == False) or (update == True and str(mapping_dict.get('high_ipaddress', None)) != ''):
                  excluded_address_object.high_ipaddress = mapping_dict.get('high_ipaddress', None)
                else:
                  excluded_address_object.high_ipaddress._empty_tag = True
              except TypeError:
                pass
              try:
                if (update == False) or (update == True and str(mapping_dict.get('vrf_name', None)) != ''):
                  excluded_address_object.vrf_name = mapping_dict.get('vrf_name', None)
                else:
                  excluded_address_object.vrf_name._empty_tag = True
              except TypeError:
                pass
              excluded_address_object_list.append(excluded_address_object)

            return excluded_address_object_list

