
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class action(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/eem-applets/event-manager-applet/actions/action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__label','__action_statement','__cli_type','__cli_string','__regex_pattern','__input_string','__syslog','__syslog_priority','__syslog_msg','__first_operand','__compare','__second_operand','__exit_result','__comment_string','__handle_error_type','__wait_time','__snmp_trap_type','__snmp_trap_data','__match_varaible','__submatch_variable',)

  _yang_name = 'action'
  _module_name = 'l3features'
  _namespace = 'http://anutanetworks.com/l3features'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="wait-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint64', is_config=True)
    self.__compare = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ge': {}, u'eq': {}, u'lt': {}},), is_leaf=True, yang_name="compare", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__syslog_msg = YANGDynClass(base=unicode, is_leaf=True, yang_name="syslog-msg", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__submatch_variable = YANGDynClass(base=unicode, is_leaf=True, yang_name="submatch-variable", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__snmp_trap_data = YANGDynClass(base=[unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),], is_leaf=True, yang_name="snmp-trap-data", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='union', is_config=True)
    self.__first_operand = YANGDynClass(base=unicode, is_leaf=True, yang_name="first-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__comment_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="comment-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__cli_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="cli-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__label = YANGDynClass(base=unicode, is_leaf=True, yang_name="label", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__second_operand = YANGDynClass(base=unicode, is_leaf=True, yang_name="second-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__syslog = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'priority': {}, u'msg': {}},), is_leaf=True, yang_name="syslog", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__regex_pattern = YANGDynClass(base=unicode, is_leaf=True, yang_name="regex-pattern", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__match_varaible = YANGDynClass(base=unicode, is_leaf=True, yang_name="match-varaible", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__handle_error_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ignore': {}, u'warn': {}, u'exit': {}},), is_leaf=True, yang_name="handle-error-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__input_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="input-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__syslog_priority = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'debugging': {}, u'errors': {}, u'warnings': {}, u'alerts': {}, u'emergencies': {}, u'notifications': {}, u'critical': {}, u'informational': {}},), is_leaf=True, yang_name="syslog-priority", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__snmp_trap_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'intdata1': {}, u'strdata': {}, u'intdata2': {}},), is_leaf=True, yang_name="snmp-trap-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__action_statement = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'comment': {}, u'end': {}, u'cli': {}, u'snmp-trap': {}, u'wait': {}, u'else': {}, u'syslog': {}, u'exit': {}, u'regexp': {}, u'handle-error': {}, u'if': {}},), is_leaf=True, yang_name="action-statement", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__cli_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pattern': {}, u'command': {}},), is_leaf=True, yang_name="cli-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__exit_result = YANGDynClass(base=unicode, is_leaf=True, yang_name="exit-result", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'eem-applets', u'event-manager-applet', u'actions', u'action']

  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/label (string)

    YANG Description: string
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="label", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="label", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=unicode, is_leaf=True, yang_name="label", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_action_statement(self):
    """
    Getter method for action_statement, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/action_statement (enumeration)

    YANG Description: Add or modify an action statement
    """
    return self.__action_statement
      
  def _set_action_statement(self, v, load=False):
    """
    Setter method for action_statement, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/action_statement (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action_statement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action_statement() directly.

    YANG Description: Add or modify an action statement
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'comment': {}, u'end': {}, u'cli': {}, u'snmp-trap': {}, u'wait': {}, u'else': {}, u'syslog': {}, u'exit': {}, u'regexp': {}, u'handle-error': {}, u'if': {}},), is_leaf=True, yang_name="action-statement", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action_statement must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'comment': {}, u'end': {}, u'cli': {}, u'snmp-trap': {}, u'wait': {}, u'else': {}, u'syslog': {}, u'exit': {}, u'regexp': {}, u'handle-error': {}, u'if': {}},), is_leaf=True, yang_name="action-statement", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__action_statement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action_statement(self):
    self.__action_statement = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'comment': {}, u'end': {}, u'cli': {}, u'snmp-trap': {}, u'wait': {}, u'else': {}, u'syslog': {}, u'exit': {}, u'regexp': {}, u'handle-error': {}, u'if': {}},), is_leaf=True, yang_name="action-statement", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_cli_type(self):
    """
    Getter method for cli_type, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/cli_type (enumeration)

    YANG Description: command
pattern

    """
    return self.__cli_type
      
  def _set_cli_type(self, v, load=False):
    """
    Setter method for cli_type, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/cli_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cli_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cli_type() directly.

    YANG Description: command
pattern

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pattern': {}, u'command': {}},), is_leaf=True, yang_name="cli-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cli_type must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pattern': {}, u'command': {}},), is_leaf=True, yang_name="cli-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__cli_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cli_type(self):
    self.__cli_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pattern': {}, u'command': {}},), is_leaf=True, yang_name="cli-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_cli_string(self):
    """
    Getter method for cli_string, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/cli_string (string)

    YANG Description: string
    """
    return self.__cli_string
      
  def _set_cli_string(self, v, load=False):
    """
    Setter method for cli_string, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/cli_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cli_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cli_string() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cli-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cli_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cli-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__cli_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cli_string(self):
    self.__cli_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="cli-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_regex_pattern(self):
    """
    Getter method for regex_pattern, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/regex_pattern (string)

    YANG Description: regular expression pattern
    """
    return self.__regex_pattern
      
  def _set_regex_pattern(self, v, load=False):
    """
    Setter method for regex_pattern, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/regex_pattern (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_regex_pattern is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_regex_pattern() directly.

    YANG Description: regular expression pattern
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="regex-pattern", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """regex_pattern must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="regex-pattern", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__regex_pattern = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_regex_pattern(self):
    self.__regex_pattern = YANGDynClass(base=unicode, is_leaf=True, yang_name="regex-pattern", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_input_string(self):
    """
    Getter method for input_string, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/input_string (string)

    YANG Description: string
    """
    return self.__input_string
      
  def _set_input_string(self, v, load=False):
    """
    Setter method for input_string, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/input_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_string() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="input-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="input-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__input_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_string(self):
    self.__input_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="input-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_syslog(self):
    """
    Getter method for syslog, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/syslog (enumeration)

    YANG Description: priority
msg

    """
    return self.__syslog
      
  def _set_syslog(self, v, load=False):
    """
    Setter method for syslog, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/syslog (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_syslog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_syslog() directly.

    YANG Description: priority
msg

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'priority': {}, u'msg': {}},), is_leaf=True, yang_name="syslog", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """syslog must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'priority': {}, u'msg': {}},), is_leaf=True, yang_name="syslog", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__syslog = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_syslog(self):
    self.__syslog = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'priority': {}, u'msg': {}},), is_leaf=True, yang_name="syslog", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_syslog_priority(self):
    """
    Getter method for syslog_priority, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/syslog_priority (enumeration)

    YANG Description: alerts
critical
debugging
emergencies
errors
informational
notifications
warnings

    """
    return self.__syslog_priority
      
  def _set_syslog_priority(self, v, load=False):
    """
    Setter method for syslog_priority, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/syslog_priority (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_syslog_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_syslog_priority() directly.

    YANG Description: alerts
critical
debugging
emergencies
errors
informational
notifications
warnings

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'debugging': {}, u'errors': {}, u'warnings': {}, u'alerts': {}, u'emergencies': {}, u'notifications': {}, u'critical': {}, u'informational': {}},), is_leaf=True, yang_name="syslog-priority", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """syslog_priority must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'debugging': {}, u'errors': {}, u'warnings': {}, u'alerts': {}, u'emergencies': {}, u'notifications': {}, u'critical': {}, u'informational': {}},), is_leaf=True, yang_name="syslog-priority", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__syslog_priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_syslog_priority(self):
    self.__syslog_priority = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'debugging': {}, u'errors': {}, u'warnings': {}, u'alerts': {}, u'emergencies': {}, u'notifications': {}, u'critical': {}, u'informational': {}},), is_leaf=True, yang_name="syslog-priority", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_syslog_msg(self):
    """
    Getter method for syslog_msg, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/syslog_msg (string)

    YANG Description: string
    """
    return self.__syslog_msg
      
  def _set_syslog_msg(self, v, load=False):
    """
    Setter method for syslog_msg, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/syslog_msg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_syslog_msg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_syslog_msg() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="syslog-msg", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """syslog_msg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="syslog-msg", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__syslog_msg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_syslog_msg(self):
    self.__syslog_msg = YANGDynClass(base=unicode, is_leaf=True, yang_name="syslog-msg", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_first_operand(self):
    """
    Getter method for first_operand, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/first_operand (string)

    YANG Description: string
    """
    return self.__first_operand
      
  def _set_first_operand(self, v, load=False):
    """
    Setter method for first_operand, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/first_operand (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_first_operand is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_first_operand() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="first-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """first_operand must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="first-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__first_operand = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_first_operand(self):
    self.__first_operand = YANGDynClass(base=unicode, is_leaf=True, yang_name="first-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_compare(self):
    """
    Getter method for compare, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/compare (enumeration)

    YANG Description: eq
ge
lt

    """
    return self.__compare
      
  def _set_compare(self, v, load=False):
    """
    Setter method for compare, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/compare (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compare is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compare() directly.

    YANG Description: eq
ge
lt

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ge': {}, u'eq': {}, u'lt': {}},), is_leaf=True, yang_name="compare", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compare must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ge': {}, u'eq': {}, u'lt': {}},), is_leaf=True, yang_name="compare", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__compare = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compare(self):
    self.__compare = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ge': {}, u'eq': {}, u'lt': {}},), is_leaf=True, yang_name="compare", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_second_operand(self):
    """
    Getter method for second_operand, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/second_operand (string)

    YANG Description: string
    """
    return self.__second_operand
      
  def _set_second_operand(self, v, load=False):
    """
    Setter method for second_operand, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/second_operand (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_second_operand is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_second_operand() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="second-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """second_operand must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="second-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__second_operand = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_second_operand(self):
    self.__second_operand = YANGDynClass(base=unicode, is_leaf=True, yang_name="second-operand", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_exit_result(self):
    """
    Getter method for exit_result, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/exit_result (string)

    YANG Description: string
    """
    return self.__exit_result
      
  def _set_exit_result(self, v, load=False):
    """
    Setter method for exit_result, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/exit_result (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exit_result is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exit_result() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="exit-result", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exit_result must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="exit-result", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__exit_result = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exit_result(self):
    self.__exit_result = YANGDynClass(base=unicode, is_leaf=True, yang_name="exit-result", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_comment_string(self):
    """
    Getter method for comment_string, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/comment_string (string)

    YANG Description: string
    """
    return self.__comment_string
      
  def _set_comment_string(self, v, load=False):
    """
    Setter method for comment_string, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/comment_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_comment_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_comment_string() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="comment-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """comment_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="comment-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__comment_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_comment_string(self):
    self.__comment_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="comment-string", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_handle_error_type(self):
    """
    Getter method for handle_error_type, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/handle_error_type (enumeration)

    YANG Description: exit
ignore
warn

    """
    return self.__handle_error_type
      
  def _set_handle_error_type(self, v, load=False):
    """
    Setter method for handle_error_type, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/handle_error_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_handle_error_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_handle_error_type() directly.

    YANG Description: exit
ignore
warn

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ignore': {}, u'warn': {}, u'exit': {}},), is_leaf=True, yang_name="handle-error-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """handle_error_type must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ignore': {}, u'warn': {}, u'exit': {}},), is_leaf=True, yang_name="handle-error-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__handle_error_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_handle_error_type(self):
    self.__handle_error_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ignore': {}, u'warn': {}, u'exit': {}},), is_leaf=True, yang_name="handle-error-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_wait_time(self):
    """
    Getter method for wait_time, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/wait_time (uint64)

    YANG Description: wait time in seconds <1-31536000>
    """
    return self.__wait_time
      
  def _set_wait_time(self, v, load=False):
    """
    Setter method for wait_time, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/wait_time (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait_time() directly.

    YANG Description: wait time in seconds <1-31536000>
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="wait-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait_time must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="wait-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint64', is_config=True)""",
        })

    self.__wait_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait_time(self):
    self.__wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="wait-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint64', is_config=True)


  def _get_snmp_trap_type(self):
    """
    Getter method for snmp_trap_type, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/snmp_trap_type (enumeration)

    YANG Description: intdata1
intdata2
strdata

    """
    return self.__snmp_trap_type
      
  def _set_snmp_trap_type(self, v, load=False):
    """
    Setter method for snmp_trap_type, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/snmp_trap_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp_trap_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp_trap_type() directly.

    YANG Description: intdata1
intdata2
strdata

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'intdata1': {}, u'strdata': {}, u'intdata2': {}},), is_leaf=True, yang_name="snmp-trap-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp_trap_type must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'intdata1': {}, u'strdata': {}, u'intdata2': {}},), is_leaf=True, yang_name="snmp-trap-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__snmp_trap_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp_trap_type(self):
    self.__snmp_trap_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'intdata1': {}, u'strdata': {}, u'intdata2': {}},), is_leaf=True, yang_name="snmp-trap-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_snmp_trap_data(self):
    """
    Getter method for snmp_trap_data, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/snmp_trap_data (union)

    YANG Description: Union Input types:
string
int64

    """
    return self.__snmp_trap_data
      
  def _set_snmp_trap_data(self, v, load=False):
    """
    Setter method for snmp_trap_data, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/snmp_trap_data (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp_trap_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp_trap_data() directly.

    YANG Description: Union Input types:
string
int64

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),], is_leaf=True, yang_name="snmp-trap-data", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp_trap_data must be of a type compatible with union""",
          'defined-type': "l3features:union",
          'generated-type': """YANGDynClass(base=[unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),], is_leaf=True, yang_name="snmp-trap-data", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='union', is_config=True)""",
        })

    self.__snmp_trap_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp_trap_data(self):
    self.__snmp_trap_data = YANGDynClass(base=[unicode,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),], is_leaf=True, yang_name="snmp-trap-data", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='union', is_config=True)


  def _get_match_varaible(self):
    """
    Getter method for match_varaible, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/match_varaible (string)

    YANG Description: string
    """
    return self.__match_varaible
      
  def _set_match_varaible(self, v, load=False):
    """
    Setter method for match_varaible, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/match_varaible (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match_varaible is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match_varaible() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="match-varaible", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match_varaible must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="match-varaible", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__match_varaible = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match_varaible(self):
    self.__match_varaible = YANGDynClass(base=unicode, is_leaf=True, yang_name="match-varaible", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_submatch_variable(self):
    """
    Getter method for submatch_variable, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/submatch_variable (string)

    YANG Description: string
    """
    return self.__submatch_variable
      
  def _set_submatch_variable(self, v, load=False):
    """
    Setter method for submatch_variable, mapped from YANG variable /devices/device/eem_applets/event_manager_applet/actions/action/submatch_variable (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_submatch_variable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_submatch_variable() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="submatch-variable", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """submatch_variable must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="submatch-variable", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__submatch_variable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_submatch_variable(self):
    self.__submatch_variable = YANGDynClass(base=unicode, is_leaf=True, yang_name="submatch-variable", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)

  label = __builtin__.property(_get_label, _set_label)
  action_statement = __builtin__.property(_get_action_statement, _set_action_statement)
  cli_type = __builtin__.property(_get_cli_type, _set_cli_type)
  cli_string = __builtin__.property(_get_cli_string, _set_cli_string)
  regex_pattern = __builtin__.property(_get_regex_pattern, _set_regex_pattern)
  input_string = __builtin__.property(_get_input_string, _set_input_string)
  syslog = __builtin__.property(_get_syslog, _set_syslog)
  syslog_priority = __builtin__.property(_get_syslog_priority, _set_syslog_priority)
  syslog_msg = __builtin__.property(_get_syslog_msg, _set_syslog_msg)
  first_operand = __builtin__.property(_get_first_operand, _set_first_operand)
  compare = __builtin__.property(_get_compare, _set_compare)
  second_operand = __builtin__.property(_get_second_operand, _set_second_operand)
  exit_result = __builtin__.property(_get_exit_result, _set_exit_result)
  comment_string = __builtin__.property(_get_comment_string, _set_comment_string)
  handle_error_type = __builtin__.property(_get_handle_error_type, _set_handle_error_type)
  wait_time = __builtin__.property(_get_wait_time, _set_wait_time)
  snmp_trap_type = __builtin__.property(_get_snmp_trap_type, _set_snmp_trap_type)
  snmp_trap_data = __builtin__.property(_get_snmp_trap_data, _set_snmp_trap_data)
  match_varaible = __builtin__.property(_get_match_varaible, _set_match_varaible)
  submatch_variable = __builtin__.property(_get_submatch_variable, _set_submatch_variable)


  _pyangbind_elements = collections.OrderedDict([('label', label), ('action_statement', action_statement), ('cli_type', cli_type), ('cli_string', cli_string), ('regex_pattern', regex_pattern), ('input_string', input_string), ('syslog', syslog), ('syslog_priority', syslog_priority), ('syslog_msg', syslog_msg), ('first_operand', first_operand), ('compare', compare), ('second_operand', second_operand), ('exit_result', exit_result), ('comment_string', comment_string), ('handle_error_type', handle_error_type), ('wait_time', wait_time), ('snmp_trap_type', snmp_trap_type), ('snmp_trap_data', snmp_trap_data), ('match_varaible', match_varaible), ('submatch_variable', submatch_variable), ])


