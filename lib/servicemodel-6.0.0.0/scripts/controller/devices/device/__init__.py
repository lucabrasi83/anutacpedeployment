
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import reconciliation
import location_properties
import violations
import compliances
import interfaces
import interface_ranges
import vlans
import vlan_groups
import vn_services
import vn_paths
import port_groups
import port_channels
import route_policies
import rib_groups
import vrfs
import community_lists
import extcommunity_lists
import ip_sla
import ip_sla_schedules
import ip_nat_pool
import ip_nat
import tracks
import prefix_sets
import as_path_acls
import route_maps
import eigrp
import policy_options
import dhcp_server
import CaTrustPointCertificate
import ip_prefixlist_list
import vpls_list
import eem_script
import eem_applets
import netflow
import bridge
import key_chain
import static_routes
import routes
import snmp
import ntp
import username
import clock
import banner
import http
import service_time_stamps
import ha
import local_credentials
import ssh
import logging
import aaa_root
import aaa_group
import call_home
import tacacs_conf
import tftp
import license
import hostname
import vty_configs
import console
import auxiliary_port
import features
import spanning_tree
import error_disable_recovery
import bfd
import ip_arp
import mac_table
import service_unsupported
import jumbo_mtu
import bgp
import interface_breakout
import event_manager
import shell_options
import crypto
import crypto_policies
import crypto_proposals
import crypto_keyrings
import transform_sets
import ipsec_profiles
import dmvpntunnels
import domain
import dns_server
import a_records
import host_records
import dns_zones
import resource_records
import access_lists
import number_access_lists
import object_groups_acl
import interface_access_lists
import security_rules
import svclcs
import virtual_devices
import zones
import policers
import applications
import applicationsets
import addressbooks
import dnsproxies
import dhcppools
import object_groups
import fw_users
import fw_user_groups
import addresses
import address_sets
import address_entries
import address_groups
import services
import service_groups
import templates
import ips_sensors
import ipsec_tunnels
import network_objects
import failover_groups
import vdom_links
import modules
import wanop
import inpath_config
import network_proxy
import label_configuration
import wanop_applications
import inpath_rules
import domain_lists
import optimization_services
import network_services
import general_services
import protocols
import secure_peering
import class_maps
import policy_maps
import system_qos
import pfr_classes
import pfr_policy_maps
import qos_scheduler_policies
import qos_group_templates
import vpls
import lb_domains
import self_ips
import contexts
import real_servers
import rservice_pools
import virtual_servers
import snat_pools
import lb_routes
import lb_ha_node
import health_monitors
import certificates
import partitions
import linecard
import configurations
import subnets
import tenants
import capacities
import l2_neighbors
class device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__id','__management_mode','__status','__name','__mgmt_ip_address','__fqdn_name','__credential_set','__derived_credential_set','__device_type','__os_version','__platform','__description','__driver_name','__hardware_throughput','__dns_name','__rma','__num_vms','__num_nics','__num_cpus','__cpu_mhz','__is_module','__chassis','__model','__memory','__processor','__port_channel','__num_sockets','__subscribed_to_snmp_traps','__subscribed_to_syslog','__vem_module_num','__stale_entry','__pair_mgmt_ip_address','__vmstatus','__device_family_string','__ostype_string','__vendor_string','__serial_number','__sys_descr','__sys_object_id','__sys_location','__sys_up_time','__mgmt_vrf_name','__manage_by_management_station','__management_station','__managed_devices','__vm_name','__cluster_ip_address','__device_capability','__unmanaged_device_capability','__virtual_appliance_image','__agent_id','__priv_status','__reconciliation','__unique_name','__service_provisioning_status','__location_properties','__violations','__compliance_status','__compliances','__interfaces','__interface_ranges','__vlans','__vlan_groups','__vn_services','__vn_paths','__port_groups','__port_channels','__route_policies','__rib_groups','__vrfs','__community_lists','__extcommunity_lists','__ip_sla','__ip_sla_schedules','__ip_nat_pool','__ip_nat','__tracks','__prefix_sets','__bgp_as','__as_path_acls','__route_maps','__eigrp','__policy_options','__dhcp_server','__CaTrustPointCertificate','__ip_prefixlist_list','__vpls_list','__eem_script','__eem_applets','__netflow','__bridge','__key_chain','__static_routes','__routes','__snmp','__ntp','__username','__clock','__banner','__http','__service_time_stamps','__ha','__local_credentials','__ssh','__logging','__aaa_root','__aaa_group','__call_home','__tacacs_conf','__tftp','__license','__hostname','__vty_configs','__console','__auxiliary_port','__features','__spanning_tree','__error_disable_recovery','__bfd','__ip_arp','__mac_table','__service_unsupported','__jumbo_mtu','__bgp','__interface_breakout','__event_manager','__shell_options','__crypto','__crypto_policies','__crypto_proposals','__crypto_keyrings','__transform_sets','__ipsec_profiles','__dmvpntunnels','__domain','__dns_server','__a_records','__host_records','__dns_zones','__resource_records','__access_lists','__number_access_lists','__object_groups_acl','__interface_access_lists','__security_rules','__svclcs','__virtual_devices','__zones','__policers','__applications','__applicationsets','__addressbooks','__dnsproxies','__dhcppools','__object_groups','__fw_users','__fw_user_groups','__addresses','__address_sets','__address_entries','__address_groups','__services','__service_groups','__templates','__ips_sensors','__ipsec_tunnels','__network_objects','__failover_groups','__vdom_links','__modules','__wanop','__inpath_config','__network_proxy','__label_configuration','__wanop_applications','__inpath_rules','__domain_lists','__optimization_services','__network_services','__general_services','__protocols','__secure_peering','__class_maps','__policy_maps','__system_qos','__pfr_classes','__pfr_policy_maps','__qos_scheduler_policies','__qos_group_templates','__vpls','__lb_domains','__self_ips','__contexts','__real_servers','__rservice_pools','__virtual_servers','__snat_pools','__lb_routes','__lb_ha_node','__health_monitors','__certificates','__partitions','__linecard','__cspservice_type','__csp_ip_url','__region','__configurations','__subnets','__tenants','__keystone_ip','__capacities','__l2_neighbors',)

  _yang_name = 'device'
  _module_name = 'controller'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cspservice_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AWS': {}, u'NEUSTAR': {}},), is_leaf=True, yang_name="cspservice-type", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='service-type-enum', is_config=True)
    self.__network_objects = YANGDynClass(base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__route_policies = YANGDynClass(base=route_policies.route_policies, is_container='container', yang_name="route-policies", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__self_ips = YANGDynClass(base=self_ips.self_ips, is_container='container', yang_name="self-ips", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__port_channel = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port-channel", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__fw_user_groups = YANGDynClass(base=fw_user_groups.fw_user_groups, is_container='container', yang_name="fw-user-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__error_disable_recovery = YANGDynClass(base=error_disable_recovery.error_disable_recovery, is_container='container', yang_name="error-disable-recovery", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__addresses = YANGDynClass(base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__host_records = YANGDynClass(base=host_records.host_records, is_container='container', yang_name="host-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    self.__ha = YANGDynClass(base=ha.ha, is_container='container', yang_name="ha", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__console = YANGDynClass(base=console.console, is_container='container', yang_name="console", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__hardware_throughput = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hardware-throughput", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint16', is_config=True)
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__platform = YANGDynClass(base=unicode, default=unicode(""), is_leaf=True, yang_name="platform", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__mgmt_vrf_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[a-zA-Z0-9_]+$', 'length': [u'1..64']}), is_leaf=True, yang_name="mgmt-vrf-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:nameString64', is_config=True)
    self.__interface_breakout = YANGDynClass(base=interface_breakout.interface_breakout, is_container='container', yang_name="interface-breakout", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__is_module = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-module", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__port_groups = YANGDynClass(base=port_groups.port_groups, is_container='container', yang_name="port-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    self.__sys_object_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-object-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__violations = YANGDynClass(base=violations.violations, is_container='container', yang_name="violations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__sys_up_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-up-time", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__vm_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vm-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__pfr_policy_maps = YANGDynClass(base=pfr_policy_maps.pfr_policy_maps, is_container='container', yang_name="pfr-policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__keystone_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="keystone-ip", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='inet:ipv4-address', is_config=True)
    self.__address_sets = YANGDynClass(base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__tenants = YANGDynClass(base=tenants.tenants, is_container='container', yang_name="tenants", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='container', is_config=True)
    self.__sys_location = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-location", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__pair_mgmt_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="pair-mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=False)
    self.__capacities = YANGDynClass(base=capacities.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    self.__call_home = YANGDynClass(base=call_home.call_home, is_container='container', yang_name="call-home", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__location_properties = YANGDynClass(base=location_properties.location_properties, is_container='container', yang_name="location-properties", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__derived_credential_set = YANGDynClass(base=unicode, is_leaf=True, yang_name="derived-credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    self.__local_credentials = YANGDynClass(base=local_credentials.local_credentials, is_container='container', yang_name="local-credentials", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__access_lists = YANGDynClass(base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    self.__vn_services = YANGDynClass(base=vn_services.vn_services, is_container='container', yang_name="vn-services", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    self.__management_station = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__ssh = YANGDynClass(base=ssh.ssh, is_container='container', yang_name="ssh", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__vendor_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__eem_script = YANGDynClass(base=eem_script.eem_script, is_container='container', yang_name="eem-script", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__netflow = YANGDynClass(base=netflow.netflow, is_container='container', yang_name="netflow", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__banner = YANGDynClass(base=banner.banner, is_container='container', yang_name="banner", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__partitions = YANGDynClass(base=partitions.partitions, is_container='container', yang_name="partitions", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__crypto = YANGDynClass(base=crypto.crypto, is_container='container', yang_name="crypto", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__eem_applets = YANGDynClass(base=eem_applets.eem_applets, is_container='container', yang_name="eem-applets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__ostype_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="ostype-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__vem_module_num = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vem-module-num", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__vrfs = YANGDynClass(base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__general_services = YANGDynClass(base=general_services.general_services, is_container='container', yang_name="general-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__auxiliary_port = YANGDynClass(base=auxiliary_port.auxiliary_port, is_container='container', yang_name="auxiliary-port", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__ipsec_tunnels = YANGDynClass(base=ipsec_tunnels.ipsec_tunnels, is_container='container', yang_name="ipsec-tunnels", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__service_time_stamps = YANGDynClass(base=service_time_stamps.service_time_stamps, is_container='container', yang_name="service-time-stamps", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__configurations = YANGDynClass(base=configurations.configurations, is_container='container', yang_name="configurations", module_name="bluecat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/bluecat', defining_module='bluecat', yang_type='container', is_config=True)
    self.__rib_groups = YANGDynClass(base=rib_groups.rib_groups, is_container='container', yang_name="rib-groups", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__templates = YANGDynClass(base=templates.templates, is_container='container', yang_name="templates", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__domain = YANGDynClass(base=domain.domain, is_container='container', yang_name="domain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__virtual_servers = YANGDynClass(base=virtual_servers.virtual_servers, is_container='container', yang_name="virtual-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__management_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'MANAGED': {}, u'DUMMY': {}},), default=unicode("MANAGED"), is_leaf=True, yang_name="management-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='enumeration', is_config=True)
    self.__zones = YANGDynClass(base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__real_servers = YANGDynClass(base=real_servers.real_servers, is_container='container', yang_name="real-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__transform_sets = YANGDynClass(base=transform_sets.transform_sets, is_container='container', yang_name="transform-sets", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__rma = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rma", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__as_path_acls = YANGDynClass(base=as_path_acls.as_path_acls, is_container='container', yang_name="as-path-acls", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__lb_ha_node = YANGDynClass(base=lb_ha_node.lb_ha_node, is_container='container', yang_name="lb-ha-node", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__compliances = YANGDynClass(base=compliances.compliances, is_container='container', yang_name="compliances", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__reconciliation = YANGDynClass(base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__prefix_sets = YANGDynClass(base=prefix_sets.prefix_sets, is_container='container', yang_name="prefix-sets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__dns_zones = YANGDynClass(base=dns_zones.dns_zones, is_container='container', yang_name="dns-zones", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    self.__virtual_devices = YANGDynClass(base=virtual_devices.virtual_devices, is_container='container', yang_name="virtual-devices", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__bgp_as = YANGDynClass(base=unicode, is_leaf=True, yang_name="bgp-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='l3:as-number', is_config=False)
    self.__lb_domains = YANGDynClass(base=lb_domains.lb_domains, is_container='container', yang_name="lb-domains", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__wanop = YANGDynClass(base=wanop.wanop, is_container='container', yang_name="wanop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__resource_records = YANGDynClass(base=resource_records.resource_records, is_container='container', yang_name="resource-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    self.__object_groups = YANGDynClass(base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__subscribed_to_syslog = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="subscribed-to-syslog", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__credential_set = YANGDynClass(base=unicode, is_leaf=True, yang_name="credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__mgmt_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)
    self.__vmstatus = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TO_BE_DEPLOYED': {}, u'TO_BE_DELETED': {}, u'PREMANAGED': {}, u'CONTEXT': {}, u'DEPLOYED': {}},), is_leaf=True, yang_name="vmstatus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='vm-status', is_config=False)
    self.__policers = YANGDynClass(base=policers.policers, is_container='container', yang_name="policers", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__class_maps = YANGDynClass(base=class_maps.class_maps, is_container='container', yang_name="class-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__compliance_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMPLIANT': {}, u'NON_COMPLIANT': {}, u'NONE': {}},), is_leaf=True, yang_name="compliance-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:compliance-status', is_config=False)
    self.__num_sockets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-sockets", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__vdom_links = YANGDynClass(base=vdom_links.vdom_links, is_container='container', yang_name="vdom-links", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__tracks = YANGDynClass(base=tracks.tracks, is_container='container', yang_name="tracks", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__chassis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__dmvpntunnels = YANGDynClass(base=dmvpntunnels.dmvpntunnels, is_container='container', yang_name="dmvpntunnels", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__agent_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="agent-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    self.__policy_options = YANGDynClass(base=policy_options.policy_options, is_container='container', yang_name="policy-options", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__vpls_list = YANGDynClass(base=vpls_list.vpls_list, is_container='container', yang_name="vpls-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__interface_ranges = YANGDynClass(base=interface_ranges.interface_ranges, is_container='container', yang_name="interface-ranges", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__service_unsupported = YANGDynClass(base=service_unsupported.service_unsupported, is_container='container', yang_name="service-unsupported", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__csp_ip_url = YANGDynClass(base=unicode, is_leaf=True, yang_name="csp_ip-url", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=True)
    self.__ip_arp = YANGDynClass(base=ip_arp.ip_arp, is_container='container', yang_name="ip-arp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__lb_routes = YANGDynClass(base=lb_routes.lb_routes, is_container='container', yang_name="lb-routes", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__license = YANGDynClass(base=license.license, is_container='container', yang_name="license", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__sys_descr = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-descr", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__snat_pools = YANGDynClass(base=snat_pools.snat_pools, is_container='container', yang_name="snat-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__extcommunity_lists = YANGDynClass(base=extcommunity_lists.extcommunity_lists, is_container='container', yang_name="extcommunity-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__system_qos = YANGDynClass(base=system_qos.system_qos, is_container='container', yang_name="system-qos", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__inpath_config = YANGDynClass(base=inpath_config.inpath_config, is_container='container', yang_name="inpath-config", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__unmanaged_device_capability = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="unmanaged-device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__tacacs_conf = YANGDynClass(base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__routes = YANGDynClass(base=routes.routes, is_container='container', yang_name="routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__event_manager = YANGDynClass(base=event_manager.event_manager, is_container='container', yang_name="event-manager", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__tftp = YANGDynClass(base=tftp.tftp, is_container='container', yang_name="tftp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__vty_configs = YANGDynClass(base=vty_configs.vty_configs, is_container='container', yang_name="vty-configs", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__processor = YANGDynClass(base=unicode, is_leaf=True, yang_name="processor", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__device_family_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="device-family-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__port_channels = YANGDynClass(base=port_channels.port_channels, is_container='container', yang_name="port-channels", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    self.__unique_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="unique-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__features = YANGDynClass(base=features.features, is_container='container', yang_name="features", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__ipsec_profiles = YANGDynClass(base=ipsec_profiles.ipsec_profiles, is_container='container', yang_name="ipsec-profiles", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__interface_access_lists = YANGDynClass(base=interface_access_lists.interface_access_lists, is_container='container', yang_name="interface-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    self.__services = YANGDynClass(base=services.services, is_container='container', yang_name="services", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__aaa_group = YANGDynClass(base=aaa_group.aaa_group, is_container='container', yang_name="aaa-group", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__address_groups = YANGDynClass(base=address_groups.address_groups, is_container='container', yang_name="address-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__spanning_tree = YANGDynClass(base=spanning_tree.spanning_tree, is_container='container', yang_name="spanning-tree", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__certificates = YANGDynClass(base=certificates.certificates, is_container='container', yang_name="certificates", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__shell_options = YANGDynClass(base=shell_options.shell_options, is_container='container', yang_name="shell-options", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__label_configuration = YANGDynClass(base=label_configuration.label_configuration, is_container='container', yang_name="label-configuration", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__aaa_root = YANGDynClass(base=aaa_root.aaa_root, is_container='container', yang_name="aaa-root", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__stale_entry = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stale-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__qos_scheduler_policies = YANGDynClass(base=qos_scheduler_policies.qos_scheduler_policies, is_container='container', yang_name="qos-scheduler-policies", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__addressbooks = YANGDynClass(base=addressbooks.addressbooks, is_container='container', yang_name="addressbooks", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__optimization_services = YANGDynClass(base=optimization_services.optimization_services, is_container='container', yang_name="optimization-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__snmp = YANGDynClass(base=snmp.snmp, is_container='container', yang_name="snmp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__os_version = YANGDynClass(base=unicode, default=unicode(""), is_leaf=True, yang_name="os-version", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__secure_peering = YANGDynClass(base=secure_peering.secure_peering, is_container='container', yang_name="secure-peering", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="memory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__serial_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="serial-number", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__crypto_keyrings = YANGDynClass(base=crypto_keyrings.crypto_keyrings, is_container='container', yang_name="crypto-keyrings", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__domain_lists = YANGDynClass(base=domain_lists.domain_lists, is_container='container', yang_name="domain-lists", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__number_access_lists = YANGDynClass(base=number_access_lists.number_access_lists, is_container='container', yang_name="number-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    self.__username = YANGDynClass(base=username.username, is_container='container', yang_name="username", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__rservice_pools = YANGDynClass(base=rservice_pools.rservice_pools, is_container='container', yang_name="rservice-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__ip_sla = YANGDynClass(base=ip_sla.ip_sla, is_container='container', yang_name="ip-sla", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__inpath_rules = YANGDynClass(base=inpath_rules.inpath_rules, is_container='container', yang_name="inpath-rules", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__address_entries = YANGDynClass(base=address_entries.address_entries, is_container='container', yang_name="address-entries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__managed_devices = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="managed-devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    self.__cluster_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="cluster-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)
    self.__network_proxy = YANGDynClass(base=network_proxy.network_proxy, is_container='container', yang_name="network-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__ip_nat_pool = YANGDynClass(base=ip_nat_pool.ip_nat_pool, is_container='container', yang_name="ip-nat-pool", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__CaTrustPointCertificate = YANGDynClass(base=CaTrustPointCertificate.CaTrustPointCertificate, is_container='container', yang_name="CaTrustPointCertificate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__mac_table = YANGDynClass(base=mac_table.mac_table, is_container='container', yang_name="mac-table", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__device_capability = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    self.__applicationsets = YANGDynClass(base=applicationsets.applicationsets, is_container='container', yang_name="applicationsets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__vlans = YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    self.__qos_group_templates = YANGDynClass(base=qos_group_templates.qos_group_templates, is_container='container', yang_name="qos-group-templates", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__jumbo_mtu = YANGDynClass(base=jumbo_mtu.jumbo_mtu, is_container='container', yang_name="jumbo-mtu", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__protocols = YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__dns_server = YANGDynClass(base=dns_server.dns_server, is_container='container', yang_name="dns-server", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    self.__ip_nat = YANGDynClass(base=ip_nat.ip_nat, is_container='container', yang_name="ip-nat", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__static_routes = YANGDynClass(base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__contexts = YANGDynClass(base=contexts.contexts, is_container='container', yang_name="contexts", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__fw_users = YANGDynClass(base=fw_users.fw_users, is_container='container', yang_name="fw-users", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__linecard = YANGDynClass(base=YANGListType("switch_number slot_number",linecard.linecard, yang_name="linecard", module_name="linecard", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='switch-number slot-number'), is_container='list', yang_name="linecard", module_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/linecard', defining_module='linecard', yang_type='list', is_config=True)
    self.__eigrp = YANGDynClass(base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__service_provisioning_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Provisioned': {}, u'Unprovisioned': {}},), is_leaf=True, yang_name="service-provisioning-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='service-provisioning', is_config=True)
    self.__crypto_policies = YANGDynClass(base=crypto_policies.crypto_policies, is_container='container', yang_name="crypto-policies", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__dhcp_server = YANGDynClass(base=dhcp_server.dhcp_server, is_container='container', yang_name="dhcp-server", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__a_records = YANGDynClass(base=a_records.a_records, is_container='container', yang_name="a-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    self.__dnsproxies = YANGDynClass(base=dnsproxies.dnsproxies, is_container='container', yang_name="dnsproxies", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__bridge = YANGDynClass(base=bridge.bridge, is_container='container', yang_name="bridge", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__device_type = YANGDynClass(base=unicode, default=unicode("UNKNOWN"), is_leaf=True, yang_name="device-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__svclcs = YANGDynClass(base=svclcs.svclcs, is_container='container', yang_name="svclcs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__health_monitors = YANGDynClass(base=health_monitors.health_monitors, is_container='container', yang_name="health-monitors", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    self.__ip_sla_schedules = YANGDynClass(base=ip_sla_schedules.ip_sla_schedules, is_container='container', yang_name="ip-sla-schedules", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__ips_sensors = YANGDynClass(base=ips_sensors.ips_sensors, is_container='container', yang_name="ips-sensors", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__policy_maps = YANGDynClass(base=policy_maps.policy_maps, is_container='container', yang_name="policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__num_nics = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-nics", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__virtual_appliance_image = YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-appliance-image", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    self.__route_maps = YANGDynClass(base=route_maps.route_maps, is_container='container', yang_name="route-maps", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[\\w.:-]+', 'length': [u'1..64']}), is_leaf=True, yang_name="id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:id', is_config=True)
    self.__pfr_classes = YANGDynClass(base=pfr_classes.pfr_classes, is_container='container', yang_name="pfr-classes", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    self.__vn_paths = YANGDynClass(base=vn_paths.vn_paths, is_container='container', yang_name="vn-paths", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    self.__fqdn_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="fqdn-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__num_cpus = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-cpus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__hostname = YANGDynClass(base=hostname.hostname, is_container='container', yang_name="hostname", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__network_services = YANGDynClass(base=network_services.network_services, is_container='container', yang_name="network-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__object_groups_acl = YANGDynClass(base=object_groups_acl.object_groups_acl, is_container='container', yang_name="object-groups-acl", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    self.__vlan_groups = YANGDynClass(base=vlan_groups.vlan_groups, is_container='container', yang_name="vlan-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    self.__service_groups = YANGDynClass(base=service_groups.service_groups, is_container='container', yang_name="service-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__wanop_applications = YANGDynClass(base=wanop_applications.wanop_applications, is_container='container', yang_name="wanop-applications", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    self.__manage_by_management_station = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="manage-by-management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), default=unicode("OFFLINE"), is_leaf=True, yang_name="status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)
    self.__subnets = YANGDynClass(base=YANGListType("ip_address",subnets.subnets, yang_name="subnets", module_name="acs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="subnets", module_name="acs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acs', defining_module='acs', yang_type='list', is_config=True)
    self.__http = YANGDynClass(base=http.http, is_container='container', yang_name="http", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__priv_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), is_leaf=True, yang_name="priv-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)
    self.__dhcppools = YANGDynClass(base=dhcppools.dhcppools, is_container='container', yang_name="dhcppools", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__failover_groups = YANGDynClass(base=failover_groups.failover_groups, is_container='container', yang_name="failover-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__applications = YANGDynClass(base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__crypto_proposals = YANGDynClass(base=crypto_proposals.crypto_proposals, is_container='container', yang_name="crypto-proposals", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__l2_neighbors = YANGDynClass(base=l2_neighbors.l2_neighbors, is_container='container', yang_name="l2-neighbors", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)
    self.__vpls = YANGDynClass(base=vpls.vpls, is_container='container', yang_name="vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__security_rules = YANGDynClass(base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    self.__num_vms = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-vms", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__community_lists = YANGDynClass(base=community_lists.community_lists, is_container='container', yang_name="community-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__dns_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="dns-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__key_chain = YANGDynClass(base=key_chain.key_chain, is_container='container', yang_name="key-chain", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    self.__clock = YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    self.__modules = YANGDynClass(base=modules.modules, is_container='container', yang_name="modules", module_name="devicemodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/devicemodule', defining_module='devicemodule', yang_type='container', is_config=True)
    self.__subscribed_to_snmp_traps = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="subscribed-to-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    self.__driver_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="driver-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__cpu_mhz = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cpu-mhz", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    self.__region = YANGDynClass(base=unicode, is_leaf=True, yang_name="region", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=False)
    self.__model = YANGDynClass(base=unicode, is_leaf=True, yang_name="model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    self.__ip_prefixlist_list = YANGDynClass(base=ip_prefixlist_list.ip_prefixlist_list, is_container='container', yang_name="ip-prefixlist-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /devices/device/id (ncx:id)

    YANG Description: string
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /devices/device/id (ncx:id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[\\w.:-]+', 'length': [u'1..64']}), is_leaf=True, yang_name="id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with ncx:id""",
          'defined-type': "ncx:id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[\\w.:-]+', 'length': [u'1..64']}), is_leaf=True, yang_name="id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:id', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'[\\w.:-]+', 'length': [u'1..64']}), is_leaf=True, yang_name="id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:id', is_config=True)


  def _get_management_mode(self):
    """
    Getter method for management_mode, mapped from YANG variable /devices/device/management_mode (enumeration)

    YANG Description: 
Managed device: NCX manages and orchestrates such devices. 
UnManaged Devices: Neither managed nor orchestrated. No operations(commands) are created for unmanaged devices. 
Dummy Devices: Dummy records with NCX. NCX neither interacts nor manages these devices. Operations(commands) are generated for Dummy devices. 

    """
    return self.__management_mode
      
  def _set_management_mode(self, v, load=False):
    """
    Setter method for management_mode, mapped from YANG variable /devices/device/management_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management_mode() directly.

    YANG Description: 
Managed device: NCX manages and orchestrates such devices. 
UnManaged Devices: Neither managed nor orchestrated. No operations(commands) are created for unmanaged devices. 
Dummy Devices: Dummy records with NCX. NCX neither interacts nor manages these devices. Operations(commands) are generated for Dummy devices. 

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'MANAGED': {}, u'DUMMY': {}},), default=unicode("MANAGED"), is_leaf=True, yang_name="management-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management_mode must be of a type compatible with enumeration""",
          'defined-type': "controller:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'MANAGED': {}, u'DUMMY': {}},), default=unicode("MANAGED"), is_leaf=True, yang_name="management-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='enumeration', is_config=True)""",
        })

    self.__management_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management_mode(self):
    self.__management_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'MANAGED': {}, u'DUMMY': {}},), default=unicode("MANAGED"), is_leaf=True, yang_name="management-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='enumeration', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /devices/device/status (device-status)

    YANG Description: ONLINE
OFFLINE
UNSUPPORTED
UNMANAGED
MAINTENANCE

    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /devices/device/status (device-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: ONLINE
OFFLINE
UNSUPPORTED
UNMANAGED
MAINTENANCE

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), default=unicode("OFFLINE"), is_leaf=True, yang_name="status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with device-status""",
          'defined-type': "controller:device-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), default=unicode("OFFLINE"), is_leaf=True, yang_name="status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), default=unicode("OFFLINE"), is_leaf=True, yang_name="status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)

    YANG Description: the unique name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: the unique name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_mgmt_ip_address(self):
    """
    Getter method for mgmt_ip_address, mapped from YANG variable /devices/device/mgmt_ip_address (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__mgmt_ip_address
      
  def _set_mgmt_ip_address(self, v, load=False):
    """
    Setter method for mgmt_ip_address, mapped from YANG variable /devices/device/mgmt_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip_address() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip_address(self):
    self.__mgmt_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)


  def _get_fqdn_name(self):
    """
    Getter method for fqdn_name, mapped from YANG variable /devices/device/fqdn_name (string)

    YANG Description: string
    """
    return self.__fqdn_name
      
  def _set_fqdn_name(self, v, load=False):
    """
    Setter method for fqdn_name, mapped from YANG variable /devices/device/fqdn_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fqdn_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fqdn_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="fqdn-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fqdn_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="fqdn-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__fqdn_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fqdn_name(self):
    self.__fqdn_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="fqdn-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_credential_set(self):
    """
    Getter method for credential_set, mapped from YANG variable /devices/device/credential_set (leafref)

    YANG Description: credential-set
    """
    return self.__credential_set
      
  def _set_credential_set(self, v, load=False):
    """
    Setter method for credential_set, mapped from YANG variable /devices/device/credential_set (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_credential_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_credential_set() directly.

    YANG Description: credential-set
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """credential_set must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__credential_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_credential_set(self):
    self.__credential_set = YANGDynClass(base=unicode, is_leaf=True, yang_name="credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_derived_credential_set(self):
    """
    Getter method for derived_credential_set, mapped from YANG variable /devices/device/derived_credential_set (leafref)

    YANG Description: derived-credential-set
    """
    return self.__derived_credential_set
      
  def _set_derived_credential_set(self, v, load=False):
    """
    Setter method for derived_credential_set, mapped from YANG variable /devices/device/derived_credential_set (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_derived_credential_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_derived_credential_set() directly.

    YANG Description: derived-credential-set
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="derived-credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """derived_credential_set must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="derived-credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)""",
        })

    self.__derived_credential_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_derived_credential_set(self):
    self.__derived_credential_set = YANGDynClass(base=unicode, is_leaf=True, yang_name="derived-credential-set", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (leafref)

    YANG Description: device-type
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.

    YANG Description: device-type
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, default=unicode("UNKNOWN"), is_leaf=True, yang_name="device-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, default=unicode("UNKNOWN"), is_leaf=True, yang_name="device-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=unicode, default=unicode("UNKNOWN"), is_leaf=True, yang_name="device-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_os_version(self):
    """
    Getter method for os_version, mapped from YANG variable /devices/device/os_version (string)

    YANG Description: OS version
    """
    return self.__os_version
      
  def _set_os_version(self, v, load=False):
    """
    Setter method for os_version, mapped from YANG variable /devices/device/os_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_os_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_os_version() directly.

    YANG Description: OS version
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, default=unicode(""), is_leaf=True, yang_name="os-version", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """os_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, default=unicode(""), is_leaf=True, yang_name="os-version", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__os_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_os_version(self):
    self.__os_version = YANGDynClass(base=unicode, default=unicode(""), is_leaf=True, yang_name="os-version", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_platform(self):
    """
    Getter method for platform, mapped from YANG variable /devices/device/platform (string)

    YANG Description: string
    """
    return self.__platform
      
  def _set_platform(self, v, load=False):
    """
    Setter method for platform, mapped from YANG variable /devices/device/platform (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_platform is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_platform() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, default=unicode(""), is_leaf=True, yang_name="platform", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """platform must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, default=unicode(""), is_leaf=True, yang_name="platform", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__platform = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_platform(self):
    self.__platform = YANGDynClass(base=unicode, default=unicode(""), is_leaf=True, yang_name="platform", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/description (string)

    YANG Description: device type description
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: device type description
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_driver_name(self):
    """
    Getter method for driver_name, mapped from YANG variable /devices/device/driver_name (leafref)

    YANG Description: driver-name
    """
    return self.__driver_name
      
  def _set_driver_name(self, v, load=False):
    """
    Setter method for driver_name, mapped from YANG variable /devices/device/driver_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_driver_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_driver_name() directly.

    YANG Description: driver-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="driver-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """driver_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="driver-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__driver_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_driver_name(self):
    self.__driver_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="driver-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_hardware_throughput(self):
    """
    Getter method for hardware_throughput, mapped from YANG variable /devices/device/hardware_throughput (uint16)

    YANG Description: Value should be in MB.
    """
    return self.__hardware_throughput
      
  def _set_hardware_throughput(self, v, load=False):
    """
    Setter method for hardware_throughput, mapped from YANG variable /devices/device/hardware_throughput (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_throughput is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_throughput() directly.

    YANG Description: Value should be in MB.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hardware-throughput", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_throughput must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hardware-throughput", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint16', is_config=True)""",
        })

    self.__hardware_throughput = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_throughput(self):
    self.__hardware_throughput = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="hardware-throughput", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint16', is_config=True)


  def _get_dns_name(self):
    """
    Getter method for dns_name, mapped from YANG variable /devices/device/dns_name (string)

    YANG Description: string
    """
    return self.__dns_name
      
  def _set_dns_name(self, v, load=False):
    """
    Setter method for dns_name, mapped from YANG variable /devices/device/dns_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dns-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dns-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__dns_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_name(self):
    self.__dns_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="dns-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_rma(self):
    """
    Getter method for rma, mapped from YANG variable /devices/device/rma (boolean)

    YANG Description: rma: True/False
    """
    return self.__rma
      
  def _set_rma(self, v, load=False):
    """
    Setter method for rma, mapped from YANG variable /devices/device/rma (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rma is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rma() directly.

    YANG Description: rma: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="rma", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rma must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rma", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__rma = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rma(self):
    self.__rma = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rma", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_num_vms(self):
    """
    Getter method for num_vms, mapped from YANG variable /devices/device/num_vms (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__num_vms
      
  def _set_num_vms(self, v, load=False):
    """
    Setter method for num_vms, mapped from YANG variable /devices/device/num_vms (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_vms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_vms() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-vms", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_vms must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-vms", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__num_vms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_vms(self):
    self.__num_vms = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-vms", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_num_nics(self):
    """
    Getter method for num_nics, mapped from YANG variable /devices/device/num_nics (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__num_nics
      
  def _set_num_nics(self, v, load=False):
    """
    Setter method for num_nics, mapped from YANG variable /devices/device/num_nics (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_nics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_nics() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-nics", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_nics must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-nics", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__num_nics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_nics(self):
    self.__num_nics = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-nics", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_num_cpus(self):
    """
    Getter method for num_cpus, mapped from YANG variable /devices/device/num_cpus (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__num_cpus
      
  def _set_num_cpus(self, v, load=False):
    """
    Setter method for num_cpus, mapped from YANG variable /devices/device/num_cpus (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_cpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_cpus() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-cpus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_cpus must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-cpus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__num_cpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_cpus(self):
    self.__num_cpus = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-cpus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_cpu_mhz(self):
    """
    Getter method for cpu_mhz, mapped from YANG variable /devices/device/cpu_mhz (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__cpu_mhz
      
  def _set_cpu_mhz(self, v, load=False):
    """
    Setter method for cpu_mhz, mapped from YANG variable /devices/device/cpu_mhz (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_mhz is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_mhz() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cpu-mhz", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_mhz must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cpu-mhz", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__cpu_mhz = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_mhz(self):
    self.__cpu_mhz = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="cpu-mhz", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_is_module(self):
    """
    Getter method for is_module, mapped from YANG variable /devices/device/is_module (boolean)

    YANG Description: is-module: True/False
    """
    return self.__is_module
      
  def _set_is_module(self, v, load=False):
    """
    Setter method for is_module, mapped from YANG variable /devices/device/is_module (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_module() directly.

    YANG Description: is-module: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-module", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_module must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-module", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__is_module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_module(self):
    self.__is_module = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-module", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_chassis(self):
    """
    Getter method for chassis, mapped from YANG variable /devices/device/chassis (boolean)

    YANG Description: chassis: True/False
    """
    return self.__chassis
      
  def _set_chassis(self, v, load=False):
    """
    Setter method for chassis, mapped from YANG variable /devices/device/chassis (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis() directly.

    YANG Description: chassis: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__chassis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis(self):
    self.__chassis = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_model(self):
    """
    Getter method for model, mapped from YANG variable /devices/device/model (string)

    YANG Description: string
    """
    return self.__model
      
  def _set_model(self, v, load=False):
    """
    Setter method for model, mapped from YANG variable /devices/device/model (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_model() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """model must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__model = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_model(self):
    self.__model = YANGDynClass(base=unicode, is_leaf=True, yang_name="model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /devices/device/memory (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /devices/device/memory (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="memory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="memory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="memory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_processor(self):
    """
    Getter method for processor, mapped from YANG variable /devices/device/processor (string)

    YANG Description: string
    """
    return self.__processor
      
  def _set_processor(self, v, load=False):
    """
    Setter method for processor, mapped from YANG variable /devices/device/processor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processor() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="processor", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="processor", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__processor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processor(self):
    self.__processor = YANGDynClass(base=unicode, is_leaf=True, yang_name="processor", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_port_channel(self):
    """
    Getter method for port_channel, mapped from YANG variable /devices/device/port_channel (boolean)

    YANG Description: port-channel: True/False
    """
    return self.__port_channel
      
  def _set_port_channel(self, v, load=False):
    """
    Setter method for port_channel, mapped from YANG variable /devices/device/port_channel (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_channel() directly.

    YANG Description: port-channel: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="port-channel", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_channel must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port-channel", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__port_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_channel(self):
    self.__port_channel = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="port-channel", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_num_sockets(self):
    """
    Getter method for num_sockets, mapped from YANG variable /devices/device/num_sockets (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__num_sockets
      
  def _set_num_sockets(self, v, load=False):
    """
    Setter method for num_sockets, mapped from YANG variable /devices/device/num_sockets (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_sockets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_sockets() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-sockets", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_sockets must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-sockets", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__num_sockets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_sockets(self):
    self.__num_sockets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="num-sockets", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_subscribed_to_snmp_traps(self):
    """
    Getter method for subscribed_to_snmp_traps, mapped from YANG variable /devices/device/subscribed_to_snmp_traps (boolean)

    YANG Description: subscribed-to-snmp-traps: True/False
    """
    return self.__subscribed_to_snmp_traps
      
  def _set_subscribed_to_snmp_traps(self, v, load=False):
    """
    Setter method for subscribed_to_snmp_traps, mapped from YANG variable /devices/device/subscribed_to_snmp_traps (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscribed_to_snmp_traps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscribed_to_snmp_traps() directly.

    YANG Description: subscribed-to-snmp-traps: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="subscribed-to-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscribed_to_snmp_traps must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="subscribed-to-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__subscribed_to_snmp_traps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscribed_to_snmp_traps(self):
    self.__subscribed_to_snmp_traps = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="subscribed-to-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_subscribed_to_syslog(self):
    """
    Getter method for subscribed_to_syslog, mapped from YANG variable /devices/device/subscribed_to_syslog (boolean)

    YANG Description: subscribed-to-syslog: True/False
    """
    return self.__subscribed_to_syslog
      
  def _set_subscribed_to_syslog(self, v, load=False):
    """
    Setter method for subscribed_to_syslog, mapped from YANG variable /devices/device/subscribed_to_syslog (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscribed_to_syslog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscribed_to_syslog() directly.

    YANG Description: subscribed-to-syslog: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="subscribed-to-syslog", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscribed_to_syslog must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="subscribed-to-syslog", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__subscribed_to_syslog = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscribed_to_syslog(self):
    self.__subscribed_to_syslog = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="subscribed-to-syslog", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_vem_module_num(self):
    """
    Getter method for vem_module_num, mapped from YANG variable /devices/device/vem_module_num (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__vem_module_num
      
  def _set_vem_module_num(self, v, load=False):
    """
    Setter method for vem_module_num, mapped from YANG variable /devices/device/vem_module_num (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vem_module_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vem_module_num() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vem-module-num", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vem_module_num must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vem-module-num", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)""",
        })

    self.__vem_module_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vem_module_num(self):
    self.__vem_module_num = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vem-module-num", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='int32', is_config=False)


  def _get_stale_entry(self):
    """
    Getter method for stale_entry, mapped from YANG variable /devices/device/stale_entry (boolean)

    YANG Description: stale-entry: True/False
    """
    return self.__stale_entry
      
  def _set_stale_entry(self, v, load=False):
    """
    Setter method for stale_entry, mapped from YANG variable /devices/device/stale_entry (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stale_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stale_entry() directly.

    YANG Description: stale-entry: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="stale-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stale_entry must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stale-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)""",
        })

    self.__stale_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stale_entry(self):
    self.__stale_entry = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stale-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=False)


  def _get_pair_mgmt_ip_address(self):
    """
    Getter method for pair_mgmt_ip_address, mapped from YANG variable /devices/device/pair_mgmt_ip_address (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__pair_mgmt_ip_address
      
  def _set_pair_mgmt_ip_address(self, v, load=False):
    """
    Setter method for pair_mgmt_ip_address, mapped from YANG variable /devices/device/pair_mgmt_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pair_mgmt_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pair_mgmt_ip_address() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="pair-mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pair_mgmt_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="pair-mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=False)""",
        })

    self.__pair_mgmt_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pair_mgmt_ip_address(self):
    self.__pair_mgmt_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="pair-mgmt-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=False)


  def _get_vmstatus(self):
    """
    Getter method for vmstatus, mapped from YANG variable /devices/device/vmstatus (vm-status)

    YANG Description: PREMANAGED
TO_BE_DEPLOYED
DEPLOYED
TO_BE_DELETED
CONTEXT

    """
    return self.__vmstatus
      
  def _set_vmstatus(self, v, load=False):
    """
    Setter method for vmstatus, mapped from YANG variable /devices/device/vmstatus (vm-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vmstatus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vmstatus() directly.

    YANG Description: PREMANAGED
TO_BE_DEPLOYED
DEPLOYED
TO_BE_DELETED
CONTEXT

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TO_BE_DEPLOYED': {}, u'TO_BE_DELETED': {}, u'PREMANAGED': {}, u'CONTEXT': {}, u'DEPLOYED': {}},), is_leaf=True, yang_name="vmstatus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='vm-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vmstatus must be of a type compatible with vm-status""",
          'defined-type': "controller:vm-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TO_BE_DEPLOYED': {}, u'TO_BE_DELETED': {}, u'PREMANAGED': {}, u'CONTEXT': {}, u'DEPLOYED': {}},), is_leaf=True, yang_name="vmstatus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='vm-status', is_config=False)""",
        })

    self.__vmstatus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vmstatus(self):
    self.__vmstatus = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'TO_BE_DEPLOYED': {}, u'TO_BE_DELETED': {}, u'PREMANAGED': {}, u'CONTEXT': {}, u'DEPLOYED': {}},), is_leaf=True, yang_name="vmstatus", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='vm-status', is_config=False)


  def _get_device_family_string(self):
    """
    Getter method for device_family_string, mapped from YANG variable /devices/device/device_family_string (string)

    YANG Description: string
    """
    return self.__device_family_string
      
  def _set_device_family_string(self, v, load=False):
    """
    Setter method for device_family_string, mapped from YANG variable /devices/device/device_family_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_family_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_family_string() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="device-family-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_family_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="device-family-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__device_family_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_family_string(self):
    self.__device_family_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="device-family-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_ostype_string(self):
    """
    Getter method for ostype_string, mapped from YANG variable /devices/device/ostype_string (string)

    YANG Description: string
    """
    return self.__ostype_string
      
  def _set_ostype_string(self, v, load=False):
    """
    Setter method for ostype_string, mapped from YANG variable /devices/device/ostype_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ostype_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ostype_string() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ostype-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ostype_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ostype-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__ostype_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ostype_string(self):
    self.__ostype_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="ostype-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_vendor_string(self):
    """
    Getter method for vendor_string, mapped from YANG variable /devices/device/vendor_string (string)

    YANG Description: string
    """
    return self.__vendor_string
      
  def _set_vendor_string(self, v, load=False):
    """
    Setter method for vendor_string, mapped from YANG variable /devices/device/vendor_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor_string() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vendor-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vendor_string must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__vendor_string = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vendor_string(self):
    self.__vendor_string = YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor-string", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_serial_number(self):
    """
    Getter method for serial_number, mapped from YANG variable /devices/device/serial_number (string)

    YANG Description: string
    """
    return self.__serial_number
      
  def _set_serial_number(self, v, load=False):
    """
    Setter method for serial_number, mapped from YANG variable /devices/device/serial_number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="serial-number", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial_number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="serial-number", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__serial_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial_number(self):
    self.__serial_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="serial-number", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_sys_descr(self):
    """
    Getter method for sys_descr, mapped from YANG variable /devices/device/sys_descr (string)

    YANG Description: string
    """
    return self.__sys_descr
      
  def _set_sys_descr(self, v, load=False):
    """
    Setter method for sys_descr, mapped from YANG variable /devices/device/sys_descr (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sys_descr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sys_descr() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="sys-descr", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sys_descr must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-descr", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__sys_descr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sys_descr(self):
    self.__sys_descr = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-descr", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_sys_object_id(self):
    """
    Getter method for sys_object_id, mapped from YANG variable /devices/device/sys_object_id (string)

    YANG Description: string
    """
    return self.__sys_object_id
      
  def _set_sys_object_id(self, v, load=False):
    """
    Setter method for sys_object_id, mapped from YANG variable /devices/device/sys_object_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sys_object_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sys_object_id() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="sys-object-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sys_object_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-object-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__sys_object_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sys_object_id(self):
    self.__sys_object_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-object-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_sys_location(self):
    """
    Getter method for sys_location, mapped from YANG variable /devices/device/sys_location (string)

    YANG Description: string
    """
    return self.__sys_location
      
  def _set_sys_location(self, v, load=False):
    """
    Setter method for sys_location, mapped from YANG variable /devices/device/sys_location (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sys_location is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sys_location() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="sys-location", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sys_location must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-location", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__sys_location = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sys_location(self):
    self.__sys_location = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-location", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_sys_up_time(self):
    """
    Getter method for sys_up_time, mapped from YANG variable /devices/device/sys_up_time (string)

    YANG Description: string
    """
    return self.__sys_up_time
      
  def _set_sys_up_time(self, v, load=False):
    """
    Setter method for sys_up_time, mapped from YANG variable /devices/device/sys_up_time (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sys_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sys_up_time() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="sys-up-time", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sys_up_time must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-up-time", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)""",
        })

    self.__sys_up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sys_up_time(self):
    self.__sys_up_time = YANGDynClass(base=unicode, is_leaf=True, yang_name="sys-up-time", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=False)


  def _get_mgmt_vrf_name(self):
    """
    Getter method for mgmt_vrf_name, mapped from YANG variable /devices/device/mgmt_vrf_name (ncx:nameString64)

    YANG Description: MgmtVrf to communicate to the device. Can contain AlphaNumerics and underscore characters only. Max length is 64
    """
    return self.__mgmt_vrf_name
      
  def _set_mgmt_vrf_name(self, v, load=False):
    """
    Setter method for mgmt_vrf_name, mapped from YANG variable /devices/device/mgmt_vrf_name (ncx:nameString64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_vrf_name() directly.

    YANG Description: MgmtVrf to communicate to the device. Can contain AlphaNumerics and underscore characters only. Max length is 64
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[a-zA-Z0-9_]+$', 'length': [u'1..64']}), is_leaf=True, yang_name="mgmt-vrf-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:nameString64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_vrf_name must be of a type compatible with ncx:nameString64""",
          'defined-type': "ncx:nameString64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[a-zA-Z0-9_]+$', 'length': [u'1..64']}), is_leaf=True, yang_name="mgmt-vrf-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:nameString64', is_config=True)""",
        })

    self.__mgmt_vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_vrf_name(self):
    self.__mgmt_vrf_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^[a-zA-Z0-9_]+$', 'length': [u'1..64']}), is_leaf=True, yang_name="mgmt-vrf-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:nameString64', is_config=True)


  def _get_manage_by_management_station(self):
    """
    Getter method for manage_by_management_station, mapped from YANG variable /devices/device/manage_by_management_station (boolean)

    YANG Description: The device is managed with the management station
    """
    return self.__manage_by_management_station
      
  def _set_manage_by_management_station(self, v, load=False):
    """
    Setter method for manage_by_management_station, mapped from YANG variable /devices/device/manage_by_management_station (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manage_by_management_station is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manage_by_management_station() directly.

    YANG Description: The device is managed with the management station
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="manage-by-management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manage_by_management_station must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="manage-by-management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__manage_by_management_station = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manage_by_management_station(self):
    self.__manage_by_management_station = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="manage-by-management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_management_station(self):
    """
    Getter method for management_station, mapped from YANG variable /devices/device/management_station (leafref)

    YANG Description: management-station
    """
    return self.__management_station
      
  def _set_management_station(self, v, load=False):
    """
    Setter method for management_station, mapped from YANG variable /devices/device/management_station (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_management_station is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_management_station() directly.

    YANG Description: management-station
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """management_station must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__management_station = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_management_station(self):
    self.__management_station = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="management-station", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_managed_devices(self):
    """
    Getter method for managed_devices, mapped from YANG variable /devices/device/managed_devices (leafref)

    YANG Description: managed-devices
    """
    return self.__managed_devices
      
  def _set_managed_devices(self, v, load=False):
    """
    Setter method for managed_devices, mapped from YANG variable /devices/device/managed_devices (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed_devices() directly.

    YANG Description: managed-devices
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="managed-devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed_devices must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="managed-devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)""",
        })

    self.__managed_devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed_devices(self):
    self.__managed_devices = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="managed-devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)


  def _get_vm_name(self):
    """
    Getter method for vm_name, mapped from YANG variable /devices/device/vm_name (string)

    YANG Description: string
    """
    return self.__vm_name
      
  def _set_vm_name(self, v, load=False):
    """
    Setter method for vm_name, mapped from YANG variable /devices/device/vm_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vm_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vm_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vm-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vm_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vm-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__vm_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vm_name(self):
    self.__vm_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vm-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_cluster_ip_address(self):
    """
    Getter method for cluster_ip_address, mapped from YANG variable /devices/device/cluster_ip_address (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__cluster_ip_address
      
  def _set_cluster_ip_address(self, v, load=False):
    """
    Setter method for cluster_ip_address, mapped from YANG variable /devices/device/cluster_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_ip_address() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="cluster-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="cluster-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__cluster_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_ip_address(self):
    self.__cluster_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="cluster-ip-address", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='inet:ip-address', is_config=True)


  def _get_device_capability(self):
    """
    Getter method for device_capability, mapped from YANG variable /devices/device/device_capability (leafref)

    YANG Description: device-capability
    """
    return self.__device_capability
      
  def _set_device_capability(self, v, load=False):
    """
    Setter method for device_capability, mapped from YANG variable /devices/device/device_capability (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_capability() directly.

    YANG Description: device-capability
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_capability must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)""",
        })

    self.__device_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_capability(self):
    self.__device_capability = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)


  def _get_unmanaged_device_capability(self):
    """
    Getter method for unmanaged_device_capability, mapped from YANG variable /devices/device/unmanaged_device_capability (leafref)

    YANG Description: unmanaged-device-capability
    """
    return self.__unmanaged_device_capability
      
  def _set_unmanaged_device_capability(self, v, load=False):
    """
    Setter method for unmanaged_device_capability, mapped from YANG variable /devices/device/unmanaged_device_capability (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unmanaged_device_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unmanaged_device_capability() directly.

    YANG Description: unmanaged-device-capability
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="unmanaged-device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unmanaged_device_capability must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="unmanaged-device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__unmanaged_device_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unmanaged_device_capability(self):
    self.__unmanaged_device_capability = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="unmanaged-device-capability", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_virtual_appliance_image(self):
    """
    Getter method for virtual_appliance_image, mapped from YANG variable /devices/device/virtual_appliance_image (leafref)

    YANG Description: virtual-appliance-image
    """
    return self.__virtual_appliance_image
      
  def _set_virtual_appliance_image(self, v, load=False):
    """
    Setter method for virtual_appliance_image, mapped from YANG variable /devices/device/virtual_appliance_image (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_appliance_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_appliance_image() directly.

    YANG Description: virtual-appliance-image
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="virtual-appliance-image", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_appliance_image must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-appliance-image", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)""",
        })

    self.__virtual_appliance_image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_appliance_image(self):
    self.__virtual_appliance_image = YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-appliance-image", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)


  def _get_agent_id(self):
    """
    Getter method for agent_id, mapped from YANG variable /devices/device/agent_id (leafref)

    YANG Description: agent-id
    """
    return self.__agent_id
      
  def _set_agent_id(self, v, load=False):
    """
    Setter method for agent_id, mapped from YANG variable /devices/device/agent_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_agent_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_agent_id() directly.

    YANG Description: agent-id
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="agent-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """agent_id must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="agent-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)""",
        })

    self.__agent_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_agent_id(self):
    self.__agent_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="agent-id", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=False)


  def _get_priv_status(self):
    """
    Getter method for priv_status, mapped from YANG variable /devices/device/priv_status (device-status)

    YANG Description: ONLINE
OFFLINE
UNSUPPORTED
UNMANAGED
MAINTENANCE

    """
    return self.__priv_status
      
  def _set_priv_status(self, v, load=False):
    """
    Setter method for priv_status, mapped from YANG variable /devices/device/priv_status (device-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priv_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priv_status() directly.

    YANG Description: ONLINE
OFFLINE
UNSUPPORTED
UNMANAGED
MAINTENANCE

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), is_leaf=True, yang_name="priv-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priv_status must be of a type compatible with device-status""",
          'defined-type': "controller:device-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), is_leaf=True, yang_name="priv-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)""",
        })

    self.__priv_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priv_status(self):
    self.__priv_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'UNMANAGED': {}, u'OFFLINE': {}, u'MAINTENANCE': {}, u'UNSUPPORTED': {}, u'ONLINE': {}},), is_leaf=True, yang_name="priv-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='device-status', is_config=False)


  def _get_reconciliation(self):
    """
    Getter method for reconciliation, mapped from YANG variable /devices/device/reconciliation (container)
    """
    return self.__reconciliation
      
  def _set_reconciliation(self, v, load=False):
    """
    Setter method for reconciliation, mapped from YANG variable /devices/device/reconciliation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconciliation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconciliation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconciliation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__reconciliation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconciliation(self):
    self.__reconciliation = YANGDynClass(base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_unique_name(self):
    """
    Getter method for unique_name, mapped from YANG variable /devices/device/unique_name (string)

    YANG Description: string
    """
    return self.__unique_name
      
  def _set_unique_name(self, v, load=False):
    """
    Setter method for unique_name, mapped from YANG variable /devices/device/unique_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unique_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unique_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="unique-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unique_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="unique-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__unique_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unique_name(self):
    self.__unique_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="unique-name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_service_provisioning_status(self):
    """
    Getter method for service_provisioning_status, mapped from YANG variable /devices/device/service_provisioning_status (service-provisioning)

    YANG Description: Provisioned
Unprovisioned

    """
    return self.__service_provisioning_status
      
  def _set_service_provisioning_status(self, v, load=False):
    """
    Setter method for service_provisioning_status, mapped from YANG variable /devices/device/service_provisioning_status (service-provisioning)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_provisioning_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_provisioning_status() directly.

    YANG Description: Provisioned
Unprovisioned

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Provisioned': {}, u'Unprovisioned': {}},), is_leaf=True, yang_name="service-provisioning-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='service-provisioning', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_provisioning_status must be of a type compatible with service-provisioning""",
          'defined-type': "controller:service-provisioning",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Provisioned': {}, u'Unprovisioned': {}},), is_leaf=True, yang_name="service-provisioning-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='service-provisioning', is_config=True)""",
        })

    self.__service_provisioning_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_provisioning_status(self):
    self.__service_provisioning_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'Provisioned': {}, u'Unprovisioned': {}},), is_leaf=True, yang_name="service-provisioning-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='service-provisioning', is_config=True)


  def _get_location_properties(self):
    """
    Getter method for location_properties, mapped from YANG variable /devices/device/location_properties (container)
    """
    return self.__location_properties
      
  def _set_location_properties(self, v, load=False):
    """
    Setter method for location_properties, mapped from YANG variable /devices/device/location_properties (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_location_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_location_properties() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=location_properties.location_properties, is_container='container', yang_name="location-properties", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """location_properties must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=location_properties.location_properties, is_container='container', yang_name="location-properties", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__location_properties = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_location_properties(self):
    self.__location_properties = YANGDynClass(base=location_properties.location_properties, is_container='container', yang_name="location-properties", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_violations(self):
    """
    Getter method for violations, mapped from YANG variable /devices/device/violations (container)
    """
    return self.__violations
      
  def _set_violations(self, v, load=False):
    """
    Setter method for violations, mapped from YANG variable /devices/device/violations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_violations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_violations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=violations.violations, is_container='container', yang_name="violations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """violations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=violations.violations, is_container='container', yang_name="violations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__violations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_violations(self):
    self.__violations = YANGDynClass(base=violations.violations, is_container='container', yang_name="violations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_compliance_status(self):
    """
    Getter method for compliance_status, mapped from YANG variable /devices/device/compliance_status (ncx:compliance-status)

    YANG Description: COMPLIANT
NON_COMPLIANT
NONE

    """
    return self.__compliance_status
      
  def _set_compliance_status(self, v, load=False):
    """
    Setter method for compliance_status, mapped from YANG variable /devices/device/compliance_status (ncx:compliance-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compliance_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compliance_status() directly.

    YANG Description: COMPLIANT
NON_COMPLIANT
NONE

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMPLIANT': {}, u'NON_COMPLIANT': {}, u'NONE': {}},), is_leaf=True, yang_name="compliance-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:compliance-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compliance_status must be of a type compatible with ncx:compliance-status""",
          'defined-type': "ncx:compliance-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMPLIANT': {}, u'NON_COMPLIANT': {}, u'NONE': {}},), is_leaf=True, yang_name="compliance-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:compliance-status', is_config=False)""",
        })

    self.__compliance_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compliance_status(self):
    self.__compliance_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMPLIANT': {}, u'NON_COMPLIANT': {}, u'NONE': {}},), is_leaf=True, yang_name="compliance-status", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='ncx:compliance-status', is_config=False)


  def _get_compliances(self):
    """
    Getter method for compliances, mapped from YANG variable /devices/device/compliances (container)
    """
    return self.__compliances
      
  def _set_compliances(self, v, load=False):
    """
    Setter method for compliances, mapped from YANG variable /devices/device/compliances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compliances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compliances() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=compliances.compliances, is_container='container', yang_name="compliances", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compliances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=compliances.compliances, is_container='container', yang_name="compliances", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__compliances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compliances(self):
    self.__compliances = YANGDynClass(base=compliances.compliances, is_container='container', yang_name="compliances", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /devices/device/interfaces (container)
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /devices/device/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_interface_ranges(self):
    """
    Getter method for interface_ranges, mapped from YANG variable /devices/device/interface_ranges (container)
    """
    return self.__interface_ranges
      
  def _set_interface_ranges(self, v, load=False):
    """
    Setter method for interface_ranges, mapped from YANG variable /devices/device/interface_ranges (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ranges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ranges() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=interface_ranges.interface_ranges, is_container='container', yang_name="interface-ranges", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_ranges must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_ranges.interface_ranges, is_container='container', yang_name="interface-ranges", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__interface_ranges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_ranges(self):
    self.__interface_ranges = YANGDynClass(base=interface_ranges.interface_ranges, is_container='container', yang_name="interface-ranges", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_vlans(self):
    """
    Getter method for vlans, mapped from YANG variable /devices/device/vlans (container)
    """
    return self.__vlans
      
  def _set_vlans(self, v, load=False):
    """
    Setter method for vlans, mapped from YANG variable /devices/device/vlans (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlans() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vlans.vlans, is_container='container', yang_name="vlans", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlans must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)""",
        })

    self.__vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlans(self):
    self.__vlans = YANGDynClass(base=vlans.vlans, is_container='container', yang_name="vlans", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)


  def _get_vlan_groups(self):
    """
    Getter method for vlan_groups, mapped from YANG variable /devices/device/vlan_groups (container)
    """
    return self.__vlan_groups
      
  def _set_vlan_groups(self, v, load=False):
    """
    Setter method for vlan_groups, mapped from YANG variable /devices/device/vlan_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vlan_groups.vlan_groups, is_container='container', yang_name="vlan-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlan_groups.vlan_groups, is_container='container', yang_name="vlan-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)""",
        })

    self.__vlan_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_groups(self):
    self.__vlan_groups = YANGDynClass(base=vlan_groups.vlan_groups, is_container='container', yang_name="vlan-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)


  def _get_vn_services(self):
    """
    Getter method for vn_services, mapped from YANG variable /devices/device/vn_services (container)
    """
    return self.__vn_services
      
  def _set_vn_services(self, v, load=False):
    """
    Setter method for vn_services, mapped from YANG variable /devices/device/vn_services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vn_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vn_services() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vn_services.vn_services, is_container='container', yang_name="vn-services", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vn_services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vn_services.vn_services, is_container='container', yang_name="vn-services", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)""",
        })

    self.__vn_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vn_services(self):
    self.__vn_services = YANGDynClass(base=vn_services.vn_services, is_container='container', yang_name="vn-services", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)


  def _get_vn_paths(self):
    """
    Getter method for vn_paths, mapped from YANG variable /devices/device/vn_paths (container)
    """
    return self.__vn_paths
      
  def _set_vn_paths(self, v, load=False):
    """
    Setter method for vn_paths, mapped from YANG variable /devices/device/vn_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vn_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vn_paths() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vn_paths.vn_paths, is_container='container', yang_name="vn-paths", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vn_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vn_paths.vn_paths, is_container='container', yang_name="vn-paths", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)""",
        })

    self.__vn_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vn_paths(self):
    self.__vn_paths = YANGDynClass(base=vn_paths.vn_paths, is_container='container', yang_name="vn-paths", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)


  def _get_port_groups(self):
    """
    Getter method for port_groups, mapped from YANG variable /devices/device/port_groups (container)
    """
    return self.__port_groups
      
  def _set_port_groups(self, v, load=False):
    """
    Setter method for port_groups, mapped from YANG variable /devices/device/port_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=port_groups.port_groups, is_container='container', yang_name="port-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=port_groups.port_groups, is_container='container', yang_name="port-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)""",
        })

    self.__port_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_groups(self):
    self.__port_groups = YANGDynClass(base=port_groups.port_groups, is_container='container', yang_name="port-groups", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)


  def _get_port_channels(self):
    """
    Getter method for port_channels, mapped from YANG variable /devices/device/port_channels (container)
    """
    return self.__port_channels
      
  def _set_port_channels(self, v, load=False):
    """
    Setter method for port_channels, mapped from YANG variable /devices/device/port_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_channels() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=port_channels.port_channels, is_container='container', yang_name="port-channels", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=port_channels.port_channels, is_container='container', yang_name="port-channels", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)""",
        })

    self.__port_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_channels(self):
    self.__port_channels = YANGDynClass(base=port_channels.port_channels, is_container='container', yang_name="port-channels", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='container', is_config=True)


  def _get_route_policies(self):
    """
    Getter method for route_policies, mapped from YANG variable /devices/device/route_policies (container)
    """
    return self.__route_policies
      
  def _set_route_policies(self, v, load=False):
    """
    Setter method for route_policies, mapped from YANG variable /devices/device/route_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_policies() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=route_policies.route_policies, is_container='container', yang_name="route-policies", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_policies.route_policies, is_container='container', yang_name="route-policies", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__route_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_policies(self):
    self.__route_policies = YANGDynClass(base=route_policies.route_policies, is_container='container', yang_name="route-policies", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_rib_groups(self):
    """
    Getter method for rib_groups, mapped from YANG variable /devices/device/rib_groups (container)
    """
    return self.__rib_groups
      
  def _set_rib_groups(self, v, load=False):
    """
    Setter method for rib_groups, mapped from YANG variable /devices/device/rib_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rib_groups.rib_groups, is_container='container', yang_name="rib-groups", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rib_groups.rib_groups, is_container='container', yang_name="rib-groups", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__rib_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib_groups(self):
    self.__rib_groups = YANGDynClass(base=rib_groups.rib_groups, is_container='container', yang_name="rib-groups", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_vrfs(self):
    """
    Getter method for vrfs, mapped from YANG variable /devices/device/vrfs (container)
    """
    return self.__vrfs
      
  def _set_vrfs(self, v, load=False):
    """
    Setter method for vrfs, mapped from YANG variable /devices/device/vrfs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__vrfs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfs(self):
    self.__vrfs = YANGDynClass(base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_community_lists(self):
    """
    Getter method for community_lists, mapped from YANG variable /devices/device/community_lists (container)
    """
    return self.__community_lists
      
  def _set_community_lists(self, v, load=False):
    """
    Setter method for community_lists, mapped from YANG variable /devices/device/community_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=community_lists.community_lists, is_container='container', yang_name="community-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=community_lists.community_lists, is_container='container', yang_name="community-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__community_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_lists(self):
    self.__community_lists = YANGDynClass(base=community_lists.community_lists, is_container='container', yang_name="community-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_extcommunity_lists(self):
    """
    Getter method for extcommunity_lists, mapped from YANG variable /devices/device/extcommunity_lists (container)
    """
    return self.__extcommunity_lists
      
  def _set_extcommunity_lists(self, v, load=False):
    """
    Setter method for extcommunity_lists, mapped from YANG variable /devices/device/extcommunity_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extcommunity_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extcommunity_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=extcommunity_lists.extcommunity_lists, is_container='container', yang_name="extcommunity-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extcommunity_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=extcommunity_lists.extcommunity_lists, is_container='container', yang_name="extcommunity-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__extcommunity_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extcommunity_lists(self):
    self.__extcommunity_lists = YANGDynClass(base=extcommunity_lists.extcommunity_lists, is_container='container', yang_name="extcommunity-lists", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_ip_sla(self):
    """
    Getter method for ip_sla, mapped from YANG variable /devices/device/ip_sla (container)
    """
    return self.__ip_sla
      
  def _set_ip_sla(self, v, load=False):
    """
    Setter method for ip_sla, mapped from YANG variable /devices/device/ip_sla (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_sla is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_sla() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ip_sla.ip_sla, is_container='container', yang_name="ip-sla", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_sla must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_sla.ip_sla, is_container='container', yang_name="ip-sla", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__ip_sla = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_sla(self):
    self.__ip_sla = YANGDynClass(base=ip_sla.ip_sla, is_container='container', yang_name="ip-sla", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_ip_sla_schedules(self):
    """
    Getter method for ip_sla_schedules, mapped from YANG variable /devices/device/ip_sla_schedules (container)
    """
    return self.__ip_sla_schedules
      
  def _set_ip_sla_schedules(self, v, load=False):
    """
    Setter method for ip_sla_schedules, mapped from YANG variable /devices/device/ip_sla_schedules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_sla_schedules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_sla_schedules() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ip_sla_schedules.ip_sla_schedules, is_container='container', yang_name="ip-sla-schedules", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_sla_schedules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_sla_schedules.ip_sla_schedules, is_container='container', yang_name="ip-sla-schedules", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__ip_sla_schedules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_sla_schedules(self):
    self.__ip_sla_schedules = YANGDynClass(base=ip_sla_schedules.ip_sla_schedules, is_container='container', yang_name="ip-sla-schedules", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_ip_nat_pool(self):
    """
    Getter method for ip_nat_pool, mapped from YANG variable /devices/device/ip_nat_pool (container)
    """
    return self.__ip_nat_pool
      
  def _set_ip_nat_pool(self, v, load=False):
    """
    Setter method for ip_nat_pool, mapped from YANG variable /devices/device/ip_nat_pool (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_nat_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_nat_pool() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ip_nat_pool.ip_nat_pool, is_container='container', yang_name="ip-nat-pool", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_nat_pool must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_nat_pool.ip_nat_pool, is_container='container', yang_name="ip-nat-pool", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__ip_nat_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_nat_pool(self):
    self.__ip_nat_pool = YANGDynClass(base=ip_nat_pool.ip_nat_pool, is_container='container', yang_name="ip-nat-pool", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_ip_nat(self):
    """
    Getter method for ip_nat, mapped from YANG variable /devices/device/ip_nat (container)
    """
    return self.__ip_nat
      
  def _set_ip_nat(self, v, load=False):
    """
    Setter method for ip_nat, mapped from YANG variable /devices/device/ip_nat (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_nat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_nat() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ip_nat.ip_nat, is_container='container', yang_name="ip-nat", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_nat must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_nat.ip_nat, is_container='container', yang_name="ip-nat", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__ip_nat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_nat(self):
    self.__ip_nat = YANGDynClass(base=ip_nat.ip_nat, is_container='container', yang_name="ip-nat", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_tracks(self):
    """
    Getter method for tracks, mapped from YANG variable /devices/device/tracks (container)
    """
    return self.__tracks
      
  def _set_tracks(self, v, load=False):
    """
    Setter method for tracks, mapped from YANG variable /devices/device/tracks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tracks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tracks() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tracks.tracks, is_container='container', yang_name="tracks", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tracks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tracks.tracks, is_container='container', yang_name="tracks", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__tracks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tracks(self):
    self.__tracks = YANGDynClass(base=tracks.tracks, is_container='container', yang_name="tracks", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_prefix_sets(self):
    """
    Getter method for prefix_sets, mapped from YANG variable /devices/device/prefix_sets (container)
    """
    return self.__prefix_sets
      
  def _set_prefix_sets(self, v, load=False):
    """
    Setter method for prefix_sets, mapped from YANG variable /devices/device/prefix_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_sets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=prefix_sets.prefix_sets, is_container='container', yang_name="prefix-sets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=prefix_sets.prefix_sets, is_container='container', yang_name="prefix-sets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__prefix_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_sets(self):
    self.__prefix_sets = YANGDynClass(base=prefix_sets.prefix_sets, is_container='container', yang_name="prefix-sets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_bgp_as(self):
    """
    Getter method for bgp_as, mapped from YANG variable /devices/device/bgp_as (l3:as-number)

    YANG Description: string
    """
    return self.__bgp_as
      
  def _set_bgp_as(self, v, load=False):
    """
    Setter method for bgp_as, mapped from YANG variable /devices/device/bgp_as (l3:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_as() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bgp-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='l3:as-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_as must be of a type compatible with l3:as-number""",
          'defined-type': "l3:as-number",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bgp-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='l3:as-number', is_config=False)""",
        })

    self.__bgp_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_as(self):
    self.__bgp_as = YANGDynClass(base=unicode, is_leaf=True, yang_name="bgp-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='l3:as-number', is_config=False)


  def _get_as_path_acls(self):
    """
    Getter method for as_path_acls, mapped from YANG variable /devices/device/as_path_acls (container)
    """
    return self.__as_path_acls
      
  def _set_as_path_acls(self, v, load=False):
    """
    Setter method for as_path_acls, mapped from YANG variable /devices/device/as_path_acls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_acls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_acls() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=as_path_acls.as_path_acls, is_container='container', yang_name="as-path-acls", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_acls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=as_path_acls.as_path_acls, is_container='container', yang_name="as-path-acls", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__as_path_acls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_acls(self):
    self.__as_path_acls = YANGDynClass(base=as_path_acls.as_path_acls, is_container='container', yang_name="as-path-acls", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_route_maps(self):
    """
    Getter method for route_maps, mapped from YANG variable /devices/device/route_maps (container)
    """
    return self.__route_maps
      
  def _set_route_maps(self, v, load=False):
    """
    Setter method for route_maps, mapped from YANG variable /devices/device/route_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=route_maps.route_maps, is_container='container', yang_name="route-maps", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_maps.route_maps, is_container='container', yang_name="route-maps", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__route_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_maps(self):
    self.__route_maps = YANGDynClass(base=route_maps.route_maps, is_container='container', yang_name="route-maps", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_eigrp(self):
    """
    Getter method for eigrp, mapped from YANG variable /devices/device/eigrp (container)
    """
    return self.__eigrp
      
  def _set_eigrp(self, v, load=False):
    """
    Setter method for eigrp, mapped from YANG variable /devices/device/eigrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eigrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eigrp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eigrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__eigrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eigrp(self):
    self.__eigrp = YANGDynClass(base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_policy_options(self):
    """
    Getter method for policy_options, mapped from YANG variable /devices/device/policy_options (container)
    """
    return self.__policy_options
      
  def _set_policy_options(self, v, load=False):
    """
    Setter method for policy_options, mapped from YANG variable /devices/device/policy_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_options() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=policy_options.policy_options, is_container='container', yang_name="policy-options", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_options.policy_options, is_container='container', yang_name="policy-options", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__policy_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_options(self):
    self.__policy_options = YANGDynClass(base=policy_options.policy_options, is_container='container', yang_name="policy-options", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_dhcp_server(self):
    """
    Getter method for dhcp_server, mapped from YANG variable /devices/device/dhcp_server (container)
    """
    return self.__dhcp_server
      
  def _set_dhcp_server(self, v, load=False):
    """
    Setter method for dhcp_server, mapped from YANG variable /devices/device/dhcp_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_server() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dhcp_server.dhcp_server, is_container='container', yang_name="dhcp-server", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dhcp_server.dhcp_server, is_container='container', yang_name="dhcp-server", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__dhcp_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp_server(self):
    self.__dhcp_server = YANGDynClass(base=dhcp_server.dhcp_server, is_container='container', yang_name="dhcp-server", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_CaTrustPointCertificate(self):
    """
    Getter method for CaTrustPointCertificate, mapped from YANG variable /devices/device/CaTrustPointCertificate (container)
    """
    return self.__CaTrustPointCertificate
      
  def _set_CaTrustPointCertificate(self, v, load=False):
    """
    Setter method for CaTrustPointCertificate, mapped from YANG variable /devices/device/CaTrustPointCertificate (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_CaTrustPointCertificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_CaTrustPointCertificate() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=CaTrustPointCertificate.CaTrustPointCertificate, is_container='container', yang_name="CaTrustPointCertificate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """CaTrustPointCertificate must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=CaTrustPointCertificate.CaTrustPointCertificate, is_container='container', yang_name="CaTrustPointCertificate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__CaTrustPointCertificate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_CaTrustPointCertificate(self):
    self.__CaTrustPointCertificate = YANGDynClass(base=CaTrustPointCertificate.CaTrustPointCertificate, is_container='container', yang_name="CaTrustPointCertificate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_ip_prefixlist_list(self):
    """
    Getter method for ip_prefixlist_list, mapped from YANG variable /devices/device/ip_prefixlist_list (container)
    """
    return self.__ip_prefixlist_list
      
  def _set_ip_prefixlist_list(self, v, load=False):
    """
    Setter method for ip_prefixlist_list, mapped from YANG variable /devices/device/ip_prefixlist_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_prefixlist_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_prefixlist_list() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ip_prefixlist_list.ip_prefixlist_list, is_container='container', yang_name="ip-prefixlist-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_prefixlist_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_prefixlist_list.ip_prefixlist_list, is_container='container', yang_name="ip-prefixlist-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__ip_prefixlist_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_prefixlist_list(self):
    self.__ip_prefixlist_list = YANGDynClass(base=ip_prefixlist_list.ip_prefixlist_list, is_container='container', yang_name="ip-prefixlist-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_vpls_list(self):
    """
    Getter method for vpls_list, mapped from YANG variable /devices/device/vpls_list (container)
    """
    return self.__vpls_list
      
  def _set_vpls_list(self, v, load=False):
    """
    Setter method for vpls_list, mapped from YANG variable /devices/device/vpls_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpls_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpls_list() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vpls_list.vpls_list, is_container='container', yang_name="vpls-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpls_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vpls_list.vpls_list, is_container='container', yang_name="vpls-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__vpls_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpls_list(self):
    self.__vpls_list = YANGDynClass(base=vpls_list.vpls_list, is_container='container', yang_name="vpls-list", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_eem_script(self):
    """
    Getter method for eem_script, mapped from YANG variable /devices/device/eem_script (container)
    """
    return self.__eem_script
      
  def _set_eem_script(self, v, load=False):
    """
    Setter method for eem_script, mapped from YANG variable /devices/device/eem_script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eem_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eem_script() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=eem_script.eem_script, is_container='container', yang_name="eem-script", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eem_script must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=eem_script.eem_script, is_container='container', yang_name="eem-script", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__eem_script = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eem_script(self):
    self.__eem_script = YANGDynClass(base=eem_script.eem_script, is_container='container', yang_name="eem-script", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_eem_applets(self):
    """
    Getter method for eem_applets, mapped from YANG variable /devices/device/eem_applets (container)
    """
    return self.__eem_applets
      
  def _set_eem_applets(self, v, load=False):
    """
    Setter method for eem_applets, mapped from YANG variable /devices/device/eem_applets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eem_applets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eem_applets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=eem_applets.eem_applets, is_container='container', yang_name="eem-applets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eem_applets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=eem_applets.eem_applets, is_container='container', yang_name="eem-applets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__eem_applets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eem_applets(self):
    self.__eem_applets = YANGDynClass(base=eem_applets.eem_applets, is_container='container', yang_name="eem-applets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_netflow(self):
    """
    Getter method for netflow, mapped from YANG variable /devices/device/netflow (container)
    """
    return self.__netflow
      
  def _set_netflow(self, v, load=False):
    """
    Setter method for netflow, mapped from YANG variable /devices/device/netflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netflow() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=netflow.netflow, is_container='container', yang_name="netflow", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=netflow.netflow, is_container='container', yang_name="netflow", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__netflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netflow(self):
    self.__netflow = YANGDynClass(base=netflow.netflow, is_container='container', yang_name="netflow", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_bridge(self):
    """
    Getter method for bridge, mapped from YANG variable /devices/device/bridge (container)
    """
    return self.__bridge
      
  def _set_bridge(self, v, load=False):
    """
    Setter method for bridge, mapped from YANG variable /devices/device/bridge (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=bridge.bridge, is_container='container', yang_name="bridge", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bridge.bridge, is_container='container', yang_name="bridge", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__bridge = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge(self):
    self.__bridge = YANGDynClass(base=bridge.bridge, is_container='container', yang_name="bridge", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_key_chain(self):
    """
    Getter method for key_chain, mapped from YANG variable /devices/device/key_chain (container)
    """
    return self.__key_chain
      
  def _set_key_chain(self, v, load=False):
    """
    Setter method for key_chain, mapped from YANG variable /devices/device/key_chain (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=key_chain.key_chain, is_container='container', yang_name="key-chain", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=key_chain.key_chain, is_container='container', yang_name="key-chain", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__key_chain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain(self):
    self.__key_chain = YANGDynClass(base=key_chain.key_chain, is_container='container', yang_name="key-chain", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_static_routes(self):
    """
    Getter method for static_routes, mapped from YANG variable /devices/device/static_routes (container)
    """
    return self.__static_routes
      
  def _set_static_routes(self, v, load=False):
    """
    Setter method for static_routes, mapped from YANG variable /devices/device/static_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_routes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__static_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_routes(self):
    self.__static_routes = YANGDynClass(base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /devices/device/routes (container)
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /devices/device/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=routes.routes, is_container='container', yang_name="routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=routes.routes, is_container='container', yang_name="routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=routes.routes, is_container='container', yang_name="routes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='container', is_config=True)


  def _get_snmp(self):
    """
    Getter method for snmp, mapped from YANG variable /devices/device/snmp (container)
    """
    return self.__snmp
      
  def _set_snmp(self, v, load=False):
    """
    Setter method for snmp, mapped from YANG variable /devices/device/snmp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=snmp.snmp, is_container='container', yang_name="snmp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=snmp.snmp, is_container='container', yang_name="snmp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__snmp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp(self):
    self.__snmp = YANGDynClass(base=snmp.snmp, is_container='container', yang_name="snmp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_ntp(self):
    """
    Getter method for ntp, mapped from YANG variable /devices/device/ntp (container)
    """
    return self.__ntp
      
  def _set_ntp(self, v, load=False):
    """
    Setter method for ntp, mapped from YANG variable /devices/device/ntp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ntp.ntp, is_container='container', yang_name="ntp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__ntp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp(self):
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_username(self):
    """
    Getter method for username, mapped from YANG variable /devices/device/username (container)
    """
    return self.__username
      
  def _set_username(self, v, load=False):
    """
    Setter method for username, mapped from YANG variable /devices/device/username (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=username.username, is_container='container', yang_name="username", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """username must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=username.username, is_container='container', yang_name="username", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__username = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_username(self):
    self.__username = YANGDynClass(base=username.username, is_container='container', yang_name="username", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_clock(self):
    """
    Getter method for clock, mapped from YANG variable /devices/device/clock (container)
    """
    return self.__clock
      
  def _set_clock(self, v, load=False):
    """
    Setter method for clock, mapped from YANG variable /devices/device/clock (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=clock.clock, is_container='container', yang_name="clock", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__clock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock(self):
    self.__clock = YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_banner(self):
    """
    Getter method for banner, mapped from YANG variable /devices/device/banner (container)
    """
    return self.__banner
      
  def _set_banner(self, v, load=False):
    """
    Setter method for banner, mapped from YANG variable /devices/device/banner (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_banner is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_banner() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=banner.banner, is_container='container', yang_name="banner", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """banner must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=banner.banner, is_container='container', yang_name="banner", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__banner = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_banner(self):
    self.__banner = YANGDynClass(base=banner.banner, is_container='container', yang_name="banner", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_http(self):
    """
    Getter method for http, mapped from YANG variable /devices/device/http (container)
    """
    return self.__http
      
  def _set_http(self, v, load=False):
    """
    Setter method for http, mapped from YANG variable /devices/device/http (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=http.http, is_container='container', yang_name="http", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=http.http, is_container='container', yang_name="http", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__http = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http(self):
    self.__http = YANGDynClass(base=http.http, is_container='container', yang_name="http", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_service_time_stamps(self):
    """
    Getter method for service_time_stamps, mapped from YANG variable /devices/device/service_time_stamps (container)
    """
    return self.__service_time_stamps
      
  def _set_service_time_stamps(self, v, load=False):
    """
    Setter method for service_time_stamps, mapped from YANG variable /devices/device/service_time_stamps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_time_stamps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_time_stamps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_time_stamps.service_time_stamps, is_container='container', yang_name="service-time-stamps", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_time_stamps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_time_stamps.service_time_stamps, is_container='container', yang_name="service-time-stamps", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__service_time_stamps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_time_stamps(self):
    self.__service_time_stamps = YANGDynClass(base=service_time_stamps.service_time_stamps, is_container='container', yang_name="service-time-stamps", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_ha(self):
    """
    Getter method for ha, mapped from YANG variable /devices/device/ha (container)
    """
    return self.__ha
      
  def _set_ha(self, v, load=False):
    """
    Setter method for ha, mapped from YANG variable /devices/device/ha (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ha.ha, is_container='container', yang_name="ha", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha.ha, is_container='container', yang_name="ha", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__ha = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha(self):
    self.__ha = YANGDynClass(base=ha.ha, is_container='container', yang_name="ha", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_local_credentials(self):
    """
    Getter method for local_credentials, mapped from YANG variable /devices/device/local_credentials (container)
    """
    return self.__local_credentials
      
  def _set_local_credentials(self, v, load=False):
    """
    Setter method for local_credentials, mapped from YANG variable /devices/device/local_credentials (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_credentials is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_credentials() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=local_credentials.local_credentials, is_container='container', yang_name="local-credentials", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_credentials must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=local_credentials.local_credentials, is_container='container', yang_name="local-credentials", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__local_credentials = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_credentials(self):
    self.__local_credentials = YANGDynClass(base=local_credentials.local_credentials, is_container='container', yang_name="local-credentials", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_ssh(self):
    """
    Getter method for ssh, mapped from YANG variable /devices/device/ssh (container)
    """
    return self.__ssh
      
  def _set_ssh(self, v, load=False):
    """
    Setter method for ssh, mapped from YANG variable /devices/device/ssh (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ssh.ssh, is_container='container', yang_name="ssh", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssh.ssh, is_container='container', yang_name="ssh", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__ssh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh(self):
    self.__ssh = YANGDynClass(base=ssh.ssh, is_container='container', yang_name="ssh", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /devices/device/logging (container)
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /devices/device/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=logging.logging, is_container='container', yang_name="logging", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_aaa_root(self):
    """
    Getter method for aaa_root, mapped from YANG variable /devices/device/aaa_root (container)
    """
    return self.__aaa_root
      
  def _set_aaa_root(self, v, load=False):
    """
    Setter method for aaa_root, mapped from YANG variable /devices/device/aaa_root (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aaa_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aaa_root() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=aaa_root.aaa_root, is_container='container', yang_name="aaa-root", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aaa_root must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aaa_root.aaa_root, is_container='container', yang_name="aaa-root", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__aaa_root = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aaa_root(self):
    self.__aaa_root = YANGDynClass(base=aaa_root.aaa_root, is_container='container', yang_name="aaa-root", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_aaa_group(self):
    """
    Getter method for aaa_group, mapped from YANG variable /devices/device/aaa_group (container)
    """
    return self.__aaa_group
      
  def _set_aaa_group(self, v, load=False):
    """
    Setter method for aaa_group, mapped from YANG variable /devices/device/aaa_group (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aaa_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aaa_group() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=aaa_group.aaa_group, is_container='container', yang_name="aaa-group", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aaa_group must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aaa_group.aaa_group, is_container='container', yang_name="aaa-group", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__aaa_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aaa_group(self):
    self.__aaa_group = YANGDynClass(base=aaa_group.aaa_group, is_container='container', yang_name="aaa-group", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_call_home(self):
    """
    Getter method for call_home, mapped from YANG variable /devices/device/call_home (container)
    """
    return self.__call_home
      
  def _set_call_home(self, v, load=False):
    """
    Setter method for call_home, mapped from YANG variable /devices/device/call_home (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_call_home is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_call_home() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=call_home.call_home, is_container='container', yang_name="call-home", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """call_home must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=call_home.call_home, is_container='container', yang_name="call-home", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__call_home = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_call_home(self):
    self.__call_home = YANGDynClass(base=call_home.call_home, is_container='container', yang_name="call-home", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_tacacs_conf(self):
    """
    Getter method for tacacs_conf, mapped from YANG variable /devices/device/tacacs_conf (container)
    """
    return self.__tacacs_conf
      
  def _set_tacacs_conf(self, v, load=False):
    """
    Setter method for tacacs_conf, mapped from YANG variable /devices/device/tacacs_conf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tacacs_conf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tacacs_conf() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tacacs_conf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__tacacs_conf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tacacs_conf(self):
    self.__tacacs_conf = YANGDynClass(base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_tftp(self):
    """
    Getter method for tftp, mapped from YANG variable /devices/device/tftp (container)
    """
    return self.__tftp
      
  def _set_tftp(self, v, load=False):
    """
    Setter method for tftp, mapped from YANG variable /devices/device/tftp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tftp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tftp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tftp.tftp, is_container='container', yang_name="tftp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tftp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tftp.tftp, is_container='container', yang_name="tftp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__tftp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tftp(self):
    self.__tftp = YANGDynClass(base=tftp.tftp, is_container='container', yang_name="tftp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_license(self):
    """
    Getter method for license, mapped from YANG variable /devices/device/license (container)
    """
    return self.__license
      
  def _set_license(self, v, load=False):
    """
    Setter method for license, mapped from YANG variable /devices/device/license (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_license is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_license() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=license.license, is_container='container', yang_name="license", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """license must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=license.license, is_container='container', yang_name="license", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__license = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_license(self):
    self.__license = YANGDynClass(base=license.license, is_container='container', yang_name="license", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /devices/device/hostname (container)
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /devices/device/hostname (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=hostname.hostname, is_container='container', yang_name="hostname", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hostname.hostname, is_container='container', yang_name="hostname", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=hostname.hostname, is_container='container', yang_name="hostname", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_vty_configs(self):
    """
    Getter method for vty_configs, mapped from YANG variable /devices/device/vty_configs (container)
    """
    return self.__vty_configs
      
  def _set_vty_configs(self, v, load=False):
    """
    Setter method for vty_configs, mapped from YANG variable /devices/device/vty_configs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vty_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vty_configs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vty_configs.vty_configs, is_container='container', yang_name="vty-configs", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vty_configs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vty_configs.vty_configs, is_container='container', yang_name="vty-configs", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__vty_configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vty_configs(self):
    self.__vty_configs = YANGDynClass(base=vty_configs.vty_configs, is_container='container', yang_name="vty-configs", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_console(self):
    """
    Getter method for console, mapped from YANG variable /devices/device/console (container)
    """
    return self.__console
      
  def _set_console(self, v, load=False):
    """
    Setter method for console, mapped from YANG variable /devices/device/console (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_console is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_console() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=console.console, is_container='container', yang_name="console", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """console must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=console.console, is_container='container', yang_name="console", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__console = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_console(self):
    self.__console = YANGDynClass(base=console.console, is_container='container', yang_name="console", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_auxiliary_port(self):
    """
    Getter method for auxiliary_port, mapped from YANG variable /devices/device/auxiliary_port (container)
    """
    return self.__auxiliary_port
      
  def _set_auxiliary_port(self, v, load=False):
    """
    Setter method for auxiliary_port, mapped from YANG variable /devices/device/auxiliary_port (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auxiliary_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auxiliary_port() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=auxiliary_port.auxiliary_port, is_container='container', yang_name="auxiliary-port", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auxiliary_port must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=auxiliary_port.auxiliary_port, is_container='container', yang_name="auxiliary-port", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__auxiliary_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auxiliary_port(self):
    self.__auxiliary_port = YANGDynClass(base=auxiliary_port.auxiliary_port, is_container='container', yang_name="auxiliary-port", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_features(self):
    """
    Getter method for features, mapped from YANG variable /devices/device/features (container)
    """
    return self.__features
      
  def _set_features(self, v, load=False):
    """
    Setter method for features, mapped from YANG variable /devices/device/features (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_features is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_features() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=features.features, is_container='container', yang_name="features", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """features must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=features.features, is_container='container', yang_name="features", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__features = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_features(self):
    self.__features = YANGDynClass(base=features.features, is_container='container', yang_name="features", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_spanning_tree(self):
    """
    Getter method for spanning_tree, mapped from YANG variable /devices/device/spanning_tree (container)
    """
    return self.__spanning_tree
      
  def _set_spanning_tree(self, v, load=False):
    """
    Setter method for spanning_tree, mapped from YANG variable /devices/device/spanning_tree (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spanning_tree is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spanning_tree() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=spanning_tree.spanning_tree, is_container='container', yang_name="spanning-tree", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spanning_tree must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=spanning_tree.spanning_tree, is_container='container', yang_name="spanning-tree", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__spanning_tree = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spanning_tree(self):
    self.__spanning_tree = YANGDynClass(base=spanning_tree.spanning_tree, is_container='container', yang_name="spanning-tree", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_error_disable_recovery(self):
    """
    Getter method for error_disable_recovery, mapped from YANG variable /devices/device/error_disable_recovery (container)
    """
    return self.__error_disable_recovery
      
  def _set_error_disable_recovery(self, v, load=False):
    """
    Setter method for error_disable_recovery, mapped from YANG variable /devices/device/error_disable_recovery (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_disable_recovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_disable_recovery() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=error_disable_recovery.error_disable_recovery, is_container='container', yang_name="error-disable-recovery", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_disable_recovery must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=error_disable_recovery.error_disable_recovery, is_container='container', yang_name="error-disable-recovery", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__error_disable_recovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_disable_recovery(self):
    self.__error_disable_recovery = YANGDynClass(base=error_disable_recovery.error_disable_recovery, is_container='container', yang_name="error-disable-recovery", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /devices/device/bfd (container)
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /devices/device/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=bfd.bfd, is_container='container', yang_name="bfd", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_ip_arp(self):
    """
    Getter method for ip_arp, mapped from YANG variable /devices/device/ip_arp (container)
    """
    return self.__ip_arp
      
  def _set_ip_arp(self, v, load=False):
    """
    Setter method for ip_arp, mapped from YANG variable /devices/device/ip_arp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_arp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_arp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ip_arp.ip_arp, is_container='container', yang_name="ip-arp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_arp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ip_arp.ip_arp, is_container='container', yang_name="ip-arp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__ip_arp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_arp(self):
    self.__ip_arp = YANGDynClass(base=ip_arp.ip_arp, is_container='container', yang_name="ip-arp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_mac_table(self):
    """
    Getter method for mac_table, mapped from YANG variable /devices/device/mac_table (container)
    """
    return self.__mac_table
      
  def _set_mac_table(self, v, load=False):
    """
    Setter method for mac_table, mapped from YANG variable /devices/device/mac_table (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_table is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_table() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mac_table.mac_table, is_container='container', yang_name="mac-table", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_table must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_table.mac_table, is_container='container', yang_name="mac-table", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__mac_table = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_table(self):
    self.__mac_table = YANGDynClass(base=mac_table.mac_table, is_container='container', yang_name="mac-table", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_service_unsupported(self):
    """
    Getter method for service_unsupported, mapped from YANG variable /devices/device/service_unsupported (container)
    """
    return self.__service_unsupported
      
  def _set_service_unsupported(self, v, load=False):
    """
    Setter method for service_unsupported, mapped from YANG variable /devices/device/service_unsupported (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_unsupported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_unsupported() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_unsupported.service_unsupported, is_container='container', yang_name="service-unsupported", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_unsupported must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_unsupported.service_unsupported, is_container='container', yang_name="service-unsupported", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__service_unsupported = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_unsupported(self):
    self.__service_unsupported = YANGDynClass(base=service_unsupported.service_unsupported, is_container='container', yang_name="service-unsupported", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_jumbo_mtu(self):
    """
    Getter method for jumbo_mtu, mapped from YANG variable /devices/device/jumbo_mtu (container)
    """
    return self.__jumbo_mtu
      
  def _set_jumbo_mtu(self, v, load=False):
    """
    Setter method for jumbo_mtu, mapped from YANG variable /devices/device/jumbo_mtu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_jumbo_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_jumbo_mtu() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=jumbo_mtu.jumbo_mtu, is_container='container', yang_name="jumbo-mtu", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """jumbo_mtu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=jumbo_mtu.jumbo_mtu, is_container='container', yang_name="jumbo-mtu", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__jumbo_mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_jumbo_mtu(self):
    self.__jumbo_mtu = YANGDynClass(base=jumbo_mtu.jumbo_mtu, is_container='container', yang_name="jumbo-mtu", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /devices/device/bgp (container)
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /devices/device/bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=bgp.bgp, is_container='container', yang_name="bgp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=bgp.bgp, is_container='container', yang_name="bgp", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_interface_breakout(self):
    """
    Getter method for interface_breakout, mapped from YANG variable /devices/device/interface_breakout (container)
    """
    return self.__interface_breakout
      
  def _set_interface_breakout(self, v, load=False):
    """
    Setter method for interface_breakout, mapped from YANG variable /devices/device/interface_breakout (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_breakout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_breakout() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=interface_breakout.interface_breakout, is_container='container', yang_name="interface-breakout", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_breakout must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_breakout.interface_breakout, is_container='container', yang_name="interface-breakout", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__interface_breakout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_breakout(self):
    self.__interface_breakout = YANGDynClass(base=interface_breakout.interface_breakout, is_container='container', yang_name="interface-breakout", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_event_manager(self):
    """
    Getter method for event_manager, mapped from YANG variable /devices/device/event_manager (container)
    """
    return self.__event_manager
      
  def _set_event_manager(self, v, load=False):
    """
    Setter method for event_manager, mapped from YANG variable /devices/device/event_manager (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_manager is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_manager() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=event_manager.event_manager, is_container='container', yang_name="event-manager", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_manager must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=event_manager.event_manager, is_container='container', yang_name="event-manager", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__event_manager = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_manager(self):
    self.__event_manager = YANGDynClass(base=event_manager.event_manager, is_container='container', yang_name="event-manager", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_shell_options(self):
    """
    Getter method for shell_options, mapped from YANG variable /devices/device/shell_options (container)
    """
    return self.__shell_options
      
  def _set_shell_options(self, v, load=False):
    """
    Setter method for shell_options, mapped from YANG variable /devices/device/shell_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shell_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shell_options() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=shell_options.shell_options, is_container='container', yang_name="shell-options", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shell_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=shell_options.shell_options, is_container='container', yang_name="shell-options", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)""",
        })

    self.__shell_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shell_options(self):
    self.__shell_options = YANGDynClass(base=shell_options.shell_options, is_container='container', yang_name="shell-options", module_name="basicDeviceConfigs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/basicDeviceConfigs', defining_module='basicDeviceConfigs', yang_type='container', is_config=True)


  def _get_crypto(self):
    """
    Getter method for crypto, mapped from YANG variable /devices/device/crypto (container)
    """
    return self.__crypto
      
  def _set_crypto(self, v, load=False):
    """
    Setter method for crypto, mapped from YANG variable /devices/device/crypto (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_crypto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_crypto() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=crypto.crypto, is_container='container', yang_name="crypto", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """crypto must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=crypto.crypto, is_container='container', yang_name="crypto", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__crypto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_crypto(self):
    self.__crypto = YANGDynClass(base=crypto.crypto, is_container='container', yang_name="crypto", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_crypto_policies(self):
    """
    Getter method for crypto_policies, mapped from YANG variable /devices/device/crypto_policies (container)
    """
    return self.__crypto_policies
      
  def _set_crypto_policies(self, v, load=False):
    """
    Setter method for crypto_policies, mapped from YANG variable /devices/device/crypto_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_crypto_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_crypto_policies() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=crypto_policies.crypto_policies, is_container='container', yang_name="crypto-policies", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """crypto_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=crypto_policies.crypto_policies, is_container='container', yang_name="crypto-policies", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__crypto_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_crypto_policies(self):
    self.__crypto_policies = YANGDynClass(base=crypto_policies.crypto_policies, is_container='container', yang_name="crypto-policies", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_crypto_proposals(self):
    """
    Getter method for crypto_proposals, mapped from YANG variable /devices/device/crypto_proposals (container)
    """
    return self.__crypto_proposals
      
  def _set_crypto_proposals(self, v, load=False):
    """
    Setter method for crypto_proposals, mapped from YANG variable /devices/device/crypto_proposals (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_crypto_proposals is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_crypto_proposals() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=crypto_proposals.crypto_proposals, is_container='container', yang_name="crypto-proposals", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """crypto_proposals must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=crypto_proposals.crypto_proposals, is_container='container', yang_name="crypto-proposals", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__crypto_proposals = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_crypto_proposals(self):
    self.__crypto_proposals = YANGDynClass(base=crypto_proposals.crypto_proposals, is_container='container', yang_name="crypto-proposals", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_crypto_keyrings(self):
    """
    Getter method for crypto_keyrings, mapped from YANG variable /devices/device/crypto_keyrings (container)
    """
    return self.__crypto_keyrings
      
  def _set_crypto_keyrings(self, v, load=False):
    """
    Setter method for crypto_keyrings, mapped from YANG variable /devices/device/crypto_keyrings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_crypto_keyrings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_crypto_keyrings() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=crypto_keyrings.crypto_keyrings, is_container='container', yang_name="crypto-keyrings", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """crypto_keyrings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=crypto_keyrings.crypto_keyrings, is_container='container', yang_name="crypto-keyrings", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__crypto_keyrings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_crypto_keyrings(self):
    self.__crypto_keyrings = YANGDynClass(base=crypto_keyrings.crypto_keyrings, is_container='container', yang_name="crypto-keyrings", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_transform_sets(self):
    """
    Getter method for transform_sets, mapped from YANG variable /devices/device/transform_sets (container)
    """
    return self.__transform_sets
      
  def _set_transform_sets(self, v, load=False):
    """
    Setter method for transform_sets, mapped from YANG variable /devices/device/transform_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transform_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transform_sets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=transform_sets.transform_sets, is_container='container', yang_name="transform-sets", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transform_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transform_sets.transform_sets, is_container='container', yang_name="transform-sets", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__transform_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transform_sets(self):
    self.__transform_sets = YANGDynClass(base=transform_sets.transform_sets, is_container='container', yang_name="transform-sets", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_ipsec_profiles(self):
    """
    Getter method for ipsec_profiles, mapped from YANG variable /devices/device/ipsec_profiles (container)
    """
    return self.__ipsec_profiles
      
  def _set_ipsec_profiles(self, v, load=False):
    """
    Setter method for ipsec_profiles, mapped from YANG variable /devices/device/ipsec_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_profiles() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ipsec_profiles.ipsec_profiles, is_container='container', yang_name="ipsec-profiles", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipsec_profiles.ipsec_profiles, is_container='container', yang_name="ipsec-profiles", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__ipsec_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_profiles(self):
    self.__ipsec_profiles = YANGDynClass(base=ipsec_profiles.ipsec_profiles, is_container='container', yang_name="ipsec-profiles", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_dmvpntunnels(self):
    """
    Getter method for dmvpntunnels, mapped from YANG variable /devices/device/dmvpntunnels (container)
    """
    return self.__dmvpntunnels
      
  def _set_dmvpntunnels(self, v, load=False):
    """
    Setter method for dmvpntunnels, mapped from YANG variable /devices/device/dmvpntunnels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dmvpntunnels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dmvpntunnels() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dmvpntunnels.dmvpntunnels, is_container='container', yang_name="dmvpntunnels", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dmvpntunnels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dmvpntunnels.dmvpntunnels, is_container='container', yang_name="dmvpntunnels", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__dmvpntunnels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dmvpntunnels(self):
    self.__dmvpntunnels = YANGDynClass(base=dmvpntunnels.dmvpntunnels, is_container='container', yang_name="dmvpntunnels", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_domain(self):
    """
    Getter method for domain, mapped from YANG variable /devices/device/domain (container)
    """
    return self.__domain
      
  def _set_domain(self, v, load=False):
    """
    Setter method for domain, mapped from YANG variable /devices/device/domain (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=domain.domain, is_container='container', yang_name="domain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=domain.domain, is_container='container', yang_name="domain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain(self):
    self.__domain = YANGDynClass(base=domain.domain, is_container='container', yang_name="domain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_dns_server(self):
    """
    Getter method for dns_server, mapped from YANG variable /devices/device/dns_server (container)
    """
    return self.__dns_server
      
  def _set_dns_server(self, v, load=False):
    """
    Setter method for dns_server, mapped from YANG variable /devices/device/dns_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dns_server.dns_server, is_container='container', yang_name="dns-server", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dns_server.dns_server, is_container='container', yang_name="dns-server", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)""",
        })

    self.__dns_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_server(self):
    self.__dns_server = YANGDynClass(base=dns_server.dns_server, is_container='container', yang_name="dns-server", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)


  def _get_a_records(self):
    """
    Getter method for a_records, mapped from YANG variable /devices/device/a_records (container)
    """
    return self.__a_records
      
  def _set_a_records(self, v, load=False):
    """
    Setter method for a_records, mapped from YANG variable /devices/device/a_records (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_a_records is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_a_records() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=a_records.a_records, is_container='container', yang_name="a-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """a_records must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=a_records.a_records, is_container='container', yang_name="a-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)""",
        })

    self.__a_records = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_a_records(self):
    self.__a_records = YANGDynClass(base=a_records.a_records, is_container='container', yang_name="a-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)


  def _get_host_records(self):
    """
    Getter method for host_records, mapped from YANG variable /devices/device/host_records (container)
    """
    return self.__host_records
      
  def _set_host_records(self, v, load=False):
    """
    Setter method for host_records, mapped from YANG variable /devices/device/host_records (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_records is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_records() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=host_records.host_records, is_container='container', yang_name="host-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host_records must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=host_records.host_records, is_container='container', yang_name="host-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)""",
        })

    self.__host_records = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host_records(self):
    self.__host_records = YANGDynClass(base=host_records.host_records, is_container='container', yang_name="host-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)


  def _get_dns_zones(self):
    """
    Getter method for dns_zones, mapped from YANG variable /devices/device/dns_zones (container)
    """
    return self.__dns_zones
      
  def _set_dns_zones(self, v, load=False):
    """
    Setter method for dns_zones, mapped from YANG variable /devices/device/dns_zones (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_zones is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_zones() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dns_zones.dns_zones, is_container='container', yang_name="dns-zones", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_zones must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dns_zones.dns_zones, is_container='container', yang_name="dns-zones", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)""",
        })

    self.__dns_zones = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_zones(self):
    self.__dns_zones = YANGDynClass(base=dns_zones.dns_zones, is_container='container', yang_name="dns-zones", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)


  def _get_resource_records(self):
    """
    Getter method for resource_records, mapped from YANG variable /devices/device/resource_records (container)
    """
    return self.__resource_records
      
  def _set_resource_records(self, v, load=False):
    """
    Setter method for resource_records, mapped from YANG variable /devices/device/resource_records (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resource_records is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resource_records() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=resource_records.resource_records, is_container='container', yang_name="resource-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resource_records must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=resource_records.resource_records, is_container='container', yang_name="resource-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)""",
        })

    self.__resource_records = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resource_records(self):
    self.__resource_records = YANGDynClass(base=resource_records.resource_records, is_container='container', yang_name="resource-records", module_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dns', defining_module='dns', yang_type='container', is_config=True)


  def _get_access_lists(self):
    """
    Getter method for access_lists, mapped from YANG variable /devices/device/access_lists (container)
    """
    return self.__access_lists
      
  def _set_access_lists(self, v, load=False):
    """
    Setter method for access_lists, mapped from YANG variable /devices/device/access_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)""",
        })

    self.__access_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_lists(self):
    self.__access_lists = YANGDynClass(base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)


  def _get_number_access_lists(self):
    """
    Getter method for number_access_lists, mapped from YANG variable /devices/device/number_access_lists (container)
    """
    return self.__number_access_lists
      
  def _set_number_access_lists(self, v, load=False):
    """
    Setter method for number_access_lists, mapped from YANG variable /devices/device/number_access_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_access_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_access_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=number_access_lists.number_access_lists, is_container='container', yang_name="number-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number_access_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=number_access_lists.number_access_lists, is_container='container', yang_name="number-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)""",
        })

    self.__number_access_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number_access_lists(self):
    self.__number_access_lists = YANGDynClass(base=number_access_lists.number_access_lists, is_container='container', yang_name="number-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)


  def _get_object_groups_acl(self):
    """
    Getter method for object_groups_acl, mapped from YANG variable /devices/device/object_groups_acl (container)
    """
    return self.__object_groups_acl
      
  def _set_object_groups_acl(self, v, load=False):
    """
    Setter method for object_groups_acl, mapped from YANG variable /devices/device/object_groups_acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_groups_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_groups_acl() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=object_groups_acl.object_groups_acl, is_container='container', yang_name="object-groups-acl", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """object_groups_acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=object_groups_acl.object_groups_acl, is_container='container', yang_name="object-groups-acl", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)""",
        })

    self.__object_groups_acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_object_groups_acl(self):
    self.__object_groups_acl = YANGDynClass(base=object_groups_acl.object_groups_acl, is_container='container', yang_name="object-groups-acl", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)


  def _get_interface_access_lists(self):
    """
    Getter method for interface_access_lists, mapped from YANG variable /devices/device/interface_access_lists (container)
    """
    return self.__interface_access_lists
      
  def _set_interface_access_lists(self, v, load=False):
    """
    Setter method for interface_access_lists, mapped from YANG variable /devices/device/interface_access_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_access_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_access_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=interface_access_lists.interface_access_lists, is_container='container', yang_name="interface-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_access_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_access_lists.interface_access_lists, is_container='container', yang_name="interface-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)""",
        })

    self.__interface_access_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_access_lists(self):
    self.__interface_access_lists = YANGDynClass(base=interface_access_lists.interface_access_lists, is_container='container', yang_name="interface-access-lists", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)


  def _get_security_rules(self):
    """
    Getter method for security_rules, mapped from YANG variable /devices/device/security_rules (container)
    """
    return self.__security_rules
      
  def _set_security_rules(self, v, load=False):
    """
    Setter method for security_rules, mapped from YANG variable /devices/device/security_rules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_rules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_rules() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security_rules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)""",
        })

    self.__security_rules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security_rules(self):
    self.__security_rules = YANGDynClass(base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='container', is_config=True)


  def _get_svclcs(self):
    """
    Getter method for svclcs, mapped from YANG variable /devices/device/svclcs (container)
    """
    return self.__svclcs
      
  def _set_svclcs(self, v, load=False):
    """
    Setter method for svclcs, mapped from YANG variable /devices/device/svclcs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_svclcs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_svclcs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=svclcs.svclcs, is_container='container', yang_name="svclcs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """svclcs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=svclcs.svclcs, is_container='container', yang_name="svclcs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__svclcs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_svclcs(self):
    self.__svclcs = YANGDynClass(base=svclcs.svclcs, is_container='container', yang_name="svclcs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_virtual_devices(self):
    """
    Getter method for virtual_devices, mapped from YANG variable /devices/device/virtual_devices (container)
    """
    return self.__virtual_devices
      
  def _set_virtual_devices(self, v, load=False):
    """
    Setter method for virtual_devices, mapped from YANG variable /devices/device/virtual_devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_devices() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=virtual_devices.virtual_devices, is_container='container', yang_name="virtual-devices", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=virtual_devices.virtual_devices, is_container='container', yang_name="virtual-devices", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__virtual_devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_devices(self):
    self.__virtual_devices = YANGDynClass(base=virtual_devices.virtual_devices, is_container='container', yang_name="virtual-devices", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_zones(self):
    """
    Getter method for zones, mapped from YANG variable /devices/device/zones (container)
    """
    return self.__zones
      
  def _set_zones(self, v, load=False):
    """
    Setter method for zones, mapped from YANG variable /devices/device/zones (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_zones is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_zones() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """zones must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__zones = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_zones(self):
    self.__zones = YANGDynClass(base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_policers(self):
    """
    Getter method for policers, mapped from YANG variable /devices/device/policers (container)
    """
    return self.__policers
      
  def _set_policers(self, v, load=False):
    """
    Setter method for policers, mapped from YANG variable /devices/device/policers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=policers.policers, is_container='container', yang_name="policers", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policers.policers, is_container='container', yang_name="policers", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__policers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policers(self):
    self.__policers = YANGDynClass(base=policers.policers, is_container='container', yang_name="policers", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_applications(self):
    """
    Getter method for applications, mapped from YANG variable /devices/device/applications (container)
    """
    return self.__applications
      
  def _set_applications(self, v, load=False):
    """
    Setter method for applications, mapped from YANG variable /devices/device/applications (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_applications is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_applications() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """applications must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__applications = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_applications(self):
    self.__applications = YANGDynClass(base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_applicationsets(self):
    """
    Getter method for applicationsets, mapped from YANG variable /devices/device/applicationsets (container)
    """
    return self.__applicationsets
      
  def _set_applicationsets(self, v, load=False):
    """
    Setter method for applicationsets, mapped from YANG variable /devices/device/applicationsets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_applicationsets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_applicationsets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=applicationsets.applicationsets, is_container='container', yang_name="applicationsets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """applicationsets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=applicationsets.applicationsets, is_container='container', yang_name="applicationsets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__applicationsets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_applicationsets(self):
    self.__applicationsets = YANGDynClass(base=applicationsets.applicationsets, is_container='container', yang_name="applicationsets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_addressbooks(self):
    """
    Getter method for addressbooks, mapped from YANG variable /devices/device/addressbooks (container)
    """
    return self.__addressbooks
      
  def _set_addressbooks(self, v, load=False):
    """
    Setter method for addressbooks, mapped from YANG variable /devices/device/addressbooks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addressbooks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addressbooks() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=addressbooks.addressbooks, is_container='container', yang_name="addressbooks", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addressbooks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=addressbooks.addressbooks, is_container='container', yang_name="addressbooks", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__addressbooks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addressbooks(self):
    self.__addressbooks = YANGDynClass(base=addressbooks.addressbooks, is_container='container', yang_name="addressbooks", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_dnsproxies(self):
    """
    Getter method for dnsproxies, mapped from YANG variable /devices/device/dnsproxies (container)
    """
    return self.__dnsproxies
      
  def _set_dnsproxies(self, v, load=False):
    """
    Setter method for dnsproxies, mapped from YANG variable /devices/device/dnsproxies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dnsproxies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dnsproxies() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dnsproxies.dnsproxies, is_container='container', yang_name="dnsproxies", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dnsproxies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dnsproxies.dnsproxies, is_container='container', yang_name="dnsproxies", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__dnsproxies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dnsproxies(self):
    self.__dnsproxies = YANGDynClass(base=dnsproxies.dnsproxies, is_container='container', yang_name="dnsproxies", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_dhcppools(self):
    """
    Getter method for dhcppools, mapped from YANG variable /devices/device/dhcppools (container)
    """
    return self.__dhcppools
      
  def _set_dhcppools(self, v, load=False):
    """
    Setter method for dhcppools, mapped from YANG variable /devices/device/dhcppools (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcppools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcppools() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dhcppools.dhcppools, is_container='container', yang_name="dhcppools", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcppools must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dhcppools.dhcppools, is_container='container', yang_name="dhcppools", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__dhcppools = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcppools(self):
    self.__dhcppools = YANGDynClass(base=dhcppools.dhcppools, is_container='container', yang_name="dhcppools", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_object_groups(self):
    """
    Getter method for object_groups, mapped from YANG variable /devices/device/object_groups (container)
    """
    return self.__object_groups
      
  def _set_object_groups(self, v, load=False):
    """
    Setter method for object_groups, mapped from YANG variable /devices/device/object_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """object_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__object_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_object_groups(self):
    self.__object_groups = YANGDynClass(base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_fw_users(self):
    """
    Getter method for fw_users, mapped from YANG variable /devices/device/fw_users (container)
    """
    return self.__fw_users
      
  def _set_fw_users(self, v, load=False):
    """
    Setter method for fw_users, mapped from YANG variable /devices/device/fw_users (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fw_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fw_users() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=fw_users.fw_users, is_container='container', yang_name="fw-users", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fw_users must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fw_users.fw_users, is_container='container', yang_name="fw-users", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__fw_users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fw_users(self):
    self.__fw_users = YANGDynClass(base=fw_users.fw_users, is_container='container', yang_name="fw-users", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_fw_user_groups(self):
    """
    Getter method for fw_user_groups, mapped from YANG variable /devices/device/fw_user_groups (container)
    """
    return self.__fw_user_groups
      
  def _set_fw_user_groups(self, v, load=False):
    """
    Setter method for fw_user_groups, mapped from YANG variable /devices/device/fw_user_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fw_user_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fw_user_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=fw_user_groups.fw_user_groups, is_container='container', yang_name="fw-user-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fw_user_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=fw_user_groups.fw_user_groups, is_container='container', yang_name="fw-user-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__fw_user_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fw_user_groups(self):
    self.__fw_user_groups = YANGDynClass(base=fw_user_groups.fw_user_groups, is_container='container', yang_name="fw-user-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /devices/device/addresses (container)
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /devices/device/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_address_sets(self):
    """
    Getter method for address_sets, mapped from YANG variable /devices/device/address_sets (container)
    """
    return self.__address_sets
      
  def _set_address_sets(self, v, load=False):
    """
    Setter method for address_sets, mapped from YANG variable /devices/device/address_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_sets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__address_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_sets(self):
    self.__address_sets = YANGDynClass(base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_address_entries(self):
    """
    Getter method for address_entries, mapped from YANG variable /devices/device/address_entries (container)
    """
    return self.__address_entries
      
  def _set_address_entries(self, v, load=False):
    """
    Setter method for address_entries, mapped from YANG variable /devices/device/address_entries (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_entries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_entries() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=address_entries.address_entries, is_container='container', yang_name="address-entries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_entries must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=address_entries.address_entries, is_container='container', yang_name="address-entries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__address_entries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_entries(self):
    self.__address_entries = YANGDynClass(base=address_entries.address_entries, is_container='container', yang_name="address-entries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_address_groups(self):
    """
    Getter method for address_groups, mapped from YANG variable /devices/device/address_groups (container)
    """
    return self.__address_groups
      
  def _set_address_groups(self, v, load=False):
    """
    Setter method for address_groups, mapped from YANG variable /devices/device/address_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=address_groups.address_groups, is_container='container', yang_name="address-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=address_groups.address_groups, is_container='container', yang_name="address-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__address_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_groups(self):
    self.__address_groups = YANGDynClass(base=address_groups.address_groups, is_container='container', yang_name="address-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_services(self):
    """
    Getter method for services, mapped from YANG variable /devices/device/services (container)
    """
    return self.__services
      
  def _set_services(self, v, load=False):
    """
    Setter method for services, mapped from YANG variable /devices/device/services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_services() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=services.services, is_container='container', yang_name="services", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=services.services, is_container='container', yang_name="services", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_services(self):
    self.__services = YANGDynClass(base=services.services, is_container='container', yang_name="services", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_service_groups(self):
    """
    Getter method for service_groups, mapped from YANG variable /devices/device/service_groups (container)
    """
    return self.__service_groups
      
  def _set_service_groups(self, v, load=False):
    """
    Setter method for service_groups, mapped from YANG variable /devices/device/service_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_groups.service_groups, is_container='container', yang_name="service-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_groups.service_groups, is_container='container', yang_name="service-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__service_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_groups(self):
    self.__service_groups = YANGDynClass(base=service_groups.service_groups, is_container='container', yang_name="service-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_templates(self):
    """
    Getter method for templates, mapped from YANG variable /devices/device/templates (container)
    """
    return self.__templates
      
  def _set_templates(self, v, load=False):
    """
    Setter method for templates, mapped from YANG variable /devices/device/templates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_templates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=templates.templates, is_container='container', yang_name="templates", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """templates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=templates.templates, is_container='container', yang_name="templates", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_templates(self):
    self.__templates = YANGDynClass(base=templates.templates, is_container='container', yang_name="templates", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_ips_sensors(self):
    """
    Getter method for ips_sensors, mapped from YANG variable /devices/device/ips_sensors (container)
    """
    return self.__ips_sensors
      
  def _set_ips_sensors(self, v, load=False):
    """
    Setter method for ips_sensors, mapped from YANG variable /devices/device/ips_sensors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ips_sensors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ips_sensors() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ips_sensors.ips_sensors, is_container='container', yang_name="ips-sensors", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ips_sensors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ips_sensors.ips_sensors, is_container='container', yang_name="ips-sensors", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__ips_sensors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ips_sensors(self):
    self.__ips_sensors = YANGDynClass(base=ips_sensors.ips_sensors, is_container='container', yang_name="ips-sensors", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_ipsec_tunnels(self):
    """
    Getter method for ipsec_tunnels, mapped from YANG variable /devices/device/ipsec_tunnels (container)
    """
    return self.__ipsec_tunnels
      
  def _set_ipsec_tunnels(self, v, load=False):
    """
    Setter method for ipsec_tunnels, mapped from YANG variable /devices/device/ipsec_tunnels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_tunnels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_tunnels() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ipsec_tunnels.ipsec_tunnels, is_container='container', yang_name="ipsec-tunnels", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_tunnels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipsec_tunnels.ipsec_tunnels, is_container='container', yang_name="ipsec-tunnels", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__ipsec_tunnels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_tunnels(self):
    self.__ipsec_tunnels = YANGDynClass(base=ipsec_tunnels.ipsec_tunnels, is_container='container', yang_name="ipsec-tunnels", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_network_objects(self):
    """
    Getter method for network_objects, mapped from YANG variable /devices/device/network_objects (container)
    """
    return self.__network_objects
      
  def _set_network_objects(self, v, load=False):
    """
    Setter method for network_objects, mapped from YANG variable /devices/device/network_objects (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_objects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_objects() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_objects must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__network_objects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_objects(self):
    self.__network_objects = YANGDynClass(base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_failover_groups(self):
    """
    Getter method for failover_groups, mapped from YANG variable /devices/device/failover_groups (container)
    """
    return self.__failover_groups
      
  def _set_failover_groups(self, v, load=False):
    """
    Setter method for failover_groups, mapped from YANG variable /devices/device/failover_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_failover_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_failover_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=failover_groups.failover_groups, is_container='container', yang_name="failover-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """failover_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=failover_groups.failover_groups, is_container='container', yang_name="failover-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__failover_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_failover_groups(self):
    self.__failover_groups = YANGDynClass(base=failover_groups.failover_groups, is_container='container', yang_name="failover-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_vdom_links(self):
    """
    Getter method for vdom_links, mapped from YANG variable /devices/device/vdom_links (container)
    """
    return self.__vdom_links
      
  def _set_vdom_links(self, v, load=False):
    """
    Setter method for vdom_links, mapped from YANG variable /devices/device/vdom_links (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdom_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdom_links() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vdom_links.vdom_links, is_container='container', yang_name="vdom-links", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdom_links must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vdom_links.vdom_links, is_container='container', yang_name="vdom-links", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__vdom_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdom_links(self):
    self.__vdom_links = YANGDynClass(base=vdom_links.vdom_links, is_container='container', yang_name="vdom-links", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_modules(self):
    """
    Getter method for modules, mapped from YANG variable /devices/device/modules (container)
    """
    return self.__modules
      
  def _set_modules(self, v, load=False):
    """
    Setter method for modules, mapped from YANG variable /devices/device/modules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modules() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=modules.modules, is_container='container', yang_name="modules", module_name="devicemodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/devicemodule', defining_module='devicemodule', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modules.modules, is_container='container', yang_name="modules", module_name="devicemodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/devicemodule', defining_module='devicemodule', yang_type='container', is_config=True)""",
        })

    self.__modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modules(self):
    self.__modules = YANGDynClass(base=modules.modules, is_container='container', yang_name="modules", module_name="devicemodule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/devicemodule', defining_module='devicemodule', yang_type='container', is_config=True)


  def _get_wanop(self):
    """
    Getter method for wanop, mapped from YANG variable /devices/device/wanop (container)
    """
    return self.__wanop
      
  def _set_wanop(self, v, load=False):
    """
    Setter method for wanop, mapped from YANG variable /devices/device/wanop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wanop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wanop() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=wanop.wanop, is_container='container', yang_name="wanop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wanop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=wanop.wanop, is_container='container', yang_name="wanop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__wanop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wanop(self):
    self.__wanop = YANGDynClass(base=wanop.wanop, is_container='container', yang_name="wanop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_inpath_config(self):
    """
    Getter method for inpath_config, mapped from YANG variable /devices/device/inpath_config (container)
    """
    return self.__inpath_config
      
  def _set_inpath_config(self, v, load=False):
    """
    Setter method for inpath_config, mapped from YANG variable /devices/device/inpath_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inpath_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inpath_config() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=inpath_config.inpath_config, is_container='container', yang_name="inpath-config", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inpath_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=inpath_config.inpath_config, is_container='container', yang_name="inpath-config", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__inpath_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inpath_config(self):
    self.__inpath_config = YANGDynClass(base=inpath_config.inpath_config, is_container='container', yang_name="inpath-config", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_network_proxy(self):
    """
    Getter method for network_proxy, mapped from YANG variable /devices/device/network_proxy (container)
    """
    return self.__network_proxy
      
  def _set_network_proxy(self, v, load=False):
    """
    Setter method for network_proxy, mapped from YANG variable /devices/device/network_proxy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_proxy() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=network_proxy.network_proxy, is_container='container', yang_name="network-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_proxy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_proxy.network_proxy, is_container='container', yang_name="network-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__network_proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_proxy(self):
    self.__network_proxy = YANGDynClass(base=network_proxy.network_proxy, is_container='container', yang_name="network-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_label_configuration(self):
    """
    Getter method for label_configuration, mapped from YANG variable /devices/device/label_configuration (container)
    """
    return self.__label_configuration
      
  def _set_label_configuration(self, v, load=False):
    """
    Setter method for label_configuration, mapped from YANG variable /devices/device/label_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label_configuration() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=label_configuration.label_configuration, is_container='container', yang_name="label-configuration", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=label_configuration.label_configuration, is_container='container', yang_name="label-configuration", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__label_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label_configuration(self):
    self.__label_configuration = YANGDynClass(base=label_configuration.label_configuration, is_container='container', yang_name="label-configuration", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_wanop_applications(self):
    """
    Getter method for wanop_applications, mapped from YANG variable /devices/device/wanop_applications (container)
    """
    return self.__wanop_applications
      
  def _set_wanop_applications(self, v, load=False):
    """
    Setter method for wanop_applications, mapped from YANG variable /devices/device/wanop_applications (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wanop_applications is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wanop_applications() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=wanop_applications.wanop_applications, is_container='container', yang_name="wanop-applications", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wanop_applications must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=wanop_applications.wanop_applications, is_container='container', yang_name="wanop-applications", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__wanop_applications = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wanop_applications(self):
    self.__wanop_applications = YANGDynClass(base=wanop_applications.wanop_applications, is_container='container', yang_name="wanop-applications", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_inpath_rules(self):
    """
    Getter method for inpath_rules, mapped from YANG variable /devices/device/inpath_rules (container)
    """
    return self.__inpath_rules
      
  def _set_inpath_rules(self, v, load=False):
    """
    Setter method for inpath_rules, mapped from YANG variable /devices/device/inpath_rules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inpath_rules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inpath_rules() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=inpath_rules.inpath_rules, is_container='container', yang_name="inpath-rules", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inpath_rules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=inpath_rules.inpath_rules, is_container='container', yang_name="inpath-rules", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__inpath_rules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inpath_rules(self):
    self.__inpath_rules = YANGDynClass(base=inpath_rules.inpath_rules, is_container='container', yang_name="inpath-rules", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_domain_lists(self):
    """
    Getter method for domain_lists, mapped from YANG variable /devices/device/domain_lists (container)
    """
    return self.__domain_lists
      
  def _set_domain_lists(self, v, load=False):
    """
    Setter method for domain_lists, mapped from YANG variable /devices/device/domain_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=domain_lists.domain_lists, is_container='container', yang_name="domain-lists", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=domain_lists.domain_lists, is_container='container', yang_name="domain-lists", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__domain_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_lists(self):
    self.__domain_lists = YANGDynClass(base=domain_lists.domain_lists, is_container='container', yang_name="domain-lists", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_optimization_services(self):
    """
    Getter method for optimization_services, mapped from YANG variable /devices/device/optimization_services (container)
    """
    return self.__optimization_services
      
  def _set_optimization_services(self, v, load=False):
    """
    Setter method for optimization_services, mapped from YANG variable /devices/device/optimization_services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optimization_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optimization_services() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=optimization_services.optimization_services, is_container='container', yang_name="optimization-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optimization_services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=optimization_services.optimization_services, is_container='container', yang_name="optimization-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__optimization_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optimization_services(self):
    self.__optimization_services = YANGDynClass(base=optimization_services.optimization_services, is_container='container', yang_name="optimization-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_network_services(self):
    """
    Getter method for network_services, mapped from YANG variable /devices/device/network_services (container)
    """
    return self.__network_services
      
  def _set_network_services(self, v, load=False):
    """
    Setter method for network_services, mapped from YANG variable /devices/device/network_services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_services() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=network_services.network_services, is_container='container', yang_name="network-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_services.network_services, is_container='container', yang_name="network-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__network_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_services(self):
    self.__network_services = YANGDynClass(base=network_services.network_services, is_container='container', yang_name="network-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_general_services(self):
    """
    Getter method for general_services, mapped from YANG variable /devices/device/general_services (container)
    """
    return self.__general_services
      
  def _set_general_services(self, v, load=False):
    """
    Setter method for general_services, mapped from YANG variable /devices/device/general_services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_general_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_general_services() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=general_services.general_services, is_container='container', yang_name="general-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """general_services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=general_services.general_services, is_container='container', yang_name="general-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__general_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_general_services(self):
    self.__general_services = YANGDynClass(base=general_services.general_services, is_container='container', yang_name="general-services", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_protocols(self):
    """
    Getter method for protocols, mapped from YANG variable /devices/device/protocols (container)
    """
    return self.__protocols
      
  def _set_protocols(self, v, load=False):
    """
    Setter method for protocols, mapped from YANG variable /devices/device/protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocols() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=protocols.protocols, is_container='container', yang_name="protocols", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocols(self):
    self.__protocols = YANGDynClass(base=protocols.protocols, is_container='container', yang_name="protocols", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_secure_peering(self):
    """
    Getter method for secure_peering, mapped from YANG variable /devices/device/secure_peering (container)
    """
    return self.__secure_peering
      
  def _set_secure_peering(self, v, load=False):
    """
    Setter method for secure_peering, mapped from YANG variable /devices/device/secure_peering (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secure_peering is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secure_peering() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=secure_peering.secure_peering, is_container='container', yang_name="secure-peering", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secure_peering must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=secure_peering.secure_peering, is_container='container', yang_name="secure-peering", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)""",
        })

    self.__secure_peering = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secure_peering(self):
    self.__secure_peering = YANGDynClass(base=secure_peering.secure_peering, is_container='container', yang_name="secure-peering", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='container', is_config=True)


  def _get_class_maps(self):
    """
    Getter method for class_maps, mapped from YANG variable /devices/device/class_maps (container)
    """
    return self.__class_maps
      
  def _set_class_maps(self, v, load=False):
    """
    Setter method for class_maps, mapped from YANG variable /devices/device/class_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_class_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_class_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=class_maps.class_maps, is_container='container', yang_name="class-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """class_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=class_maps.class_maps, is_container='container', yang_name="class-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__class_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_class_maps(self):
    self.__class_maps = YANGDynClass(base=class_maps.class_maps, is_container='container', yang_name="class-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_policy_maps(self):
    """
    Getter method for policy_maps, mapped from YANG variable /devices/device/policy_maps (container)
    """
    return self.__policy_maps
      
  def _set_policy_maps(self, v, load=False):
    """
    Setter method for policy_maps, mapped from YANG variable /devices/device/policy_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=policy_maps.policy_maps, is_container='container', yang_name="policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_maps.policy_maps, is_container='container', yang_name="policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__policy_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_maps(self):
    self.__policy_maps = YANGDynClass(base=policy_maps.policy_maps, is_container='container', yang_name="policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_system_qos(self):
    """
    Getter method for system_qos, mapped from YANG variable /devices/device/system_qos (container)
    """
    return self.__system_qos
      
  def _set_system_qos(self, v, load=False):
    """
    Setter method for system_qos, mapped from YANG variable /devices/device/system_qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_qos() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=system_qos.system_qos, is_container='container', yang_name="system-qos", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system_qos.system_qos, is_container='container', yang_name="system-qos", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__system_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_qos(self):
    self.__system_qos = YANGDynClass(base=system_qos.system_qos, is_container='container', yang_name="system-qos", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_pfr_classes(self):
    """
    Getter method for pfr_classes, mapped from YANG variable /devices/device/pfr_classes (container)
    """
    return self.__pfr_classes
      
  def _set_pfr_classes(self, v, load=False):
    """
    Setter method for pfr_classes, mapped from YANG variable /devices/device/pfr_classes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pfr_classes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pfr_classes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=pfr_classes.pfr_classes, is_container='container', yang_name="pfr-classes", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pfr_classes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=pfr_classes.pfr_classes, is_container='container', yang_name="pfr-classes", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__pfr_classes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pfr_classes(self):
    self.__pfr_classes = YANGDynClass(base=pfr_classes.pfr_classes, is_container='container', yang_name="pfr-classes", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_pfr_policy_maps(self):
    """
    Getter method for pfr_policy_maps, mapped from YANG variable /devices/device/pfr_policy_maps (container)
    """
    return self.__pfr_policy_maps
      
  def _set_pfr_policy_maps(self, v, load=False):
    """
    Setter method for pfr_policy_maps, mapped from YANG variable /devices/device/pfr_policy_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pfr_policy_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pfr_policy_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=pfr_policy_maps.pfr_policy_maps, is_container='container', yang_name="pfr-policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pfr_policy_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=pfr_policy_maps.pfr_policy_maps, is_container='container', yang_name="pfr-policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__pfr_policy_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pfr_policy_maps(self):
    self.__pfr_policy_maps = YANGDynClass(base=pfr_policy_maps.pfr_policy_maps, is_container='container', yang_name="pfr-policy-maps", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_qos_scheduler_policies(self):
    """
    Getter method for qos_scheduler_policies, mapped from YANG variable /devices/device/qos_scheduler_policies (container)
    """
    return self.__qos_scheduler_policies
      
  def _set_qos_scheduler_policies(self, v, load=False):
    """
    Setter method for qos_scheduler_policies, mapped from YANG variable /devices/device/qos_scheduler_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_scheduler_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_scheduler_policies() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=qos_scheduler_policies.qos_scheduler_policies, is_container='container', yang_name="qos-scheduler-policies", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_scheduler_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos_scheduler_policies.qos_scheduler_policies, is_container='container', yang_name="qos-scheduler-policies", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__qos_scheduler_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_scheduler_policies(self):
    self.__qos_scheduler_policies = YANGDynClass(base=qos_scheduler_policies.qos_scheduler_policies, is_container='container', yang_name="qos-scheduler-policies", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_qos_group_templates(self):
    """
    Getter method for qos_group_templates, mapped from YANG variable /devices/device/qos_group_templates (container)
    """
    return self.__qos_group_templates
      
  def _set_qos_group_templates(self, v, load=False):
    """
    Setter method for qos_group_templates, mapped from YANG variable /devices/device/qos_group_templates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos_group_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos_group_templates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=qos_group_templates.qos_group_templates, is_container='container', yang_name="qos-group-templates", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos_group_templates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos_group_templates.qos_group_templates, is_container='container', yang_name="qos-group-templates", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)""",
        })

    self.__qos_group_templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos_group_templates(self):
    self.__qos_group_templates = YANGDynClass(base=qos_group_templates.qos_group_templates, is_container='container', yang_name="qos-group-templates", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='container', is_config=True)


  def _get_vpls(self):
    """
    Getter method for vpls, mapped from YANG variable /devices/device/vpls (container)

    YANG Description: VPLS configuration
    """
    return self.__vpls
      
  def _set_vpls(self, v, load=False):
    """
    Setter method for vpls, mapped from YANG variable /devices/device/vpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpls() directly.

    YANG Description: VPLS configuration
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vpls.vpls, is_container='container', yang_name="vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vpls.vpls, is_container='container', yang_name="vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpls(self):
    self.__vpls = YANGDynClass(base=vpls.vpls, is_container='container', yang_name="vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_lb_domains(self):
    """
    Getter method for lb_domains, mapped from YANG variable /devices/device/lb_domains (container)
    """
    return self.__lb_domains
      
  def _set_lb_domains(self, v, load=False):
    """
    Setter method for lb_domains, mapped from YANG variable /devices/device/lb_domains (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lb_domains is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lb_domains() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=lb_domains.lb_domains, is_container='container', yang_name="lb-domains", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lb_domains must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lb_domains.lb_domains, is_container='container', yang_name="lb-domains", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__lb_domains = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lb_domains(self):
    self.__lb_domains = YANGDynClass(base=lb_domains.lb_domains, is_container='container', yang_name="lb-domains", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_self_ips(self):
    """
    Getter method for self_ips, mapped from YANG variable /devices/device/self_ips (container)
    """
    return self.__self_ips
      
  def _set_self_ips(self, v, load=False):
    """
    Setter method for self_ips, mapped from YANG variable /devices/device/self_ips (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_self_ips is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_self_ips() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=self_ips.self_ips, is_container='container', yang_name="self-ips", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """self_ips must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=self_ips.self_ips, is_container='container', yang_name="self-ips", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__self_ips = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_self_ips(self):
    self.__self_ips = YANGDynClass(base=self_ips.self_ips, is_container='container', yang_name="self-ips", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_contexts(self):
    """
    Getter method for contexts, mapped from YANG variable /devices/device/contexts (container)
    """
    return self.__contexts
      
  def _set_contexts(self, v, load=False):
    """
    Setter method for contexts, mapped from YANG variable /devices/device/contexts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_contexts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_contexts() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=contexts.contexts, is_container='container', yang_name="contexts", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """contexts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=contexts.contexts, is_container='container', yang_name="contexts", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__contexts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_contexts(self):
    self.__contexts = YANGDynClass(base=contexts.contexts, is_container='container', yang_name="contexts", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_real_servers(self):
    """
    Getter method for real_servers, mapped from YANG variable /devices/device/real_servers (container)
    """
    return self.__real_servers
      
  def _set_real_servers(self, v, load=False):
    """
    Setter method for real_servers, mapped from YANG variable /devices/device/real_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_real_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_real_servers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=real_servers.real_servers, is_container='container', yang_name="real-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """real_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=real_servers.real_servers, is_container='container', yang_name="real-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__real_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_real_servers(self):
    self.__real_servers = YANGDynClass(base=real_servers.real_servers, is_container='container', yang_name="real-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_rservice_pools(self):
    """
    Getter method for rservice_pools, mapped from YANG variable /devices/device/rservice_pools (container)
    """
    return self.__rservice_pools
      
  def _set_rservice_pools(self, v, load=False):
    """
    Setter method for rservice_pools, mapped from YANG variable /devices/device/rservice_pools (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rservice_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rservice_pools() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rservice_pools.rservice_pools, is_container='container', yang_name="rservice-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rservice_pools must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rservice_pools.rservice_pools, is_container='container', yang_name="rservice-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__rservice_pools = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rservice_pools(self):
    self.__rservice_pools = YANGDynClass(base=rservice_pools.rservice_pools, is_container='container', yang_name="rservice-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_virtual_servers(self):
    """
    Getter method for virtual_servers, mapped from YANG variable /devices/device/virtual_servers (container)
    """
    return self.__virtual_servers
      
  def _set_virtual_servers(self, v, load=False):
    """
    Setter method for virtual_servers, mapped from YANG variable /devices/device/virtual_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_servers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=virtual_servers.virtual_servers, is_container='container', yang_name="virtual-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=virtual_servers.virtual_servers, is_container='container', yang_name="virtual-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__virtual_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_servers(self):
    self.__virtual_servers = YANGDynClass(base=virtual_servers.virtual_servers, is_container='container', yang_name="virtual-servers", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_snat_pools(self):
    """
    Getter method for snat_pools, mapped from YANG variable /devices/device/snat_pools (container)
    """
    return self.__snat_pools
      
  def _set_snat_pools(self, v, load=False):
    """
    Setter method for snat_pools, mapped from YANG variable /devices/device/snat_pools (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snat_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snat_pools() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=snat_pools.snat_pools, is_container='container', yang_name="snat-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snat_pools must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=snat_pools.snat_pools, is_container='container', yang_name="snat-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__snat_pools = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snat_pools(self):
    self.__snat_pools = YANGDynClass(base=snat_pools.snat_pools, is_container='container', yang_name="snat-pools", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_lb_routes(self):
    """
    Getter method for lb_routes, mapped from YANG variable /devices/device/lb_routes (container)
    """
    return self.__lb_routes
      
  def _set_lb_routes(self, v, load=False):
    """
    Setter method for lb_routes, mapped from YANG variable /devices/device/lb_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lb_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lb_routes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=lb_routes.lb_routes, is_container='container', yang_name="lb-routes", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lb_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lb_routes.lb_routes, is_container='container', yang_name="lb-routes", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__lb_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lb_routes(self):
    self.__lb_routes = YANGDynClass(base=lb_routes.lb_routes, is_container='container', yang_name="lb-routes", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_lb_ha_node(self):
    """
    Getter method for lb_ha_node, mapped from YANG variable /devices/device/lb_ha_node (container)
    """
    return self.__lb_ha_node
      
  def _set_lb_ha_node(self, v, load=False):
    """
    Setter method for lb_ha_node, mapped from YANG variable /devices/device/lb_ha_node (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lb_ha_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lb_ha_node() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=lb_ha_node.lb_ha_node, is_container='container', yang_name="lb-ha-node", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lb_ha_node must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lb_ha_node.lb_ha_node, is_container='container', yang_name="lb-ha-node", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__lb_ha_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lb_ha_node(self):
    self.__lb_ha_node = YANGDynClass(base=lb_ha_node.lb_ha_node, is_container='container', yang_name="lb-ha-node", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_health_monitors(self):
    """
    Getter method for health_monitors, mapped from YANG variable /devices/device/health_monitors (container)
    """
    return self.__health_monitors
      
  def _set_health_monitors(self, v, load=False):
    """
    Setter method for health_monitors, mapped from YANG variable /devices/device/health_monitors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_health_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_health_monitors() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=health_monitors.health_monitors, is_container='container', yang_name="health-monitors", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """health_monitors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=health_monitors.health_monitors, is_container='container', yang_name="health-monitors", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__health_monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_health_monitors(self):
    self.__health_monitors = YANGDynClass(base=health_monitors.health_monitors, is_container='container', yang_name="health-monitors", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_certificates(self):
    """
    Getter method for certificates, mapped from YANG variable /devices/device/certificates (container)
    """
    return self.__certificates
      
  def _set_certificates(self, v, load=False):
    """
    Setter method for certificates, mapped from YANG variable /devices/device/certificates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certificates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certificates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=certificates.certificates, is_container='container', yang_name="certificates", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """certificates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=certificates.certificates, is_container='container', yang_name="certificates", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__certificates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_certificates(self):
    self.__certificates = YANGDynClass(base=certificates.certificates, is_container='container', yang_name="certificates", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_partitions(self):
    """
    Getter method for partitions, mapped from YANG variable /devices/device/partitions (container)
    """
    return self.__partitions
      
  def _set_partitions(self, v, load=False):
    """
    Setter method for partitions, mapped from YANG variable /devices/device/partitions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partitions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partitions() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=partitions.partitions, is_container='container', yang_name="partitions", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partitions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=partitions.partitions, is_container='container', yang_name="partitions", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)""",
        })

    self.__partitions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partitions(self):
    self.__partitions = YANGDynClass(base=partitions.partitions, is_container='container', yang_name="partitions", module_name="loadbalancer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/loadbalancer', defining_module='loadbalancer', yang_type='container', is_config=True)


  def _get_linecard(self):
    """
    Getter method for linecard, mapped from YANG variable /devices/device/linecard (list)
    """
    return self.__linecard
      
  def _set_linecard(self, v, load=False):
    """
    Setter method for linecard, mapped from YANG variable /devices/device/linecard (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linecard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linecard() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("switch_number slot_number",linecard.linecard, yang_name="linecard", module_name="linecard", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='switch-number slot-number'), is_container='list', yang_name="linecard", module_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/linecard', defining_module='linecard', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linecard must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("switch_number slot_number",linecard.linecard, yang_name="linecard", module_name="linecard", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='switch-number slot-number'), is_container='list', yang_name="linecard", module_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/linecard', defining_module='linecard', yang_type='list', is_config=True)""",
        })

    self.__linecard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linecard(self):
    self.__linecard = YANGDynClass(base=YANGListType("switch_number slot_number",linecard.linecard, yang_name="linecard", module_name="linecard", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='switch-number slot-number'), is_container='list', yang_name="linecard", module_name="linecard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/linecard', defining_module='linecard', yang_type='list', is_config=True)


  def _get_cspservice_type(self):
    """
    Getter method for cspservice_type, mapped from YANG variable /devices/device/cspservice_type (service-type-enum)

    YANG Description: AWS
NEUSTAR

    """
    return self.__cspservice_type
      
  def _set_cspservice_type(self, v, load=False):
    """
    Setter method for cspservice_type, mapped from YANG variable /devices/device/cspservice_type (service-type-enum)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cspservice_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cspservice_type() directly.

    YANG Description: AWS
NEUSTAR

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AWS': {}, u'NEUSTAR': {}},), is_leaf=True, yang_name="cspservice-type", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='service-type-enum', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cspservice_type must be of a type compatible with service-type-enum""",
          'defined-type': "aws:service-type-enum",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AWS': {}, u'NEUSTAR': {}},), is_leaf=True, yang_name="cspservice-type", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='service-type-enum', is_config=True)""",
        })

    self.__cspservice_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cspservice_type(self):
    self.__cspservice_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AWS': {}, u'NEUSTAR': {}},), is_leaf=True, yang_name="cspservice-type", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='service-type-enum', is_config=True)


  def _get_csp_ip_url(self):
    """
    Getter method for csp_ip_url, mapped from YANG variable /devices/device/csp_ip_url (string)

    YANG Description: string
    """
    return self.__csp_ip_url
      
  def _set_csp_ip_url(self, v, load=False):
    """
    Setter method for csp_ip_url, mapped from YANG variable /devices/device/csp_ip_url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_csp_ip_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_csp_ip_url() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="csp_ip-url", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """csp_ip_url must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="csp_ip-url", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=True)""",
        })

    self.__csp_ip_url = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_csp_ip_url(self):
    self.__csp_ip_url = YANGDynClass(base=unicode, is_leaf=True, yang_name="csp_ip-url", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=True)


  def _get_region(self):
    """
    Getter method for region, mapped from YANG variable /devices/device/region (string)

    YANG Description: string
    """
    return self.__region
      
  def _set_region(self, v, load=False):
    """
    Setter method for region, mapped from YANG variable /devices/device/region (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_region is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_region() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="region", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """region must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="region", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=False)""",
        })

    self.__region = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_region(self):
    self.__region = YANGDynClass(base=unicode, is_leaf=True, yang_name="region", module_name="aws", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/aws', defining_module='aws', yang_type='string', is_config=False)


  def _get_configurations(self):
    """
    Getter method for configurations, mapped from YANG variable /devices/device/configurations (container)
    """
    return self.__configurations
      
  def _set_configurations(self, v, load=False):
    """
    Setter method for configurations, mapped from YANG variable /devices/device/configurations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=configurations.configurations, is_container='container', yang_name="configurations", module_name="bluecat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/bluecat', defining_module='bluecat', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configurations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=configurations.configurations, is_container='container', yang_name="configurations", module_name="bluecat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/bluecat', defining_module='bluecat', yang_type='container', is_config=True)""",
        })

    self.__configurations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configurations(self):
    self.__configurations = YANGDynClass(base=configurations.configurations, is_container='container', yang_name="configurations", module_name="bluecat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/bluecat', defining_module='bluecat', yang_type='container', is_config=True)


  def _get_subnets(self):
    """
    Getter method for subnets, mapped from YANG variable /devices/device/subnets (list)
    """
    return self.__subnets
      
  def _set_subnets(self, v, load=False):
    """
    Setter method for subnets, mapped from YANG variable /devices/device/subnets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("ip_address",subnets.subnets, yang_name="subnets", module_name="acs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="subnets", module_name="acs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acs', defining_module='acs', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnets must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address",subnets.subnets, yang_name="subnets", module_name="acs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="subnets", module_name="acs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acs', defining_module='acs', yang_type='list', is_config=True)""",
        })

    self.__subnets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnets(self):
    self.__subnets = YANGDynClass(base=YANGListType("ip_address",subnets.subnets, yang_name="subnets", module_name="acs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="subnets", module_name="acs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acs', defining_module='acs', yang_type='list', is_config=True)


  def _get_tenants(self):
    """
    Getter method for tenants, mapped from YANG variable /devices/device/tenants (container)
    """
    return self.__tenants
      
  def _set_tenants(self, v, load=False):
    """
    Setter method for tenants, mapped from YANG variable /devices/device/tenants (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tenants is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tenants() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tenants.tenants, is_container='container', yang_name="tenants", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tenants must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tenants.tenants, is_container='container', yang_name="tenants", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='container', is_config=True)""",
        })

    self.__tenants = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tenants(self):
    self.__tenants = YANGDynClass(base=tenants.tenants, is_container='container', yang_name="tenants", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='container', is_config=True)


  def _get_keystone_ip(self):
    """
    Getter method for keystone_ip, mapped from YANG variable /devices/device/keystone_ip (inet:ipv4-address)

    YANG Description: Valid IPv4 Address (A.B.C.D for e.x: 172.16.1.1)
    """
    return self.__keystone_ip
      
  def _set_keystone_ip(self, v, load=False):
    """
    Setter method for keystone_ip, mapped from YANG variable /devices/device/keystone_ip (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keystone_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keystone_ip() directly.

    YANG Description: Valid IPv4 Address (A.B.C.D for e.x: 172.16.1.1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="keystone-ip", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keystone_ip must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="keystone-ip", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__keystone_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keystone_ip(self):
    self.__keystone_ip = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="keystone-ip", module_name="cso", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cso', defining_module='cso', yang_type='inet:ipv4-address', is_config=True)


  def _get_capacities(self):
    """
    Getter method for capacities, mapped from YANG variable /devices/device/capacities (container)
    """
    return self.__capacities
      
  def _set_capacities(self, v, load=False):
    """
    Setter method for capacities, mapped from YANG variable /devices/device/capacities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacities() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=capacities.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capacities.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)""",
        })

    self.__capacities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacities(self):
    self.__capacities = YANGDynClass(base=capacities.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)


  def _get_l2_neighbors(self):
    """
    Getter method for l2_neighbors, mapped from YANG variable /devices/device/l2_neighbors (container)
    """
    return self.__l2_neighbors
      
  def _set_l2_neighbors(self, v, load=False):
    """
    Setter method for l2_neighbors, mapped from YANG variable /devices/device/l2_neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_neighbors() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=l2_neighbors.l2_neighbors, is_container='container', yang_name="l2-neighbors", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=l2_neighbors.l2_neighbors, is_container='container', yang_name="l2-neighbors", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)""",
        })

    self.__l2_neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_neighbors(self):
    self.__l2_neighbors = YANGDynClass(base=l2_neighbors.l2_neighbors, is_container='container', yang_name="l2-neighbors", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  management_mode = __builtin__.property(_get_management_mode, _set_management_mode)
  status = __builtin__.property(_get_status)
  name = __builtin__.property(_get_name, _set_name)
  mgmt_ip_address = __builtin__.property(_get_mgmt_ip_address, _set_mgmt_ip_address)
  fqdn_name = __builtin__.property(_get_fqdn_name, _set_fqdn_name)
  credential_set = __builtin__.property(_get_credential_set, _set_credential_set)
  derived_credential_set = __builtin__.property(_get_derived_credential_set)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  os_version = __builtin__.property(_get_os_version)
  platform = __builtin__.property(_get_platform)
  description = __builtin__.property(_get_description, _set_description)
  driver_name = __builtin__.property(_get_driver_name, _set_driver_name)
  hardware_throughput = __builtin__.property(_get_hardware_throughput, _set_hardware_throughput)
  dns_name = __builtin__.property(_get_dns_name)
  rma = __builtin__.property(_get_rma)
  num_vms = __builtin__.property(_get_num_vms)
  num_nics = __builtin__.property(_get_num_nics)
  num_cpus = __builtin__.property(_get_num_cpus)
  cpu_mhz = __builtin__.property(_get_cpu_mhz)
  is_module = __builtin__.property(_get_is_module)
  chassis = __builtin__.property(_get_chassis)
  model = __builtin__.property(_get_model)
  memory = __builtin__.property(_get_memory)
  processor = __builtin__.property(_get_processor)
  port_channel = __builtin__.property(_get_port_channel)
  num_sockets = __builtin__.property(_get_num_sockets)
  subscribed_to_snmp_traps = __builtin__.property(_get_subscribed_to_snmp_traps)
  subscribed_to_syslog = __builtin__.property(_get_subscribed_to_syslog)
  vem_module_num = __builtin__.property(_get_vem_module_num)
  stale_entry = __builtin__.property(_get_stale_entry)
  pair_mgmt_ip_address = __builtin__.property(_get_pair_mgmt_ip_address)
  vmstatus = __builtin__.property(_get_vmstatus)
  device_family_string = __builtin__.property(_get_device_family_string)
  ostype_string = __builtin__.property(_get_ostype_string)
  vendor_string = __builtin__.property(_get_vendor_string)
  serial_number = __builtin__.property(_get_serial_number)
  sys_descr = __builtin__.property(_get_sys_descr)
  sys_object_id = __builtin__.property(_get_sys_object_id)
  sys_location = __builtin__.property(_get_sys_location)
  sys_up_time = __builtin__.property(_get_sys_up_time)
  mgmt_vrf_name = __builtin__.property(_get_mgmt_vrf_name, _set_mgmt_vrf_name)
  manage_by_management_station = __builtin__.property(_get_manage_by_management_station, _set_manage_by_management_station)
  management_station = __builtin__.property(_get_management_station, _set_management_station)
  managed_devices = __builtin__.property(_get_managed_devices)
  vm_name = __builtin__.property(_get_vm_name, _set_vm_name)
  cluster_ip_address = __builtin__.property(_get_cluster_ip_address, _set_cluster_ip_address)
  device_capability = __builtin__.property(_get_device_capability)
  unmanaged_device_capability = __builtin__.property(_get_unmanaged_device_capability, _set_unmanaged_device_capability)
  virtual_appliance_image = __builtin__.property(_get_virtual_appliance_image)
  agent_id = __builtin__.property(_get_agent_id)
  priv_status = __builtin__.property(_get_priv_status)
  reconciliation = __builtin__.property(_get_reconciliation, _set_reconciliation)
  unique_name = __builtin__.property(_get_unique_name, _set_unique_name)
  service_provisioning_status = __builtin__.property(_get_service_provisioning_status, _set_service_provisioning_status)
  location_properties = __builtin__.property(_get_location_properties, _set_location_properties)
  violations = __builtin__.property(_get_violations, _set_violations)
  compliance_status = __builtin__.property(_get_compliance_status)
  compliances = __builtin__.property(_get_compliances, _set_compliances)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  interface_ranges = __builtin__.property(_get_interface_ranges, _set_interface_ranges)
  vlans = __builtin__.property(_get_vlans, _set_vlans)
  vlan_groups = __builtin__.property(_get_vlan_groups, _set_vlan_groups)
  vn_services = __builtin__.property(_get_vn_services, _set_vn_services)
  vn_paths = __builtin__.property(_get_vn_paths, _set_vn_paths)
  port_groups = __builtin__.property(_get_port_groups, _set_port_groups)
  port_channels = __builtin__.property(_get_port_channels, _set_port_channels)
  route_policies = __builtin__.property(_get_route_policies, _set_route_policies)
  rib_groups = __builtin__.property(_get_rib_groups, _set_rib_groups)
  vrfs = __builtin__.property(_get_vrfs, _set_vrfs)
  community_lists = __builtin__.property(_get_community_lists, _set_community_lists)
  extcommunity_lists = __builtin__.property(_get_extcommunity_lists, _set_extcommunity_lists)
  ip_sla = __builtin__.property(_get_ip_sla, _set_ip_sla)
  ip_sla_schedules = __builtin__.property(_get_ip_sla_schedules, _set_ip_sla_schedules)
  ip_nat_pool = __builtin__.property(_get_ip_nat_pool, _set_ip_nat_pool)
  ip_nat = __builtin__.property(_get_ip_nat, _set_ip_nat)
  tracks = __builtin__.property(_get_tracks, _set_tracks)
  prefix_sets = __builtin__.property(_get_prefix_sets, _set_prefix_sets)
  bgp_as = __builtin__.property(_get_bgp_as)
  as_path_acls = __builtin__.property(_get_as_path_acls, _set_as_path_acls)
  route_maps = __builtin__.property(_get_route_maps, _set_route_maps)
  eigrp = __builtin__.property(_get_eigrp, _set_eigrp)
  policy_options = __builtin__.property(_get_policy_options, _set_policy_options)
  dhcp_server = __builtin__.property(_get_dhcp_server, _set_dhcp_server)
  CaTrustPointCertificate = __builtin__.property(_get_CaTrustPointCertificate, _set_CaTrustPointCertificate)
  ip_prefixlist_list = __builtin__.property(_get_ip_prefixlist_list, _set_ip_prefixlist_list)
  vpls_list = __builtin__.property(_get_vpls_list, _set_vpls_list)
  eem_script = __builtin__.property(_get_eem_script, _set_eem_script)
  eem_applets = __builtin__.property(_get_eem_applets, _set_eem_applets)
  netflow = __builtin__.property(_get_netflow, _set_netflow)
  bridge = __builtin__.property(_get_bridge, _set_bridge)
  key_chain = __builtin__.property(_get_key_chain, _set_key_chain)
  static_routes = __builtin__.property(_get_static_routes, _set_static_routes)
  routes = __builtin__.property(_get_routes, _set_routes)
  snmp = __builtin__.property(_get_snmp, _set_snmp)
  ntp = __builtin__.property(_get_ntp, _set_ntp)
  username = __builtin__.property(_get_username, _set_username)
  clock = __builtin__.property(_get_clock, _set_clock)
  banner = __builtin__.property(_get_banner, _set_banner)
  http = __builtin__.property(_get_http, _set_http)
  service_time_stamps = __builtin__.property(_get_service_time_stamps, _set_service_time_stamps)
  ha = __builtin__.property(_get_ha, _set_ha)
  local_credentials = __builtin__.property(_get_local_credentials, _set_local_credentials)
  ssh = __builtin__.property(_get_ssh, _set_ssh)
  logging = __builtin__.property(_get_logging, _set_logging)
  aaa_root = __builtin__.property(_get_aaa_root, _set_aaa_root)
  aaa_group = __builtin__.property(_get_aaa_group, _set_aaa_group)
  call_home = __builtin__.property(_get_call_home, _set_call_home)
  tacacs_conf = __builtin__.property(_get_tacacs_conf, _set_tacacs_conf)
  tftp = __builtin__.property(_get_tftp, _set_tftp)
  license = __builtin__.property(_get_license, _set_license)
  hostname = __builtin__.property(_get_hostname, _set_hostname)
  vty_configs = __builtin__.property(_get_vty_configs, _set_vty_configs)
  console = __builtin__.property(_get_console, _set_console)
  auxiliary_port = __builtin__.property(_get_auxiliary_port, _set_auxiliary_port)
  features = __builtin__.property(_get_features, _set_features)
  spanning_tree = __builtin__.property(_get_spanning_tree, _set_spanning_tree)
  error_disable_recovery = __builtin__.property(_get_error_disable_recovery, _set_error_disable_recovery)
  bfd = __builtin__.property(_get_bfd, _set_bfd)
  ip_arp = __builtin__.property(_get_ip_arp, _set_ip_arp)
  mac_table = __builtin__.property(_get_mac_table, _set_mac_table)
  service_unsupported = __builtin__.property(_get_service_unsupported, _set_service_unsupported)
  jumbo_mtu = __builtin__.property(_get_jumbo_mtu, _set_jumbo_mtu)
  bgp = __builtin__.property(_get_bgp, _set_bgp)
  interface_breakout = __builtin__.property(_get_interface_breakout, _set_interface_breakout)
  event_manager = __builtin__.property(_get_event_manager, _set_event_manager)
  shell_options = __builtin__.property(_get_shell_options, _set_shell_options)
  crypto = __builtin__.property(_get_crypto, _set_crypto)
  crypto_policies = __builtin__.property(_get_crypto_policies, _set_crypto_policies)
  crypto_proposals = __builtin__.property(_get_crypto_proposals, _set_crypto_proposals)
  crypto_keyrings = __builtin__.property(_get_crypto_keyrings, _set_crypto_keyrings)
  transform_sets = __builtin__.property(_get_transform_sets, _set_transform_sets)
  ipsec_profiles = __builtin__.property(_get_ipsec_profiles, _set_ipsec_profiles)
  dmvpntunnels = __builtin__.property(_get_dmvpntunnels, _set_dmvpntunnels)
  domain = __builtin__.property(_get_domain, _set_domain)
  dns_server = __builtin__.property(_get_dns_server, _set_dns_server)
  a_records = __builtin__.property(_get_a_records, _set_a_records)
  host_records = __builtin__.property(_get_host_records, _set_host_records)
  dns_zones = __builtin__.property(_get_dns_zones, _set_dns_zones)
  resource_records = __builtin__.property(_get_resource_records, _set_resource_records)
  access_lists = __builtin__.property(_get_access_lists, _set_access_lists)
  number_access_lists = __builtin__.property(_get_number_access_lists, _set_number_access_lists)
  object_groups_acl = __builtin__.property(_get_object_groups_acl, _set_object_groups_acl)
  interface_access_lists = __builtin__.property(_get_interface_access_lists, _set_interface_access_lists)
  security_rules = __builtin__.property(_get_security_rules, _set_security_rules)
  svclcs = __builtin__.property(_get_svclcs, _set_svclcs)
  virtual_devices = __builtin__.property(_get_virtual_devices, _set_virtual_devices)
  zones = __builtin__.property(_get_zones, _set_zones)
  policers = __builtin__.property(_get_policers, _set_policers)
  applications = __builtin__.property(_get_applications, _set_applications)
  applicationsets = __builtin__.property(_get_applicationsets, _set_applicationsets)
  addressbooks = __builtin__.property(_get_addressbooks, _set_addressbooks)
  dnsproxies = __builtin__.property(_get_dnsproxies, _set_dnsproxies)
  dhcppools = __builtin__.property(_get_dhcppools, _set_dhcppools)
  object_groups = __builtin__.property(_get_object_groups, _set_object_groups)
  fw_users = __builtin__.property(_get_fw_users, _set_fw_users)
  fw_user_groups = __builtin__.property(_get_fw_user_groups, _set_fw_user_groups)
  addresses = __builtin__.property(_get_addresses, _set_addresses)
  address_sets = __builtin__.property(_get_address_sets, _set_address_sets)
  address_entries = __builtin__.property(_get_address_entries, _set_address_entries)
  address_groups = __builtin__.property(_get_address_groups, _set_address_groups)
  services = __builtin__.property(_get_services, _set_services)
  service_groups = __builtin__.property(_get_service_groups, _set_service_groups)
  templates = __builtin__.property(_get_templates, _set_templates)
  ips_sensors = __builtin__.property(_get_ips_sensors, _set_ips_sensors)
  ipsec_tunnels = __builtin__.property(_get_ipsec_tunnels, _set_ipsec_tunnels)
  network_objects = __builtin__.property(_get_network_objects, _set_network_objects)
  failover_groups = __builtin__.property(_get_failover_groups, _set_failover_groups)
  vdom_links = __builtin__.property(_get_vdom_links, _set_vdom_links)
  modules = __builtin__.property(_get_modules, _set_modules)
  wanop = __builtin__.property(_get_wanop, _set_wanop)
  inpath_config = __builtin__.property(_get_inpath_config, _set_inpath_config)
  network_proxy = __builtin__.property(_get_network_proxy, _set_network_proxy)
  label_configuration = __builtin__.property(_get_label_configuration, _set_label_configuration)
  wanop_applications = __builtin__.property(_get_wanop_applications, _set_wanop_applications)
  inpath_rules = __builtin__.property(_get_inpath_rules, _set_inpath_rules)
  domain_lists = __builtin__.property(_get_domain_lists, _set_domain_lists)
  optimization_services = __builtin__.property(_get_optimization_services, _set_optimization_services)
  network_services = __builtin__.property(_get_network_services, _set_network_services)
  general_services = __builtin__.property(_get_general_services, _set_general_services)
  protocols = __builtin__.property(_get_protocols, _set_protocols)
  secure_peering = __builtin__.property(_get_secure_peering, _set_secure_peering)
  class_maps = __builtin__.property(_get_class_maps, _set_class_maps)
  policy_maps = __builtin__.property(_get_policy_maps, _set_policy_maps)
  system_qos = __builtin__.property(_get_system_qos, _set_system_qos)
  pfr_classes = __builtin__.property(_get_pfr_classes, _set_pfr_classes)
  pfr_policy_maps = __builtin__.property(_get_pfr_policy_maps, _set_pfr_policy_maps)
  qos_scheduler_policies = __builtin__.property(_get_qos_scheduler_policies, _set_qos_scheduler_policies)
  qos_group_templates = __builtin__.property(_get_qos_group_templates, _set_qos_group_templates)
  vpls = __builtin__.property(_get_vpls, _set_vpls)
  lb_domains = __builtin__.property(_get_lb_domains, _set_lb_domains)
  self_ips = __builtin__.property(_get_self_ips, _set_self_ips)
  contexts = __builtin__.property(_get_contexts, _set_contexts)
  real_servers = __builtin__.property(_get_real_servers, _set_real_servers)
  rservice_pools = __builtin__.property(_get_rservice_pools, _set_rservice_pools)
  virtual_servers = __builtin__.property(_get_virtual_servers, _set_virtual_servers)
  snat_pools = __builtin__.property(_get_snat_pools, _set_snat_pools)
  lb_routes = __builtin__.property(_get_lb_routes, _set_lb_routes)
  lb_ha_node = __builtin__.property(_get_lb_ha_node, _set_lb_ha_node)
  health_monitors = __builtin__.property(_get_health_monitors, _set_health_monitors)
  certificates = __builtin__.property(_get_certificates, _set_certificates)
  partitions = __builtin__.property(_get_partitions, _set_partitions)
  linecard = __builtin__.property(_get_linecard, _set_linecard)
  cspservice_type = __builtin__.property(_get_cspservice_type, _set_cspservice_type)
  csp_ip_url = __builtin__.property(_get_csp_ip_url, _set_csp_ip_url)
  region = __builtin__.property(_get_region)
  configurations = __builtin__.property(_get_configurations, _set_configurations)
  subnets = __builtin__.property(_get_subnets, _set_subnets)
  tenants = __builtin__.property(_get_tenants, _set_tenants)
  keystone_ip = __builtin__.property(_get_keystone_ip, _set_keystone_ip)
  capacities = __builtin__.property(_get_capacities, _set_capacities)
  l2_neighbors = __builtin__.property(_get_l2_neighbors, _set_l2_neighbors)


  _pyangbind_elements = collections.OrderedDict([('id', id), ('management_mode', management_mode), ('status', status), ('name', name), ('mgmt_ip_address', mgmt_ip_address), ('fqdn_name', fqdn_name), ('credential_set', credential_set), ('derived_credential_set', derived_credential_set), ('device_type', device_type), ('os_version', os_version), ('platform', platform), ('description', description), ('driver_name', driver_name), ('hardware_throughput', hardware_throughput), ('dns_name', dns_name), ('rma', rma), ('num_vms', num_vms), ('num_nics', num_nics), ('num_cpus', num_cpus), ('cpu_mhz', cpu_mhz), ('is_module', is_module), ('chassis', chassis), ('model', model), ('memory', memory), ('processor', processor), ('port_channel', port_channel), ('num_sockets', num_sockets), ('subscribed_to_snmp_traps', subscribed_to_snmp_traps), ('subscribed_to_syslog', subscribed_to_syslog), ('vem_module_num', vem_module_num), ('stale_entry', stale_entry), ('pair_mgmt_ip_address', pair_mgmt_ip_address), ('vmstatus', vmstatus), ('device_family_string', device_family_string), ('ostype_string', ostype_string), ('vendor_string', vendor_string), ('serial_number', serial_number), ('sys_descr', sys_descr), ('sys_object_id', sys_object_id), ('sys_location', sys_location), ('sys_up_time', sys_up_time), ('mgmt_vrf_name', mgmt_vrf_name), ('manage_by_management_station', manage_by_management_station), ('management_station', management_station), ('managed_devices', managed_devices), ('vm_name', vm_name), ('cluster_ip_address', cluster_ip_address), ('device_capability', device_capability), ('unmanaged_device_capability', unmanaged_device_capability), ('virtual_appliance_image', virtual_appliance_image), ('agent_id', agent_id), ('priv_status', priv_status), ('reconciliation', reconciliation), ('unique_name', unique_name), ('service_provisioning_status', service_provisioning_status), ('location_properties', location_properties), ('violations', violations), ('compliance_status', compliance_status), ('compliances', compliances), ('interfaces', interfaces), ('interface_ranges', interface_ranges), ('vlans', vlans), ('vlan_groups', vlan_groups), ('vn_services', vn_services), ('vn_paths', vn_paths), ('port_groups', port_groups), ('port_channels', port_channels), ('route_policies', route_policies), ('rib_groups', rib_groups), ('vrfs', vrfs), ('community_lists', community_lists), ('extcommunity_lists', extcommunity_lists), ('ip_sla', ip_sla), ('ip_sla_schedules', ip_sla_schedules), ('ip_nat_pool', ip_nat_pool), ('ip_nat', ip_nat), ('tracks', tracks), ('prefix_sets', prefix_sets), ('bgp_as', bgp_as), ('as_path_acls', as_path_acls), ('route_maps', route_maps), ('eigrp', eigrp), ('policy_options', policy_options), ('dhcp_server', dhcp_server), ('CaTrustPointCertificate', CaTrustPointCertificate), ('ip_prefixlist_list', ip_prefixlist_list), ('vpls_list', vpls_list), ('eem_script', eem_script), ('eem_applets', eem_applets), ('netflow', netflow), ('bridge', bridge), ('key_chain', key_chain), ('static_routes', static_routes), ('routes', routes), ('snmp', snmp), ('ntp', ntp), ('username', username), ('clock', clock), ('banner', banner), ('http', http), ('service_time_stamps', service_time_stamps), ('ha', ha), ('local_credentials', local_credentials), ('ssh', ssh), ('logging', logging), ('aaa_root', aaa_root), ('aaa_group', aaa_group), ('call_home', call_home), ('tacacs_conf', tacacs_conf), ('tftp', tftp), ('license', license), ('hostname', hostname), ('vty_configs', vty_configs), ('console', console), ('auxiliary_port', auxiliary_port), ('features', features), ('spanning_tree', spanning_tree), ('error_disable_recovery', error_disable_recovery), ('bfd', bfd), ('ip_arp', ip_arp), ('mac_table', mac_table), ('service_unsupported', service_unsupported), ('jumbo_mtu', jumbo_mtu), ('bgp', bgp), ('interface_breakout', interface_breakout), ('event_manager', event_manager), ('shell_options', shell_options), ('crypto', crypto), ('crypto_policies', crypto_policies), ('crypto_proposals', crypto_proposals), ('crypto_keyrings', crypto_keyrings), ('transform_sets', transform_sets), ('ipsec_profiles', ipsec_profiles), ('dmvpntunnels', dmvpntunnels), ('domain', domain), ('dns_server', dns_server), ('a_records', a_records), ('host_records', host_records), ('dns_zones', dns_zones), ('resource_records', resource_records), ('access_lists', access_lists), ('number_access_lists', number_access_lists), ('object_groups_acl', object_groups_acl), ('interface_access_lists', interface_access_lists), ('security_rules', security_rules), ('svclcs', svclcs), ('virtual_devices', virtual_devices), ('zones', zones), ('policers', policers), ('applications', applications), ('applicationsets', applicationsets), ('addressbooks', addressbooks), ('dnsproxies', dnsproxies), ('dhcppools', dhcppools), ('object_groups', object_groups), ('fw_users', fw_users), ('fw_user_groups', fw_user_groups), ('addresses', addresses), ('address_sets', address_sets), ('address_entries', address_entries), ('address_groups', address_groups), ('services', services), ('service_groups', service_groups), ('templates', templates), ('ips_sensors', ips_sensors), ('ipsec_tunnels', ipsec_tunnels), ('network_objects', network_objects), ('failover_groups', failover_groups), ('vdom_links', vdom_links), ('modules', modules), ('wanop', wanop), ('inpath_config', inpath_config), ('network_proxy', network_proxy), ('label_configuration', label_configuration), ('wanop_applications', wanop_applications), ('inpath_rules', inpath_rules), ('domain_lists', domain_lists), ('optimization_services', optimization_services), ('network_services', network_services), ('general_services', general_services), ('protocols', protocols), ('secure_peering', secure_peering), ('class_maps', class_maps), ('policy_maps', policy_maps), ('system_qos', system_qos), ('pfr_classes', pfr_classes), ('pfr_policy_maps', pfr_policy_maps), ('qos_scheduler_policies', qos_scheduler_policies), ('qos_group_templates', qos_group_templates), ('vpls', vpls), ('lb_domains', lb_domains), ('self_ips', self_ips), ('contexts', contexts), ('real_servers', real_servers), ('rservice_pools', rservice_pools), ('virtual_servers', virtual_servers), ('snat_pools', snat_pools), ('lb_routes', lb_routes), ('lb_ha_node', lb_ha_node), ('health_monitors', health_monitors), ('certificates', certificates), ('partitions', partitions), ('linecard', linecard), ('cspservice_type', cspservice_type), ('csp_ip_url', csp_ip_url), ('region', region), ('configurations', configurations), ('subnets', subnets), ('tenants', tenants), ('keystone_ip', keystone_ip), ('capacities', capacities), ('l2_neighbors', l2_neighbors), ])


