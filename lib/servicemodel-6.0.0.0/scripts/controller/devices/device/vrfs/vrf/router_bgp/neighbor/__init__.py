
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/vrfs/vrf/router-bgp/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__ip_address','__ipv6_address','__netmask','__local_interface','__route_limit','__neighbor_tag','__shut','__peer_group','__inbound_routepolicy','__outbound_routepolicy','__group','__auth_key','__type','__route_map','__route_map_type','__advertise_community','__advertise_ext_community','__bfd','__remote_as','__as_override','__next_hop_self','__soft_reconfiguration','__encryption','__password','__route_reflector_client','__next_hop_unchanged','__default_originate','__def_originate_route_map','__weight','__allowas_in','__allowas_in_value','__maximum_prefix','__in_route_map','__out_route_map','__ebgp_multihop','__keepalive_interval','__holdtime','__advertisement_interval','__description','__local_as_number','__send_community',)

  _yang_name = 'neighbor'
  _module_name = 'l3features'
  _namespace = 'http://anutanetworks.com/l3features'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv6-address', is_config=True)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    self.__local_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__in_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__out_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__allowas_in_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    self.__route_reflector_client = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__outbound_routepolicy = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__as_override = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__next_hop_unchanged = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__soft_reconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__group = YANGDynClass(base=unicode, is_leaf=True, yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__encryption = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)
    self.__bfd = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bfd", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__route_map_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}, u'in': {}},), is_leaf=True, yang_name="route-map-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='route-type', is_config=True)
    self.__allowas_in = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__peer_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__maximum_prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'internal': {}, u'external': {}},), is_leaf=True, yang_name="type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='neighbor-type', is_config=True)
    self.__advertise_ext_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-ext-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__advertise_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__shut = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shut", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__inbound_routepolicy = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    self.__netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__next_hop_self = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__password = YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv4-address', is_config=True)
    self.__local_as_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    self.__keepalive_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    self.__neighbor_tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="neighbor-tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__def_originate_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__auth_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="auth-key", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__route_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__send_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__remote_as = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    self.__holdtime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'vrfs', u'vrf', u'router-bgp', u'neighbor']

  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/ip_address (inet:ipv4-address)

    YANG Description: Valid IPv4 Address (A.B.C.D for e.x: 172.16.1.1)
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/ip_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: Valid IPv4 Address (A.B.C.D for e.x: 172.16.1.1)
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv4-address', is_config=True)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/ipv6_address (inet:ipv6-address)

    YANG Description: Valid IPv6 Address (X::Y for e.x: 2001::1)
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/ipv6_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: Valid IPv6 Address (X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ipv6-address', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/netmask (string)

    YANG Description: string
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/netmask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="netmask", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_local_interface(self):
    """
    Getter method for local_interface, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/local_interface (leafref)

    YANG Description: local-interface
    """
    return self.__local_interface
      
  def _set_local_interface(self, v, load=False):
    """
    Setter method for local_interface, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/local_interface (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface() directly.

    YANG Description: local-interface
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__local_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface(self):
    self.__local_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_route_limit(self):
    """
    Getter method for route_limit, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_limit (uint32)

    YANG Description: 0..4294967295
    """
    return self.__route_limit
      
  def _set_route_limit(self, v, load=False):
    """
    Setter method for route_limit, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_limit() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__route_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_limit(self):
    self.__route_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_neighbor_tag(self):
    """
    Getter method for neighbor_tag, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/neighbor_tag (string)

    YANG Description: string
    """
    return self.__neighbor_tag
      
  def _set_neighbor_tag(self, v, load=False):
    """
    Setter method for neighbor_tag, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/neighbor_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_tag() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="neighbor-tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="neighbor-tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__neighbor_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_tag(self):
    self.__neighbor_tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="neighbor-tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_shut(self):
    """
    Getter method for shut, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/shut (boolean)

    YANG Description: shut: True/False
    """
    return self.__shut
      
  def _set_shut(self, v, load=False):
    """
    Setter method for shut, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/shut (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shut is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shut() directly.

    YANG Description: shut: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="shut", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shut must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shut", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__shut = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shut(self):
    self.__shut = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shut", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_peer_group(self):
    """
    Getter method for peer_group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/peer_group (string)

    YANG Description: string
    """
    return self.__peer_group
      
  def _set_peer_group(self, v, load=False):
    """
    Setter method for peer_group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/peer_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__peer_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group(self):
    self.__peer_group = YANGDynClass(base=unicode, is_leaf=True, yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_inbound_routepolicy(self):
    """
    Getter method for inbound_routepolicy, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/inbound_routepolicy (string)

    YANG Description: string
    """
    return self.__inbound_routepolicy
      
  def _set_inbound_routepolicy(self, v, load=False):
    """
    Setter method for inbound_routepolicy, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/inbound_routepolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inbound_routepolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inbound_routepolicy() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inbound_routepolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__inbound_routepolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inbound_routepolicy(self):
    self.__inbound_routepolicy = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_outbound_routepolicy(self):
    """
    Getter method for outbound_routepolicy, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/outbound_routepolicy (string)

    YANG Description: string
    """
    return self.__outbound_routepolicy
      
  def _set_outbound_routepolicy(self, v, load=False):
    """
    Setter method for outbound_routepolicy, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/outbound_routepolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outbound_routepolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outbound_routepolicy() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="outbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outbound_routepolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__outbound_routepolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outbound_routepolicy(self):
    self.__outbound_routepolicy = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-routepolicy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/group (leafref)

    YANG Description: group
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/group (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.

    YANG Description: group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=unicode, is_leaf=True, yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_auth_key(self):
    """
    Getter method for auth_key, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/auth_key (string)

    YANG Description: string
    """
    return self.__auth_key
      
  def _set_auth_key(self, v, load=False):
    """
    Setter method for auth_key, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/auth_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_key() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="auth-key", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="auth-key", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__auth_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_key(self):
    self.__auth_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="auth-key", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/type (neighbor-type)

    YANG Description: internal
external

    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/type (neighbor-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: internal
external

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'internal': {}, u'external': {}},), is_leaf=True, yang_name="type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='neighbor-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with neighbor-type""",
          'defined-type': "l3features:neighbor-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'internal': {}, u'external': {}},), is_leaf=True, yang_name="type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='neighbor-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'internal': {}, u'external': {}},), is_leaf=True, yang_name="type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='neighbor-type', is_config=True)


  def _get_route_map(self):
    """
    Getter method for route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_map (leafref)

    YANG Description: route-map
    """
    return self.__route_map
      
  def _set_route_map(self, v, load=False):
    """
    Setter method for route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_map() directly.

    YANG Description: route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_map(self):
    self.__route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_route_map_type(self):
    """
    Getter method for route_map_type, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_map_type (route-type)

    YANG Description: in
out

    """
    return self.__route_map_type
      
  def _set_route_map_type(self, v, load=False):
    """
    Setter method for route_map_type, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_map_type (route-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_map_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_map_type() directly.

    YANG Description: in
out

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}, u'in': {}},), is_leaf=True, yang_name="route-map-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='route-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_map_type must be of a type compatible with route-type""",
          'defined-type': "l3features:route-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}, u'in': {}},), is_leaf=True, yang_name="route-map-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='route-type', is_config=True)""",
        })

    self.__route_map_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_map_type(self):
    self.__route_map_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}, u'in': {}},), is_leaf=True, yang_name="route-map-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='route-type', is_config=True)


  def _get_advertise_community(self):
    """
    Getter method for advertise_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/advertise_community (boolean)

    YANG Description: advertise-community: True/False
    """
    return self.__advertise_community
      
  def _set_advertise_community(self, v, load=False):
    """
    Setter method for advertise_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/advertise_community (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_community() directly.

    YANG Description: advertise-community: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_community must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_community(self):
    self.__advertise_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_advertise_ext_community(self):
    """
    Getter method for advertise_ext_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/advertise_ext_community (boolean)

    YANG Description: advertise-ext-community: True/False
    """
    return self.__advertise_ext_community
      
  def _set_advertise_ext_community(self, v, load=False):
    """
    Setter method for advertise_ext_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/advertise_ext_community (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_ext_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_ext_community() directly.

    YANG Description: advertise-ext-community: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertise-ext-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_ext_community must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-ext-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_ext_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_ext_community(self):
    self.__advertise_ext_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertise-ext-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/bfd (boolean)

    YANG Description: bfd: True/False
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/bfd (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: bfd: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bfd", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bfd", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bfd", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_remote_as(self):
    """
    Getter method for remote_as, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/remote_as (as-number)

    YANG Description: string
    """
    return self.__remote_as
      
  def _set_remote_as(self, v, load=False):
    """
    Setter method for remote_as, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/remote_as (as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_as() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_as must be of a type compatible with as-number""",
          'defined-type': "l3features:as-number",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)""",
        })

    self.__remote_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_as(self):
    self.__remote_as = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)


  def _get_as_override(self):
    """
    Getter method for as_override, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/as_override (boolean)

    YANG Description: as-override: True/False
    """
    return self.__as_override
      
  def _set_as_override(self, v, load=False):
    """
    Setter method for as_override, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/as_override (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_override is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_override() directly.

    YANG Description: as-override: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_override must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__as_override = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_override(self):
    self.__as_override = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_next_hop_self(self):
    """
    Getter method for next_hop_self, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/next_hop_self (boolean)

    YANG Description: next-hop-self: True/False
    """
    return self.__next_hop_self
      
  def _set_next_hop_self(self, v, load=False):
    """
    Setter method for next_hop_self, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/next_hop_self (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_self is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_self() directly.

    YANG Description: next-hop-self: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_self must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__next_hop_self = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_self(self):
    self.__next_hop_self = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_soft_reconfiguration(self):
    """
    Getter method for soft_reconfiguration, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/soft_reconfiguration (boolean)

    YANG Description: soft-reconfiguration: True/False
    """
    return self.__soft_reconfiguration
      
  def _set_soft_reconfiguration(self, v, load=False):
    """
    Setter method for soft_reconfiguration, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/soft_reconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_reconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_reconfiguration() directly.

    YANG Description: soft-reconfiguration: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_reconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__soft_reconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_reconfiguration(self):
    self.__soft_reconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_encryption(self):
    """
    Getter method for encryption, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/encryption (boolean)

    YANG Description: encryption: True/False
    """
    return self.__encryption
      
  def _set_encryption(self, v, load=False):
    """
    Setter method for encryption, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/encryption (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption() directly.

    YANG Description: encryption: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption(self):
    self.__encryption = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/password (string)

    YANG Description: string
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_route_reflector_client(self):
    """
    Getter method for route_reflector_client, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_reflector_client (boolean)

    YANG Description: route-reflector-client: True/False
    """
    return self.__route_reflector_client
      
  def _set_route_reflector_client(self, v, load=False):
    """
    Setter method for route_reflector_client, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/route_reflector_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_client() directly.

    YANG Description: route-reflector-client: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__route_reflector_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_client(self):
    self.__route_reflector_client = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_next_hop_unchanged(self):
    """
    Getter method for next_hop_unchanged, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/next_hop_unchanged (boolean)

    YANG Description: next-hop-unchanged: True/False
    """
    return self.__next_hop_unchanged
      
  def _set_next_hop_unchanged(self, v, load=False):
    """
    Setter method for next_hop_unchanged, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/next_hop_unchanged (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_unchanged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_unchanged() directly.

    YANG Description: next-hop-unchanged: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_unchanged must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__next_hop_unchanged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_unchanged(self):
    self.__next_hop_unchanged = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_default_originate(self):
    """
    Getter method for default_originate, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/default_originate (boolean)

    YANG Description: default-originate: True/False
    """
    return self.__default_originate
      
  def _set_default_originate(self, v, load=False):
    """
    Setter method for default_originate, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/default_originate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_originate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_originate() directly.

    YANG Description: default-originate: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_originate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__default_originate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_originate(self):
    self.__default_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_def_originate_route_map(self):
    """
    Getter method for def_originate_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/def_originate_route_map (leafref)

    YANG Description: def-originate-route-map
    """
    return self.__def_originate_route_map
      
  def _set_def_originate_route_map(self, v, load=False):
    """
    Setter method for def_originate_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/def_originate_route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_def_originate_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_def_originate_route_map() directly.

    YANG Description: def-originate-route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """def_originate_route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__def_originate_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_def_originate_route_map(self):
    self.__def_originate_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/weight (timer-range)

    YANG Description: 0..65535
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/weight (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_allowas_in(self):
    """
    Getter method for allowas_in, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/allowas_in (boolean)

    YANG Description: allowas-in: True/False
    """
    return self.__allowas_in
      
  def _set_allowas_in(self, v, load=False):
    """
    Setter method for allowas_in, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/allowas_in (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowas_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowas_in() directly.

    YANG Description: allowas-in: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowas_in must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__allowas_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowas_in(self):
    self.__allowas_in = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_allowas_in_value(self):
    """
    Getter method for allowas_in_value, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/allowas_in_value (uint8)

    YANG Description: 0..10
    """
    return self.__allowas_in_value
      
  def _set_allowas_in_value(self, v, load=False):
    """
    Setter method for allowas_in_value, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/allowas_in_value (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowas_in_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowas_in_value() directly.

    YANG Description: 0..10
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowas_in_value must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)""",
        })

    self.__allowas_in_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowas_in_value(self):
    self.__allowas_in_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)


  def _get_maximum_prefix(self):
    """
    Getter method for maximum_prefix, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/maximum_prefix (maximum-prefix-range)

    YANG Description: 1..2147483647
    """
    return self.__maximum_prefix
      
  def _set_maximum_prefix(self, v, load=False):
    """
    Setter method for maximum_prefix, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/maximum_prefix (maximum-prefix-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_prefix() directly.

    YANG Description: 1..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_prefix must be of a type compatible with maximum-prefix-range""",
          'defined-type': "l3features:maximum-prefix-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)""",
        })

    self.__maximum_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_prefix(self):
    self.__maximum_prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)


  def _get_in_route_map(self):
    """
    Getter method for in_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/in_route_map (leafref)

    YANG Description: in-route-map
    """
    return self.__in_route_map
      
  def _set_in_route_map(self, v, load=False):
    """
    Setter method for in_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/in_route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_route_map() directly.

    YANG Description: in-route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__in_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_route_map(self):
    self.__in_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_out_route_map(self):
    """
    Getter method for out_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/out_route_map (leafref)

    YANG Description: out-route-map
    """
    return self.__out_route_map
      
  def _set_out_route_map(self, v, load=False):
    """
    Setter method for out_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/out_route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_route_map() directly.

    YANG Description: out-route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__out_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_route_map(self):
    self.__out_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/ebgp_multihop (ebgp-multihop-range)

    YANG Description: 1..255
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/ebgp_multihop (ebgp-multihop-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: 1..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with ebgp-multihop-range""",
          'defined-type': "l3features:ebgp-multihop-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)


  def _get_keepalive_interval(self):
    """
    Getter method for keepalive_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/keepalive_interval (timer-range)

    YANG Description: 0..65535
    """
    return self.__keepalive_interval
      
  def _set_keepalive_interval(self, v, load=False):
    """
    Setter method for keepalive_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/keepalive_interval (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepalive_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepalive_interval() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepalive_interval must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__keepalive_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepalive_interval(self):
    self.__keepalive_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_holdtime(self):
    """
    Getter method for holdtime, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/holdtime (timer-range)

    YANG Description: 0..65535
    """
    return self.__holdtime
      
  def _set_holdtime(self, v, load=False):
    """
    Setter method for holdtime, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/holdtime (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdtime() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdtime must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdtime(self):
    self.__holdtime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/advertisement_interval (timer-range)

    YANG Description: 0..65535
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/advertisement_interval (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_local_as_number(self):
    """
    Getter method for local_as_number, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/local_as_number (as-number)

    YANG Description: string
    """
    return self.__local_as_number
      
  def _set_local_as_number(self, v, load=False):
    """
    Setter method for local_as_number, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/local_as_number (as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_as_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_as_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_as_number must be of a type compatible with as-number""",
          'defined-type': "l3features:as-number",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)""",
        })

    self.__local_as_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_as_number(self):
    self.__local_as_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)


  def _get_send_community(self):
    """
    Getter method for send_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/send_community (boolean)

    YANG Description: send-community: True/False
    """
    return self.__send_community
      
  def _set_send_community(self, v, load=False):
    """
    Setter method for send_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor/send_community (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_community() directly.

    YANG Description: send-community: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_community must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__send_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_community(self):
    self.__send_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)

  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  ipv6_address = __builtin__.property(_get_ipv6_address, _set_ipv6_address)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  local_interface = __builtin__.property(_get_local_interface, _set_local_interface)
  route_limit = __builtin__.property(_get_route_limit, _set_route_limit)
  neighbor_tag = __builtin__.property(_get_neighbor_tag, _set_neighbor_tag)
  shut = __builtin__.property(_get_shut, _set_shut)
  peer_group = __builtin__.property(_get_peer_group, _set_peer_group)
  inbound_routepolicy = __builtin__.property(_get_inbound_routepolicy, _set_inbound_routepolicy)
  outbound_routepolicy = __builtin__.property(_get_outbound_routepolicy, _set_outbound_routepolicy)
  group = __builtin__.property(_get_group, _set_group)
  auth_key = __builtin__.property(_get_auth_key, _set_auth_key)
  type = __builtin__.property(_get_type, _set_type)
  route_map = __builtin__.property(_get_route_map, _set_route_map)
  route_map_type = __builtin__.property(_get_route_map_type, _set_route_map_type)
  advertise_community = __builtin__.property(_get_advertise_community, _set_advertise_community)
  advertise_ext_community = __builtin__.property(_get_advertise_ext_community, _set_advertise_ext_community)
  bfd = __builtin__.property(_get_bfd, _set_bfd)
  remote_as = __builtin__.property(_get_remote_as, _set_remote_as)
  as_override = __builtin__.property(_get_as_override, _set_as_override)
  next_hop_self = __builtin__.property(_get_next_hop_self, _set_next_hop_self)
  soft_reconfiguration = __builtin__.property(_get_soft_reconfiguration, _set_soft_reconfiguration)
  encryption = __builtin__.property(_get_encryption, _set_encryption)
  password = __builtin__.property(_get_password, _set_password)
  route_reflector_client = __builtin__.property(_get_route_reflector_client, _set_route_reflector_client)
  next_hop_unchanged = __builtin__.property(_get_next_hop_unchanged, _set_next_hop_unchanged)
  default_originate = __builtin__.property(_get_default_originate, _set_default_originate)
  def_originate_route_map = __builtin__.property(_get_def_originate_route_map, _set_def_originate_route_map)
  weight = __builtin__.property(_get_weight, _set_weight)
  allowas_in = __builtin__.property(_get_allowas_in, _set_allowas_in)
  allowas_in_value = __builtin__.property(_get_allowas_in_value, _set_allowas_in_value)
  maximum_prefix = __builtin__.property(_get_maximum_prefix, _set_maximum_prefix)
  in_route_map = __builtin__.property(_get_in_route_map, _set_in_route_map)
  out_route_map = __builtin__.property(_get_out_route_map, _set_out_route_map)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  keepalive_interval = __builtin__.property(_get_keepalive_interval, _set_keepalive_interval)
  holdtime = __builtin__.property(_get_holdtime, _set_holdtime)
  advertisement_interval = __builtin__.property(_get_advertisement_interval, _set_advertisement_interval)
  description = __builtin__.property(_get_description, _set_description)
  local_as_number = __builtin__.property(_get_local_as_number, _set_local_as_number)
  send_community = __builtin__.property(_get_send_community, _set_send_community)


  _pyangbind_elements = collections.OrderedDict([('ip_address', ip_address), ('ipv6_address', ipv6_address), ('netmask', netmask), ('local_interface', local_interface), ('route_limit', route_limit), ('neighbor_tag', neighbor_tag), ('shut', shut), ('peer_group', peer_group), ('inbound_routepolicy', inbound_routepolicy), ('outbound_routepolicy', outbound_routepolicy), ('group', group), ('auth_key', auth_key), ('type', type), ('route_map', route_map), ('route_map_type', route_map_type), ('advertise_community', advertise_community), ('advertise_ext_community', advertise_ext_community), ('bfd', bfd), ('remote_as', remote_as), ('as_override', as_override), ('next_hop_self', next_hop_self), ('soft_reconfiguration', soft_reconfiguration), ('encryption', encryption), ('password', password), ('route_reflector_client', route_reflector_client), ('next_hop_unchanged', next_hop_unchanged), ('default_originate', default_originate), ('def_originate_route_map', def_originate_route_map), ('weight', weight), ('allowas_in', allowas_in), ('allowas_in_value', allowas_in_value), ('maximum_prefix', maximum_prefix), ('in_route_map', in_route_map), ('out_route_map', out_route_map), ('ebgp_multihop', ebgp_multihop), ('keepalive_interval', keepalive_interval), ('holdtime', holdtime), ('advertisement_interval', advertisement_interval), ('description', description), ('local_as_number', local_as_number), ('send_community', send_community), ])


