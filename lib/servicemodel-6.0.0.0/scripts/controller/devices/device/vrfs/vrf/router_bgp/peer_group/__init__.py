
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/vrfs/vrf/router-bgp/peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__cidr','__remote_as','__as_override','__next_hop_self','__soft_reconfiguration','__encryption','__password','__route_reflector_client','__next_hop_unchanged','__default_originate','__def_originate_route_map','__weight','__allowas_in','__allowas_in_value','__maximum_prefix','__in_route_map','__out_route_map','__ebgp_multihop','__keepalive_interval','__holdtime','__advertisement_interval','__description','__local_as_number','__send_community','__local_interface',)

  _yang_name = 'peer-group'
  _module_name = 'l3features'
  _namespace = 'http://anutanetworks.com/l3features'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__default_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    self.__local_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__in_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__out_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__allowas_in_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    self.__route_reflector_client = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__as_override = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__next_hop_unchanged = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__soft_reconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__remote_as = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)
    self.__encryption = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__allowas_in = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__next_hop_self = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__cidr = YANGDynClass(base=unicode, is_leaf=True, yang_name="cidr", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=False)
    self.__password = YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__local_as_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    self.__keepalive_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    self.__def_originate_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__maximum_prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)
    self.__send_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__holdtime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'vrfs', u'vrf', u'router-bgp', u'peer-group']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_cidr(self):
    """
    Getter method for cidr, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/cidr (string)

    YANG Description: A.B.C.D/nn  Subnet range <network>/<length>, e.g., 10.0.0.0/24
    """
    return self.__cidr
      
  def _set_cidr(self, v, load=False):
    """
    Setter method for cidr, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/cidr (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cidr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cidr() directly.

    YANG Description: A.B.C.D/nn  Subnet range <network>/<length>, e.g., 10.0.0.0/24
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cidr", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cidr must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cidr", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=False)""",
        })

    self.__cidr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cidr(self):
    self.__cidr = YANGDynClass(base=unicode, is_leaf=True, yang_name="cidr", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=False)


  def _get_remote_as(self):
    """
    Getter method for remote_as, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/remote_as (as-number)

    YANG Description: string
    """
    return self.__remote_as
      
  def _set_remote_as(self, v, load=False):
    """
    Setter method for remote_as, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/remote_as (as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_as() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_as must be of a type compatible with as-number""",
          'defined-type': "l3features:as-number",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)""",
        })

    self.__remote_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_as(self):
    self.__remote_as = YANGDynClass(base=unicode, is_leaf=True, yang_name="remote-as", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)


  def _get_as_override(self):
    """
    Getter method for as_override, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/as_override (boolean)

    YANG Description: as-override: True/False
    """
    return self.__as_override
      
  def _set_as_override(self, v, load=False):
    """
    Setter method for as_override, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/as_override (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_override is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_override() directly.

    YANG Description: as-override: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_override must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__as_override = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_override(self):
    self.__as_override = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="as-override", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_next_hop_self(self):
    """
    Getter method for next_hop_self, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/next_hop_self (boolean)

    YANG Description: next-hop-self: True/False
    """
    return self.__next_hop_self
      
  def _set_next_hop_self(self, v, load=False):
    """
    Setter method for next_hop_self, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/next_hop_self (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_self is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_self() directly.

    YANG Description: next-hop-self: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_self must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__next_hop_self = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_self(self):
    self.__next_hop_self = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-self", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_soft_reconfiguration(self):
    """
    Getter method for soft_reconfiguration, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/soft_reconfiguration (boolean)

    YANG Description: soft-reconfiguration: True/False
    """
    return self.__soft_reconfiguration
      
  def _set_soft_reconfiguration(self, v, load=False):
    """
    Setter method for soft_reconfiguration, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/soft_reconfiguration (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_reconfiguration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_reconfiguration() directly.

    YANG Description: soft-reconfiguration: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_reconfiguration must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__soft_reconfiguration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_reconfiguration(self):
    self.__soft_reconfiguration = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="soft-reconfiguration", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_encryption(self):
    """
    Getter method for encryption, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/encryption (boolean)

    YANG Description: encryption: True/False
    """
    return self.__encryption
      
  def _set_encryption(self, v, load=False):
    """
    Setter method for encryption, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/encryption (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption() directly.

    YANG Description: encryption: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption(self):
    self.__encryption = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="encryption", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/password (string)

    YANG Description: string
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_route_reflector_client(self):
    """
    Getter method for route_reflector_client, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/route_reflector_client (boolean)

    YANG Description: route-reflector-client: True/False
    """
    return self.__route_reflector_client
      
  def _set_route_reflector_client(self, v, load=False):
    """
    Setter method for route_reflector_client, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/route_reflector_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_client() directly.

    YANG Description: route-reflector-client: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__route_reflector_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_client(self):
    self.__route_reflector_client = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="route-reflector-client", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_next_hop_unchanged(self):
    """
    Getter method for next_hop_unchanged, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/next_hop_unchanged (boolean)

    YANG Description: next-hop-unchanged: True/False
    """
    return self.__next_hop_unchanged
      
  def _set_next_hop_unchanged(self, v, load=False):
    """
    Setter method for next_hop_unchanged, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/next_hop_unchanged (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_unchanged is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_unchanged() directly.

    YANG Description: next-hop-unchanged: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_unchanged must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__next_hop_unchanged = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_unchanged(self):
    self.__next_hop_unchanged = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="next-hop-unchanged", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_default_originate(self):
    """
    Getter method for default_originate, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/default_originate (boolean)

    YANG Description: default-originate: True/False
    """
    return self.__default_originate
      
  def _set_default_originate(self, v, load=False):
    """
    Setter method for default_originate, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/default_originate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_originate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_originate() directly.

    YANG Description: default-originate: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_originate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__default_originate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_originate(self):
    self.__default_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_def_originate_route_map(self):
    """
    Getter method for def_originate_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/def_originate_route_map (leafref)

    YANG Description: def-originate-route-map
    """
    return self.__def_originate_route_map
      
  def _set_def_originate_route_map(self, v, load=False):
    """
    Setter method for def_originate_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/def_originate_route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_def_originate_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_def_originate_route_map() directly.

    YANG Description: def-originate-route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """def_originate_route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__def_originate_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_def_originate_route_map(self):
    self.__def_originate_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="def-originate-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/weight (timer-range)

    YANG Description: 0..65535
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/weight (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="weight", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_allowas_in(self):
    """
    Getter method for allowas_in, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/allowas_in (boolean)

    YANG Description: allowas-in: True/False
    """
    return self.__allowas_in
      
  def _set_allowas_in(self, v, load=False):
    """
    Setter method for allowas_in, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/allowas_in (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowas_in is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowas_in() directly.

    YANG Description: allowas-in: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowas_in must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__allowas_in = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowas_in(self):
    self.__allowas_in = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="allowas-in", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_allowas_in_value(self):
    """
    Getter method for allowas_in_value, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/allowas_in_value (uint8)

    YANG Description: 0..10
    """
    return self.__allowas_in_value
      
  def _set_allowas_in_value(self, v, load=False):
    """
    Setter method for allowas_in_value, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/allowas_in_value (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowas_in_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowas_in_value() directly.

    YANG Description: 0..10
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowas_in_value must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)""",
        })

    self.__allowas_in_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowas_in_value(self):
    self.__allowas_in_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..10']}), is_leaf=True, yang_name="allowas_in_value", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)


  def _get_maximum_prefix(self):
    """
    Getter method for maximum_prefix, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/maximum_prefix (maximum-prefix-range)

    YANG Description: 1..2147483647
    """
    return self.__maximum_prefix
      
  def _set_maximum_prefix(self, v, load=False):
    """
    Setter method for maximum_prefix, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/maximum_prefix (maximum-prefix-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_prefix() directly.

    YANG Description: 1..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_prefix must be of a type compatible with maximum-prefix-range""",
          'defined-type': "l3features:maximum-prefix-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)""",
        })

    self.__maximum_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_prefix(self):
    self.__maximum_prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="maximum-prefix", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-prefix-range', is_config=True)


  def _get_in_route_map(self):
    """
    Getter method for in_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/in_route_map (leafref)

    YANG Description: in-route-map
    """
    return self.__in_route_map
      
  def _set_in_route_map(self, v, load=False):
    """
    Setter method for in_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/in_route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_route_map() directly.

    YANG Description: in-route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__in_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_route_map(self):
    self.__in_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="in-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_out_route_map(self):
    """
    Getter method for out_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/out_route_map (leafref)

    YANG Description: out-route-map
    """
    return self.__out_route_map
      
  def _set_out_route_map(self, v, load=False):
    """
    Setter method for out_route_map, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/out_route_map (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_route_map is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_route_map() directly.

    YANG Description: out-route-map
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_route_map must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__out_route_map = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_route_map(self):
    self.__out_route_map = YANGDynClass(base=unicode, is_leaf=True, yang_name="out-route-map", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/ebgp_multihop (ebgp-multihop-range)

    YANG Description: 1..255
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/ebgp_multihop (ebgp-multihop-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: 1..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with ebgp-multihop-range""",
          'defined-type': "l3features:ebgp-multihop-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="ebgp-multihop", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='ebgp-multihop-range', is_config=True)


  def _get_keepalive_interval(self):
    """
    Getter method for keepalive_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/keepalive_interval (timer-range)

    YANG Description: 0..65535
    """
    return self.__keepalive_interval
      
  def _set_keepalive_interval(self, v, load=False):
    """
    Setter method for keepalive_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/keepalive_interval (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepalive_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepalive_interval() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepalive_interval must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__keepalive_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepalive_interval(self):
    self.__keepalive_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="keepalive-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_holdtime(self):
    """
    Getter method for holdtime, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/holdtime (timer-range)

    YANG Description: 0..65535
    """
    return self.__holdtime
      
  def _set_holdtime(self, v, load=False):
    """
    Setter method for holdtime, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/holdtime (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holdtime() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holdtime must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holdtime(self):
    self.__holdtime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="holdtime", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_advertisement_interval(self):
    """
    Getter method for advertisement_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/advertisement_interval (timer-range)

    YANG Description: 0..65535
    """
    return self.__advertisement_interval
      
  def _set_advertisement_interval(self, v, load=False):
    """
    Setter method for advertisement_interval, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/advertisement_interval (timer-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertisement_interval() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertisement_interval must be of a type compatible with timer-range""",
          'defined-type': "l3features:timer-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)""",
        })

    self.__advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertisement_interval(self):
    self.__advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="advertisement-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='timer-range', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_local_as_number(self):
    """
    Getter method for local_as_number, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/local_as_number (as-number)

    YANG Description: string
    """
    return self.__local_as_number
      
  def _set_local_as_number(self, v, load=False):
    """
    Setter method for local_as_number, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/local_as_number (as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_as_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_as_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_as_number must be of a type compatible with as-number""",
          'defined-type': "l3features:as-number",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)""",
        })

    self.__local_as_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_as_number(self):
    self.__local_as_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)


  def _get_send_community(self):
    """
    Getter method for send_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/send_community (boolean)

    YANG Description: send-community: True/False
    """
    return self.__send_community
      
  def _set_send_community(self, v, load=False):
    """
    Setter method for send_community, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/send_community (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_community() directly.

    YANG Description: send-community: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_community must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__send_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_community(self):
    self.__send_community = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="send-community", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_local_interface(self):
    """
    Getter method for local_interface, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/local_interface (string)

    YANG Description: string
    """
    return self.__local_interface
      
  def _set_local_interface(self, v, load=False):
    """
    Setter method for local_interface, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group/local_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_interface() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__local_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_interface(self):
    self.__local_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="local-interface", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  cidr = __builtin__.property(_get_cidr)
  remote_as = __builtin__.property(_get_remote_as, _set_remote_as)
  as_override = __builtin__.property(_get_as_override, _set_as_override)
  next_hop_self = __builtin__.property(_get_next_hop_self, _set_next_hop_self)
  soft_reconfiguration = __builtin__.property(_get_soft_reconfiguration, _set_soft_reconfiguration)
  encryption = __builtin__.property(_get_encryption, _set_encryption)
  password = __builtin__.property(_get_password, _set_password)
  route_reflector_client = __builtin__.property(_get_route_reflector_client, _set_route_reflector_client)
  next_hop_unchanged = __builtin__.property(_get_next_hop_unchanged, _set_next_hop_unchanged)
  default_originate = __builtin__.property(_get_default_originate, _set_default_originate)
  def_originate_route_map = __builtin__.property(_get_def_originate_route_map, _set_def_originate_route_map)
  weight = __builtin__.property(_get_weight, _set_weight)
  allowas_in = __builtin__.property(_get_allowas_in, _set_allowas_in)
  allowas_in_value = __builtin__.property(_get_allowas_in_value, _set_allowas_in_value)
  maximum_prefix = __builtin__.property(_get_maximum_prefix, _set_maximum_prefix)
  in_route_map = __builtin__.property(_get_in_route_map, _set_in_route_map)
  out_route_map = __builtin__.property(_get_out_route_map, _set_out_route_map)
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop)
  keepalive_interval = __builtin__.property(_get_keepalive_interval, _set_keepalive_interval)
  holdtime = __builtin__.property(_get_holdtime, _set_holdtime)
  advertisement_interval = __builtin__.property(_get_advertisement_interval, _set_advertisement_interval)
  description = __builtin__.property(_get_description, _set_description)
  local_as_number = __builtin__.property(_get_local_as_number, _set_local_as_number)
  send_community = __builtin__.property(_get_send_community, _set_send_community)
  local_interface = __builtin__.property(_get_local_interface, _set_local_interface)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('cidr', cidr), ('remote_as', remote_as), ('as_override', as_override), ('next_hop_self', next_hop_self), ('soft_reconfiguration', soft_reconfiguration), ('encryption', encryption), ('password', password), ('route_reflector_client', route_reflector_client), ('next_hop_unchanged', next_hop_unchanged), ('default_originate', default_originate), ('def_originate_route_map', def_originate_route_map), ('weight', weight), ('allowas_in', allowas_in), ('allowas_in_value', allowas_in_value), ('maximum_prefix', maximum_prefix), ('in_route_map', in_route_map), ('out_route_map', out_route_map), ('ebgp_multihop', ebgp_multihop), ('keepalive_interval', keepalive_interval), ('holdtime', holdtime), ('advertisement_interval', advertisement_interval), ('description', description), ('local_as_number', local_as_number), ('send_community', send_community), ('local_interface', local_interface), ])


