
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import listen_range
import peer_group
import neighbor
import aggregate_summary_network
import network
import redistribute
import group
class router_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/vrfs/vrf/router-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__as_number','__router_id','__default_information_originate','__bgp_keepalive_timer','__bgp_holdtime_timer','__address_family','__log_neighbor_changes','__qppb_policy','__trigger_delay','__listen_limit','__maximum_paths','__eroutes','__iroutes','__lroutes','__redistribute_internal','__listen_range','__peer_group','__neighbor','__aggregate_summary_network','__network','__redistribute','__group',)

  _yang_name = 'router-bgp'
  _module_name = 'l3features'
  _namespace = 'http://anutanetworks.com/l3features'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__trigger_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="trigger-delay", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='trigger-delay-range', is_config=True)
    self.__listen_range = YANGDynClass(base=YANGListType("name cidr",listen_range.listen_range, yang_name="listen-range", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name cidr'), is_container='list', yang_name="listen-range", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__aggregate_summary_network = YANGDynClass(base=YANGListType("network",aggregate_summary_network.aggregate_summary_network, yang_name="aggregate-summary-network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network'), is_container='list', yang_name="aggregate-summary-network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__lroutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="lroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)
    self.__group = YANGDynClass(base=YANGListType("name",group.group, yang_name="group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__network = YANGDynClass(base=YANGListType("ip_address",network.network, yang_name="network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__default_information_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-information-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__peer_group = YANGDynClass(base=YANGListType("name",peer_group.peer_group, yang_name="peer-group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__bgp_holdtime_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-holdtime-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__router_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="router-id", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__as_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    self.__listen_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..10000']}), is_leaf=True, yang_name="listen-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='listen-limit-range', is_config=True)
    self.__eroutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="eroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)
    self.__log_neighbor_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-neighbor-changes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'vpnv4': {}, u'ipv4': {}, u'ipv4-vpnv4': {}, u'ipv6': {}},), is_leaf=True, yang_name="address-family", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='address-family', is_config=True)
    self.__redistribute = YANGDynClass(base=YANGListType("protocol",redistribute.redistribute, yang_name="redistribute", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol'), is_container='list', yang_name="redistribute", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__bgp_keepalive_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-keepalive-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..32']}), is_leaf=True, yang_name="maximum-paths", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-paths-range', is_config=True)
    self.__iroutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="iroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)
    self.__neighbor = YANGDynClass(base=YANGListType("ip_address",neighbor.neighbor, yang_name="neighbor", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="neighbor", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    self.__redistribute_internal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="redistribute-internal", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    self.__qppb_policy = YANGDynClass(base=unicode, is_leaf=True, yang_name="qppb-policy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'vrfs', u'vrf', u'router-bgp']

  def _get_as_number(self):
    """
    Getter method for as_number, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/as_number (as-number)

    YANG Description: string
    """
    return self.__as_number
      
  def _set_as_number(self, v, load=False):
    """
    Setter method for as_number, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/as_number (as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_number must be of a type compatible with as-number""",
          'defined-type': "l3features:as-number",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)""",
        })

    self.__as_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_number(self):
    self.__as_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="as-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='as-number', is_config=True)


  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/router_id (string)

    YANG Description: string
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/router_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="router-id", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="router-id", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="router-id", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_default_information_originate(self):
    """
    Getter method for default_information_originate, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/default_information_originate (boolean)

    YANG Description: default-information-originate: True/False
    """
    return self.__default_information_originate
      
  def _set_default_information_originate(self, v, load=False):
    """
    Setter method for default_information_originate, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/default_information_originate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_information_originate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_information_originate() directly.

    YANG Description: default-information-originate: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="default-information-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_information_originate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-information-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__default_information_originate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_information_originate(self):
    self.__default_information_originate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-information-originate", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_bgp_keepalive_timer(self):
    """
    Getter method for bgp_keepalive_timer, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/bgp_keepalive_timer (uint16)

    YANG Description: 0..65535
    """
    return self.__bgp_keepalive_timer
      
  def _set_bgp_keepalive_timer(self, v, load=False):
    """
    Setter method for bgp_keepalive_timer, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/bgp_keepalive_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_keepalive_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_keepalive_timer() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-keepalive-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_keepalive_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-keepalive-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__bgp_keepalive_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_keepalive_timer(self):
    self.__bgp_keepalive_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-keepalive-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_bgp_holdtime_timer(self):
    """
    Getter method for bgp_holdtime_timer, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/bgp_holdtime_timer (uint16)

    YANG Description: 0..65535
    """
    return self.__bgp_holdtime_timer
      
  def _set_bgp_holdtime_timer(self, v, load=False):
    """
    Setter method for bgp_holdtime_timer, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/bgp_holdtime_timer (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_holdtime_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_holdtime_timer() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-holdtime-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_holdtime_timer must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-holdtime-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__bgp_holdtime_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_holdtime_timer(self):
    self.__bgp_holdtime_timer = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="bgp-holdtime-timer", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/address_family (address-family)

    YANG Description: ipv4
ipv6
vpnv4
ipv4-vpnv4

    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/address_family (address-family)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: ipv4
ipv6
vpnv4
ipv4-vpnv4

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'vpnv4': {}, u'ipv4': {}, u'ipv4-vpnv4': {}, u'ipv6': {}},), is_leaf=True, yang_name="address-family", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='address-family', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with address-family""",
          'defined-type': "l3features:address-family",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'vpnv4': {}, u'ipv4': {}, u'ipv4-vpnv4': {}, u'ipv6': {}},), is_leaf=True, yang_name="address-family", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='address-family', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'vpnv4': {}, u'ipv4': {}, u'ipv4-vpnv4': {}, u'ipv6': {}},), is_leaf=True, yang_name="address-family", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='address-family', is_config=True)


  def _get_log_neighbor_changes(self):
    """
    Getter method for log_neighbor_changes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/log_neighbor_changes (boolean)

    YANG Description: log-neighbor-changes: True/False
    """
    return self.__log_neighbor_changes
      
  def _set_log_neighbor_changes(self, v, load=False):
    """
    Setter method for log_neighbor_changes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/log_neighbor_changes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_neighbor_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_neighbor_changes() directly.

    YANG Description: log-neighbor-changes: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="log-neighbor-changes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_neighbor_changes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-neighbor-changes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__log_neighbor_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_neighbor_changes(self):
    self.__log_neighbor_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-neighbor-changes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_qppb_policy(self):
    """
    Getter method for qppb_policy, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/qppb_policy (string)

    YANG Description: string
    """
    return self.__qppb_policy
      
  def _set_qppb_policy(self, v, load=False):
    """
    Setter method for qppb_policy, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/qppb_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qppb_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qppb_policy() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="qppb-policy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qppb_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="qppb-policy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__qppb_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qppb_policy(self):
    self.__qppb_policy = YANGDynClass(base=unicode, is_leaf=True, yang_name="qppb-policy", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_trigger_delay(self):
    """
    Getter method for trigger_delay, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/trigger_delay (trigger-delay-range)

    YANG Description: 0..100
    """
    return self.__trigger_delay
      
  def _set_trigger_delay(self, v, load=False):
    """
    Setter method for trigger_delay, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/trigger_delay (trigger-delay-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trigger_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trigger_delay() directly.

    YANG Description: 0..100
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="trigger-delay", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='trigger-delay-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trigger_delay must be of a type compatible with trigger-delay-range""",
          'defined-type': "l3features:trigger-delay-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="trigger-delay", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='trigger-delay-range', is_config=True)""",
        })

    self.__trigger_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trigger_delay(self):
    self.__trigger_delay = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..100']}), is_leaf=True, yang_name="trigger-delay", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='trigger-delay-range', is_config=True)


  def _get_listen_limit(self):
    """
    Getter method for listen_limit, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/listen_limit (listen-limit-range)

    YANG Description: 1..10000
    """
    return self.__listen_limit
      
  def _set_listen_limit(self, v, load=False):
    """
    Setter method for listen_limit, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/listen_limit (listen-limit-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_listen_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_listen_limit() directly.

    YANG Description: 1..10000
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..10000']}), is_leaf=True, yang_name="listen-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='listen-limit-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """listen_limit must be of a type compatible with listen-limit-range""",
          'defined-type': "l3features:listen-limit-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..10000']}), is_leaf=True, yang_name="listen-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='listen-limit-range', is_config=True)""",
        })

    self.__listen_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_listen_limit(self):
    self.__listen_limit = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..10000']}), is_leaf=True, yang_name="listen-limit", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='listen-limit-range', is_config=True)


  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/maximum_paths (maximum-paths-range)

    YANG Description: 1..32
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/maximum_paths (maximum-paths-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: 1..32
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..32']}), is_leaf=True, yang_name="maximum-paths", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-paths-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with maximum-paths-range""",
          'defined-type': "l3features:maximum-paths-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..32']}), is_leaf=True, yang_name="maximum-paths", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-paths-range', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..32']}), is_leaf=True, yang_name="maximum-paths", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='maximum-paths-range', is_config=True)


  def _get_eroutes(self):
    """
    Getter method for eroutes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/eroutes (bgp-distance-range)

    YANG Description: 1..255
    """
    return self.__eroutes
      
  def _set_eroutes(self, v, load=False):
    """
    Setter method for eroutes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/eroutes (bgp-distance-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eroutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eroutes() directly.

    YANG Description: 1..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="eroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eroutes must be of a type compatible with bgp-distance-range""",
          'defined-type': "l3features:bgp-distance-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="eroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)""",
        })

    self.__eroutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eroutes(self):
    self.__eroutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="eroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)


  def _get_iroutes(self):
    """
    Getter method for iroutes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/iroutes (bgp-distance-range)

    YANG Description: 1..255
    """
    return self.__iroutes
      
  def _set_iroutes(self, v, load=False):
    """
    Setter method for iroutes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/iroutes (bgp-distance-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iroutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iroutes() directly.

    YANG Description: 1..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="iroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iroutes must be of a type compatible with bgp-distance-range""",
          'defined-type': "l3features:bgp-distance-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="iroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)""",
        })

    self.__iroutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iroutes(self):
    self.__iroutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="iroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)


  def _get_lroutes(self):
    """
    Getter method for lroutes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/lroutes (bgp-distance-range)

    YANG Description: 1..255
    """
    return self.__lroutes
      
  def _set_lroutes(self, v, load=False):
    """
    Setter method for lroutes, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/lroutes (bgp-distance-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lroutes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lroutes() directly.

    YANG Description: 1..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="lroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lroutes must be of a type compatible with bgp-distance-range""",
          'defined-type': "l3features:bgp-distance-range",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="lroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)""",
        })

    self.__lroutes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lroutes(self):
    self.__lroutes = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="lroutes", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='bgp-distance-range', is_config=True)


  def _get_redistribute_internal(self):
    """
    Getter method for redistribute_internal, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/redistribute_internal (boolean)

    YANG Description: redistribute-internal: True/False
    """
    return self.__redistribute_internal
      
  def _set_redistribute_internal(self, v, load=False):
    """
    Setter method for redistribute_internal, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/redistribute_internal (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redistribute_internal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redistribute_internal() directly.

    YANG Description: redistribute-internal: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="redistribute-internal", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redistribute_internal must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="redistribute-internal", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)""",
        })

    self.__redistribute_internal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redistribute_internal(self):
    self.__redistribute_internal = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="redistribute-internal", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='boolean', is_config=True)


  def _get_listen_range(self):
    """
    Getter method for listen_range, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/listen_range (list)
    """
    return self.__listen_range
      
  def _set_listen_range(self, v, load=False):
    """
    Setter method for listen_range, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/listen_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_listen_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_listen_range() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("name cidr",listen_range.listen_range, yang_name="listen-range", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name cidr'), is_container='list', yang_name="listen-range", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """listen_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name cidr",listen_range.listen_range, yang_name="listen-range", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name cidr'), is_container='list', yang_name="listen-range", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__listen_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_listen_range(self):
    self.__listen_range = YANGDynClass(base=YANGListType("name cidr",listen_range.listen_range, yang_name="listen-range", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name cidr'), is_container='list', yang_name="listen-range", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)


  def _get_peer_group(self):
    """
    Getter method for peer_group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group (list)
    """
    return self.__peer_group
      
  def _set_peer_group(self, v, load=False):
    """
    Setter method for peer_group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/peer_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("name",peer_group.peer_group, yang_name="peer-group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",peer_group.peer_group, yang_name="peer-group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__peer_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group(self):
    self.__peer_group = YANGDynClass(base=YANGListType("name",peer_group.peer_group, yang_name="peer-group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="peer-group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor (list)
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("ip_address",neighbor.neighbor, yang_name="neighbor", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="neighbor", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address",neighbor.neighbor, yang_name="neighbor", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="neighbor", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("ip_address",neighbor.neighbor, yang_name="neighbor", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="neighbor", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)


  def _get_aggregate_summary_network(self):
    """
    Getter method for aggregate_summary_network, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/aggregate_summary_network (list)
    """
    return self.__aggregate_summary_network
      
  def _set_aggregate_summary_network(self, v, load=False):
    """
    Setter method for aggregate_summary_network, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/aggregate_summary_network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregate_summary_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregate_summary_network() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("network",aggregate_summary_network.aggregate_summary_network, yang_name="aggregate-summary-network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network'), is_container='list', yang_name="aggregate-summary-network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregate_summary_network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network",aggregate_summary_network.aggregate_summary_network, yang_name="aggregate-summary-network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network'), is_container='list', yang_name="aggregate-summary-network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__aggregate_summary_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregate_summary_network(self):
    self.__aggregate_summary_network = YANGDynClass(base=YANGListType("network",aggregate_summary_network.aggregate_summary_network, yang_name="aggregate-summary-network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network'), is_container='list', yang_name="aggregate-summary-network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)


  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/network (list)
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("ip_address",network.network, yang_name="network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address",network.network, yang_name="network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=YANGListType("ip_address",network.network, yang_name="network", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="network", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)


  def _get_redistribute(self):
    """
    Getter method for redistribute, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/redistribute (list)
    """
    return self.__redistribute
      
  def _set_redistribute(self, v, load=False):
    """
    Setter method for redistribute, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/redistribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_redistribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_redistribute() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("protocol",redistribute.redistribute, yang_name="redistribute", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol'), is_container='list', yang_name="redistribute", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """redistribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("protocol",redistribute.redistribute, yang_name="redistribute", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol'), is_container='list', yang_name="redistribute", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__redistribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_redistribute(self):
    self.__redistribute = YANGDynClass(base=YANGListType("protocol",redistribute.redistribute, yang_name="redistribute", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='protocol'), is_container='list', yang_name="redistribute", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)


  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/group (list)
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /devices/device/vrfs/vrf/router_bgp/group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("name",group.group, yang_name="group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",group.group, yang_name="group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=YANGListType("name",group.group, yang_name="group", module_name="l3features", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="group", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='list', is_config=True)

  as_number = __builtin__.property(_get_as_number, _set_as_number)
  router_id = __builtin__.property(_get_router_id, _set_router_id)
  default_information_originate = __builtin__.property(_get_default_information_originate, _set_default_information_originate)
  bgp_keepalive_timer = __builtin__.property(_get_bgp_keepalive_timer, _set_bgp_keepalive_timer)
  bgp_holdtime_timer = __builtin__.property(_get_bgp_holdtime_timer, _set_bgp_holdtime_timer)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  log_neighbor_changes = __builtin__.property(_get_log_neighbor_changes, _set_log_neighbor_changes)
  qppb_policy = __builtin__.property(_get_qppb_policy, _set_qppb_policy)
  trigger_delay = __builtin__.property(_get_trigger_delay, _set_trigger_delay)
  listen_limit = __builtin__.property(_get_listen_limit, _set_listen_limit)
  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)
  eroutes = __builtin__.property(_get_eroutes, _set_eroutes)
  iroutes = __builtin__.property(_get_iroutes, _set_iroutes)
  lroutes = __builtin__.property(_get_lroutes, _set_lroutes)
  redistribute_internal = __builtin__.property(_get_redistribute_internal, _set_redistribute_internal)
  listen_range = __builtin__.property(_get_listen_range, _set_listen_range)
  peer_group = __builtin__.property(_get_peer_group, _set_peer_group)
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)
  aggregate_summary_network = __builtin__.property(_get_aggregate_summary_network, _set_aggregate_summary_network)
  network = __builtin__.property(_get_network, _set_network)
  redistribute = __builtin__.property(_get_redistribute, _set_redistribute)
  group = __builtin__.property(_get_group, _set_group)


  _pyangbind_elements = collections.OrderedDict([('as_number', as_number), ('router_id', router_id), ('default_information_originate', default_information_originate), ('bgp_keepalive_timer', bgp_keepalive_timer), ('bgp_holdtime_timer', bgp_holdtime_timer), ('address_family', address_family), ('log_neighbor_changes', log_neighbor_changes), ('qppb_policy', qppb_policy), ('trigger_delay', trigger_delay), ('listen_limit', listen_limit), ('maximum_paths', maximum_paths), ('eroutes', eroutes), ('iroutes', iroutes), ('lroutes', lroutes), ('redistribute_internal', redistribute_internal), ('listen_range', listen_range), ('peer_group', peer_group), ('neighbor', neighbor), ('aggregate_summary_network', aggregate_summary_network), ('network', network), ('redistribute', redistribute), ('group', group), ])


