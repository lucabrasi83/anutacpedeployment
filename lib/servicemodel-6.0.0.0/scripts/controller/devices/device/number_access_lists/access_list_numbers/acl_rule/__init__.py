
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class acl_rule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/number-access-lists/access-list-numbers/acl-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__extra_options','__description','__family','__payload_protocol','__linenumber','__action','__layer4protocol','__application','__source_condition_type','__source_ip','__source_mask','__source_obj_name','__service_obj_name','__source_port_operator','__port_name','__policer_name','__source_port','__dest_condition_type','__dest_ip','__dest_mask','__dest_obj_name','__dest_port_operator','__dest_port','__match_packets','__precedence','__next_acl_rule_name','__prev_acl_rule_name','__next_acl_rule_linenumber','__prev_acl_rule_linenumber','__log_action','__log_traffic','__rule_nat','__schedule','__rule_status','__ips_sensor','__ssl_profile','__tag','__service','__sample','__counter','__dest_prefix_list','__packet_length','__src_prefix_list','__routing_instance','__source_mac','__dest_mac',)

  _yang_name = 'acl-rule'
  _module_name = 'acl-types'
  _namespace = 'http://anutanetworks.com/acl'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_obj_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__service_obj_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="service-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__family = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inet6': {}, u'inet': {}},), is_leaf=True, yang_name="family", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)
    self.__next_acl_rule_linenumber = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="next-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)
    self.__sample = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='boolean', is_config=True)
    self.__packet_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-length", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint32', is_config=True)
    self.__tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="tag", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__port_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__next_acl_rule_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="next-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__prev_acl_rule_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="prev-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__routing_instance = YANGDynClass(base=unicode, is_leaf=True, yang_name="routing-instance", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__dest_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__precedence = YANGDynClass(base=unicode, is_leaf=True, yang_name="precedence", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__service = YANGDynClass(base=unicode, is_leaf=True, yang_name="service", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__src_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="src-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__extra_options = YANGDynClass(base=unicode, is_leaf=True, yang_name="extra-options", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__source_condition_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="source-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)
    self.__ssl_profile = YANGDynClass(base=unicode, is_leaf=True, yang_name="ssl-profile", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__match_packets = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'log': {}, u'precedence': {}, u'tracked': {}, u'log-input': {}, u'tos': {}, u'dscp': {}, u'echo': {}, u'time-range': {}, u'ttl': {}, u'fragments': {}, u'echo-reply': {}, u'option': {}},), is_leaf=True, yang_name="match-packets", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='match-packets-type', is_config=True)
    self.__dest_port_operator = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="dest-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)
    self.__application = YANGDynClass(base=unicode, is_leaf=True, yang_name="application", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__dest_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'None': {}, u'session-init': {}, u'session-close': {}},), is_leaf=True, yang_name="log-action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-action-type', is_config=True)
    self.__log_traffic = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all': {}, u'disable': {}, u'utm': {}},), is_leaf=True, yang_name="log-traffic", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-traffic-type', is_config=True)
    self.__dest_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__dest_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__source_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__source_port_operator = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="source-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__schedule = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'none': {}},), is_leaf=True, yang_name="schedule", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='schedule-type', is_config=True)
    self.__prev_acl_rule_linenumber = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="prev-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)
    self.__action = YANGDynClass(base=unicode, is_leaf=True, yang_name="action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__payload_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'tcp': {}},), is_leaf=True, yang_name="payload-protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__dest_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__source_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__counter = YANGDynClass(base=unicode, is_leaf=True, yang_name="counter", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__source_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__ips_sensor = YANGDynClass(base=unicode, is_leaf=True, yang_name="ips-sensor", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__rule_nat = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-nat", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)
    self.__layer4protocol = YANGDynClass(base=unicode, is_leaf=True, yang_name="layer4protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__dest_condition_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="dest-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)
    self.__linenumber = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)
    self.__source_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__policer_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    self.__rule_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-status", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)
    self.__dest_obj_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'number-access-lists', u'access-list-numbers', u'acl-rule']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_extra_options(self):
    """
    Getter method for extra_options, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/extra_options (string)

    YANG Description: string
    """
    return self.__extra_options
      
  def _set_extra_options(self, v, load=False):
    """
    Setter method for extra_options, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/extra_options (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extra_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extra_options() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="extra-options", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extra_options must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="extra-options", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__extra_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extra_options(self):
    self.__extra_options = YANGDynClass(base=unicode, is_leaf=True, yang_name="extra-options", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_family(self):
    """
    Getter method for family, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/family (enumeration)

    YANG Description: inet
inet6

    """
    return self.__family
      
  def _set_family(self, v, load=False):
    """
    Setter method for family, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/family (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_family() directly.

    YANG Description: inet
inet6

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inet6': {}, u'inet': {}},), is_leaf=True, yang_name="family", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """family must be of a type compatible with enumeration""",
          'defined-type': "acl:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inet6': {}, u'inet': {}},), is_leaf=True, yang_name="family", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)""",
        })

    self.__family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_family(self):
    self.__family = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inet6': {}, u'inet': {}},), is_leaf=True, yang_name="family", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)


  def _get_payload_protocol(self):
    """
    Getter method for payload_protocol, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/payload_protocol (enumeration)

    YANG Description: tcp
udp

    """
    return self.__payload_protocol
      
  def _set_payload_protocol(self, v, load=False):
    """
    Setter method for payload_protocol, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/payload_protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_payload_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_payload_protocol() directly.

    YANG Description: tcp
udp

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'tcp': {}},), is_leaf=True, yang_name="payload-protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """payload_protocol must be of a type compatible with enumeration""",
          'defined-type': "acl:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'tcp': {}},), is_leaf=True, yang_name="payload-protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)""",
        })

    self.__payload_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_payload_protocol(self):
    self.__payload_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'tcp': {}},), is_leaf=True, yang_name="payload-protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enumeration', is_config=True)


  def _get_linenumber(self):
    """
    Getter method for linenumber, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/linenumber (uint16)

    YANG Description: 0..65535
    """
    return self.__linenumber
      
  def _set_linenumber(self, v, load=False):
    """
    Setter method for linenumber, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/linenumber (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linenumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linenumber() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linenumber must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)""",
        })

    self.__linenumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linenumber(self):
    self.__linenumber = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/action (string)

    YANG Description: string
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/action (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=unicode, is_leaf=True, yang_name="action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_layer4protocol(self):
    """
    Getter method for layer4protocol, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/layer4protocol (string)

    YANG Description: string
    """
    return self.__layer4protocol
      
  def _set_layer4protocol(self, v, load=False):
    """
    Setter method for layer4protocol, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/layer4protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer4protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer4protocol() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="layer4protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """layer4protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="layer4protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__layer4protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_layer4protocol(self):
    self.__layer4protocol = YANGDynClass(base=unicode, is_leaf=True, yang_name="layer4protocol", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_application(self):
    """
    Getter method for application, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/application (string)

    YANG Description: string
    """
    return self.__application
      
  def _set_application(self, v, load=False):
    """
    Setter method for application, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/application (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_application is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_application() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="application", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """application must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="application", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__application = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_application(self):
    self.__application = YANGDynClass(base=unicode, is_leaf=True, yang_name="application", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_source_condition_type(self):
    """
    Getter method for source_condition_type, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_condition_type (condition-type)

    YANG Description: any
cidr
objectgroup
host
address
networkobject

    """
    return self.__source_condition_type
      
  def _set_source_condition_type(self, v, load=False):
    """
    Setter method for source_condition_type, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_condition_type (condition-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_condition_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_condition_type() directly.

    YANG Description: any
cidr
objectgroup
host
address
networkobject

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="source-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_condition_type must be of a type compatible with condition-type""",
          'defined-type': "acl:condition-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="source-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)""",
        })

    self.__source_condition_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_condition_type(self):
    self.__source_condition_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="source-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)


  def _get_source_ip(self):
    """
    Getter method for source_ip, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_ip (string)

    YANG Description: string
    """
    return self.__source_ip
      
  def _set_source_ip(self, v, load=False):
    """
    Setter method for source_ip, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__source_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ip(self):
    self.__source_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_source_mask(self):
    """
    Getter method for source_mask, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_mask (string)

    YANG Description: string
    """
    return self.__source_mask
      
  def _set_source_mask(self, v, load=False):
    """
    Setter method for source_mask, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_mask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_mask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_mask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__source_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_mask(self):
    self.__source_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_source_obj_name(self):
    """
    Getter method for source_obj_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_obj_name (string)

    YANG Description: string
    """
    return self.__source_obj_name
      
  def _set_source_obj_name(self, v, load=False):
    """
    Setter method for source_obj_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_obj_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_obj_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_obj_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_obj_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__source_obj_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_obj_name(self):
    self.__source_obj_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_service_obj_name(self):
    """
    Getter method for service_obj_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/service_obj_name (string)

    YANG Description: string
    """
    return self.__service_obj_name
      
  def _set_service_obj_name(self, v, load=False):
    """
    Setter method for service_obj_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/service_obj_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_obj_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_obj_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="service-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_obj_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="service-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__service_obj_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_obj_name(self):
    self.__service_obj_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="service-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_source_port_operator(self):
    """
    Getter method for source_port_operator, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_port_operator (operator-type)

    YANG Description: eq
gt
lt
neq
range

    """
    return self.__source_port_operator
      
  def _set_source_port_operator(self, v, load=False):
    """
    Setter method for source_port_operator, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_port_operator (operator-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port_operator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port_operator() directly.

    YANG Description: eq
gt
lt
neq
range

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="source-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port_operator must be of a type compatible with operator-type""",
          'defined-type': "acl:operator-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="source-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)""",
        })

    self.__source_port_operator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port_operator(self):
    self.__source_port_operator = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="source-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)


  def _get_port_name(self):
    """
    Getter method for port_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/port_name (string)

    YANG Description: string
    """
    return self.__port_name
      
  def _set_port_name(self, v, load=False):
    """
    Setter method for port_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/port_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__port_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_name(self):
    self.__port_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_policer_name(self):
    """
    Getter method for policer_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/policer_name (string)

    YANG Description: string
    """
    return self.__policer_name
      
  def _set_policer_name(self, v, load=False):
    """
    Setter method for policer_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/policer_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policer_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policer_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="policer-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policer_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__policer_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policer_name(self):
    self.__policer_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_source_port(self):
    """
    Getter method for source_port, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_port (string)

    YANG Description: string
    """
    return self.__source_port
      
  def _set_source_port(self, v, load=False):
    """
    Setter method for source_port, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_port (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port(self):
    self.__source_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_dest_condition_type(self):
    """
    Getter method for dest_condition_type, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_condition_type (condition-type)

    YANG Description: any
cidr
objectgroup
host
address
networkobject

    """
    return self.__dest_condition_type
      
  def _set_dest_condition_type(self, v, load=False):
    """
    Setter method for dest_condition_type, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_condition_type (condition-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_condition_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_condition_type() directly.

    YANG Description: any
cidr
objectgroup
host
address
networkobject

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="dest-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_condition_type must be of a type compatible with condition-type""",
          'defined-type': "acl:condition-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="dest-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)""",
        })

    self.__dest_condition_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_condition_type(self):
    self.__dest_condition_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'objectgroup': {}, u'networkobject': {}, u'host': {}, u'address': {}, u'cidr': {}, u'any': {}},), is_leaf=True, yang_name="dest-condition-type", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='condition-type', is_config=True)


  def _get_dest_ip(self):
    """
    Getter method for dest_ip, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_ip (string)

    YANG Description: string
    """
    return self.__dest_ip
      
  def _set_dest_ip(self, v, load=False):
    """
    Setter method for dest_ip, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_ip() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dest-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__dest_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_ip(self):
    self.__dest_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-ip", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_dest_mask(self):
    """
    Getter method for dest_mask, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_mask (string)

    YANG Description: string
    """
    return self.__dest_mask
      
  def _set_dest_mask(self, v, load=False):
    """
    Setter method for dest_mask, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_mask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_mask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dest-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_mask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__dest_mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_mask(self):
    self.__dest_mask = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-mask", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_dest_obj_name(self):
    """
    Getter method for dest_obj_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_obj_name (string)

    YANG Description: string
    """
    return self.__dest_obj_name
      
  def _set_dest_obj_name(self, v, load=False):
    """
    Setter method for dest_obj_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_obj_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_obj_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_obj_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dest-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_obj_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__dest_obj_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_obj_name(self):
    self.__dest_obj_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-obj-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_dest_port_operator(self):
    """
    Getter method for dest_port_operator, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_port_operator (operator-type)

    YANG Description: eq
gt
lt
neq
range

    """
    return self.__dest_port_operator
      
  def _set_dest_port_operator(self, v, load=False):
    """
    Setter method for dest_port_operator, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_port_operator (operator-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_port_operator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_port_operator() directly.

    YANG Description: eq
gt
lt
neq
range

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="dest-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_port_operator must be of a type compatible with operator-type""",
          'defined-type': "acl:operator-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="dest-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)""",
        })

    self.__dest_port_operator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_port_operator(self):
    self.__dest_port_operator = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lt': {}, u'gt': {}, u'eq': {}, u'range': {}, u'neq': {}},), is_leaf=True, yang_name="dest-port-operator", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='operator-type', is_config=True)


  def _get_dest_port(self):
    """
    Getter method for dest_port, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_port (string)

    YANG Description: string
    """
    return self.__dest_port
      
  def _set_dest_port(self, v, load=False):
    """
    Setter method for dest_port, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_port (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_port() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dest-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_port must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__dest_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_port(self):
    self.__dest_port = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-port", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_match_packets(self):
    """
    Getter method for match_packets, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/match_packets (match-packets-type)

    YANG Description: dscp
fragments
log
log-input
option
precedence
time-range
tos
ttl
echo
echo-reply
tracked

    """
    return self.__match_packets
      
  def _set_match_packets(self, v, load=False):
    """
    Setter method for match_packets, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/match_packets (match-packets-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match_packets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match_packets() directly.

    YANG Description: dscp
fragments
log
log-input
option
precedence
time-range
tos
ttl
echo
echo-reply
tracked

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'log': {}, u'precedence': {}, u'tracked': {}, u'log-input': {}, u'tos': {}, u'dscp': {}, u'echo': {}, u'time-range': {}, u'ttl': {}, u'fragments': {}, u'echo-reply': {}, u'option': {}},), is_leaf=True, yang_name="match-packets", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='match-packets-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """match_packets must be of a type compatible with match-packets-type""",
          'defined-type': "acl:match-packets-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'log': {}, u'precedence': {}, u'tracked': {}, u'log-input': {}, u'tos': {}, u'dscp': {}, u'echo': {}, u'time-range': {}, u'ttl': {}, u'fragments': {}, u'echo-reply': {}, u'option': {}},), is_leaf=True, yang_name="match-packets", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='match-packets-type', is_config=True)""",
        })

    self.__match_packets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_match_packets(self):
    self.__match_packets = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'log': {}, u'precedence': {}, u'tracked': {}, u'log-input': {}, u'tos': {}, u'dscp': {}, u'echo': {}, u'time-range': {}, u'ttl': {}, u'fragments': {}, u'echo-reply': {}, u'option': {}},), is_leaf=True, yang_name="match-packets", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='match-packets-type', is_config=True)


  def _get_precedence(self):
    """
    Getter method for precedence, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/precedence (string)

    YANG Description: string
    """
    return self.__precedence
      
  def _set_precedence(self, v, load=False):
    """
    Setter method for precedence, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/precedence (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_precedence is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_precedence() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="precedence", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """precedence must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="precedence", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__precedence = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_precedence(self):
    self.__precedence = YANGDynClass(base=unicode, is_leaf=True, yang_name="precedence", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_next_acl_rule_name(self):
    """
    Getter method for next_acl_rule_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/next_acl_rule_name (string)

    YANG Description: string
    """
    return self.__next_acl_rule_name
      
  def _set_next_acl_rule_name(self, v, load=False):
    """
    Setter method for next_acl_rule_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/next_acl_rule_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_acl_rule_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_acl_rule_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="next-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_acl_rule_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="next-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__next_acl_rule_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_acl_rule_name(self):
    self.__next_acl_rule_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="next-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_prev_acl_rule_name(self):
    """
    Getter method for prev_acl_rule_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/prev_acl_rule_name (string)

    YANG Description: string
    """
    return self.__prev_acl_rule_name
      
  def _set_prev_acl_rule_name(self, v, load=False):
    """
    Setter method for prev_acl_rule_name, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/prev_acl_rule_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prev_acl_rule_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prev_acl_rule_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="prev-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prev_acl_rule_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="prev-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__prev_acl_rule_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prev_acl_rule_name(self):
    self.__prev_acl_rule_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="prev-acl-rule-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_next_acl_rule_linenumber(self):
    """
    Getter method for next_acl_rule_linenumber, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/next_acl_rule_linenumber (uint16)

    YANG Description: 0..65535
    """
    return self.__next_acl_rule_linenumber
      
  def _set_next_acl_rule_linenumber(self, v, load=False):
    """
    Setter method for next_acl_rule_linenumber, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/next_acl_rule_linenumber (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_acl_rule_linenumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_acl_rule_linenumber() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="next-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_acl_rule_linenumber must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="next-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)""",
        })

    self.__next_acl_rule_linenumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_acl_rule_linenumber(self):
    self.__next_acl_rule_linenumber = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="next-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)


  def _get_prev_acl_rule_linenumber(self):
    """
    Getter method for prev_acl_rule_linenumber, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/prev_acl_rule_linenumber (uint16)

    YANG Description: 0..65535
    """
    return self.__prev_acl_rule_linenumber
      
  def _set_prev_acl_rule_linenumber(self, v, load=False):
    """
    Setter method for prev_acl_rule_linenumber, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/prev_acl_rule_linenumber (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prev_acl_rule_linenumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prev_acl_rule_linenumber() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="prev-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prev_acl_rule_linenumber must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="prev-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)""",
        })

    self.__prev_acl_rule_linenumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prev_acl_rule_linenumber(self):
    self.__prev_acl_rule_linenumber = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="prev-acl-rule-linenumber", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint16', is_config=True)


  def _get_log_action(self):
    """
    Getter method for log_action, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/log_action (log-action-type)

    YANG Description: None
session-init
session-close

    """
    return self.__log_action
      
  def _set_log_action(self, v, load=False):
    """
    Setter method for log_action, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/log_action (log-action-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_action() directly.

    YANG Description: None
session-init
session-close

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'None': {}, u'session-init': {}, u'session-close': {}},), is_leaf=True, yang_name="log-action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-action-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_action must be of a type compatible with log-action-type""",
          'defined-type': "acl:log-action-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'None': {}, u'session-init': {}, u'session-close': {}},), is_leaf=True, yang_name="log-action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-action-type', is_config=True)""",
        })

    self.__log_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_action(self):
    self.__log_action = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'None': {}, u'session-init': {}, u'session-close': {}},), is_leaf=True, yang_name="log-action", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-action-type', is_config=True)


  def _get_log_traffic(self):
    """
    Getter method for log_traffic, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/log_traffic (log-traffic-type)

    YANG Description: all
utm
disable

    """
    return self.__log_traffic
      
  def _set_log_traffic(self, v, load=False):
    """
    Setter method for log_traffic, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/log_traffic (log-traffic-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_traffic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_traffic() directly.

    YANG Description: all
utm
disable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all': {}, u'disable': {}, u'utm': {}},), is_leaf=True, yang_name="log-traffic", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-traffic-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_traffic must be of a type compatible with log-traffic-type""",
          'defined-type': "acl:log-traffic-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all': {}, u'disable': {}, u'utm': {}},), is_leaf=True, yang_name="log-traffic", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-traffic-type', is_config=True)""",
        })

    self.__log_traffic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_traffic(self):
    self.__log_traffic = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all': {}, u'disable': {}, u'utm': {}},), is_leaf=True, yang_name="log-traffic", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='log-traffic-type', is_config=True)


  def _get_rule_nat(self):
    """
    Getter method for rule_nat, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/rule_nat (enable-disable-type)

    YANG Description: enable
disable

    """
    return self.__rule_nat
      
  def _set_rule_nat(self, v, load=False):
    """
    Setter method for rule_nat, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/rule_nat (enable-disable-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_nat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_nat() directly.

    YANG Description: enable
disable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-nat", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_nat must be of a type compatible with enable-disable-type""",
          'defined-type': "acl:enable-disable-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-nat", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)""",
        })

    self.__rule_nat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_nat(self):
    self.__rule_nat = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-nat", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)


  def _get_schedule(self):
    """
    Getter method for schedule, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/schedule (schedule-type)

    YANG Description: always
none

    """
    return self.__schedule
      
  def _set_schedule(self, v, load=False):
    """
    Setter method for schedule, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/schedule (schedule-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schedule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schedule() directly.

    YANG Description: always
none

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'none': {}},), is_leaf=True, yang_name="schedule", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='schedule-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schedule must be of a type compatible with schedule-type""",
          'defined-type': "acl:schedule-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'none': {}},), is_leaf=True, yang_name="schedule", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='schedule-type', is_config=True)""",
        })

    self.__schedule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schedule(self):
    self.__schedule = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'none': {}},), is_leaf=True, yang_name="schedule", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='schedule-type', is_config=True)


  def _get_rule_status(self):
    """
    Getter method for rule_status, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/rule_status (enable-disable-type)

    YANG Description: enable
disable

    """
    return self.__rule_status
      
  def _set_rule_status(self, v, load=False):
    """
    Setter method for rule_status, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/rule_status (enable-disable-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_status() directly.

    YANG Description: enable
disable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-status", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_status must be of a type compatible with enable-disable-type""",
          'defined-type': "acl:enable-disable-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-status", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)""",
        })

    self.__rule_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_status(self):
    self.__rule_status = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="rule-status", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='enable-disable-type', is_config=True)


  def _get_ips_sensor(self):
    """
    Getter method for ips_sensor, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/ips_sensor (string)

    YANG Description: string
    """
    return self.__ips_sensor
      
  def _set_ips_sensor(self, v, load=False):
    """
    Setter method for ips_sensor, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/ips_sensor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ips_sensor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ips_sensor() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ips-sensor", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ips_sensor must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ips-sensor", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__ips_sensor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ips_sensor(self):
    self.__ips_sensor = YANGDynClass(base=unicode, is_leaf=True, yang_name="ips-sensor", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_ssl_profile(self):
    """
    Getter method for ssl_profile, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/ssl_profile (string)

    YANG Description: string
    """
    return self.__ssl_profile
      
  def _set_ssl_profile(self, v, load=False):
    """
    Setter method for ssl_profile, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/ssl_profile (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssl_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssl_profile() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ssl-profile", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssl_profile must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ssl-profile", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__ssl_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssl_profile(self):
    self.__ssl_profile = YANGDynClass(base=unicode, is_leaf=True, yang_name="ssl-profile", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/tag (string)

    YANG Description: string
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tag", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tag", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="tag", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/service (string)

    YANG Description: string
    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="service", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="service", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=unicode, is_leaf=True, yang_name="service", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_sample(self):
    """
    Getter method for sample, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/sample (boolean)

    YANG Description: sample: True/False
    """
    return self.__sample
      
  def _set_sample(self, v, load=False):
    """
    Setter method for sample, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/sample (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sample is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sample() directly.

    YANG Description: sample: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="sample", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sample must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='boolean', is_config=True)""",
        })

    self.__sample = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sample(self):
    self.__sample = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="sample", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='boolean', is_config=True)


  def _get_counter(self):
    """
    Getter method for counter, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/counter (string)

    YANG Description: string
    """
    return self.__counter
      
  def _set_counter(self, v, load=False):
    """
    Setter method for counter, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/counter (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_counter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_counter() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="counter", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """counter must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="counter", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__counter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_counter(self):
    self.__counter = YANGDynClass(base=unicode, is_leaf=True, yang_name="counter", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_dest_prefix_list(self):
    """
    Getter method for dest_prefix_list, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_prefix_list (string)

    YANG Description: string
    """
    return self.__dest_prefix_list
      
  def _set_dest_prefix_list(self, v, load=False):
    """
    Setter method for dest_prefix_list, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_prefix_list() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dest-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__dest_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_prefix_list(self):
    self.__dest_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_packet_length(self):
    """
    Getter method for packet_length, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/packet_length (uint32)

    YANG Description: 0..4294967295
    """
    return self.__packet_length
      
  def _set_packet_length(self, v, load=False):
    """
    Setter method for packet_length, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/packet_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_length() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-length", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-length", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint32', is_config=True)""",
        })

    self.__packet_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_length(self):
    self.__packet_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-length", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='uint32', is_config=True)


  def _get_src_prefix_list(self):
    """
    Getter method for src_prefix_list, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/src_prefix_list (string)

    YANG Description: string
    """
    return self.__src_prefix_list
      
  def _set_src_prefix_list(self, v, load=False):
    """
    Setter method for src_prefix_list, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/src_prefix_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_prefix_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_prefix_list() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="src-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_prefix_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="src-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__src_prefix_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_prefix_list(self):
    self.__src_prefix_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="src-prefix-list", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_routing_instance(self):
    """
    Getter method for routing_instance, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/routing_instance (string)

    YANG Description: string
    """
    return self.__routing_instance
      
  def _set_routing_instance(self, v, load=False):
    """
    Setter method for routing_instance, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/routing_instance (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_instance() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="routing-instance", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_instance must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="routing-instance", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__routing_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_instance(self):
    self.__routing_instance = YANGDynClass(base=unicode, is_leaf=True, yang_name="routing-instance", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_source_mac(self):
    """
    Getter method for source_mac, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_mac (string)

    YANG Description: string
    """
    return self.__source_mac
      
  def _set_source_mac(self, v, load=False):
    """
    Setter method for source_mac, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/source_mac (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_mac() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_mac must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__source_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_mac(self):
    self.__source_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)


  def _get_dest_mac(self):
    """
    Getter method for dest_mac, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_mac (string)

    YANG Description: string
    """
    return self.__dest_mac
      
  def _set_dest_mac(self, v, load=False):
    """
    Setter method for dest_mac, mapped from YANG variable /devices/device/number_access_lists/access_list_numbers/acl_rule/dest_mac (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_mac() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dest-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_mac must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)""",
        })

    self.__dest_mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_mac(self):
    self.__dest_mac = YANGDynClass(base=unicode, is_leaf=True, yang_name="dest-mac", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  extra_options = __builtin__.property(_get_extra_options, _set_extra_options)
  description = __builtin__.property(_get_description, _set_description)
  family = __builtin__.property(_get_family, _set_family)
  payload_protocol = __builtin__.property(_get_payload_protocol, _set_payload_protocol)
  linenumber = __builtin__.property(_get_linenumber, _set_linenumber)
  action = __builtin__.property(_get_action, _set_action)
  layer4protocol = __builtin__.property(_get_layer4protocol, _set_layer4protocol)
  application = __builtin__.property(_get_application, _set_application)
  source_condition_type = __builtin__.property(_get_source_condition_type, _set_source_condition_type)
  source_ip = __builtin__.property(_get_source_ip, _set_source_ip)
  source_mask = __builtin__.property(_get_source_mask, _set_source_mask)
  source_obj_name = __builtin__.property(_get_source_obj_name, _set_source_obj_name)
  service_obj_name = __builtin__.property(_get_service_obj_name, _set_service_obj_name)
  source_port_operator = __builtin__.property(_get_source_port_operator, _set_source_port_operator)
  port_name = __builtin__.property(_get_port_name, _set_port_name)
  policer_name = __builtin__.property(_get_policer_name, _set_policer_name)
  source_port = __builtin__.property(_get_source_port, _set_source_port)
  dest_condition_type = __builtin__.property(_get_dest_condition_type, _set_dest_condition_type)
  dest_ip = __builtin__.property(_get_dest_ip, _set_dest_ip)
  dest_mask = __builtin__.property(_get_dest_mask, _set_dest_mask)
  dest_obj_name = __builtin__.property(_get_dest_obj_name, _set_dest_obj_name)
  dest_port_operator = __builtin__.property(_get_dest_port_operator, _set_dest_port_operator)
  dest_port = __builtin__.property(_get_dest_port, _set_dest_port)
  match_packets = __builtin__.property(_get_match_packets, _set_match_packets)
  precedence = __builtin__.property(_get_precedence, _set_precedence)
  next_acl_rule_name = __builtin__.property(_get_next_acl_rule_name, _set_next_acl_rule_name)
  prev_acl_rule_name = __builtin__.property(_get_prev_acl_rule_name, _set_prev_acl_rule_name)
  next_acl_rule_linenumber = __builtin__.property(_get_next_acl_rule_linenumber, _set_next_acl_rule_linenumber)
  prev_acl_rule_linenumber = __builtin__.property(_get_prev_acl_rule_linenumber, _set_prev_acl_rule_linenumber)
  log_action = __builtin__.property(_get_log_action, _set_log_action)
  log_traffic = __builtin__.property(_get_log_traffic, _set_log_traffic)
  rule_nat = __builtin__.property(_get_rule_nat, _set_rule_nat)
  schedule = __builtin__.property(_get_schedule, _set_schedule)
  rule_status = __builtin__.property(_get_rule_status, _set_rule_status)
  ips_sensor = __builtin__.property(_get_ips_sensor, _set_ips_sensor)
  ssl_profile = __builtin__.property(_get_ssl_profile, _set_ssl_profile)
  tag = __builtin__.property(_get_tag, _set_tag)
  service = __builtin__.property(_get_service, _set_service)
  sample = __builtin__.property(_get_sample, _set_sample)
  counter = __builtin__.property(_get_counter, _set_counter)
  dest_prefix_list = __builtin__.property(_get_dest_prefix_list, _set_dest_prefix_list)
  packet_length = __builtin__.property(_get_packet_length, _set_packet_length)
  src_prefix_list = __builtin__.property(_get_src_prefix_list, _set_src_prefix_list)
  routing_instance = __builtin__.property(_get_routing_instance, _set_routing_instance)
  source_mac = __builtin__.property(_get_source_mac, _set_source_mac)
  dest_mac = __builtin__.property(_get_dest_mac, _set_dest_mac)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('extra_options', extra_options), ('description', description), ('family', family), ('payload_protocol', payload_protocol), ('linenumber', linenumber), ('action', action), ('layer4protocol', layer4protocol), ('application', application), ('source_condition_type', source_condition_type), ('source_ip', source_ip), ('source_mask', source_mask), ('source_obj_name', source_obj_name), ('service_obj_name', service_obj_name), ('source_port_operator', source_port_operator), ('port_name', port_name), ('policer_name', policer_name), ('source_port', source_port), ('dest_condition_type', dest_condition_type), ('dest_ip', dest_ip), ('dest_mask', dest_mask), ('dest_obj_name', dest_obj_name), ('dest_port_operator', dest_port_operator), ('dest_port', dest_port), ('match_packets', match_packets), ('precedence', precedence), ('next_acl_rule_name', next_acl_rule_name), ('prev_acl_rule_name', prev_acl_rule_name), ('next_acl_rule_linenumber', next_acl_rule_linenumber), ('prev_acl_rule_linenumber', prev_acl_rule_linenumber), ('log_action', log_action), ('log_traffic', log_traffic), ('rule_nat', rule_nat), ('schedule', schedule), ('rule_status', rule_status), ('ips_sensor', ips_sensor), ('ssl_profile', ssl_profile), ('tag', tag), ('service', service), ('sample', sample), ('counter', counter), ('dest_prefix_list', dest_prefix_list), ('packet_length', packet_length), ('src_prefix_list', src_prefix_list), ('routing_instance', routing_instance), ('source_mac', source_mac), ('dest_mac', dest_mac), ])


