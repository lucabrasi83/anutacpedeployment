
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import associate_profile
import peer_as
import vrf_target
import mac_flush
import neighbor
import route_distinguisher
class mesh_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/vpls/mesh-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Mesh-group under this VPLS instance
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__mesh_group_name','__associate_profile','__peer_as','__vpls_id','__vrf_import','__vrf_export','__vrf_target','__mac_flush','__local_switching','__neighbor','__route_distinguisher',)

  _yang_name = 'mesh-group'
  _module_name = 'vpls'
  _namespace = 'http://anutanetworks.com/vpls'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__associate_profile = YANGDynClass(base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__mesh_group_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^.{1,32}$'}), is_leaf=True, yang_name="mesh-group-name", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    self.__vrf_export = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-export", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)
    self.__vpls_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    self.__route_distinguisher = YANGDynClass(base=route_distinguisher.route_distinguisher, is_container='container', yang_name="route-distinguisher", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__peer_as = YANGDynClass(base=peer_as.peer_as, is_container='container', yang_name="peer-as", module_name="vpls", parent=self, choice=(u'peer-as-choice', u'peer-as'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    self.__mac_flush = YANGDynClass(base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__vrf_import = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-import", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)
    self.__vrf_target = YANGDynClass(base=vrf_target.vrf_target, is_container='container', yang_name="vrf-target", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__local_switching = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-switching", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'vpls', u'mesh-group']

  def _get_mesh_group_name(self):
    """
    Getter method for mesh_group_name, mapped from YANG variable /devices/device/vpls/mesh_group/mesh_group_name (string)

    YANG Description: Mesh-group name
    """
    return self.__mesh_group_name
      
  def _set_mesh_group_name(self, v, load=False):
    """
    Setter method for mesh_group_name, mapped from YANG variable /devices/device/vpls/mesh_group/mesh_group_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mesh_group_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mesh_group_name() directly.

    YANG Description: Mesh-group name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^.{1,32}$'}), is_leaf=True, yang_name="mesh-group-name", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mesh_group_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^.{1,32}$'}), is_leaf=True, yang_name="mesh-group-name", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)""",
        })

    self.__mesh_group_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mesh_group_name(self):
    self.__mesh_group_name = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'^.{1,32}$'}), is_leaf=True, yang_name="mesh-group-name", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)


  def _get_associate_profile(self):
    """
    Getter method for associate_profile, mapped from YANG variable /devices/device/vpls/mesh_group/associate_profile (container)

    YANG Description: Associate profile options for dynamic IFL
    """
    return self.__associate_profile
      
  def _set_associate_profile(self, v, load=False):
    """
    Setter method for associate_profile, mapped from YANG variable /devices/device/vpls/mesh_group/associate_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associate_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associate_profile() directly.

    YANG Description: Associate profile options for dynamic IFL
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """associate_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__associate_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_associate_profile(self):
    self.__associate_profile = YANGDynClass(base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_peer_as(self):
    """
    Getter method for peer_as, mapped from YANG variable /devices/device/vpls/mesh_group/peer_as (container)

    YANG Description: Autonomous system of the peer
    """
    return self.__peer_as
      
  def _set_peer_as(self, v, load=False):
    """
    Setter method for peer_as, mapped from YANG variable /devices/device/vpls/mesh_group/peer_as (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_as() directly.

    YANG Description: Autonomous system of the peer
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=peer_as.peer_as, is_container='container', yang_name="peer-as", module_name="vpls", parent=self, choice=(u'peer-as-choice', u'peer-as'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_as must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=peer_as.peer_as, is_container='container', yang_name="peer-as", module_name="vpls", parent=self, choice=(u'peer-as-choice', u'peer-as'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__peer_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_as(self):
    self.__peer_as = YANGDynClass(base=peer_as.peer_as, is_container='container', yang_name="peer-as", module_name="vpls", parent=self, choice=(u'peer-as-choice', u'peer-as'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_vpls_id(self):
    """
    Getter method for vpls_id, mapped from YANG variable /devices/device/vpls/mesh_group/vpls_id (string)

    YANG Description: LDP VPLS Identifier for this mesh-group
    """
    return self.__vpls_id
      
  def _set_vpls_id(self, v, load=False):
    """
    Setter method for vpls_id, mapped from YANG variable /devices/device/vpls/mesh_group/vpls_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpls_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpls_id() directly.

    YANG Description: LDP VPLS Identifier for this mesh-group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpls_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)""",
        })

    self.__vpls_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpls_id(self):
    self.__vpls_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)


  def _get_vrf_import(self):
    """
    Getter method for vrf_import, mapped from YANG variable /devices/device/vpls/mesh_group/vrf_import (policy-algebra)

    YANG Description: Import policy for VPLS instance mesh-group
    """
    return self.__vrf_import
      
  def _set_vrf_import(self, v, load=False):
    """
    Setter method for vrf_import, mapped from YANG variable /devices/device/vpls/mesh_group/vrf_import (policy-algebra)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_import is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_import() directly.

    YANG Description: Import policy for VPLS instance mesh-group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-import", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_import must be of a type compatible with policy-algebra""",
          'defined-type': "vpls:policy-algebra",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-import", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)""",
        })

    self.__vrf_import = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_import(self):
    self.__vrf_import = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-import", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)


  def _get_vrf_export(self):
    """
    Getter method for vrf_export, mapped from YANG variable /devices/device/vpls/mesh_group/vrf_export (policy-algebra)

    YANG Description: Export policy for VPLS instance mesh-group
    """
    return self.__vrf_export
      
  def _set_vrf_export(self, v, load=False):
    """
    Setter method for vrf_export, mapped from YANG variable /devices/device/vpls/mesh_group/vrf_export (policy-algebra)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_export is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_export() directly.

    YANG Description: Export policy for VPLS instance mesh-group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-export", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_export must be of a type compatible with policy-algebra""",
          'defined-type': "vpls:policy-algebra",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-export", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)""",
        })

    self.__vrf_export = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_export(self):
    self.__vrf_export = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="vrf-export", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='policy-algebra', is_config=True)


  def _get_vrf_target(self):
    """
    Getter method for vrf_target, mapped from YANG variable /devices/device/vpls/mesh_group/vrf_target (container)

    YANG Description: VPLS mesh-group target community configuration
    """
    return self.__vrf_target
      
  def _set_vrf_target(self, v, load=False):
    """
    Setter method for vrf_target, mapped from YANG variable /devices/device/vpls/mesh_group/vrf_target (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_target() directly.

    YANG Description: VPLS mesh-group target community configuration
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vrf_target.vrf_target, is_container='container', yang_name="vrf-target", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_target must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vrf_target.vrf_target, is_container='container', yang_name="vrf-target", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__vrf_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_target(self):
    self.__vrf_target = YANGDynClass(base=vrf_target.vrf_target, is_container='container', yang_name="vrf-target", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_mac_flush(self):
    """
    Getter method for mac_flush, mapped from YANG variable /devices/device/vpls/mesh_group/mac_flush (container)

    YANG Description: Enables mac-flush processing
    """
    return self.__mac_flush
      
  def _set_mac_flush(self, v, load=False):
    """
    Setter method for mac_flush, mapped from YANG variable /devices/device/vpls/mesh_group/mac_flush (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_flush is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_flush() directly.

    YANG Description: Enables mac-flush processing
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_flush must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__mac_flush = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_flush(self):
    self.__mac_flush = YANGDynClass(base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_local_switching(self):
    """
    Getter method for local_switching, mapped from YANG variable /devices/device/vpls/mesh_group/local_switching (empty)

    YANG Description: Allow local-switching within interfaces in this mesh-group
    """
    return self.__local_switching
      
  def _set_local_switching(self, v, load=False):
    """
    Setter method for local_switching, mapped from YANG variable /devices/device/vpls/mesh_group/local_switching (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_switching is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_switching() directly.

    YANG Description: Allow local-switching within interfaces in this mesh-group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="local-switching", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_switching must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-switching", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__local_switching = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_switching(self):
    self.__local_switching = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-switching", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /devices/device/vpls/mesh_group/neighbor (list)

    YANG Description: Neighbor belonging to this mesh-group
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /devices/device/vpls/mesh_group/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: Neighbor belonging to this mesh-group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)


  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /devices/device/vpls/mesh_group/route_distinguisher (container)

    YANG Description: Route distinguisher for this mesh-group
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /devices/device/vpls/mesh_group/route_distinguisher (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: Route distinguisher for this mesh-group
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=route_distinguisher.route_distinguisher, is_container='container', yang_name="route-distinguisher", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=route_distinguisher.route_distinguisher, is_container='container', yang_name="route-distinguisher", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=route_distinguisher.route_distinguisher, is_container='container', yang_name="route-distinguisher", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)

  mesh_group_name = __builtin__.property(_get_mesh_group_name, _set_mesh_group_name)
  associate_profile = __builtin__.property(_get_associate_profile, _set_associate_profile)
  peer_as = __builtin__.property(_get_peer_as, _set_peer_as)
  vpls_id = __builtin__.property(_get_vpls_id, _set_vpls_id)
  vrf_import = __builtin__.property(_get_vrf_import, _set_vrf_import)
  vrf_export = __builtin__.property(_get_vrf_export, _set_vrf_export)
  vrf_target = __builtin__.property(_get_vrf_target, _set_vrf_target)
  mac_flush = __builtin__.property(_get_mac_flush, _set_mac_flush)
  local_switching = __builtin__.property(_get_local_switching, _set_local_switching)
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)
  route_distinguisher = __builtin__.property(_get_route_distinguisher, _set_route_distinguisher)

  __choices__ = {u'peer-as-choice': {u'peer-as': [u'peer_as']}}
  _pyangbind_elements = collections.OrderedDict([('mesh_group_name', mesh_group_name), ('associate_profile', associate_profile), ('peer_as', peer_as), ('vpls_id', vpls_id), ('vrf_import', vrf_import), ('vrf_export', vrf_export), ('vrf_target', vrf_target), ('mac_flush', mac_flush), ('local_switching', local_switching), ('neighbor', neighbor), ('route_distinguisher', route_distinguisher), ])


