
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import static_vpls
import mac_table_size
import interface_mac_limit
import interface
import tunnel_services
import site
import mac_flush
import neighbor
import associate_profile
import mesh_group
import oam
import multi_homing
class vpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/vpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VPLS configuration
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__static_vpls','__encapsulation_type','__control_word','__no_control_word','__site_range','__bum_hashing','__enable_mac_move_action','__label_block_size','__mac_table_size','__interface_mac_limit','__mac_table_aging_time','__no_mac_learning','__mac_statistics','__interface','__tunnel_services','__no_tunnel_services','__site','__community','__vpls_id','__mtu','__ignore_mtu_mismatch','__mac_flush','__ignore_encapsulation_mismatch','__pseudowire_status_tlv','__neighbor','__flow_label_transmit','__flow_label_receive','__associate_profile','__mesh_group','__connectivity_type','__oam','__multi_homing','__designated_forwarder_election_hold_time','__extended_vlan_list',)

  _yang_name = 'vpls'
  _module_name = 'vpls'
  _namespace = 'http://anutanetworks.com/vpls'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__associate_profile = YANGDynClass(base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__control_word = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="control-word", module_name="vpls", parent=self, choice=(u'cword', u'control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__static_vpls = YANGDynClass(base=static_vpls.static_vpls, is_container='container', yang_name="static-vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__flow_label_transmit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label-transmit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__label_block_size = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'8': {}, u'2': {}, u'4': {}, u'16': {}},), is_leaf=True, yang_name="label-block-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)
    self.__site = YANGDynClass(base=YANGListType("site_name",site.site, yang_name="site", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='site-name'), is_container='list', yang_name="site", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    self.__community = YANGDynClass(base=unicode, is_leaf=True, yang_name="community", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    self.__extended_vlan_list = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="extended-vlan-list", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='vlan-range', is_config=True)
    self.__pseudowire_status_tlv = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="pseudowire-status-tlv", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__no_control_word = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-control-word", module_name="vpls", parent=self, choice=(u'cword', u'no-control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__no_tunnel_services = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'no-tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'satop-t1': {}, u'satop-t3': {}, u'ethernet': {}, u'atm-cell-vp-mode': {}, u'frame-relay': {}, u'atm-aal5': {}, u'atm-cell-port-mode': {}, u'interworking': {}, u'ethernet-vlan': {}, u'frame-relay-port-mode': {}, u'ppp': {}, u'satop-e1': {}, u'satop-e3': {}, u'atm-cell-vc-mode': {}, u'atm-cell': {}, u'cesop': {}, u'cisco-hdlc': {}},), is_leaf=True, yang_name="encapsulation-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)
    self.__tunnel_services = YANGDynClass(base=tunnel_services.tunnel_services, is_container='container', yang_name="tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__connectivity_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'irb': {}, u'permanent': {}, u'ce': {}},), is_leaf=True, yang_name="connectivity-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)
    self.__oam = YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__ignore_mtu_mismatch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-mtu-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__mac_flush = YANGDynClass(base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__mac_table_size = YANGDynClass(base=mac_table_size.mac_table_size, is_container='container', yang_name="mac-table-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__enable_mac_move_action = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-mac-move-action", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__mesh_group = YANGDynClass(base=YANGListType("mesh_group_name",mesh_group.mesh_group, yang_name="mesh-group", module_name="vpls", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mesh-group-name'), is_container='list', yang_name="mesh-group", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    self.__mac_statistics = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-statistics", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__interface_mac_limit = YANGDynClass(base=interface_mac_limit.interface_mac_limit, is_container='container', yang_name="interface-mac-limit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__mac_table_aging_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10 .. 1000000']}), is_leaf=True, yang_name="mac-table-aging-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)
    self.__vpls_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    self.__bum_hashing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bum-hashing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__designated_forwarder_election_hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 1800']}), is_leaf=True, yang_name="designated-forwarder-election-hold-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)
    self.__interface = YANGDynClass(base=YANGListType("name",interface.interface, yang_name="interface", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="interface", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    self.__ignore_encapsulation_mismatch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-encapsulation-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__site_range = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 65534']}), is_leaf=True, yang_name="site-range", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)
    self.__multi_homing = YANGDynClass(base=multi_homing.multi_homing, is_container='container', yang_name="multi-homing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'512 .. 65535']}), is_leaf=True, yang_name="mtu", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint16', is_config=True)
    self.__flow_label_receive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label-receive", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    self.__no_mac_learning = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-mac-learning", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'vpls']

  def _get_static_vpls(self):
    """
    Getter method for static_vpls, mapped from YANG variable /devices/device/vpls/static_vpls (container)

    YANG Description: Enables static vpls configuration using no-tunnel-services
    """
    return self.__static_vpls
      
  def _set_static_vpls(self, v, load=False):
    """
    Setter method for static_vpls, mapped from YANG variable /devices/device/vpls/static_vpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_vpls() directly.

    YANG Description: Enables static vpls configuration using no-tunnel-services
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=static_vpls.static_vpls, is_container='container', yang_name="static-vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_vpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=static_vpls.static_vpls, is_container='container', yang_name="static-vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__static_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_vpls(self):
    self.__static_vpls = YANGDynClass(base=static_vpls.static_vpls, is_container='container', yang_name="static-vpls", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_encapsulation_type(self):
    """
    Getter method for encapsulation_type, mapped from YANG variable /devices/device/vpls/encapsulation_type (enumeration)

    YANG Description: Encapsulation type for VPN
    """
    return self.__encapsulation_type
      
  def _set_encapsulation_type(self, v, load=False):
    """
    Setter method for encapsulation_type, mapped from YANG variable /devices/device/vpls/encapsulation_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation_type() directly.

    YANG Description: Encapsulation type for VPN
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'satop-t1': {}, u'satop-t3': {}, u'ethernet': {}, u'atm-cell-vp-mode': {}, u'frame-relay': {}, u'atm-aal5': {}, u'atm-cell-port-mode': {}, u'interworking': {}, u'ethernet-vlan': {}, u'frame-relay-port-mode': {}, u'ppp': {}, u'satop-e1': {}, u'satop-e3': {}, u'atm-cell-vc-mode': {}, u'atm-cell': {}, u'cesop': {}, u'cisco-hdlc': {}},), is_leaf=True, yang_name="encapsulation-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation_type must be of a type compatible with enumeration""",
          'defined-type': "vpls:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'satop-t1': {}, u'satop-t3': {}, u'ethernet': {}, u'atm-cell-vp-mode': {}, u'frame-relay': {}, u'atm-aal5': {}, u'atm-cell-port-mode': {}, u'interworking': {}, u'ethernet-vlan': {}, u'frame-relay-port-mode': {}, u'ppp': {}, u'satop-e1': {}, u'satop-e3': {}, u'atm-cell-vc-mode': {}, u'atm-cell': {}, u'cesop': {}, u'cisco-hdlc': {}},), is_leaf=True, yang_name="encapsulation-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)""",
        })

    self.__encapsulation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation_type(self):
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'satop-t1': {}, u'satop-t3': {}, u'ethernet': {}, u'atm-cell-vp-mode': {}, u'frame-relay': {}, u'atm-aal5': {}, u'atm-cell-port-mode': {}, u'interworking': {}, u'ethernet-vlan': {}, u'frame-relay-port-mode': {}, u'ppp': {}, u'satop-e1': {}, u'satop-e3': {}, u'atm-cell-vc-mode': {}, u'atm-cell': {}, u'cesop': {}, u'cisco-hdlc': {}},), is_leaf=True, yang_name="encapsulation-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)


  def _get_control_word(self):
    """
    Getter method for control_word, mapped from YANG variable /devices/device/vpls/control_word (empty)

    YANG Description: Add control word to the Layer 2 encapsulation
    """
    return self.__control_word
      
  def _set_control_word(self, v, load=False):
    """
    Setter method for control_word, mapped from YANG variable /devices/device/vpls/control_word (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_word is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_word() directly.

    YANG Description: Add control word to the Layer 2 encapsulation
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="control-word", module_name="vpls", parent=self, choice=(u'cword', u'control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_word must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="control-word", module_name="vpls", parent=self, choice=(u'cword', u'control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__control_word = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_word(self):
    self.__control_word = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="control-word", module_name="vpls", parent=self, choice=(u'cword', u'control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_no_control_word(self):
    """
    Getter method for no_control_word, mapped from YANG variable /devices/device/vpls/no_control_word (empty)

    YANG Description: Disables control word on the Layer 2 encapsulation
    """
    return self.__no_control_word
      
  def _set_no_control_word(self, v, load=False):
    """
    Setter method for no_control_word, mapped from YANG variable /devices/device/vpls/no_control_word (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_control_word is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_control_word() directly.

    YANG Description: Disables control word on the Layer 2 encapsulation
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="no-control-word", module_name="vpls", parent=self, choice=(u'cword', u'no-control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_control_word must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-control-word", module_name="vpls", parent=self, choice=(u'cword', u'no-control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__no_control_word = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_control_word(self):
    self.__no_control_word = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-control-word", module_name="vpls", parent=self, choice=(u'cword', u'no-control-word'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_site_range(self):
    """
    Getter method for site_range, mapped from YANG variable /devices/device/vpls/site_range (uint32)

    YANG Description: Maximum site identifier in this VPLS domain
    """
    return self.__site_range
      
  def _set_site_range(self, v, load=False):
    """
    Setter method for site_range, mapped from YANG variable /devices/device/vpls/site_range (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_site_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_site_range() directly.

    YANG Description: Maximum site identifier in this VPLS domain
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 65534']}), is_leaf=True, yang_name="site-range", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """site_range must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 65534']}), is_leaf=True, yang_name="site-range", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)""",
        })

    self.__site_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_site_range(self):
    self.__site_range = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 65534']}), is_leaf=True, yang_name="site-range", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)


  def _get_bum_hashing(self):
    """
    Getter method for bum_hashing, mapped from YANG variable /devices/device/vpls/bum_hashing (empty)

    YANG Description: Enable BUM hashing feature in the instance
    """
    return self.__bum_hashing
      
  def _set_bum_hashing(self, v, load=False):
    """
    Setter method for bum_hashing, mapped from YANG variable /devices/device/vpls/bum_hashing (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bum_hashing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bum_hashing() directly.

    YANG Description: Enable BUM hashing feature in the instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bum-hashing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bum_hashing must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bum-hashing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__bum_hashing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bum_hashing(self):
    self.__bum_hashing = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bum-hashing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_enable_mac_move_action(self):
    """
    Getter method for enable_mac_move_action, mapped from YANG variable /devices/device/vpls/enable_mac_move_action (empty)

    YANG Description: Enable VPLS loop prevention feature in the instance
    """
    return self.__enable_mac_move_action
      
  def _set_enable_mac_move_action(self, v, load=False):
    """
    Setter method for enable_mac_move_action, mapped from YANG variable /devices/device/vpls/enable_mac_move_action (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_mac_move_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_mac_move_action() directly.

    YANG Description: Enable VPLS loop prevention feature in the instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-mac-move-action", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_mac_move_action must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-mac-move-action", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__enable_mac_move_action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_mac_move_action(self):
    self.__enable_mac_move_action = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-mac-move-action", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_label_block_size(self):
    """
    Getter method for label_block_size, mapped from YANG variable /devices/device/vpls/label_block_size (enumeration)

    YANG Description: Label block size for this VPLS instance
    """
    return self.__label_block_size
      
  def _set_label_block_size(self, v, load=False):
    """
    Setter method for label_block_size, mapped from YANG variable /devices/device/vpls/label_block_size (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label_block_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label_block_size() directly.

    YANG Description: Label block size for this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'8': {}, u'2': {}, u'4': {}, u'16': {}},), is_leaf=True, yang_name="label-block-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label_block_size must be of a type compatible with enumeration""",
          'defined-type': "vpls:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'8': {}, u'2': {}, u'4': {}, u'16': {}},), is_leaf=True, yang_name="label-block-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)""",
        })

    self.__label_block_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label_block_size(self):
    self.__label_block_size = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'8': {}, u'2': {}, u'4': {}, u'16': {}},), is_leaf=True, yang_name="label-block-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)


  def _get_mac_table_size(self):
    """
    Getter method for mac_table_size, mapped from YANG variable /devices/device/vpls/mac_table_size (container)

    YANG Description: Size of MAC address forwarding table
    """
    return self.__mac_table_size
      
  def _set_mac_table_size(self, v, load=False):
    """
    Setter method for mac_table_size, mapped from YANG variable /devices/device/vpls/mac_table_size (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_table_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_table_size() directly.

    YANG Description: Size of MAC address forwarding table
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mac_table_size.mac_table_size, is_container='container', yang_name="mac-table-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_table_size must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_table_size.mac_table_size, is_container='container', yang_name="mac-table-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__mac_table_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_table_size(self):
    self.__mac_table_size = YANGDynClass(base=mac_table_size.mac_table_size, is_container='container', yang_name="mac-table-size", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_interface_mac_limit(self):
    """
    Getter method for interface_mac_limit, mapped from YANG variable /devices/device/vpls/interface_mac_limit (container)

    YANG Description: Maximum MAC address learned per interface
    """
    return self.__interface_mac_limit
      
  def _set_interface_mac_limit(self, v, load=False):
    """
    Setter method for interface_mac_limit, mapped from YANG variable /devices/device/vpls/interface_mac_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_mac_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_mac_limit() directly.

    YANG Description: Maximum MAC address learned per interface
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=interface_mac_limit.interface_mac_limit, is_container='container', yang_name="interface-mac-limit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_mac_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interface_mac_limit.interface_mac_limit, is_container='container', yang_name="interface-mac-limit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__interface_mac_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_mac_limit(self):
    self.__interface_mac_limit = YANGDynClass(base=interface_mac_limit.interface_mac_limit, is_container='container', yang_name="interface-mac-limit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_mac_table_aging_time(self):
    """
    Getter method for mac_table_aging_time, mapped from YANG variable /devices/device/vpls/mac_table_aging_time (uint32)

    YANG Description: Delay for discarding MAC address if no updates are received
    """
    return self.__mac_table_aging_time
      
  def _set_mac_table_aging_time(self, v, load=False):
    """
    Setter method for mac_table_aging_time, mapped from YANG variable /devices/device/vpls/mac_table_aging_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_table_aging_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_table_aging_time() directly.

    YANG Description: Delay for discarding MAC address if no updates are received
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10 .. 1000000']}), is_leaf=True, yang_name="mac-table-aging-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_table_aging_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10 .. 1000000']}), is_leaf=True, yang_name="mac-table-aging-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)""",
        })

    self.__mac_table_aging_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_table_aging_time(self):
    self.__mac_table_aging_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'10 .. 1000000']}), is_leaf=True, yang_name="mac-table-aging-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)


  def _get_no_mac_learning(self):
    """
    Getter method for no_mac_learning, mapped from YANG variable /devices/device/vpls/no_mac_learning (empty)

    YANG Description: Disable dynamic MAC address learning
    """
    return self.__no_mac_learning
      
  def _set_no_mac_learning(self, v, load=False):
    """
    Setter method for no_mac_learning, mapped from YANG variable /devices/device/vpls/no_mac_learning (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_mac_learning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_mac_learning() directly.

    YANG Description: Disable dynamic MAC address learning
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="no-mac-learning", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_mac_learning must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-mac-learning", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__no_mac_learning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_mac_learning(self):
    self.__no_mac_learning = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-mac-learning", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_mac_statistics(self):
    """
    Getter method for mac_statistics, mapped from YANG variable /devices/device/vpls/mac_statistics (empty)

    YANG Description: Enable MAC address statistics
    """
    return self.__mac_statistics
      
  def _set_mac_statistics(self, v, load=False):
    """
    Setter method for mac_statistics, mapped from YANG variable /devices/device/vpls/mac_statistics (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_statistics() directly.

    YANG Description: Enable MAC address statistics
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mac-statistics", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_statistics must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-statistics", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__mac_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_statistics(self):
    self.__mac_statistics = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-statistics", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /devices/device/vpls/interface (list)

    YANG Description: Interface that connect this site to the VPN
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /devices/device/vpls/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Interface that connect this site to the VPN
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("name",interface.interface, yang_name="interface", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="interface", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",interface.interface, yang_name="interface", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="interface", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",interface.interface, yang_name="interface", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="interface", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)


  def _get_tunnel_services(self):
    """
    Getter method for tunnel_services, mapped from YANG variable /devices/device/vpls/tunnel_services (container)

    YANG Description: Use tunnel services for this VPLS instance
    """
    return self.__tunnel_services
      
  def _set_tunnel_services(self, v, load=False):
    """
    Setter method for tunnel_services, mapped from YANG variable /devices/device/vpls/tunnel_services (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_services() directly.

    YANG Description: Use tunnel services for this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tunnel_services.tunnel_services, is_container='container', yang_name="tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_services must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tunnel_services.tunnel_services, is_container='container', yang_name="tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__tunnel_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_services(self):
    self.__tunnel_services = YANGDynClass(base=tunnel_services.tunnel_services, is_container='container', yang_name="tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_no_tunnel_services(self):
    """
    Getter method for no_tunnel_services, mapped from YANG variable /devices/device/vpls/no_tunnel_services (empty)

    YANG Description: Do not use tunnel services for this VPLS instance
    """
    return self.__no_tunnel_services
      
  def _set_no_tunnel_services(self, v, load=False):
    """
    Setter method for no_tunnel_services, mapped from YANG variable /devices/device/vpls/no_tunnel_services (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_tunnel_services is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_tunnel_services() directly.

    YANG Description: Do not use tunnel services for this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="no-tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'no-tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_tunnel_services must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'no-tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__no_tunnel_services = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_tunnel_services(self):
    self.__no_tunnel_services = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-tunnel-services", module_name="vpls", parent=self, choice=(u'tunnel-services-choice', u'no-tunnel-services'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_site(self):
    """
    Getter method for site, mapped from YANG variable /devices/device/vpls/site (list)

    YANG Description: Sites connected to this provider equipment
    """
    return self.__site
      
  def _set_site(self, v, load=False):
    """
    Setter method for site, mapped from YANG variable /devices/device/vpls/site (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_site is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_site() directly.

    YANG Description: Sites connected to this provider equipment
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("site_name",site.site, yang_name="site", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='site-name'), is_container='list', yang_name="site", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """site must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("site_name",site.site, yang_name="site", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='site-name'), is_container='list', yang_name="site", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)""",
        })

    self.__site = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_site(self):
    self.__site = YANGDynClass(base=YANGListType("site_name",site.site, yang_name="site", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='site-name'), is_container='list', yang_name="site", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)


  def _get_community(self):
    """
    Getter method for community, mapped from YANG variable /devices/device/vpls/community (string)

    YANG Description: Community associated with this VPLS instance
    """
    return self.__community
      
  def _set_community(self, v, load=False):
    """
    Setter method for community, mapped from YANG variable /devices/device/vpls/community (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community() directly.

    YANG Description: Community associated with this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="community", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="community", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)""",
        })

    self.__community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community(self):
    self.__community = YANGDynClass(base=unicode, is_leaf=True, yang_name="community", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)


  def _get_vpls_id(self):
    """
    Getter method for vpls_id, mapped from YANG variable /devices/device/vpls/vpls_id (string)

    YANG Description: Identifier for this VPLS instance
    """
    return self.__vpls_id
      
  def _set_vpls_id(self, v, load=False):
    """
    Setter method for vpls_id, mapped from YANG variable /devices/device/vpls/vpls_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpls_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpls_id() directly.

    YANG Description: Identifier for this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpls_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)""",
        })

    self.__vpls_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpls_id(self):
    self.__vpls_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-id", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='string', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /devices/device/vpls/mtu (uint16)

    YANG Description: MTU to be advertised to the remote end
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /devices/device/vpls/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: MTU to be advertised to the remote end
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'512 .. 65535']}), is_leaf=True, yang_name="mtu", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'512 .. 65535']}), is_leaf=True, yang_name="mtu", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint16', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'512 .. 65535']}), is_leaf=True, yang_name="mtu", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint16', is_config=True)


  def _get_ignore_mtu_mismatch(self):
    """
    Getter method for ignore_mtu_mismatch, mapped from YANG variable /devices/device/vpls/ignore_mtu_mismatch (empty)

    YANG Description: Allow different MTU values on local and remote end
    """
    return self.__ignore_mtu_mismatch
      
  def _set_ignore_mtu_mismatch(self, v, load=False):
    """
    Setter method for ignore_mtu_mismatch, mapped from YANG variable /devices/device/vpls/ignore_mtu_mismatch (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_mtu_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_mtu_mismatch() directly.

    YANG Description: Allow different MTU values on local and remote end
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ignore-mtu-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_mtu_mismatch must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-mtu-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__ignore_mtu_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_mtu_mismatch(self):
    self.__ignore_mtu_mismatch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-mtu-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_mac_flush(self):
    """
    Getter method for mac_flush, mapped from YANG variable /devices/device/vpls/mac_flush (container)

    YANG Description: Enables mac-flush processing
    """
    return self.__mac_flush
      
  def _set_mac_flush(self, v, load=False):
    """
    Setter method for mac_flush, mapped from YANG variable /devices/device/vpls/mac_flush (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_flush is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_flush() directly.

    YANG Description: Enables mac-flush processing
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_flush must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__mac_flush = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_flush(self):
    self.__mac_flush = YANGDynClass(base=mac_flush.mac_flush, is_container='container', yang_name="mac-flush", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_ignore_encapsulation_mismatch(self):
    """
    Getter method for ignore_encapsulation_mismatch, mapped from YANG variable /devices/device/vpls/ignore_encapsulation_mismatch (empty)

    YANG Description: Allow different encapsulation types on local and remote end
    """
    return self.__ignore_encapsulation_mismatch
      
  def _set_ignore_encapsulation_mismatch(self, v, load=False):
    """
    Setter method for ignore_encapsulation_mismatch, mapped from YANG variable /devices/device/vpls/ignore_encapsulation_mismatch (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_encapsulation_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_encapsulation_mismatch() directly.

    YANG Description: Allow different encapsulation types on local and remote end
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ignore-encapsulation-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_encapsulation_mismatch must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-encapsulation-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__ignore_encapsulation_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_encapsulation_mismatch(self):
    self.__ignore_encapsulation_mismatch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ignore-encapsulation-mismatch", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_pseudowire_status_tlv(self):
    """
    Getter method for pseudowire_status_tlv, mapped from YANG variable /devices/device/vpls/pseudowire_status_tlv (empty)

    YANG Description: Send pseudowire status TLV
    """
    return self.__pseudowire_status_tlv
      
  def _set_pseudowire_status_tlv(self, v, load=False):
    """
    Setter method for pseudowire_status_tlv, mapped from YANG variable /devices/device/vpls/pseudowire_status_tlv (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pseudowire_status_tlv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pseudowire_status_tlv() directly.

    YANG Description: Send pseudowire status TLV
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="pseudowire-status-tlv", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pseudowire_status_tlv must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="pseudowire-status-tlv", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__pseudowire_status_tlv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pseudowire_status_tlv(self):
    self.__pseudowire_status_tlv = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="pseudowire-status-tlv", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /devices/device/vpls/neighbor (list)

    YANG Description: Neighbor for this VPLS instance
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /devices/device/vpls/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: Neighbor for this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_id",neighbor.neighbor, yang_name="neighbor", module_name="vpls", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='neighbor-id'), is_container='list', yang_name="neighbor", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)


  def _get_flow_label_transmit(self):
    """
    Getter method for flow_label_transmit, mapped from YANG variable /devices/device/vpls/flow_label_transmit (empty)

    YANG Description: Advertise capability to push Flow Label in transmit direction to remote PE
    """
    return self.__flow_label_transmit
      
  def _set_flow_label_transmit(self, v, load=False):
    """
    Setter method for flow_label_transmit, mapped from YANG variable /devices/device/vpls/flow_label_transmit (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_label_transmit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_label_transmit() directly.

    YANG Description: Advertise capability to push Flow Label in transmit direction to remote PE
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="flow-label-transmit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_label_transmit must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label-transmit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__flow_label_transmit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_label_transmit(self):
    self.__flow_label_transmit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label-transmit", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_flow_label_receive(self):
    """
    Getter method for flow_label_receive, mapped from YANG variable /devices/device/vpls/flow_label_receive (empty)

    YANG Description: Advertise capability to pop Flow Label in receive direction to remote PE
    """
    return self.__flow_label_receive
      
  def _set_flow_label_receive(self, v, load=False):
    """
    Setter method for flow_label_receive, mapped from YANG variable /devices/device/vpls/flow_label_receive (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_label_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_label_receive() directly.

    YANG Description: Advertise capability to pop Flow Label in receive direction to remote PE
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="flow-label-receive", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_label_receive must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label-receive", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)""",
        })

    self.__flow_label_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_label_receive(self):
    self.__flow_label_receive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label-receive", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='empty', is_config=True)


  def _get_associate_profile(self):
    """
    Getter method for associate_profile, mapped from YANG variable /devices/device/vpls/associate_profile (container)

    YANG Description: Associate profile options for dynamic IFL
    """
    return self.__associate_profile
      
  def _set_associate_profile(self, v, load=False):
    """
    Setter method for associate_profile, mapped from YANG variable /devices/device/vpls/associate_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associate_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associate_profile() directly.

    YANG Description: Associate profile options for dynamic IFL
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """associate_profile must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__associate_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_associate_profile(self):
    self.__associate_profile = YANGDynClass(base=associate_profile.associate_profile, is_container='container', yang_name="associate-profile", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_mesh_group(self):
    """
    Getter method for mesh_group, mapped from YANG variable /devices/device/vpls/mesh_group (list)

    YANG Description: Mesh-group under this VPLS instance
    """
    return self.__mesh_group
      
  def _set_mesh_group(self, v, load=False):
    """
    Setter method for mesh_group, mapped from YANG variable /devices/device/vpls/mesh_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mesh_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mesh_group() directly.

    YANG Description: Mesh-group under this VPLS instance
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("mesh_group_name",mesh_group.mesh_group, yang_name="mesh-group", module_name="vpls", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mesh-group-name'), is_container='list', yang_name="mesh-group", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mesh_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mesh_group_name",mesh_group.mesh_group, yang_name="mesh-group", module_name="vpls", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mesh-group-name'), is_container='list', yang_name="mesh-group", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)""",
        })

    self.__mesh_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mesh_group(self):
    self.__mesh_group = YANGDynClass(base=YANGListType("mesh_group_name",mesh_group.mesh_group, yang_name="mesh-group", module_name="vpls", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mesh-group-name'), is_container='list', yang_name="mesh-group", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='list', is_config=True)


  def _get_connectivity_type(self):
    """
    Getter method for connectivity_type, mapped from YANG variable /devices/device/vpls/connectivity_type (enumeration)

    YANG Description: Specify type of interface sufficient to bring vpls connection up
    """
    return self.__connectivity_type
      
  def _set_connectivity_type(self, v, load=False):
    """
    Setter method for connectivity_type, mapped from YANG variable /devices/device/vpls/connectivity_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectivity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectivity_type() directly.

    YANG Description: Specify type of interface sufficient to bring vpls connection up
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'irb': {}, u'permanent': {}, u'ce': {}},), is_leaf=True, yang_name="connectivity-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connectivity_type must be of a type compatible with enumeration""",
          'defined-type': "vpls:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'irb': {}, u'permanent': {}, u'ce': {}},), is_leaf=True, yang_name="connectivity-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)""",
        })

    self.__connectivity_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connectivity_type(self):
    self.__connectivity_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'irb': {}, u'permanent': {}, u'ce': {}},), is_leaf=True, yang_name="connectivity-type", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='enumeration', is_config=True)


  def _get_oam(self):
    """
    Getter method for oam, mapped from YANG variable /devices/device/vpls/oam (container)

    YANG Description: OAM Configuration for VPN
    """
    return self.__oam
      
  def _set_oam(self, v, load=False):
    """
    Setter method for oam, mapped from YANG variable /devices/device/vpls/oam (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oam is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oam() directly.

    YANG Description: OAM Configuration for VPN
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=oam.oam, is_container='container', yang_name="oam", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oam must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__oam = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oam(self):
    self.__oam = YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_multi_homing(self):
    """
    Getter method for multi_homing, mapped from YANG variable /devices/device/vpls/multi_homing (container)

    YANG Description: Multi-homing configuration for FEC129 VPLS
    """
    return self.__multi_homing
      
  def _set_multi_homing(self, v, load=False):
    """
    Setter method for multi_homing, mapped from YANG variable /devices/device/vpls/multi_homing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multi_homing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multi_homing() directly.

    YANG Description: Multi-homing configuration for FEC129 VPLS
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=multi_homing.multi_homing, is_container='container', yang_name="multi-homing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multi_homing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=multi_homing.multi_homing, is_container='container', yang_name="multi-homing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)""",
        })

    self.__multi_homing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multi_homing(self):
    self.__multi_homing = YANGDynClass(base=multi_homing.multi_homing, is_container='container', yang_name="multi-homing", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='container', is_config=True)


  def _get_designated_forwarder_election_hold_time(self):
    """
    Getter method for designated_forwarder_election_hold_time, mapped from YANG variable /devices/device/vpls/designated_forwarder_election_hold_time (uint32)

    YANG Description: Time to wait before electing a DF(seconds)
    """
    return self.__designated_forwarder_election_hold_time
      
  def _set_designated_forwarder_election_hold_time(self, v, load=False):
    """
    Setter method for designated_forwarder_election_hold_time, mapped from YANG variable /devices/device/vpls/designated_forwarder_election_hold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_designated_forwarder_election_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_designated_forwarder_election_hold_time() directly.

    YANG Description: Time to wait before electing a DF(seconds)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 1800']}), is_leaf=True, yang_name="designated-forwarder-election-hold-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """designated_forwarder_election_hold_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 1800']}), is_leaf=True, yang_name="designated-forwarder-election-hold-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)""",
        })

    self.__designated_forwarder_election_hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_designated_forwarder_election_hold_time(self):
    self.__designated_forwarder_election_hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1 .. 1800']}), is_leaf=True, yang_name="designated-forwarder-election-hold-time", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='uint32', is_config=True)


  def _get_extended_vlan_list(self):
    """
    Getter method for extended_vlan_list, mapped from YANG variable /devices/device/vpls/extended_vlan_list (vlan-range)

    YANG Description: List of VLAN identifiers that are to be EVPN extended
    """
    return self.__extended_vlan_list
      
  def _set_extended_vlan_list(self, v, load=False):
    """
    Setter method for extended_vlan_list, mapped from YANG variable /devices/device/vpls/extended_vlan_list (vlan-range)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_vlan_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_vlan_list() directly.

    YANG Description: List of VLAN identifiers that are to be EVPN extended
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="extended-vlan-list", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='vlan-range', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_vlan_list must be of a type compatible with vlan-range""",
          'defined-type': "vpls:vlan-range",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="extended-vlan-list", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='vlan-range', is_config=True)""",
        })

    self.__extended_vlan_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_vlan_list(self):
    self.__extended_vlan_list = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="extended-vlan-list", module_name="vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vpls', defining_module='vpls', yang_type='vlan-range', is_config=True)

  static_vpls = __builtin__.property(_get_static_vpls, _set_static_vpls)
  encapsulation_type = __builtin__.property(_get_encapsulation_type, _set_encapsulation_type)
  control_word = __builtin__.property(_get_control_word, _set_control_word)
  no_control_word = __builtin__.property(_get_no_control_word, _set_no_control_word)
  site_range = __builtin__.property(_get_site_range, _set_site_range)
  bum_hashing = __builtin__.property(_get_bum_hashing, _set_bum_hashing)
  enable_mac_move_action = __builtin__.property(_get_enable_mac_move_action, _set_enable_mac_move_action)
  label_block_size = __builtin__.property(_get_label_block_size, _set_label_block_size)
  mac_table_size = __builtin__.property(_get_mac_table_size, _set_mac_table_size)
  interface_mac_limit = __builtin__.property(_get_interface_mac_limit, _set_interface_mac_limit)
  mac_table_aging_time = __builtin__.property(_get_mac_table_aging_time, _set_mac_table_aging_time)
  no_mac_learning = __builtin__.property(_get_no_mac_learning, _set_no_mac_learning)
  mac_statistics = __builtin__.property(_get_mac_statistics, _set_mac_statistics)
  interface = __builtin__.property(_get_interface, _set_interface)
  tunnel_services = __builtin__.property(_get_tunnel_services, _set_tunnel_services)
  no_tunnel_services = __builtin__.property(_get_no_tunnel_services, _set_no_tunnel_services)
  site = __builtin__.property(_get_site, _set_site)
  community = __builtin__.property(_get_community, _set_community)
  vpls_id = __builtin__.property(_get_vpls_id, _set_vpls_id)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  ignore_mtu_mismatch = __builtin__.property(_get_ignore_mtu_mismatch, _set_ignore_mtu_mismatch)
  mac_flush = __builtin__.property(_get_mac_flush, _set_mac_flush)
  ignore_encapsulation_mismatch = __builtin__.property(_get_ignore_encapsulation_mismatch, _set_ignore_encapsulation_mismatch)
  pseudowire_status_tlv = __builtin__.property(_get_pseudowire_status_tlv, _set_pseudowire_status_tlv)
  neighbor = __builtin__.property(_get_neighbor, _set_neighbor)
  flow_label_transmit = __builtin__.property(_get_flow_label_transmit, _set_flow_label_transmit)
  flow_label_receive = __builtin__.property(_get_flow_label_receive, _set_flow_label_receive)
  associate_profile = __builtin__.property(_get_associate_profile, _set_associate_profile)
  mesh_group = __builtin__.property(_get_mesh_group, _set_mesh_group)
  connectivity_type = __builtin__.property(_get_connectivity_type, _set_connectivity_type)
  oam = __builtin__.property(_get_oam, _set_oam)
  multi_homing = __builtin__.property(_get_multi_homing, _set_multi_homing)
  designated_forwarder_election_hold_time = __builtin__.property(_get_designated_forwarder_election_hold_time, _set_designated_forwarder_election_hold_time)
  extended_vlan_list = __builtin__.property(_get_extended_vlan_list, _set_extended_vlan_list)

  __choices__ = {u'cword': {u'control-word': [u'control_word'], u'no-control-word': [u'no_control_word']}, u'tunnel-services-choice': {u'tunnel-services': [u'tunnel_services'], u'no-tunnel-services': [u'no_tunnel_services']}}
  _pyangbind_elements = collections.OrderedDict([('static_vpls', static_vpls), ('encapsulation_type', encapsulation_type), ('control_word', control_word), ('no_control_word', no_control_word), ('site_range', site_range), ('bum_hashing', bum_hashing), ('enable_mac_move_action', enable_mac_move_action), ('label_block_size', label_block_size), ('mac_table_size', mac_table_size), ('interface_mac_limit', interface_mac_limit), ('mac_table_aging_time', mac_table_aging_time), ('no_mac_learning', no_mac_learning), ('mac_statistics', mac_statistics), ('interface', interface), ('tunnel_services', tunnel_services), ('no_tunnel_services', no_tunnel_services), ('site', site), ('community', community), ('vpls_id', vpls_id), ('mtu', mtu), ('ignore_mtu_mismatch', ignore_mtu_mismatch), ('mac_flush', mac_flush), ('ignore_encapsulation_mismatch', ignore_encapsulation_mismatch), ('pseudowire_status_tlv', pseudowire_status_tlv), ('neighbor', neighbor), ('flow_label_transmit', flow_label_transmit), ('flow_label_receive', flow_label_receive), ('associate_profile', associate_profile), ('mesh_group', mesh_group), ('connectivity_type', connectivity_type), ('oam', oam), ('multi_homing', multi_homing), ('designated_forwarder_election_hold_time', designated_forwarder_election_hold_time), ('extended_vlan_list', extended_vlan_list), ])


