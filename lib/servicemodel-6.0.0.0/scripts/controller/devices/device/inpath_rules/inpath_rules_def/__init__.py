
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class inpath_rules_def(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/inpath-rules/inpath-rules-def. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__rulenum','__rule_type','__packet_mode_uni','__srcaddr','__srcport','__dstaddr','__dstport','__dst_domain','__dst_host','__optimization','__preoptimization','__latency_opt','__vlan','__neural_mode','__cloud_accel','__web_proxy','__wan_visibility','__wan_vis_opt','__description','__auto_kickoff','__rule_enable','__protocol','__target_addr','__target_port','__backup_addr','__backup_port',)

  _yang_name = 'inpath-rules-def'
  _module_name = 'wanoptimizer'
  _namespace = 'http://anutanetworks.com/wanoptimizer'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__protocol = YANGDynClass(base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'any': {}, u'tcp': {}},),], is_leaf=True, yang_name="protocol", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__target_addr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="target-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__auto_kickoff = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="auto-kickoff", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__packet_mode_uni = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'packet-mode-uni': {}},), is_leaf=True, yang_name="packet-mode-uni", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__backup_port = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="backup-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__dst_domain = YANGDynClass(base=unicode, is_leaf=True, yang_name="dst-domain", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)
    self.__rulenum = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'start': {}, u'end': {}},),], is_leaf=True, yang_name="rulenum", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__preoptimization = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'oracle-forms': {}, u'ssl': {}, u'none': {}, u'oracle-forms+ssl': {}},), is_leaf=True, yang_name="preoptimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__dstport = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="dstport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), restriction_dict={'range': [u'-1..4096']}), is_leaf=True, yang_name="vlan", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='int16', is_config=True)
    self.__web_proxy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'none': {}, u'force': {}},), is_leaf=True, yang_name="web-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__srcaddr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="srcaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__target_port = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="target-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__wan_visibility = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'full': {}, u'correct': {}, u'port': {}},), is_leaf=True, yang_name="wan-visibility", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__rule_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rule-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='boolean', is_config=True)
    self.__rule_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'discard': {}, u'deny': {}, u'pass-through': {}, u'fixed-target': {}, u'auto-discover': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__latency_opt = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'exchange-auto': {}, u'none': {}, u'http': {}, u'normal': {}, u'outlook-anywhr': {}, u'citrix': {}},), is_leaf=True, yang_name="latency-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__srcport = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="srcport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__backup_addr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ip-address', is_config=True)
    self.__dst_host = YANGDynClass(base=unicode, is_leaf=True, yang_name="dst-host", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)
    self.__optimization = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sdr-only': {}, u'compr-only': {}, u'none': {}, u'sdr-m': {}, u'normal': {}},), is_leaf=True, yang_name="optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__wan_vis_opt = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'fwd-reset': {}, u'none': {}},), is_leaf=True, yang_name="wan-vis-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__neural_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'never': {}, u'dynamic': {}, u'tcphints': {}},), is_leaf=True, yang_name="neural-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__cloud_accel = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'passthru': {}, u'auto': {}},), is_leaf=True, yang_name="cloud-accel", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__dstaddr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="dstaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'inpath-rules', u'inpath-rules-def']

  def _get_rulenum(self):
    """
    Getter method for rulenum, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/rulenum (union)

    YANG Description: The rule is inserted into the list at the specified position.
    """
    return self.__rulenum
      
  def _set_rulenum(self, v, load=False):
    """
    Setter method for rulenum, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/rulenum (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rulenum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rulenum() directly.

    YANG Description: The rule is inserted into the list at the specified position.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'start': {}, u'end': {}},),], is_leaf=True, yang_name="rulenum", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rulenum must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'start': {}, u'end': {}},),], is_leaf=True, yang_name="rulenum", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__rulenum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rulenum(self):
    self.__rulenum = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'start': {}, u'end': {}},),], is_leaf=True, yang_name="rulenum", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_rule_type(self):
    """
    Getter method for rule_type, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/rule_type (enumeration)

    YANG Description: auto-discover
pass-through
discard
deny
fixed-target

    """
    return self.__rule_type
      
  def _set_rule_type(self, v, load=False):
    """
    Setter method for rule_type, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/rule_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_type() directly.

    YANG Description: auto-discover
pass-through
discard
deny
fixed-target

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'discard': {}, u'deny': {}, u'pass-through': {}, u'fixed-target': {}, u'auto-discover': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_type must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'discard': {}, u'deny': {}, u'pass-through': {}, u'fixed-target': {}, u'auto-discover': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__rule_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_type(self):
    self.__rule_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'discard': {}, u'deny': {}, u'pass-through': {}, u'fixed-target': {}, u'auto-discover': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_packet_mode_uni(self):
    """
    Getter method for packet_mode_uni, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/packet_mode_uni (enumeration)

    YANG Description: packet-mode-uni

    """
    return self.__packet_mode_uni
      
  def _set_packet_mode_uni(self, v, load=False):
    """
    Setter method for packet_mode_uni, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/packet_mode_uni (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_mode_uni is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_mode_uni() directly.

    YANG Description: packet-mode-uni

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'packet-mode-uni': {}},), is_leaf=True, yang_name="packet-mode-uni", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_mode_uni must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'packet-mode-uni': {}},), is_leaf=True, yang_name="packet-mode-uni", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__packet_mode_uni = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_mode_uni(self):
    self.__packet_mode_uni = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'packet-mode-uni': {}},), is_leaf=True, yang_name="packet-mode-uni", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_srcaddr(self):
    """
    Getter method for srcaddr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/srcaddr (union)

    YANG Description: Union Input types:
inet:ipv4-prefix
enumeration

    """
    return self.__srcaddr
      
  def _set_srcaddr(self, v, load=False):
    """
    Setter method for srcaddr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/srcaddr (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcaddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcaddr() directly.

    YANG Description: Union Input types:
inet:ipv4-prefix
enumeration

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="srcaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcaddr must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="srcaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__srcaddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcaddr(self):
    self.__srcaddr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="srcaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_srcport(self):
    """
    Getter method for srcport, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/srcport (union)

    YANG Description: Union Input types:
string
leafref

    """
    return self.__srcport
      
  def _set_srcport(self, v, load=False):
    """
    Setter method for srcport, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/srcport (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcport() directly.

    YANG Description: Union Input types:
string
leafref

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,unicode,], is_leaf=True, yang_name="srcport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcport must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="srcport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__srcport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcport(self):
    self.__srcport = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="srcport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_dstaddr(self):
    """
    Getter method for dstaddr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dstaddr (union)

    YANG Description: Union Input types:
inet:ipv4-prefix
enumeration

    """
    return self.__dstaddr
      
  def _set_dstaddr(self, v, load=False):
    """
    Setter method for dstaddr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dstaddr (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstaddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstaddr() directly.

    YANG Description: Union Input types:
inet:ipv4-prefix
enumeration

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="dstaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstaddr must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="dstaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__dstaddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstaddr(self):
    self.__dstaddr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="dstaddr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_dstport(self):
    """
    Getter method for dstport, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dstport (union)

    YANG Description: Union Input types:
string
leafref

    """
    return self.__dstport
      
  def _set_dstport(self, v, load=False):
    """
    Setter method for dstport, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dstport (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstport() directly.

    YANG Description: Union Input types:
string
leafref

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,unicode,], is_leaf=True, yang_name="dstport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstport must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="dstport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__dstport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstport(self):
    self.__dstport = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="dstport", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_dst_domain(self):
    """
    Getter method for dst_domain, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dst_domain (leafref)

    YANG Description: dst-domain
    """
    return self.__dst_domain
      
  def _set_dst_domain(self, v, load=False):
    """
    Setter method for dst_domain, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dst_domain (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_domain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_domain() directly.

    YANG Description: dst-domain
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dst-domain", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_domain must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dst-domain", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)""",
        })

    self.__dst_domain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_domain(self):
    self.__dst_domain = YANGDynClass(base=unicode, is_leaf=True, yang_name="dst-domain", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)


  def _get_dst_host(self):
    """
    Getter method for dst_host, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dst_host (leafref)

    YANG Description: dst-host
    """
    return self.__dst_host
      
  def _set_dst_host(self, v, load=False):
    """
    Setter method for dst_host, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/dst_host (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_host() directly.

    YANG Description: dst-host
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dst-host", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_host must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dst-host", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)""",
        })

    self.__dst_host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_host(self):
    self.__dst_host = YANGDynClass(base=unicode, is_leaf=True, yang_name="dst-host", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='leafref', is_config=True)


  def _get_optimization(self):
    """
    Getter method for optimization, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/optimization (enumeration)

    YANG Description: normal - Performs LZ compression and SDR. This is the default optimization policy.
sdr-only - Turns off LZ compression.
sdr-m - Performs data reduction entirely in memory, which prevents the SteelHead from reading and writing to and from the disk.
compr-only - Turns off SDR but perform LZ compression.
none - Turns off LZ compression and SDR.
    """
    return self.__optimization
      
  def _set_optimization(self, v, load=False):
    """
    Setter method for optimization, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/optimization (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optimization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optimization() directly.

    YANG Description: normal - Performs LZ compression and SDR. This is the default optimization policy.
sdr-only - Turns off LZ compression.
sdr-m - Performs data reduction entirely in memory, which prevents the SteelHead from reading and writing to and from the disk.
compr-only - Turns off SDR but perform LZ compression.
none - Turns off LZ compression and SDR.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sdr-only': {}, u'compr-only': {}, u'none': {}, u'sdr-m': {}, u'normal': {}},), is_leaf=True, yang_name="optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optimization must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sdr-only': {}, u'compr-only': {}, u'none': {}, u'sdr-m': {}, u'normal': {}},), is_leaf=True, yang_name="optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__optimization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optimization(self):
    self.__optimization = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'sdr-only': {}, u'compr-only': {}, u'none': {}, u'sdr-m': {}, u'normal': {}},), is_leaf=True, yang_name="optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_preoptimization(self):
    """
    Getter method for preoptimization, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/preoptimization (enumeration)

    YANG Description: enum ssl - Enables SSL preoptimization processing for traffic via SSL secure ports.
enum oracle-forms - Enables preoptimization processing for the Oracle Forms browser plug-in. This policy is not compatible with IPv6.
enum oracle-forms+ssl - Enables preoptimization processing for both the Oracle Forms browser plug-in and SSL encrypted traffic through SSL secure ports on the client-side SteelHead. This policy is not compatible with IPv6.
enum none - If SSL or Oracle Forms preoptimization processing is turned on and you want to turn it off for a port, specify none.
    """
    return self.__preoptimization
      
  def _set_preoptimization(self, v, load=False):
    """
    Setter method for preoptimization, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/preoptimization (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preoptimization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preoptimization() directly.

    YANG Description: enum ssl - Enables SSL preoptimization processing for traffic via SSL secure ports.
enum oracle-forms - Enables preoptimization processing for the Oracle Forms browser plug-in. This policy is not compatible with IPv6.
enum oracle-forms+ssl - Enables preoptimization processing for both the Oracle Forms browser plug-in and SSL encrypted traffic through SSL secure ports on the client-side SteelHead. This policy is not compatible with IPv6.
enum none - If SSL or Oracle Forms preoptimization processing is turned on and you want to turn it off for a port, specify none.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'oracle-forms': {}, u'ssl': {}, u'none': {}, u'oracle-forms+ssl': {}},), is_leaf=True, yang_name="preoptimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preoptimization must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'oracle-forms': {}, u'ssl': {}, u'none': {}, u'oracle-forms+ssl': {}},), is_leaf=True, yang_name="preoptimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__preoptimization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preoptimization(self):
    self.__preoptimization = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'oracle-forms': {}, u'ssl': {}, u'none': {}, u'oracle-forms+ssl': {}},), is_leaf=True, yang_name="preoptimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_latency_opt(self):
    """
    Getter method for latency_opt, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/latency_opt (enumeration)

    YANG Description: citrix - Always uses Citrix optimization on connections matching this rule.
http - Performs HTTP optimization on connections matching this rule.
normal - Performs HTTP optimization on ports 80, 8080, and (with SSL preoptimization) 443.
outlook-anywhr - Always uses Outlook-Anywhere optimization on the connection.
exchange-auto - Automatically detects MAPI transport protocols (Autodiscover, Outlook Anywhere, and MAPI over HTTP) and HTTP traffic.
none - Does not perform latency optimization on connections matching this rule.
    """
    return self.__latency_opt
      
  def _set_latency_opt(self, v, load=False):
    """
    Setter method for latency_opt, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/latency_opt (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency_opt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency_opt() directly.

    YANG Description: citrix - Always uses Citrix optimization on connections matching this rule.
http - Performs HTTP optimization on connections matching this rule.
normal - Performs HTTP optimization on ports 80, 8080, and (with SSL preoptimization) 443.
outlook-anywhr - Always uses Outlook-Anywhere optimization on the connection.
exchange-auto - Automatically detects MAPI transport protocols (Autodiscover, Outlook Anywhere, and MAPI over HTTP) and HTTP traffic.
none - Does not perform latency optimization on connections matching this rule.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'exchange-auto': {}, u'none': {}, u'http': {}, u'normal': {}, u'outlook-anywhr': {}, u'citrix': {}},), is_leaf=True, yang_name="latency-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latency_opt must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'exchange-auto': {}, u'none': {}, u'http': {}, u'normal': {}, u'outlook-anywhr': {}, u'citrix': {}},), is_leaf=True, yang_name="latency-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__latency_opt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latency_opt(self):
    self.__latency_opt = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'exchange-auto': {}, u'none': {}, u'http': {}, u'normal': {}, u'outlook-anywhr': {}, u'citrix': {}},), is_leaf=True, yang_name="latency-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/vlan (int16)

    YANG Description: VLAN Tag ID (1-4094, 0 for untagged, or -1 for all)
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/vlan (int16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.

    YANG Description: VLAN Tag ID (1-4094, 0 for untagged, or -1 for all)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), restriction_dict={'range': [u'-1..4096']}), is_leaf=True, yang_name="vlan", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='int16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with int16""",
          'defined-type': "int16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), restriction_dict={'range': [u'-1..4096']}), is_leaf=True, yang_name="vlan", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='int16', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), restriction_dict={'range': [u'-1..4096']}), is_leaf=True, yang_name="vlan", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='int16', is_config=True)


  def _get_neural_mode(self):
    """
    Getter method for neural_mode, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/neural_mode (enumeration)

    YANG Description: always
dynamic
never
tcphints

    """
    return self.__neural_mode
      
  def _set_neural_mode(self, v, load=False):
    """
    Setter method for neural_mode, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/neural_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neural_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neural_mode() directly.

    YANG Description: always
dynamic
never
tcphints

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'never': {}, u'dynamic': {}, u'tcphints': {}},), is_leaf=True, yang_name="neural-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neural_mode must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'never': {}, u'dynamic': {}, u'tcphints': {}},), is_leaf=True, yang_name="neural-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__neural_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neural_mode(self):
    self.__neural_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'always': {}, u'never': {}, u'dynamic': {}, u'tcphints': {}},), is_leaf=True, yang_name="neural-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_cloud_accel(self):
    """
    Getter method for cloud_accel, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/cloud_accel (enumeration)

    YANG Description: auto
passthru

    """
    return self.__cloud_accel
      
  def _set_cloud_accel(self, v, load=False):
    """
    Setter method for cloud_accel, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/cloud_accel (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_accel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_accel() directly.

    YANG Description: auto
passthru

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'passthru': {}, u'auto': {}},), is_leaf=True, yang_name="cloud-accel", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloud_accel must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'passthru': {}, u'auto': {}},), is_leaf=True, yang_name="cloud-accel", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__cloud_accel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloud_accel(self):
    self.__cloud_accel = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'passthru': {}, u'auto': {}},), is_leaf=True, yang_name="cloud-accel", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_web_proxy(self):
    """
    Getter method for web_proxy, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/web_proxy (enumeration)

    YANG Description: auto
force
none

    """
    return self.__web_proxy
      
  def _set_web_proxy(self, v, load=False):
    """
    Setter method for web_proxy, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/web_proxy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_web_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_web_proxy() directly.

    YANG Description: auto
force
none

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'none': {}, u'force': {}},), is_leaf=True, yang_name="web-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """web_proxy must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'none': {}, u'force': {}},), is_leaf=True, yang_name="web-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__web_proxy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_web_proxy(self):
    self.__web_proxy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'none': {}, u'force': {}},), is_leaf=True, yang_name="web-proxy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_wan_visibility(self):
    """
    Getter method for wan_visibility, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/wan_visibility (enumeration)

    YANG Description: correct
port
full

    """
    return self.__wan_visibility
      
  def _set_wan_visibility(self, v, load=False):
    """
    Setter method for wan_visibility, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/wan_visibility (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wan_visibility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wan_visibility() directly.

    YANG Description: correct
port
full

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'full': {}, u'correct': {}, u'port': {}},), is_leaf=True, yang_name="wan-visibility", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wan_visibility must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'full': {}, u'correct': {}, u'port': {}},), is_leaf=True, yang_name="wan-visibility", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__wan_visibility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wan_visibility(self):
    self.__wan_visibility = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'full': {}, u'correct': {}, u'port': {}},), is_leaf=True, yang_name="wan-visibility", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_wan_vis_opt(self):
    """
    Getter method for wan_vis_opt, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/wan_vis_opt (enumeration)

    YANG Description: fwd-reset
none

    """
    return self.__wan_vis_opt
      
  def _set_wan_vis_opt(self, v, load=False):
    """
    Setter method for wan_vis_opt, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/wan_vis_opt (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wan_vis_opt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wan_vis_opt() directly.

    YANG Description: fwd-reset
none

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'fwd-reset': {}, u'none': {}},), is_leaf=True, yang_name="wan-vis-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wan_vis_opt must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'fwd-reset': {}, u'none': {}},), is_leaf=True, yang_name="wan-vis-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__wan_vis_opt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wan_vis_opt(self):
    self.__wan_vis_opt = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'fwd-reset': {}, u'none': {}},), is_leaf=True, yang_name="wan-vis-opt", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_auto_kickoff(self):
    """
    Getter method for auto_kickoff, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/auto_kickoff (enumeration)

    YANG Description: Enable/disable auto-kichoff
    """
    return self.__auto_kickoff
      
  def _set_auto_kickoff(self, v, load=False):
    """
    Setter method for auto_kickoff, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/auto_kickoff (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_kickoff is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_kickoff() directly.

    YANG Description: Enable/disable auto-kichoff
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="auto-kickoff", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_kickoff must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="auto-kickoff", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__auto_kickoff = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_kickoff(self):
    self.__auto_kickoff = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="auto-kickoff", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_rule_enable(self):
    """
    Getter method for rule_enable, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/rule_enable (boolean)

    YANG Description: Enable rule: True/False
    """
    return self.__rule_enable
      
  def _set_rule_enable(self, v, load=False):
    """
    Setter method for rule_enable, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/rule_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_enable() directly.

    YANG Description: Enable rule: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="rule-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rule-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='boolean', is_config=True)""",
        })

    self.__rule_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_enable(self):
    self.__rule_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rule-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='boolean', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/protocol (union)

    YANG Description: Union Input types:
string
enumeration

    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/protocol (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Union Input types:
string
enumeration

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'any': {}, u'tcp': {}},),], is_leaf=True, yang_name="protocol", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'any': {}, u'tcp': {}},),], is_leaf=True, yang_name="protocol", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'udp': {}, u'any': {}, u'tcp': {}},),], is_leaf=True, yang_name="protocol", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_target_addr(self):
    """
    Getter method for target_addr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/target_addr (union)

    YANG Description: Union Input types:
inet:ip-address
enumeration

    """
    return self.__target_addr
      
  def _set_target_addr(self, v, load=False):
    """
    Setter method for target_addr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/target_addr (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_addr() directly.

    YANG Description: Union Input types:
inet:ip-address
enumeration

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="target-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_addr must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="target-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__target_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_addr(self):
    self.__target_addr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'all-ipv6': {}, u'all-ipv4': {}, u'all-ip': {}},),], is_leaf=True, yang_name="target-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_target_port(self):
    """
    Getter method for target_port, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/target_port (union)

    YANG Description: Union Input types:
string
leafref

    """
    return self.__target_port
      
  def _set_target_port(self, v, load=False):
    """
    Setter method for target_port, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/target_port (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_port() directly.

    YANG Description: Union Input types:
string
leafref

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,unicode,], is_leaf=True, yang_name="target-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_port must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="target-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__target_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_port(self):
    self.__target_port = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="target-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_backup_addr(self):
    """
    Getter method for backup_addr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/backup_addr (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__backup_addr
      
  def _set_backup_addr(self, v, load=False):
    """
    Setter method for backup_addr, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/backup_addr (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup_addr() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup_addr must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__backup_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup_addr(self):
    self.__backup_addr = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="backup-addr", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ip-address', is_config=True)


  def _get_backup_port(self):
    """
    Getter method for backup_port, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/backup_port (union)

    YANG Description: Union Input types:
string
leafref

    """
    return self.__backup_port
      
  def _set_backup_port(self, v, load=False):
    """
    Setter method for backup_port, mapped from YANG variable /devices/device/inpath_rules/inpath_rules_def/backup_port (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backup_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backup_port() directly.

    YANG Description: Union Input types:
string
leafref

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,unicode,], is_leaf=True, yang_name="backup-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backup_port must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="backup-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__backup_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backup_port(self):
    self.__backup_port = YANGDynClass(base=[unicode,unicode,], is_leaf=True, yang_name="backup-port", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)

  rulenum = __builtin__.property(_get_rulenum, _set_rulenum)
  rule_type = __builtin__.property(_get_rule_type, _set_rule_type)
  packet_mode_uni = __builtin__.property(_get_packet_mode_uni, _set_packet_mode_uni)
  srcaddr = __builtin__.property(_get_srcaddr, _set_srcaddr)
  srcport = __builtin__.property(_get_srcport, _set_srcport)
  dstaddr = __builtin__.property(_get_dstaddr, _set_dstaddr)
  dstport = __builtin__.property(_get_dstport, _set_dstport)
  dst_domain = __builtin__.property(_get_dst_domain, _set_dst_domain)
  dst_host = __builtin__.property(_get_dst_host, _set_dst_host)
  optimization = __builtin__.property(_get_optimization, _set_optimization)
  preoptimization = __builtin__.property(_get_preoptimization, _set_preoptimization)
  latency_opt = __builtin__.property(_get_latency_opt, _set_latency_opt)
  vlan = __builtin__.property(_get_vlan, _set_vlan)
  neural_mode = __builtin__.property(_get_neural_mode, _set_neural_mode)
  cloud_accel = __builtin__.property(_get_cloud_accel, _set_cloud_accel)
  web_proxy = __builtin__.property(_get_web_proxy, _set_web_proxy)
  wan_visibility = __builtin__.property(_get_wan_visibility, _set_wan_visibility)
  wan_vis_opt = __builtin__.property(_get_wan_vis_opt, _set_wan_vis_opt)
  description = __builtin__.property(_get_description, _set_description)
  auto_kickoff = __builtin__.property(_get_auto_kickoff, _set_auto_kickoff)
  rule_enable = __builtin__.property(_get_rule_enable, _set_rule_enable)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  target_addr = __builtin__.property(_get_target_addr, _set_target_addr)
  target_port = __builtin__.property(_get_target_port, _set_target_port)
  backup_addr = __builtin__.property(_get_backup_addr, _set_backup_addr)
  backup_port = __builtin__.property(_get_backup_port, _set_backup_port)


  _pyangbind_elements = collections.OrderedDict([('rulenum', rulenum), ('rule_type', rule_type), ('packet_mode_uni', packet_mode_uni), ('srcaddr', srcaddr), ('srcport', srcport), ('dstaddr', dstaddr), ('dstport', dstport), ('dst_domain', dst_domain), ('dst_host', dst_host), ('optimization', optimization), ('preoptimization', preoptimization), ('latency_opt', latency_opt), ('vlan', vlan), ('neural_mode', neural_mode), ('cloud_accel', cloud_accel), ('web_proxy', web_proxy), ('wan_visibility', wan_visibility), ('wan_vis_opt', wan_vis_opt), ('description', description), ('auto_kickoff', auto_kickoff), ('rule_enable', rule_enable), ('protocol', protocol), ('target_addr', target_addr), ('target_port', target_port), ('backup_addr', backup_addr), ('backup_port', backup_port), ])


