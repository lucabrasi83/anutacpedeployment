
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class auto_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/optimization-services/active-directory/auto-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__domain_name','__login','__password','__dc_list','__short_name','__enable_smbv1_mode','__enable_smb_signing','__smb_signing_modetype','__delegation','__auto_mode','__user_name','__user_password','__rule_type','__ipaddress','__select','__enable_smb2_signing','__enable_smb3_signing','__mapi',)

  _yang_name = 'auto-config'
  _module_name = 'wanoptimizer'
  _namespace = 'http://anutanetworks.com/wanoptimizer'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable_smb_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__dc_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="dc-list", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__short_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__rule_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'select': {}, u'dlg-only': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__user_password = YANGDynClass(base=unicode, is_leaf=True, yang_name="user-password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__mapi = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mapi", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__domain_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="domain-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__enable_smbv1_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__auto_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="auto-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__enable_smb3_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb3-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__ipaddress = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipaddress", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ipv4-address', is_config=True)
    self.__delegation = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rule': {}, u'delegate-user': {}, u'auto-mode': {}},), is_leaf=True, yang_name="delegation", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__login = YANGDynClass(base=unicode, is_leaf=True, yang_name="login", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__password = YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__user_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="user-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__smb_signing_modetype = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},), is_leaf=True, yang_name="smb-signing-modetype", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__select = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'dlg-only': {}},), is_leaf=True, yang_name="select", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__enable_smb2_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb2-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'optimization-services', u'active-directory', u'auto-config']

  def _get_domain_name(self):
    """
    Getter method for domain_name, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/domain_name (string)

    YANG Description: string
    """
    return self.__domain_name
      
  def _set_domain_name(self, v, load=False):
    """
    Setter method for domain_name, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/domain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="domain-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="domain-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__domain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_name(self):
    self.__domain_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="domain-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_login(self):
    """
    Getter method for login, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/login (string)

    YANG Description: string
    """
    return self.__login
      
  def _set_login(self, v, load=False):
    """
    Setter method for login, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/login (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_login is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_login() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="login", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """login must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="login", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__login = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_login(self):
    self.__login = YANGDynClass(base=unicode, is_leaf=True, yang_name="login", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_password(self):
    """
    Getter method for password, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/password (string)

    YANG Description: string
    """
    return self.__password
      
  def _set_password(self, v, load=False):
    """
    Setter method for password, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password(self):
    self.__password = YANGDynClass(base=unicode, is_leaf=True, yang_name="password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_dc_list(self):
    """
    Getter method for dc_list, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/dc_list (string)

    YANG Description: string
    """
    return self.__dc_list
      
  def _set_dc_list(self, v, load=False):
    """
    Setter method for dc_list, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/dc_list (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dc_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dc_list() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dc-list", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dc_list must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dc-list", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__dc_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dc_list(self):
    self.__dc_list = YANGDynClass(base=unicode, is_leaf=True, yang_name="dc-list", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_short_name(self):
    """
    Getter method for short_name, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/short_name (string)

    YANG Description: string
    """
    return self.__short_name
      
  def _set_short_name(self, v, load=False):
    """
    Setter method for short_name, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="short-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """short_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__short_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_short_name(self):
    self.__short_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_enable_smbv1_mode(self):
    """
    Getter method for enable_smbv1_mode, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smbv1_mode (enumeration)

    YANG Description: enable

    """
    return self.__enable_smbv1_mode
      
  def _set_enable_smbv1_mode(self, v, load=False):
    """
    Setter method for enable_smbv1_mode, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smbv1_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_smbv1_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_smbv1_mode() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_smbv1_mode must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__enable_smbv1_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_smbv1_mode(self):
    self.__enable_smbv1_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_enable_smb_signing(self):
    """
    Getter method for enable_smb_signing, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smb_signing (enumeration)

    YANG Description: enable

    """
    return self.__enable_smb_signing
      
  def _set_enable_smb_signing(self, v, load=False):
    """
    Setter method for enable_smb_signing, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smb_signing (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_smb_signing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_smb_signing() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_smb_signing must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__enable_smb_signing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_smb_signing(self):
    self.__enable_smb_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_smb_signing_modetype(self):
    """
    Getter method for smb_signing_modetype, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/smb_signing_modetype (enumeration)

    YANG Description: transparent
delegation

    """
    return self.__smb_signing_modetype
      
  def _set_smb_signing_modetype(self, v, load=False):
    """
    Setter method for smb_signing_modetype, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/smb_signing_modetype (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smb_signing_modetype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smb_signing_modetype() directly.

    YANG Description: transparent
delegation

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},), is_leaf=True, yang_name="smb-signing-modetype", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smb_signing_modetype must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},), is_leaf=True, yang_name="smb-signing-modetype", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__smb_signing_modetype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smb_signing_modetype(self):
    self.__smb_signing_modetype = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},), is_leaf=True, yang_name="smb-signing-modetype", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_delegation(self):
    """
    Getter method for delegation, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/delegation (enumeration)

    YANG Description: auto-mode
delegate-user
rule

    """
    return self.__delegation
      
  def _set_delegation(self, v, load=False):
    """
    Setter method for delegation, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/delegation (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delegation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delegation() directly.

    YANG Description: auto-mode
delegate-user
rule

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rule': {}, u'delegate-user': {}, u'auto-mode': {}},), is_leaf=True, yang_name="delegation", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delegation must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rule': {}, u'delegate-user': {}, u'auto-mode': {}},), is_leaf=True, yang_name="delegation", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__delegation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delegation(self):
    self.__delegation = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rule': {}, u'delegate-user': {}, u'auto-mode': {}},), is_leaf=True, yang_name="delegation", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_auto_mode(self):
    """
    Getter method for auto_mode, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/auto_mode (enumeration)

    YANG Description: enable

    """
    return self.__auto_mode
      
  def _set_auto_mode(self, v, load=False):
    """
    Setter method for auto_mode, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/auto_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_mode() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="auto-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_mode must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="auto-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__auto_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_mode(self):
    self.__auto_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="auto-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_user_name(self):
    """
    Getter method for user_name, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/user_name (string)

    YANG Description: string
    """
    return self.__user_name
      
  def _set_user_name(self, v, load=False):
    """
    Setter method for user_name, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/user_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="user-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__user_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_name(self):
    self.__user_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="user-name", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_user_password(self):
    """
    Getter method for user_password, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/user_password (string)

    YANG Description: string
    """
    return self.__user_password
      
  def _set_user_password(self, v, load=False):
    """
    Setter method for user_password, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/user_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_password() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="user-password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__user_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_password(self):
    self.__user_password = YANGDynClass(base=unicode, is_leaf=True, yang_name="user-password", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_rule_type(self):
    """
    Getter method for rule_type, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/rule_type (enumeration)

    YANG Description: dlg-all-except
dlg-only
select

    """
    return self.__rule_type
      
  def _set_rule_type(self, v, load=False):
    """
    Setter method for rule_type, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/rule_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_type() directly.

    YANG Description: dlg-all-except
dlg-only
select

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'select': {}, u'dlg-only': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_type must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'select': {}, u'dlg-only': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__rule_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_type(self):
    self.__rule_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'select': {}, u'dlg-only': {}},), is_leaf=True, yang_name="rule-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_ipaddress(self):
    """
    Getter method for ipaddress, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/ipaddress (inet:ipv4-address)

    YANG Description: Valid IPv4 Address (A.B.C.D for e.x: 172.16.1.1)
    """
    return self.__ipaddress
      
  def _set_ipaddress(self, v, load=False):
    """
    Setter method for ipaddress, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/ipaddress (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipaddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipaddress() directly.

    YANG Description: Valid IPv4 Address (A.B.C.D for e.x: 172.16.1.1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipaddress", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipaddress must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipaddress", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__ipaddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipaddress(self):
    self.__ipaddress = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipaddress", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='inet:ipv4-address', is_config=True)


  def _get_select(self):
    """
    Getter method for select, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/select (enumeration)

    YANG Description: dlg-all-except
dlg-only

    """
    return self.__select
      
  def _set_select(self, v, load=False):
    """
    Setter method for select, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/select (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_select is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_select() directly.

    YANG Description: dlg-all-except
dlg-only

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'dlg-only': {}},), is_leaf=True, yang_name="select", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """select must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'dlg-only': {}},), is_leaf=True, yang_name="select", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__select = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_select(self):
    self.__select = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'dlg-all-except': {}, u'dlg-only': {}},), is_leaf=True, yang_name="select", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_enable_smb2_signing(self):
    """
    Getter method for enable_smb2_signing, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smb2_signing (enumeration)

    YANG Description: enable

    """
    return self.__enable_smb2_signing
      
  def _set_enable_smb2_signing(self, v, load=False):
    """
    Setter method for enable_smb2_signing, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smb2_signing (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_smb2_signing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_smb2_signing() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb2-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_smb2_signing must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb2-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__enable_smb2_signing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_smb2_signing(self):
    self.__enable_smb2_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb2-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_enable_smb3_signing(self):
    """
    Getter method for enable_smb3_signing, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smb3_signing (enumeration)

    YANG Description: enable

    """
    return self.__enable_smb3_signing
      
  def _set_enable_smb3_signing(self, v, load=False):
    """
    Setter method for enable_smb3_signing, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/enable_smb3_signing (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_smb3_signing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_smb3_signing() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb3-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_smb3_signing must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb3-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__enable_smb3_signing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_smb3_signing(self):
    self.__enable_smb3_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="enable-smb3-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_mapi(self):
    """
    Getter method for mapi, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/mapi (enumeration)

    YANG Description: enable

    """
    return self.__mapi
      
  def _set_mapi(self, v, load=False):
    """
    Setter method for mapi, mapped from YANG variable /devices/device/optimization_services/active_directory/auto_config/mapi (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mapi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mapi() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mapi", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mapi must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mapi", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__mapi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mapi(self):
    self.__mapi = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mapi", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)

  domain_name = __builtin__.property(_get_domain_name, _set_domain_name)
  login = __builtin__.property(_get_login, _set_login)
  password = __builtin__.property(_get_password, _set_password)
  dc_list = __builtin__.property(_get_dc_list, _set_dc_list)
  short_name = __builtin__.property(_get_short_name, _set_short_name)
  enable_smbv1_mode = __builtin__.property(_get_enable_smbv1_mode, _set_enable_smbv1_mode)
  enable_smb_signing = __builtin__.property(_get_enable_smb_signing, _set_enable_smb_signing)
  smb_signing_modetype = __builtin__.property(_get_smb_signing_modetype, _set_smb_signing_modetype)
  delegation = __builtin__.property(_get_delegation, _set_delegation)
  auto_mode = __builtin__.property(_get_auto_mode, _set_auto_mode)
  user_name = __builtin__.property(_get_user_name, _set_user_name)
  user_password = __builtin__.property(_get_user_password, _set_user_password)
  rule_type = __builtin__.property(_get_rule_type, _set_rule_type)
  ipaddress = __builtin__.property(_get_ipaddress, _set_ipaddress)
  select = __builtin__.property(_get_select, _set_select)
  enable_smb2_signing = __builtin__.property(_get_enable_smb2_signing, _set_enable_smb2_signing)
  enable_smb3_signing = __builtin__.property(_get_enable_smb3_signing, _set_enable_smb3_signing)
  mapi = __builtin__.property(_get_mapi, _set_mapi)


  _pyangbind_elements = collections.OrderedDict([('domain_name', domain_name), ('login', login), ('password', password), ('dc_list', dc_list), ('short_name', short_name), ('enable_smbv1_mode', enable_smbv1_mode), ('enable_smb_signing', enable_smb_signing), ('smb_signing_modetype', smb_signing_modetype), ('delegation', delegation), ('auto_mode', auto_mode), ('user_name', user_name), ('user_password', user_password), ('rule_type', rule_type), ('ipaddress', ipaddress), ('select', select), ('enable_smb2_signing', enable_smb2_signing), ('enable_smb3_signing', enable_smb3_signing), ('mapi', mapi), ])


