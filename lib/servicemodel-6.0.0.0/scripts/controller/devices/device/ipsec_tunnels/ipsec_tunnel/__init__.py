
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class ipsec_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/ipsec-tunnels/ipsec-tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__description','__type','__source_interface','__exchange_mode','__phase1_keylifetime','__phase1_enc_auth_combination','__phase1_dhgrp','__dpd','__dpd_max_retries','__dpd_retry_interval','__nat_traversal','__frequency','__pre_shared_key','__xauthtype','__usergroup','__mode_cfg','__startip','__endip','__netmask','__ipv4_split','__phase2_keylifetime','__phase2_enc_auth_combination','__phase2_dhgrp','__pfs','__reply','__virtual_device_name',)

  _yang_name = 'ipsec-tunnel'
  _module_name = 'firewall'
  _namespace = 'http://anutanetworks.com/firewall'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__phase1_enc_auth_combination = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase1-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__xauthtype = YANGDynClass(base=unicode, is_leaf=True, yang_name="xauthtype", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frequency", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__phase2_enc_auth_combination = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase2-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__usergroup = YANGDynClass(base=unicode, is_leaf=True, yang_name="usergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    self.__phase1_dhgrp = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase1-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__pre_shared_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="pre-shared-key", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__mode_cfg = YANGDynClass(base=unicode, is_leaf=True, yang_name="mode-cfg", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__source_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__reply = YANGDynClass(base=unicode, is_leaf=True, yang_name="reply", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__phase1_keylifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase1-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__phase2_keylifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase2-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__nat_traversal = YANGDynClass(base=unicode, is_leaf=True, yang_name="nat-traversal", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__virtual_device_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-device-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    self.__endip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="endip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__dpd_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-retry-interval", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__startip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="startip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    self.__dpd_max_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-max-retries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__pfs = YANGDynClass(base=unicode, is_leaf=True, yang_name="pfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__exchange_mode = YANGDynClass(base=unicode, is_leaf=True, yang_name="exchange-mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__ipv4_split = YANGDynClass(base=unicode, is_leaf=True, yang_name="ipv4-split", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__dpd = YANGDynClass(base=unicode, is_leaf=True, yang_name="dpd", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__phase2_dhgrp = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase2-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'ipsec-tunnels', u'ipsec-tunnel']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/type (string)

    YANG Description: string
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="type", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="type", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=unicode, is_leaf=True, yang_name="type", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_source_interface(self):
    """
    Getter method for source_interface, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/source_interface (string)

    YANG Description: string
    """
    return self.__source_interface
      
  def _set_source_interface(self, v, load=False):
    """
    Setter method for source_interface, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/source_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_interface() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__source_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_interface(self):
    self.__source_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_exchange_mode(self):
    """
    Getter method for exchange_mode, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/exchange_mode (string)

    YANG Description: string
    """
    return self.__exchange_mode
      
  def _set_exchange_mode(self, v, load=False):
    """
    Setter method for exchange_mode, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/exchange_mode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exchange_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exchange_mode() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="exchange-mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exchange_mode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="exchange-mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__exchange_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exchange_mode(self):
    self.__exchange_mode = YANGDynClass(base=unicode, is_leaf=True, yang_name="exchange-mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_phase1_keylifetime(self):
    """
    Getter method for phase1_keylifetime, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase1_keylifetime (uint32)

    YANG Description: 0..4294967295
    """
    return self.__phase1_keylifetime
      
  def _set_phase1_keylifetime(self, v, load=False):
    """
    Setter method for phase1_keylifetime, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase1_keylifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phase1_keylifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phase1_keylifetime() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase1-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phase1_keylifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase1-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__phase1_keylifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phase1_keylifetime(self):
    self.__phase1_keylifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase1-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_phase1_enc_auth_combination(self):
    """
    Getter method for phase1_enc_auth_combination, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase1_enc_auth_combination (string)

    YANG Description: string
    """
    return self.__phase1_enc_auth_combination
      
  def _set_phase1_enc_auth_combination(self, v, load=False):
    """
    Setter method for phase1_enc_auth_combination, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase1_enc_auth_combination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phase1_enc_auth_combination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phase1_enc_auth_combination() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="phase1-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phase1_enc_auth_combination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="phase1-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__phase1_enc_auth_combination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phase1_enc_auth_combination(self):
    self.__phase1_enc_auth_combination = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase1-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_phase1_dhgrp(self):
    """
    Getter method for phase1_dhgrp, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase1_dhgrp (string)

    YANG Description: string
    """
    return self.__phase1_dhgrp
      
  def _set_phase1_dhgrp(self, v, load=False):
    """
    Setter method for phase1_dhgrp, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase1_dhgrp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phase1_dhgrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phase1_dhgrp() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="phase1-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phase1_dhgrp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="phase1-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__phase1_dhgrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phase1_dhgrp(self):
    self.__phase1_dhgrp = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase1-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_dpd(self):
    """
    Getter method for dpd, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/dpd (string)

    YANG Description: string
    """
    return self.__dpd
      
  def _set_dpd(self, v, load=False):
    """
    Setter method for dpd, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/dpd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dpd() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dpd", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dpd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dpd", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__dpd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dpd(self):
    self.__dpd = YANGDynClass(base=unicode, is_leaf=True, yang_name="dpd", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_dpd_max_retries(self):
    """
    Getter method for dpd_max_retries, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/dpd_max_retries (uint32)

    YANG Description: 0..4294967295
    """
    return self.__dpd_max_retries
      
  def _set_dpd_max_retries(self, v, load=False):
    """
    Setter method for dpd_max_retries, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/dpd_max_retries (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dpd_max_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dpd_max_retries() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-max-retries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dpd_max_retries must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-max-retries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__dpd_max_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dpd_max_retries(self):
    self.__dpd_max_retries = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-max-retries", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_dpd_retry_interval(self):
    """
    Getter method for dpd_retry_interval, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/dpd_retry_interval (uint32)

    YANG Description: 0..4294967295
    """
    return self.__dpd_retry_interval
      
  def _set_dpd_retry_interval(self, v, load=False):
    """
    Setter method for dpd_retry_interval, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/dpd_retry_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dpd_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dpd_retry_interval() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-retry-interval", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dpd_retry_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-retry-interval", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__dpd_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dpd_retry_interval(self):
    self.__dpd_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="dpd-retry-interval", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_nat_traversal(self):
    """
    Getter method for nat_traversal, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/nat_traversal (string)

    YANG Description: string
    """
    return self.__nat_traversal
      
  def _set_nat_traversal(self, v, load=False):
    """
    Setter method for nat_traversal, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/nat_traversal (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nat_traversal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nat_traversal() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="nat-traversal", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nat_traversal must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="nat-traversal", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__nat_traversal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nat_traversal(self):
    self.__nat_traversal = YANGDynClass(base=unicode, is_leaf=True, yang_name="nat-traversal", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/frequency (uint32)

    YANG Description: 0..4294967295
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/frequency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frequency", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frequency", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="frequency", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_pre_shared_key(self):
    """
    Getter method for pre_shared_key, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/pre_shared_key (string)

    YANG Description: string
    """
    return self.__pre_shared_key
      
  def _set_pre_shared_key(self, v, load=False):
    """
    Setter method for pre_shared_key, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/pre_shared_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_shared_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_shared_key() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="pre-shared-key", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_shared_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="pre-shared-key", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__pre_shared_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_shared_key(self):
    self.__pre_shared_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="pre-shared-key", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_xauthtype(self):
    """
    Getter method for xauthtype, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/xauthtype (string)

    YANG Description: string
    """
    return self.__xauthtype
      
  def _set_xauthtype(self, v, load=False):
    """
    Setter method for xauthtype, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/xauthtype (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_xauthtype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_xauthtype() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="xauthtype", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """xauthtype must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="xauthtype", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__xauthtype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_xauthtype(self):
    self.__xauthtype = YANGDynClass(base=unicode, is_leaf=True, yang_name="xauthtype", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_usergroup(self):
    """
    Getter method for usergroup, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/usergroup (leafref)

    YANG Description: usergroup
    """
    return self.__usergroup
      
  def _set_usergroup(self, v, load=False):
    """
    Setter method for usergroup, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/usergroup (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_usergroup is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_usergroup() directly.

    YANG Description: usergroup
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="usergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """usergroup must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="usergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)""",
        })

    self.__usergroup = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_usergroup(self):
    self.__usergroup = YANGDynClass(base=unicode, is_leaf=True, yang_name="usergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)


  def _get_mode_cfg(self):
    """
    Getter method for mode_cfg, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/mode_cfg (string)

    YANG Description: string
    """
    return self.__mode_cfg
      
  def _set_mode_cfg(self, v, load=False):
    """
    Setter method for mode_cfg, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/mode_cfg (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_cfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_cfg() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mode-cfg", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_cfg must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mode-cfg", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__mode_cfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_cfg(self):
    self.__mode_cfg = YANGDynClass(base=unicode, is_leaf=True, yang_name="mode-cfg", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_startip(self):
    """
    Getter method for startip, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/startip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__startip
      
  def _set_startip(self, v, load=False):
    """
    Setter method for startip, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/startip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_startip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_startip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="startip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """startip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="startip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__startip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_startip(self):
    self.__startip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="startip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)


  def _get_endip(self):
    """
    Getter method for endip, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/endip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__endip
      
  def _set_endip(self, v, load=False):
    """
    Setter method for endip, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/endip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="endip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="endip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__endip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endip(self):
    self.__endip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="endip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/netmask (string)

    YANG Description: string
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/netmask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_ipv4_split(self):
    """
    Getter method for ipv4_split, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/ipv4_split (string)

    YANG Description: string
    """
    return self.__ipv4_split
      
  def _set_ipv4_split(self, v, load=False):
    """
    Setter method for ipv4_split, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/ipv4_split (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_split is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_split() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ipv4-split", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_split must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ipv4-split", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__ipv4_split = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_split(self):
    self.__ipv4_split = YANGDynClass(base=unicode, is_leaf=True, yang_name="ipv4-split", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_phase2_keylifetime(self):
    """
    Getter method for phase2_keylifetime, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase2_keylifetime (uint32)

    YANG Description: 0..4294967295
    """
    return self.__phase2_keylifetime
      
  def _set_phase2_keylifetime(self, v, load=False):
    """
    Setter method for phase2_keylifetime, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase2_keylifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phase2_keylifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phase2_keylifetime() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase2-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phase2_keylifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase2-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__phase2_keylifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phase2_keylifetime(self):
    self.__phase2_keylifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="phase2-keylifetime", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_phase2_enc_auth_combination(self):
    """
    Getter method for phase2_enc_auth_combination, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase2_enc_auth_combination (string)

    YANG Description: string
    """
    return self.__phase2_enc_auth_combination
      
  def _set_phase2_enc_auth_combination(self, v, load=False):
    """
    Setter method for phase2_enc_auth_combination, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase2_enc_auth_combination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phase2_enc_auth_combination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phase2_enc_auth_combination() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="phase2-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phase2_enc_auth_combination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="phase2-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__phase2_enc_auth_combination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phase2_enc_auth_combination(self):
    self.__phase2_enc_auth_combination = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase2-enc-auth-combination", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_phase2_dhgrp(self):
    """
    Getter method for phase2_dhgrp, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase2_dhgrp (string)

    YANG Description: string
    """
    return self.__phase2_dhgrp
      
  def _set_phase2_dhgrp(self, v, load=False):
    """
    Setter method for phase2_dhgrp, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/phase2_dhgrp (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_phase2_dhgrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_phase2_dhgrp() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="phase2-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """phase2_dhgrp must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="phase2-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__phase2_dhgrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_phase2_dhgrp(self):
    self.__phase2_dhgrp = YANGDynClass(base=unicode, is_leaf=True, yang_name="phase2-dhgrp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_pfs(self):
    """
    Getter method for pfs, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/pfs (string)

    YANG Description: string
    """
    return self.__pfs
      
  def _set_pfs(self, v, load=False):
    """
    Setter method for pfs, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/pfs (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pfs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pfs() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="pfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pfs must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="pfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__pfs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pfs(self):
    self.__pfs = YANGDynClass(base=unicode, is_leaf=True, yang_name="pfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_reply(self):
    """
    Getter method for reply, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/reply (string)

    YANG Description: string
    """
    return self.__reply
      
  def _set_reply(self, v, load=False):
    """
    Setter method for reply, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/reply (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reply is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reply() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="reply", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reply must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="reply", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__reply = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reply(self):
    self.__reply = YANGDynClass(base=unicode, is_leaf=True, yang_name="reply", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_virtual_device_name(self):
    """
    Getter method for virtual_device_name, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/virtual_device_name (leafref)

    YANG Description: virtual-device-name
    """
    return self.__virtual_device_name
      
  def _set_virtual_device_name(self, v, load=False):
    """
    Setter method for virtual_device_name, mapped from YANG variable /devices/device/ipsec_tunnels/ipsec_tunnel/virtual_device_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_device_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_device_name() directly.

    YANG Description: virtual-device-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="virtual-device-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_device_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-device-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)""",
        })

    self.__virtual_device_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_device_name(self):
    self.__virtual_device_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-device-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  source_interface = __builtin__.property(_get_source_interface, _set_source_interface)
  exchange_mode = __builtin__.property(_get_exchange_mode, _set_exchange_mode)
  phase1_keylifetime = __builtin__.property(_get_phase1_keylifetime, _set_phase1_keylifetime)
  phase1_enc_auth_combination = __builtin__.property(_get_phase1_enc_auth_combination, _set_phase1_enc_auth_combination)
  phase1_dhgrp = __builtin__.property(_get_phase1_dhgrp, _set_phase1_dhgrp)
  dpd = __builtin__.property(_get_dpd, _set_dpd)
  dpd_max_retries = __builtin__.property(_get_dpd_max_retries, _set_dpd_max_retries)
  dpd_retry_interval = __builtin__.property(_get_dpd_retry_interval, _set_dpd_retry_interval)
  nat_traversal = __builtin__.property(_get_nat_traversal, _set_nat_traversal)
  frequency = __builtin__.property(_get_frequency, _set_frequency)
  pre_shared_key = __builtin__.property(_get_pre_shared_key, _set_pre_shared_key)
  xauthtype = __builtin__.property(_get_xauthtype, _set_xauthtype)
  usergroup = __builtin__.property(_get_usergroup, _set_usergroup)
  mode_cfg = __builtin__.property(_get_mode_cfg, _set_mode_cfg)
  startip = __builtin__.property(_get_startip, _set_startip)
  endip = __builtin__.property(_get_endip, _set_endip)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  ipv4_split = __builtin__.property(_get_ipv4_split, _set_ipv4_split)
  phase2_keylifetime = __builtin__.property(_get_phase2_keylifetime, _set_phase2_keylifetime)
  phase2_enc_auth_combination = __builtin__.property(_get_phase2_enc_auth_combination, _set_phase2_enc_auth_combination)
  phase2_dhgrp = __builtin__.property(_get_phase2_dhgrp, _set_phase2_dhgrp)
  pfs = __builtin__.property(_get_pfs, _set_pfs)
  reply = __builtin__.property(_get_reply, _set_reply)
  virtual_device_name = __builtin__.property(_get_virtual_device_name, _set_virtual_device_name)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('description', description), ('type', type), ('source_interface', source_interface), ('exchange_mode', exchange_mode), ('phase1_keylifetime', phase1_keylifetime), ('phase1_enc_auth_combination', phase1_enc_auth_combination), ('phase1_dhgrp', phase1_dhgrp), ('dpd', dpd), ('dpd_max_retries', dpd_max_retries), ('dpd_retry_interval', dpd_retry_interval), ('nat_traversal', nat_traversal), ('frequency', frequency), ('pre_shared_key', pre_shared_key), ('xauthtype', xauthtype), ('usergroup', usergroup), ('mode_cfg', mode_cfg), ('startip', startip), ('endip', endip), ('netmask', netmask), ('ipv4_split', ipv4_split), ('phase2_keylifetime', phase2_keylifetime), ('phase2_enc_auth_combination', phase2_enc_auth_combination), ('phase2_dhgrp', phase2_dhgrp), ('pfs', pfs), ('reply', reply), ('virtual_device_name', virtual_device_name), ])


