
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import hub_list
import nhrp_maps
import nhrp_qos_maps
import domain_path
class dmvpntunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/dmvpntunnels/dmvpntunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__type','__ipaddress','__netmask','__tunnel_source','__tunnel_destination','__tunnel_mode','__tunnel_key','__nhrp_network_id','__nhrp_auth_key','__bandwidth','__shared','__no_nhrp_route_watch','__nhrp_reg_no_uniq','__nhrp_reg_timeout','__nhrp_holdtime','__nhrp_redirect','__nhrp_shortcut','__tunnel_keepalive_period','__tunnel_keepalive_retries','__if_state_nhrp','__delay','__nat_name','__mtu','__tcp_adjust_mss','__authentication_type','__eigrpProcessNumber','__key_chain','__vrf_definition_mode','__vrf_name','__front_vrf_name','__in_queue_length','__out_queue_length','__map_multicast','__ipsec_profile_name','__routing_protocol','__hub_list','__nhrp_maps','__nhrp_qos_maps','__domain_path','__description',)

  _yang_name = 'dmvpntunnel'
  _module_name = 'dmvpn'
  _namespace = 'http://anutanetworks.com/dmvpn'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nhrp_holdtime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="nhrp-holdtime", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)
    self.__in_queue_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="in-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__no_nhrp_route_watch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-nhrp-route-watch", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__map_multicast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="map-multicast", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__nhrp_auth_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="nhrp-auth-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__tunnel_keepalive_retries = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="tunnel-keepalive-retries", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint8', is_config=True)
    self.__nhrp_reg_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-reg-timeout", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__vrf_definition_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__authentication_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="authentication-type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__tunnel_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'gre': {}, u'mpls': {}, u'read-only': {}},), is_leaf=True, yang_name="tunnel-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)
    self.__ipsec_profile_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="ipsec-profile-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='leafref', is_config=True)
    self.__if_state_nhrp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="if-state-nhrp", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__domain_path = YANGDynClass(base=domain_path.domain_path, is_container='container', yang_name="domain-path", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    self.__eigrpProcessNumber = YANGDynClass(base=unicode, is_leaf=True, yang_name="eigrpProcessNumber", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__routing_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'bgp': {}, u'eigrp': {}, u'ospf': {}},), is_leaf=True, yang_name="routing-protocol", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)
    self.__nhrp_maps = YANGDynClass(base=YANGListType("sourceip destip",nhrp_maps.nhrp_maps, yang_name="nhrp-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sourceip destip'), is_container='list', yang_name="nhrp-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)
    self.__nhrp_shortcut = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-shortcut", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__shared = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shared", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)
    self.__nhrp_reg_no_uniq = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-reg-no-uniq", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__tunnel_destination = YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-destination", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__tunnel_key = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__nhrp_network_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-network-id", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__front_vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="front-vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__out_queue_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="out-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__ipaddress = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ipaddress", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='inet:ip-address', is_config=True)
    self.__tunnel_keepalive_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..32767']}), is_leaf=True, yang_name="tunnel-keepalive-period", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__nat_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="nat-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__key_chain = YANGDynClass(base=unicode, is_leaf=True, yang_name="key-chain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__nhrp_redirect = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-redirect", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__hub_list = YANGDynClass(base=YANGListType("ip_address",hub_list.hub_list, yang_name="hub-list", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="hub-list", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)
    self.__nhrp_qos_maps = YANGDynClass(base=YANGListType("name",nhrp_qos_maps.nhrp_qos_maps, yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)
    self.__tunnel_source = YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-source", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    self.__tcp_adjust_mss = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tcp-adjust-mss", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    self.__netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'dmvpntunnels', u'dmvpntunnel']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/type (enumeration)

    YANG Description: SPOKE
HUB

    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: SPOKE
HUB

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "dmvpn:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)


  def _get_ipaddress(self):
    """
    Getter method for ipaddress, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/ipaddress (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__ipaddress
      
  def _set_ipaddress(self, v, load=False):
    """
    Setter method for ipaddress, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/ipaddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipaddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipaddress() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ipaddress", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipaddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ipaddress", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ipaddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipaddress(self):
    self.__ipaddress = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ipaddress", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='inet:ip-address', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/netmask (string)

    YANG Description: string
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/netmask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="netmask", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="netmask", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_tunnel_source(self):
    """
    Getter method for tunnel_source, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_source (string)

    YANG Description: string
    """
    return self.__tunnel_source
      
  def _set_tunnel_source(self, v, load=False):
    """
    Setter method for tunnel_source, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_source (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_source() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tunnel-source", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_source must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-source", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__tunnel_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_source(self):
    self.__tunnel_source = YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-source", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_tunnel_destination(self):
    """
    Getter method for tunnel_destination, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_destination (string)

    YANG Description: string
    """
    return self.__tunnel_destination
      
  def _set_tunnel_destination(self, v, load=False):
    """
    Setter method for tunnel_destination, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_destination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_destination() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tunnel-destination", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_destination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-destination", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__tunnel_destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_destination(self):
    self.__tunnel_destination = YANGDynClass(base=unicode, is_leaf=True, yang_name="tunnel-destination", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_tunnel_mode(self):
    """
    Getter method for tunnel_mode, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_mode (enumeration)

    YANG Description: gre
read-only
mpls

    """
    return self.__tunnel_mode
      
  def _set_tunnel_mode(self, v, load=False):
    """
    Setter method for tunnel_mode, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_mode() directly.

    YANG Description: gre
read-only
mpls

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'gre': {}, u'mpls': {}, u'read-only': {}},), is_leaf=True, yang_name="tunnel-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_mode must be of a type compatible with enumeration""",
          'defined-type': "dmvpn:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'gre': {}, u'mpls': {}, u'read-only': {}},), is_leaf=True, yang_name="tunnel-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)""",
        })

    self.__tunnel_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_mode(self):
    self.__tunnel_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'gre': {}, u'mpls': {}, u'read-only': {}},), is_leaf=True, yang_name="tunnel-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)


  def _get_tunnel_key(self):
    """
    Getter method for tunnel_key, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_key (uint32)

    YANG Description: 0..4294967295
    """
    return self.__tunnel_key
      
  def _set_tunnel_key(self, v, load=False):
    """
    Setter method for tunnel_key, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_key (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_key() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_key must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__tunnel_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_key(self):
    self.__tunnel_key = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tunnel-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_nhrp_network_id(self):
    """
    Getter method for nhrp_network_id, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_network_id (uint32)

    YANG Description: 0..4294967295
    """
    return self.__nhrp_network_id
      
  def _set_nhrp_network_id(self, v, load=False):
    """
    Setter method for nhrp_network_id, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_network_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_network_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_network_id() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-network-id", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_network_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-network-id", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__nhrp_network_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_network_id(self):
    self.__nhrp_network_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-network-id", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_nhrp_auth_key(self):
    """
    Getter method for nhrp_auth_key, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_auth_key (string)

    YANG Description: string
    """
    return self.__nhrp_auth_key
      
  def _set_nhrp_auth_key(self, v, load=False):
    """
    Setter method for nhrp_auth_key, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_auth_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_auth_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_auth_key() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="nhrp-auth-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_auth_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="nhrp-auth-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__nhrp_auth_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_auth_key(self):
    self.__nhrp_auth_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="nhrp-auth-key", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/bandwidth (uint32)

    YANG Description: 0..4294967295
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_shared(self):
    """
    Getter method for shared, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/shared (boolean)

    YANG Description: shared: True/False
    """
    return self.__shared
      
  def _set_shared(self, v, load=False):
    """
    Setter method for shared, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/shared (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared() directly.

    YANG Description: shared: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="shared", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shared", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__shared = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared(self):
    self.__shared = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="shared", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_no_nhrp_route_watch(self):
    """
    Getter method for no_nhrp_route_watch, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/no_nhrp_route_watch (boolean)

    YANG Description: no-nhrp-route-watch: True/False
    """
    return self.__no_nhrp_route_watch
      
  def _set_no_nhrp_route_watch(self, v, load=False):
    """
    Setter method for no_nhrp_route_watch, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/no_nhrp_route_watch (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_nhrp_route_watch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_nhrp_route_watch() directly.

    YANG Description: no-nhrp-route-watch: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="no-nhrp-route-watch", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_nhrp_route_watch must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-nhrp-route-watch", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__no_nhrp_route_watch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_nhrp_route_watch(self):
    self.__no_nhrp_route_watch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="no-nhrp-route-watch", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_nhrp_reg_no_uniq(self):
    """
    Getter method for nhrp_reg_no_uniq, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_reg_no_uniq (boolean)

    YANG Description: nhrp-reg-no-uniq: True/False
    """
    return self.__nhrp_reg_no_uniq
      
  def _set_nhrp_reg_no_uniq(self, v, load=False):
    """
    Setter method for nhrp_reg_no_uniq, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_reg_no_uniq (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_reg_no_uniq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_reg_no_uniq() directly.

    YANG Description: nhrp-reg-no-uniq: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nhrp-reg-no-uniq", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_reg_no_uniq must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-reg-no-uniq", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__nhrp_reg_no_uniq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_reg_no_uniq(self):
    self.__nhrp_reg_no_uniq = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-reg-no-uniq", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_nhrp_reg_timeout(self):
    """
    Getter method for nhrp_reg_timeout, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_reg_timeout (uint32)

    YANG Description: 0..4294967295
    """
    return self.__nhrp_reg_timeout
      
  def _set_nhrp_reg_timeout(self, v, load=False):
    """
    Setter method for nhrp_reg_timeout, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_reg_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_reg_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_reg_timeout() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-reg-timeout", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_reg_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-reg-timeout", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__nhrp_reg_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_reg_timeout(self):
    self.__nhrp_reg_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="nhrp-reg-timeout", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_nhrp_holdtime(self):
    """
    Getter method for nhrp_holdtime, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_holdtime (uint16)

    YANG Description: 1..65535
    """
    return self.__nhrp_holdtime
      
  def _set_nhrp_holdtime(self, v, load=False):
    """
    Setter method for nhrp_holdtime, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_holdtime (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_holdtime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_holdtime() directly.

    YANG Description: 1..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="nhrp-holdtime", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_holdtime must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="nhrp-holdtime", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)""",
        })

    self.__nhrp_holdtime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_holdtime(self):
    self.__nhrp_holdtime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="nhrp-holdtime", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)


  def _get_nhrp_redirect(self):
    """
    Getter method for nhrp_redirect, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_redirect (boolean)

    YANG Description: nhrp-redirect: True/False
    """
    return self.__nhrp_redirect
      
  def _set_nhrp_redirect(self, v, load=False):
    """
    Setter method for nhrp_redirect, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_redirect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_redirect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_redirect() directly.

    YANG Description: nhrp-redirect: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nhrp-redirect", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_redirect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-redirect", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__nhrp_redirect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_redirect(self):
    self.__nhrp_redirect = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-redirect", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_nhrp_shortcut(self):
    """
    Getter method for nhrp_shortcut, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_shortcut (boolean)

    YANG Description: nhrp-shortcut: True/False
    """
    return self.__nhrp_shortcut
      
  def _set_nhrp_shortcut(self, v, load=False):
    """
    Setter method for nhrp_shortcut, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_shortcut (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_shortcut is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_shortcut() directly.

    YANG Description: nhrp-shortcut: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nhrp-shortcut", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_shortcut must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-shortcut", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__nhrp_shortcut = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_shortcut(self):
    self.__nhrp_shortcut = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nhrp-shortcut", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_tunnel_keepalive_period(self):
    """
    Getter method for tunnel_keepalive_period, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_keepalive_period (uint16)

    YANG Description: 0..32767
    """
    return self.__tunnel_keepalive_period
      
  def _set_tunnel_keepalive_period(self, v, load=False):
    """
    Setter method for tunnel_keepalive_period, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_keepalive_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_keepalive_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_keepalive_period() directly.

    YANG Description: 0..32767
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..32767']}), is_leaf=True, yang_name="tunnel-keepalive-period", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_keepalive_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..32767']}), is_leaf=True, yang_name="tunnel-keepalive-period", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)""",
        })

    self.__tunnel_keepalive_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_keepalive_period(self):
    self.__tunnel_keepalive_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..32767']}), is_leaf=True, yang_name="tunnel-keepalive-period", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint16', is_config=True)


  def _get_tunnel_keepalive_retries(self):
    """
    Getter method for tunnel_keepalive_retries, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_keepalive_retries (uint8)

    YANG Description: 1..255
    """
    return self.__tunnel_keepalive_retries
      
  def _set_tunnel_keepalive_retries(self, v, load=False):
    """
    Setter method for tunnel_keepalive_retries, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tunnel_keepalive_retries (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_keepalive_retries is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_keepalive_retries() directly.

    YANG Description: 1..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="tunnel-keepalive-retries", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_keepalive_retries must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="tunnel-keepalive-retries", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint8', is_config=True)""",
        })

    self.__tunnel_keepalive_retries = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_keepalive_retries(self):
    self.__tunnel_keepalive_retries = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..255']}), is_leaf=True, yang_name="tunnel-keepalive-retries", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint8', is_config=True)


  def _get_if_state_nhrp(self):
    """
    Getter method for if_state_nhrp, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/if_state_nhrp (boolean)

    YANG Description: if-state-nhrp: True/False
    """
    return self.__if_state_nhrp
      
  def _set_if_state_nhrp(self, v, load=False):
    """
    Setter method for if_state_nhrp, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/if_state_nhrp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_state_nhrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_state_nhrp() directly.

    YANG Description: if-state-nhrp: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="if-state-nhrp", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_state_nhrp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="if-state-nhrp", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__if_state_nhrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_state_nhrp(self):
    self.__if_state_nhrp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="if-state-nhrp", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_delay(self):
    """
    Getter method for delay, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/delay (uint32)

    YANG Description: 0..4294967295
    """
    return self.__delay
      
  def _set_delay(self, v, load=False):
    """
    Setter method for delay, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay(self):
    self.__delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_nat_name(self):
    """
    Getter method for nat_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nat_name (string)

    YANG Description: string
    """
    return self.__nat_name
      
  def _set_nat_name(self, v, load=False):
    """
    Setter method for nat_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nat_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nat_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nat_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="nat-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nat_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="nat-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__nat_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nat_name(self):
    self.__nat_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="nat-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/mtu (uint32)

    YANG Description: 0..4294967295
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_tcp_adjust_mss(self):
    """
    Getter method for tcp_adjust_mss, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tcp_adjust_mss (uint32)

    YANG Description: 0..4294967295
    """
    return self.__tcp_adjust_mss
      
  def _set_tcp_adjust_mss(self, v, load=False):
    """
    Setter method for tcp_adjust_mss, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/tcp_adjust_mss (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_adjust_mss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_adjust_mss() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tcp-adjust-mss", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_adjust_mss must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tcp-adjust-mss", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__tcp_adjust_mss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_adjust_mss(self):
    self.__tcp_adjust_mss = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="tcp-adjust-mss", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_authentication_type(self):
    """
    Getter method for authentication_type, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/authentication_type (string)

    YANG Description: string
    """
    return self.__authentication_type
      
  def _set_authentication_type(self, v, load=False):
    """
    Setter method for authentication_type, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/authentication_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_authentication_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_authentication_type() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="authentication-type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """authentication_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="authentication-type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__authentication_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_authentication_type(self):
    self.__authentication_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="authentication-type", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_eigrpProcessNumber(self):
    """
    Getter method for eigrpProcessNumber, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/eigrpProcessNumber (string)

    YANG Description: string
    """
    return self.__eigrpProcessNumber
      
  def _set_eigrpProcessNumber(self, v, load=False):
    """
    Setter method for eigrpProcessNumber, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/eigrpProcessNumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eigrpProcessNumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eigrpProcessNumber() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="eigrpProcessNumber", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eigrpProcessNumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="eigrpProcessNumber", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__eigrpProcessNumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eigrpProcessNumber(self):
    self.__eigrpProcessNumber = YANGDynClass(base=unicode, is_leaf=True, yang_name="eigrpProcessNumber", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_key_chain(self):
    """
    Getter method for key_chain, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/key_chain (string)

    YANG Description: string
    """
    return self.__key_chain
      
  def _set_key_chain(self, v, load=False):
    """
    Setter method for key_chain, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/key_chain (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_chain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_chain() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="key-chain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_chain must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="key-chain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__key_chain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_chain(self):
    self.__key_chain = YANGDynClass(base=unicode, is_leaf=True, yang_name="key-chain", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_vrf_definition_mode(self):
    """
    Getter method for vrf_definition_mode, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/vrf_definition_mode (boolean)

    YANG Description: vrf-definition-mode: True/False
    """
    return self.__vrf_definition_mode
      
  def _set_vrf_definition_mode(self, v, load=False):
    """
    Setter method for vrf_definition_mode, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/vrf_definition_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_definition_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_definition_mode() directly.

    YANG Description: vrf-definition-mode: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_definition_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__vrf_definition_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_definition_mode(self):
    self.__vrf_definition_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/vrf_name (string)

    YANG Description: string
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/vrf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_front_vrf_name(self):
    """
    Getter method for front_vrf_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/front_vrf_name (string)

    YANG Description: string
    """
    return self.__front_vrf_name
      
  def _set_front_vrf_name(self, v, load=False):
    """
    Setter method for front_vrf_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/front_vrf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_front_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_front_vrf_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="front-vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """front_vrf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="front-vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__front_vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_front_vrf_name(self):
    self.__front_vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="front-vrf-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)


  def _get_in_queue_length(self):
    """
    Getter method for in_queue_length, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/in_queue_length (uint32)

    YANG Description: 0..240000
    """
    return self.__in_queue_length
      
  def _set_in_queue_length(self, v, load=False):
    """
    Setter method for in_queue_length, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/in_queue_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_queue_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_queue_length() directly.

    YANG Description: 0..240000
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="in-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_queue_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="in-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__in_queue_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_queue_length(self):
    self.__in_queue_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="in-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_out_queue_length(self):
    """
    Getter method for out_queue_length, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/out_queue_length (uint32)

    YANG Description: 0..240000
    """
    return self.__out_queue_length
      
  def _set_out_queue_length(self, v, load=False):
    """
    Setter method for out_queue_length, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/out_queue_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_queue_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_queue_length() directly.

    YANG Description: 0..240000
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="out-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_queue_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="out-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)""",
        })

    self.__out_queue_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_queue_length(self):
    self.__out_queue_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..240000']}), is_leaf=True, yang_name="out-queue-length", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='uint32', is_config=True)


  def _get_map_multicast(self):
    """
    Getter method for map_multicast, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/map_multicast (boolean)

    YANG Description: map-multicast: True/False
    """
    return self.__map_multicast
      
  def _set_map_multicast(self, v, load=False):
    """
    Setter method for map_multicast, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/map_multicast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_map_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_map_multicast() directly.

    YANG Description: map-multicast: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="map-multicast", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """map_multicast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="map-multicast", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)""",
        })

    self.__map_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_map_multicast(self):
    self.__map_multicast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="map-multicast", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='boolean', is_config=True)


  def _get_ipsec_profile_name(self):
    """
    Getter method for ipsec_profile_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/ipsec_profile_name (leafref)

    YANG Description: ipsec-profile-name
    """
    return self.__ipsec_profile_name
      
  def _set_ipsec_profile_name(self, v, load=False):
    """
    Setter method for ipsec_profile_name, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/ipsec_profile_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_profile_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_profile_name() directly.

    YANG Description: ipsec-profile-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ipsec-profile-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_profile_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ipsec-profile-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='leafref', is_config=True)""",
        })

    self.__ipsec_profile_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_profile_name(self):
    self.__ipsec_profile_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="ipsec-profile-name", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='leafref', is_config=True)


  def _get_routing_protocol(self):
    """
    Getter method for routing_protocol, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/routing_protocol (enumeration)

    YANG Description: ospf
eigrp
bgp

    """
    return self.__routing_protocol
      
  def _set_routing_protocol(self, v, load=False):
    """
    Setter method for routing_protocol, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/routing_protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_protocol() directly.

    YANG Description: ospf
eigrp
bgp

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'bgp': {}, u'eigrp': {}, u'ospf': {}},), is_leaf=True, yang_name="routing-protocol", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_protocol must be of a type compatible with enumeration""",
          'defined-type': "dmvpn:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'bgp': {}, u'eigrp': {}, u'ospf': {}},), is_leaf=True, yang_name="routing-protocol", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)""",
        })

    self.__routing_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_protocol(self):
    self.__routing_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'bgp': {}, u'eigrp': {}, u'ospf': {}},), is_leaf=True, yang_name="routing-protocol", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='enumeration', is_config=True)


  def _get_hub_list(self):
    """
    Getter method for hub_list, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/hub_list (list)
    """
    return self.__hub_list
      
  def _set_hub_list(self, v, load=False):
    """
    Setter method for hub_list, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/hub_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hub_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hub_list() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("ip_address",hub_list.hub_list, yang_name="hub-list", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="hub-list", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hub_list must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip_address",hub_list.hub_list, yang_name="hub-list", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="hub-list", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)""",
        })

    self.__hub_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hub_list(self):
    self.__hub_list = YANGDynClass(base=YANGListType("ip_address",hub_list.hub_list, yang_name="hub-list", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip-address'), is_container='list', yang_name="hub-list", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)


  def _get_nhrp_maps(self):
    """
    Getter method for nhrp_maps, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_maps (list)
    """
    return self.__nhrp_maps
      
  def _set_nhrp_maps(self, v, load=False):
    """
    Setter method for nhrp_maps, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_maps (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("sourceip destip",nhrp_maps.nhrp_maps, yang_name="nhrp-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sourceip destip'), is_container='list', yang_name="nhrp-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_maps must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("sourceip destip",nhrp_maps.nhrp_maps, yang_name="nhrp-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sourceip destip'), is_container='list', yang_name="nhrp-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)""",
        })

    self.__nhrp_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_maps(self):
    self.__nhrp_maps = YANGDynClass(base=YANGListType("sourceip destip",nhrp_maps.nhrp_maps, yang_name="nhrp-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sourceip destip'), is_container='list', yang_name="nhrp-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)


  def _get_nhrp_qos_maps(self):
    """
    Getter method for nhrp_qos_maps, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_qos_maps (list)
    """
    return self.__nhrp_qos_maps
      
  def _set_nhrp_qos_maps(self, v, load=False):
    """
    Setter method for nhrp_qos_maps, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/nhrp_qos_maps (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_qos_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_qos_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("name",nhrp_qos_maps.nhrp_qos_maps, yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_qos_maps must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",nhrp_qos_maps.nhrp_qos_maps, yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)""",
        })

    self.__nhrp_qos_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_qos_maps(self):
    self.__nhrp_qos_maps = YANGDynClass(base=YANGListType("name",nhrp_qos_maps.nhrp_qos_maps, yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="nhrp-qos-maps", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='list', is_config=True)


  def _get_domain_path(self):
    """
    Getter method for domain_path, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/domain_path (container)
    """
    return self.__domain_path
      
  def _set_domain_path(self, v, load=False):
    """
    Setter method for domain_path, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/domain_path (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_path() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=domain_path.domain_path, is_container='container', yang_name="domain-path", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_path must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=domain_path.domain_path, is_container='container', yang_name="domain-path", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)""",
        })

    self.__domain_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_path(self):
    self.__domain_path = YANGDynClass(base=domain_path.domain_path, is_container='container', yang_name="domain-path", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='container', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/dmvpntunnels/dmvpntunnel/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="dmvpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dmvpn', defining_module='dmvpn', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  ipaddress = __builtin__.property(_get_ipaddress, _set_ipaddress)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  tunnel_source = __builtin__.property(_get_tunnel_source, _set_tunnel_source)
  tunnel_destination = __builtin__.property(_get_tunnel_destination, _set_tunnel_destination)
  tunnel_mode = __builtin__.property(_get_tunnel_mode, _set_tunnel_mode)
  tunnel_key = __builtin__.property(_get_tunnel_key, _set_tunnel_key)
  nhrp_network_id = __builtin__.property(_get_nhrp_network_id, _set_nhrp_network_id)
  nhrp_auth_key = __builtin__.property(_get_nhrp_auth_key, _set_nhrp_auth_key)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  shared = __builtin__.property(_get_shared, _set_shared)
  no_nhrp_route_watch = __builtin__.property(_get_no_nhrp_route_watch, _set_no_nhrp_route_watch)
  nhrp_reg_no_uniq = __builtin__.property(_get_nhrp_reg_no_uniq, _set_nhrp_reg_no_uniq)
  nhrp_reg_timeout = __builtin__.property(_get_nhrp_reg_timeout, _set_nhrp_reg_timeout)
  nhrp_holdtime = __builtin__.property(_get_nhrp_holdtime, _set_nhrp_holdtime)
  nhrp_redirect = __builtin__.property(_get_nhrp_redirect, _set_nhrp_redirect)
  nhrp_shortcut = __builtin__.property(_get_nhrp_shortcut, _set_nhrp_shortcut)
  tunnel_keepalive_period = __builtin__.property(_get_tunnel_keepalive_period, _set_tunnel_keepalive_period)
  tunnel_keepalive_retries = __builtin__.property(_get_tunnel_keepalive_retries, _set_tunnel_keepalive_retries)
  if_state_nhrp = __builtin__.property(_get_if_state_nhrp, _set_if_state_nhrp)
  delay = __builtin__.property(_get_delay, _set_delay)
  nat_name = __builtin__.property(_get_nat_name, _set_nat_name)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  tcp_adjust_mss = __builtin__.property(_get_tcp_adjust_mss, _set_tcp_adjust_mss)
  authentication_type = __builtin__.property(_get_authentication_type, _set_authentication_type)
  eigrpProcessNumber = __builtin__.property(_get_eigrpProcessNumber, _set_eigrpProcessNumber)
  key_chain = __builtin__.property(_get_key_chain, _set_key_chain)
  vrf_definition_mode = __builtin__.property(_get_vrf_definition_mode, _set_vrf_definition_mode)
  vrf_name = __builtin__.property(_get_vrf_name, _set_vrf_name)
  front_vrf_name = __builtin__.property(_get_front_vrf_name, _set_front_vrf_name)
  in_queue_length = __builtin__.property(_get_in_queue_length, _set_in_queue_length)
  out_queue_length = __builtin__.property(_get_out_queue_length, _set_out_queue_length)
  map_multicast = __builtin__.property(_get_map_multicast, _set_map_multicast)
  ipsec_profile_name = __builtin__.property(_get_ipsec_profile_name, _set_ipsec_profile_name)
  routing_protocol = __builtin__.property(_get_routing_protocol, _set_routing_protocol)
  hub_list = __builtin__.property(_get_hub_list, _set_hub_list)
  nhrp_maps = __builtin__.property(_get_nhrp_maps, _set_nhrp_maps)
  nhrp_qos_maps = __builtin__.property(_get_nhrp_qos_maps, _set_nhrp_qos_maps)
  domain_path = __builtin__.property(_get_domain_path, _set_domain_path)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('type', type), ('ipaddress', ipaddress), ('netmask', netmask), ('tunnel_source', tunnel_source), ('tunnel_destination', tunnel_destination), ('tunnel_mode', tunnel_mode), ('tunnel_key', tunnel_key), ('nhrp_network_id', nhrp_network_id), ('nhrp_auth_key', nhrp_auth_key), ('bandwidth', bandwidth), ('shared', shared), ('no_nhrp_route_watch', no_nhrp_route_watch), ('nhrp_reg_no_uniq', nhrp_reg_no_uniq), ('nhrp_reg_timeout', nhrp_reg_timeout), ('nhrp_holdtime', nhrp_holdtime), ('nhrp_redirect', nhrp_redirect), ('nhrp_shortcut', nhrp_shortcut), ('tunnel_keepalive_period', tunnel_keepalive_period), ('tunnel_keepalive_retries', tunnel_keepalive_retries), ('if_state_nhrp', if_state_nhrp), ('delay', delay), ('nat_name', nat_name), ('mtu', mtu), ('tcp_adjust_mss', tcp_adjust_mss), ('authentication_type', authentication_type), ('eigrpProcessNumber', eigrpProcessNumber), ('key_chain', key_chain), ('vrf_definition_mode', vrf_definition_mode), ('vrf_name', vrf_name), ('front_vrf_name', front_vrf_name), ('in_queue_length', in_queue_length), ('out_queue_length', out_queue_length), ('map_multicast', map_multicast), ('ipsec_profile_name', ipsec_profile_name), ('routing_protocol', routing_protocol), ('hub_list', hub_list), ('nhrp_maps', nhrp_maps), ('nhrp_qos_maps', nhrp_qos_maps), ('domain_path', domain_path), ('description', description), ])


