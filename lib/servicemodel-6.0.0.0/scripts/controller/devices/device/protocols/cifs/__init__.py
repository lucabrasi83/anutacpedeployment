
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class cifs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/protocols/cifs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__cifs_enable','__applock','__clear_read_resp','__write_optimization','__dw_throttling','__ext_dir_cache','__mac_oplock','__oopen','__oopen_policy','__oopen_extension','__oopen_add_extension','__add_settings_always_policy','__oopen_modify_extension','__modify_settings_policy','__oopen_remove_extension','__smb_signing','__smb_signing_ntlm_bypass','__smb_signing_mode_type','__smb_signing_native_krb','__smbv1_mode','__cifs_prepop',)

  _yang_name = 'cifs'
  _module_name = 'wanoptimizer'
  _namespace = 'http://anutanetworks.com/wanoptimizer'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__modify_settings_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="modify-settings-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__smbv1_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__add_settings_always_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="add-settings-always-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__oopen_extension = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'add': {}, u'modify': {}, u'remove': {}},), is_leaf=True, yang_name="oopen-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__oopen_remove_extension = YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-remove-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__smb_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__cifs_enable = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__clear_read_resp = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="clear-read-resp", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__write_optimization = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}},), is_leaf=True, yang_name="write-optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__oopen_modify_extension = YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-modify-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__oopen = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="oopen", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__cifs_prepop = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-prepop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__mac_oplock = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mac-oplock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__smb_signing_mode_type = YANGDynClass(base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},),], is_leaf=True, yang_name="smb-signing-mode-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    self.__smb_signing_ntlm_bypass = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing-ntlm-bypass", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__oopen_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="oopen-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__smb_signing_native_krb = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'downgrade': {}, u'enable': {}},), is_leaf=True, yang_name="smb-signing-native-krb", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__applock = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="applock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__oopen_add_extension = YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-add-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    self.__dw_throttling = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="dw-throttling", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    self.__ext_dir_cache = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="ext-dir-cache", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'protocols', u'cifs']

  def _get_cifs_enable(self):
    """
    Getter method for cifs_enable, mapped from YANG variable /devices/device/protocols/cifs/cifs_enable (enumeration)

    YANG Description: enable

    """
    return self.__cifs_enable
      
  def _set_cifs_enable(self, v, load=False):
    """
    Setter method for cifs_enable, mapped from YANG variable /devices/device/protocols/cifs/cifs_enable (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cifs_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cifs_enable() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cifs_enable must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__cifs_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cifs_enable(self):
    self.__cifs_enable = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-enable", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_applock(self):
    """
    Getter method for applock, mapped from YANG variable /devices/device/protocols/cifs/applock (enumeration)

    YANG Description: enable

    """
    return self.__applock
      
  def _set_applock(self, v, load=False):
    """
    Setter method for applock, mapped from YANG variable /devices/device/protocols/cifs/applock (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_applock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_applock() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="applock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """applock must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="applock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__applock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_applock(self):
    self.__applock = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="applock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_clear_read_resp(self):
    """
    Getter method for clear_read_resp, mapped from YANG variable /devices/device/protocols/cifs/clear_read_resp (enumeration)

    YANG Description: enable

    """
    return self.__clear_read_resp
      
  def _set_clear_read_resp(self, v, load=False):
    """
    Setter method for clear_read_resp, mapped from YANG variable /devices/device/protocols/cifs/clear_read_resp (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_read_resp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_read_resp() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="clear-read-resp", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_read_resp must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="clear-read-resp", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__clear_read_resp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_read_resp(self):
    self.__clear_read_resp = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="clear-read-resp", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_write_optimization(self):
    """
    Getter method for write_optimization, mapped from YANG variable /devices/device/protocols/cifs/write_optimization (enumeration)

    YANG Description: disable

    """
    return self.__write_optimization
      
  def _set_write_optimization(self, v, load=False):
    """
    Setter method for write_optimization, mapped from YANG variable /devices/device/protocols/cifs/write_optimization (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_write_optimization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_write_optimization() directly.

    YANG Description: disable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}},), is_leaf=True, yang_name="write-optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """write_optimization must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}},), is_leaf=True, yang_name="write-optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__write_optimization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_write_optimization(self):
    self.__write_optimization = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}},), is_leaf=True, yang_name="write-optimization", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_dw_throttling(self):
    """
    Getter method for dw_throttling, mapped from YANG variable /devices/device/protocols/cifs/dw_throttling (enumeration)

    YANG Description: enable

    """
    return self.__dw_throttling
      
  def _set_dw_throttling(self, v, load=False):
    """
    Setter method for dw_throttling, mapped from YANG variable /devices/device/protocols/cifs/dw_throttling (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dw_throttling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dw_throttling() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="dw-throttling", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dw_throttling must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="dw-throttling", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__dw_throttling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dw_throttling(self):
    self.__dw_throttling = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="dw-throttling", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_ext_dir_cache(self):
    """
    Getter method for ext_dir_cache, mapped from YANG variable /devices/device/protocols/cifs/ext_dir_cache (enumeration)

    YANG Description: enable

    """
    return self.__ext_dir_cache
      
  def _set_ext_dir_cache(self, v, load=False):
    """
    Setter method for ext_dir_cache, mapped from YANG variable /devices/device/protocols/cifs/ext_dir_cache (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_dir_cache is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_dir_cache() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="ext-dir-cache", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_dir_cache must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="ext-dir-cache", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__ext_dir_cache = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_dir_cache(self):
    self.__ext_dir_cache = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="ext-dir-cache", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_mac_oplock(self):
    """
    Getter method for mac_oplock, mapped from YANG variable /devices/device/protocols/cifs/mac_oplock (enumeration)

    YANG Description: enable

    """
    return self.__mac_oplock
      
  def _set_mac_oplock(self, v, load=False):
    """
    Setter method for mac_oplock, mapped from YANG variable /devices/device/protocols/cifs/mac_oplock (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_oplock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_oplock() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mac-oplock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_oplock must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mac-oplock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__mac_oplock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_oplock(self):
    self.__mac_oplock = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="mac-oplock", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_oopen(self):
    """
    Getter method for oopen, mapped from YANG variable /devices/device/protocols/cifs/oopen (enumeration)

    YANG Description: enable

    """
    return self.__oopen
      
  def _set_oopen(self, v, load=False):
    """
    Setter method for oopen, mapped from YANG variable /devices/device/protocols/cifs/oopen (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oopen is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oopen() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="oopen", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oopen must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="oopen", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__oopen = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oopen(self):
    self.__oopen = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="oopen", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_oopen_policy(self):
    """
    Getter method for oopen_policy, mapped from YANG variable /devices/device/protocols/cifs/oopen_policy (enumeration)

    YANG Description: allow
deny

    """
    return self.__oopen_policy
      
  def _set_oopen_policy(self, v, load=False):
    """
    Setter method for oopen_policy, mapped from YANG variable /devices/device/protocols/cifs/oopen_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oopen_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oopen_policy() directly.

    YANG Description: allow
deny

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="oopen-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oopen_policy must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="oopen-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__oopen_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oopen_policy(self):
    self.__oopen_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="oopen-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_oopen_extension(self):
    """
    Getter method for oopen_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_extension (enumeration)

    YANG Description: add
modify
remove

    """
    return self.__oopen_extension
      
  def _set_oopen_extension(self, v, load=False):
    """
    Setter method for oopen_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_extension (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oopen_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oopen_extension() directly.

    YANG Description: add
modify
remove

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'add': {}, u'modify': {}, u'remove': {}},), is_leaf=True, yang_name="oopen-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oopen_extension must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'add': {}, u'modify': {}, u'remove': {}},), is_leaf=True, yang_name="oopen-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__oopen_extension = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oopen_extension(self):
    self.__oopen_extension = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'add': {}, u'modify': {}, u'remove': {}},), is_leaf=True, yang_name="oopen-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_oopen_add_extension(self):
    """
    Getter method for oopen_add_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_add_extension (string)

    YANG Description: string
    """
    return self.__oopen_add_extension
      
  def _set_oopen_add_extension(self, v, load=False):
    """
    Setter method for oopen_add_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_add_extension (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oopen_add_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oopen_add_extension() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="oopen-add-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oopen_add_extension must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-add-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__oopen_add_extension = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oopen_add_extension(self):
    self.__oopen_add_extension = YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-add-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_add_settings_always_policy(self):
    """
    Getter method for add_settings_always_policy, mapped from YANG variable /devices/device/protocols/cifs/add_settings_always_policy (enumeration)

    YANG Description: allow
deny

    """
    return self.__add_settings_always_policy
      
  def _set_add_settings_always_policy(self, v, load=False):
    """
    Setter method for add_settings_always_policy, mapped from YANG variable /devices/device/protocols/cifs/add_settings_always_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_add_settings_always_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_add_settings_always_policy() directly.

    YANG Description: allow
deny

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="add-settings-always-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """add_settings_always_policy must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="add-settings-always-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__add_settings_always_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_add_settings_always_policy(self):
    self.__add_settings_always_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="add-settings-always-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_oopen_modify_extension(self):
    """
    Getter method for oopen_modify_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_modify_extension (string)

    YANG Description: string
    """
    return self.__oopen_modify_extension
      
  def _set_oopen_modify_extension(self, v, load=False):
    """
    Setter method for oopen_modify_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_modify_extension (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oopen_modify_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oopen_modify_extension() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="oopen-modify-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oopen_modify_extension must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-modify-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__oopen_modify_extension = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oopen_modify_extension(self):
    self.__oopen_modify_extension = YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-modify-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_modify_settings_policy(self):
    """
    Getter method for modify_settings_policy, mapped from YANG variable /devices/device/protocols/cifs/modify_settings_policy (enumeration)

    YANG Description: allow
deny

    """
    return self.__modify_settings_policy
      
  def _set_modify_settings_policy(self, v, load=False):
    """
    Setter method for modify_settings_policy, mapped from YANG variable /devices/device/protocols/cifs/modify_settings_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modify_settings_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modify_settings_policy() directly.

    YANG Description: allow
deny

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="modify-settings-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modify_settings_policy must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="modify-settings-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__modify_settings_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modify_settings_policy(self):
    self.__modify_settings_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'deny': {}, u'allow': {}},), is_leaf=True, yang_name="modify-settings-policy", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_oopen_remove_extension(self):
    """
    Getter method for oopen_remove_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_remove_extension (string)

    YANG Description: string
    """
    return self.__oopen_remove_extension
      
  def _set_oopen_remove_extension(self, v, load=False):
    """
    Setter method for oopen_remove_extension, mapped from YANG variable /devices/device/protocols/cifs/oopen_remove_extension (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oopen_remove_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oopen_remove_extension() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="oopen-remove-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oopen_remove_extension must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-remove-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)""",
        })

    self.__oopen_remove_extension = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oopen_remove_extension(self):
    self.__oopen_remove_extension = YANGDynClass(base=unicode, is_leaf=True, yang_name="oopen-remove-extension", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='string', is_config=True)


  def _get_smb_signing(self):
    """
    Getter method for smb_signing, mapped from YANG variable /devices/device/protocols/cifs/smb_signing (enumeration)

    YANG Description: enable

    """
    return self.__smb_signing
      
  def _set_smb_signing(self, v, load=False):
    """
    Setter method for smb_signing, mapped from YANG variable /devices/device/protocols/cifs/smb_signing (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smb_signing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smb_signing() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smb_signing must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__smb_signing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smb_signing(self):
    self.__smb_signing = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_smb_signing_ntlm_bypass(self):
    """
    Getter method for smb_signing_ntlm_bypass, mapped from YANG variable /devices/device/protocols/cifs/smb_signing_ntlm_bypass (enumeration)

    YANG Description: enable

    """
    return self.__smb_signing_ntlm_bypass
      
  def _set_smb_signing_ntlm_bypass(self, v, load=False):
    """
    Setter method for smb_signing_ntlm_bypass, mapped from YANG variable /devices/device/protocols/cifs/smb_signing_ntlm_bypass (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smb_signing_ntlm_bypass is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smb_signing_ntlm_bypass() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing-ntlm-bypass", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smb_signing_ntlm_bypass must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing-ntlm-bypass", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__smb_signing_ntlm_bypass = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smb_signing_ntlm_bypass(self):
    self.__smb_signing_ntlm_bypass = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smb-signing-ntlm-bypass", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_smb_signing_mode_type(self):
    """
    Getter method for smb_signing_mode_type, mapped from YANG variable /devices/device/protocols/cifs/smb_signing_mode_type (union)

    YANG Description: Union Input types:
string
enumeration

    """
    return self.__smb_signing_mode_type
      
  def _set_smb_signing_mode_type(self, v, load=False):
    """
    Setter method for smb_signing_mode_type, mapped from YANG variable /devices/device/protocols/cifs/smb_signing_mode_type (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smb_signing_mode_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smb_signing_mode_type() directly.

    YANG Description: Union Input types:
string
enumeration

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},),], is_leaf=True, yang_name="smb-signing-mode-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smb_signing_mode_type must be of a type compatible with union""",
          'defined-type': "wanoptimizer:union",
          'generated-type': """YANGDynClass(base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},),], is_leaf=True, yang_name="smb-signing-mode-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)""",
        })

    self.__smb_signing_mode_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smb_signing_mode_type(self):
    self.__smb_signing_mode_type = YANGDynClass(base=[unicode,RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'delegation': {}, u'transparent': {}},),], is_leaf=True, yang_name="smb-signing-mode-type", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='union', is_config=True)


  def _get_smb_signing_native_krb(self):
    """
    Getter method for smb_signing_native_krb, mapped from YANG variable /devices/device/protocols/cifs/smb_signing_native_krb (enumeration)

    YANG Description: enable
downgrade

    """
    return self.__smb_signing_native_krb
      
  def _set_smb_signing_native_krb(self, v, load=False):
    """
    Setter method for smb_signing_native_krb, mapped from YANG variable /devices/device/protocols/cifs/smb_signing_native_krb (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smb_signing_native_krb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smb_signing_native_krb() directly.

    YANG Description: enable
downgrade

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'downgrade': {}, u'enable': {}},), is_leaf=True, yang_name="smb-signing-native-krb", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smb_signing_native_krb must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'downgrade': {}, u'enable': {}},), is_leaf=True, yang_name="smb-signing-native-krb", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__smb_signing_native_krb = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smb_signing_native_krb(self):
    self.__smb_signing_native_krb = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'downgrade': {}, u'enable': {}},), is_leaf=True, yang_name="smb-signing-native-krb", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_smbv1_mode(self):
    """
    Getter method for smbv1_mode, mapped from YANG variable /devices/device/protocols/cifs/smbv1_mode (enumeration)

    YANG Description: enable

    """
    return self.__smbv1_mode
      
  def _set_smbv1_mode(self, v, load=False):
    """
    Setter method for smbv1_mode, mapped from YANG variable /devices/device/protocols/cifs/smbv1_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_smbv1_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_smbv1_mode() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """smbv1_mode must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__smbv1_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_smbv1_mode(self):
    self.__smbv1_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="smbv1-mode", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)


  def _get_cifs_prepop(self):
    """
    Getter method for cifs_prepop, mapped from YANG variable /devices/device/protocols/cifs/cifs_prepop (enumeration)

    YANG Description: enable

    """
    return self.__cifs_prepop
      
  def _set_cifs_prepop(self, v, load=False):
    """
    Setter method for cifs_prepop, mapped from YANG variable /devices/device/protocols/cifs/cifs_prepop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cifs_prepop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cifs_prepop() directly.

    YANG Description: enable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-prepop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cifs_prepop must be of a type compatible with enumeration""",
          'defined-type': "wanoptimizer:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-prepop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)""",
        })

    self.__cifs_prepop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cifs_prepop(self):
    self.__cifs_prepop = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="cifs-prepop", module_name="wanoptimizer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/wanoptimizer', defining_module='wanoptimizer', yang_type='enumeration', is_config=True)

  cifs_enable = __builtin__.property(_get_cifs_enable, _set_cifs_enable)
  applock = __builtin__.property(_get_applock, _set_applock)
  clear_read_resp = __builtin__.property(_get_clear_read_resp, _set_clear_read_resp)
  write_optimization = __builtin__.property(_get_write_optimization, _set_write_optimization)
  dw_throttling = __builtin__.property(_get_dw_throttling, _set_dw_throttling)
  ext_dir_cache = __builtin__.property(_get_ext_dir_cache, _set_ext_dir_cache)
  mac_oplock = __builtin__.property(_get_mac_oplock, _set_mac_oplock)
  oopen = __builtin__.property(_get_oopen, _set_oopen)
  oopen_policy = __builtin__.property(_get_oopen_policy, _set_oopen_policy)
  oopen_extension = __builtin__.property(_get_oopen_extension, _set_oopen_extension)
  oopen_add_extension = __builtin__.property(_get_oopen_add_extension, _set_oopen_add_extension)
  add_settings_always_policy = __builtin__.property(_get_add_settings_always_policy, _set_add_settings_always_policy)
  oopen_modify_extension = __builtin__.property(_get_oopen_modify_extension, _set_oopen_modify_extension)
  modify_settings_policy = __builtin__.property(_get_modify_settings_policy, _set_modify_settings_policy)
  oopen_remove_extension = __builtin__.property(_get_oopen_remove_extension, _set_oopen_remove_extension)
  smb_signing = __builtin__.property(_get_smb_signing, _set_smb_signing)
  smb_signing_ntlm_bypass = __builtin__.property(_get_smb_signing_ntlm_bypass, _set_smb_signing_ntlm_bypass)
  smb_signing_mode_type = __builtin__.property(_get_smb_signing_mode_type, _set_smb_signing_mode_type)
  smb_signing_native_krb = __builtin__.property(_get_smb_signing_native_krb, _set_smb_signing_native_krb)
  smbv1_mode = __builtin__.property(_get_smbv1_mode, _set_smbv1_mode)
  cifs_prepop = __builtin__.property(_get_cifs_prepop, _set_cifs_prepop)


  _pyangbind_elements = collections.OrderedDict([('cifs_enable', cifs_enable), ('applock', applock), ('clear_read_resp', clear_read_resp), ('write_optimization', write_optimization), ('dw_throttling', dw_throttling), ('ext_dir_cache', ext_dir_cache), ('mac_oplock', mac_oplock), ('oopen', oopen), ('oopen_policy', oopen_policy), ('oopen_extension', oopen_extension), ('oopen_add_extension', oopen_add_extension), ('add_settings_always_policy', add_settings_always_policy), ('oopen_modify_extension', oopen_modify_extension), ('modify_settings_policy', modify_settings_policy), ('oopen_remove_extension', oopen_remove_extension), ('smb_signing', smb_signing), ('smb_signing_ntlm_bypass', smb_signing_ntlm_bypass), ('smb_signing_mode_type', smb_signing_mode_type), ('smb_signing_native_krb', smb_signing_native_krb), ('smbv1_mode', smbv1_mode), ('cifs_prepop', cifs_prepop), ])


