
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class sla(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/ip-sla/sla. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__entry_number','__vrf_name','__operation_type','__http_request_type','__http_url','__http_raw_request','__destination','__source','__source_interface_name','__source_interface_ip','__data_size','__response_data_size','__frequency','__timeout','__threshold','__destination_port','__source_port','__interval','__tos','__tag','__history_interval','__buckets_size','__num_packets','__down_delay_time','__up_delay_time',)

  _yang_name = 'sla'
  _module_name = 'l3features'
  _namespace = 'http://anutanetworks.com/l3features'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__history_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..3600']}), is_leaf=True, yang_name="history-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__down_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="down-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__source_interface_ip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-interface-ip", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ip-address', is_config=True)
    self.__tos = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="tos", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    self.__source_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-interface-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__destination = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__up_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="up-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__source = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'source-interface': {}, u'source-ip': {}},), default=unicode("source-ip"), is_leaf=True, yang_name="source", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__http_url = YANGDynClass(base=unicode, is_leaf=True, yang_name="http-url", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__data_size = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..17512']}), is_leaf=True, yang_name="data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__response_data_size = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'20..17512']}), is_leaf=True, yang_name="response-data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="source-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__entry_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="entry-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="destination-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__buckets_size = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..100']}), is_leaf=True, yang_name="buckets-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    self.__http_raw_request = YANGDynClass(base=unicode, is_leaf=True, yang_name="http-raw-request", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'4..60000']}), is_leaf=True, yang_name="interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__num_packets = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..60000']}), is_leaf=True, yang_name="num-packets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..604800']}), is_leaf=True, yang_name="frequency", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..604800000']}), is_leaf=True, yang_name="timeout", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    self.__operation_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ftp': {}, u'udp-echo': {}, u'http': {}, u'path-jitter': {}, u'path-echo': {}, u'mpls': {}, u'udp-jitter': {}, u'icmp-jitter': {}, u'tcp-connect': {}, u'icmp-echo': {}, u'exit': {}, u'dns': {}, u'ethernet': {}, u'dhcp': {}, u'voip': {}},), is_leaf=True, yang_name="operation-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    self.__http_request_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'raw': {}, u'get': {}},), is_leaf=True, yang_name="http-request-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'ip-sla', u'sla']

  def _get_entry_number(self):
    """
    Getter method for entry_number, mapped from YANG variable /devices/device/ip_sla/sla/entry_number (uint32)

    YANG Description: Enter number with in the range: 1..2147483647
    """
    return self.__entry_number
      
  def _set_entry_number(self, v, load=False):
    """
    Setter method for entry_number, mapped from YANG variable /devices/device/ip_sla/sla/entry_number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entry_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entry_number() directly.

    YANG Description: Enter number with in the range: 1..2147483647
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="entry-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """entry_number must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="entry-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__entry_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_entry_number(self):
    self.__entry_number = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..2147483647']}), is_leaf=True, yang_name="entry-number", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /devices/device/ip_sla/sla/vrf_name (leafref)

    YANG Description: vrf-name
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /devices/device/ip_sla/sla/vrf_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: vrf-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vrf-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_operation_type(self):
    """
    Getter method for operation_type, mapped from YANG variable /devices/device/ip_sla/sla/operation_type (enumeration)

    YANG Description: Select one of the operttion-type from list
    """
    return self.__operation_type
      
  def _set_operation_type(self, v, load=False):
    """
    Setter method for operation_type, mapped from YANG variable /devices/device/ip_sla/sla/operation_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation_type() directly.

    YANG Description: Select one of the operttion-type from list
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ftp': {}, u'udp-echo': {}, u'http': {}, u'path-jitter': {}, u'path-echo': {}, u'mpls': {}, u'udp-jitter': {}, u'icmp-jitter': {}, u'tcp-connect': {}, u'icmp-echo': {}, u'exit': {}, u'dns': {}, u'ethernet': {}, u'dhcp': {}, u'voip': {}},), is_leaf=True, yang_name="operation-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation_type must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ftp': {}, u'udp-echo': {}, u'http': {}, u'path-jitter': {}, u'path-echo': {}, u'mpls': {}, u'udp-jitter': {}, u'icmp-jitter': {}, u'tcp-connect': {}, u'icmp-echo': {}, u'exit': {}, u'dns': {}, u'ethernet': {}, u'dhcp': {}, u'voip': {}},), is_leaf=True, yang_name="operation-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__operation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation_type(self):
    self.__operation_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ftp': {}, u'udp-echo': {}, u'http': {}, u'path-jitter': {}, u'path-echo': {}, u'mpls': {}, u'udp-jitter': {}, u'icmp-jitter': {}, u'tcp-connect': {}, u'icmp-echo': {}, u'exit': {}, u'dns': {}, u'ethernet': {}, u'dhcp': {}, u'voip': {}},), is_leaf=True, yang_name="operation-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_http_request_type(self):
    """
    Getter method for http_request_type, mapped from YANG variable /devices/device/ip_sla/sla/http_request_type (enumeration)

    YANG Description: raw
get

    """
    return self.__http_request_type
      
  def _set_http_request_type(self, v, load=False):
    """
    Setter method for http_request_type, mapped from YANG variable /devices/device/ip_sla/sla/http_request_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_request_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_request_type() directly.

    YANG Description: raw
get

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'raw': {}, u'get': {}},), is_leaf=True, yang_name="http-request-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http_request_type must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'raw': {}, u'get': {}},), is_leaf=True, yang_name="http-request-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__http_request_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http_request_type(self):
    self.__http_request_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'raw': {}, u'get': {}},), is_leaf=True, yang_name="http-request-type", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_http_url(self):
    """
    Getter method for http_url, mapped from YANG variable /devices/device/ip_sla/sla/http_url (string)

    YANG Description: string
    """
    return self.__http_url
      
  def _set_http_url(self, v, load=False):
    """
    Setter method for http_url, mapped from YANG variable /devices/device/ip_sla/sla/http_url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_url() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="http-url", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http_url must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="http-url", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__http_url = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http_url(self):
    self.__http_url = YANGDynClass(base=unicode, is_leaf=True, yang_name="http-url", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_http_raw_request(self):
    """
    Getter method for http_raw_request, mapped from YANG variable /devices/device/ip_sla/sla/http_raw_request (string)

    YANG Description: string
    """
    return self.__http_raw_request
      
  def _set_http_raw_request(self, v, load=False):
    """
    Setter method for http_raw_request, mapped from YANG variable /devices/device/ip_sla/sla/http_raw_request (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_raw_request is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_raw_request() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="http-raw-request", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """http_raw_request must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="http-raw-request", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__http_raw_request = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_http_raw_request(self):
    self.__http_raw_request = YANGDynClass(base=unicode, is_leaf=True, yang_name="http-raw-request", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /devices/device/ip_sla/sla/destination (string)

    YANG Description: Hostname or A.B.C.D Destination IP address or hostname
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /devices/device/ip_sla/sla/destination (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: Hostname or A.B.C.D Destination IP address or hostname
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /devices/device/ip_sla/sla/source (enumeration)

    YANG Description: source-interface
source-ip

    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /devices/device/ip_sla/sla/source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: source-interface
source-ip

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'source-interface': {}, u'source-ip': {}},), default=unicode("source-ip"), is_leaf=True, yang_name="source", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with enumeration""",
          'defined-type': "l3features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'source-interface': {}, u'source-ip': {}},), default=unicode("source-ip"), is_leaf=True, yang_name="source", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'source-interface': {}, u'source-ip': {}},), default=unicode("source-ip"), is_leaf=True, yang_name="source", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='enumeration', is_config=True)


  def _get_source_interface_name(self):
    """
    Getter method for source_interface_name, mapped from YANG variable /devices/device/ip_sla/sla/source_interface_name (string)

    YANG Description: string
    """
    return self.__source_interface_name
      
  def _set_source_interface_name(self, v, load=False):
    """
    Setter method for source_interface_name, mapped from YANG variable /devices/device/ip_sla/sla/source_interface_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_interface_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_interface_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source-interface-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_interface_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source-interface-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__source_interface_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_interface_name(self):
    self.__source_interface_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="source-interface-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_source_interface_ip(self):
    """
    Getter method for source_interface_ip, mapped from YANG variable /devices/device/ip_sla/sla/source_interface_ip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__source_interface_ip
      
  def _set_source_interface_ip(self, v, load=False):
    """
    Setter method for source_interface_ip, mapped from YANG variable /devices/device/ip_sla/sla/source_interface_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_interface_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_interface_ip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-interface-ip", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_interface_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-interface-ip", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__source_interface_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_interface_ip(self):
    self.__source_interface_ip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-interface-ip", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='inet:ip-address', is_config=True)


  def _get_data_size(self):
    """
    Getter method for data_size, mapped from YANG variable /devices/device/ip_sla/sla/data_size (uint32)

    YANG Description: <16-17512>  Data Size in bytes 
    """
    return self.__data_size
      
  def _set_data_size(self, v, load=False):
    """
    Setter method for data_size, mapped from YANG variable /devices/device/ip_sla/sla/data_size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_size() directly.

    YANG Description: <16-17512>  Data Size in bytes 
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..17512']}), is_leaf=True, yang_name="data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..17512']}), is_leaf=True, yang_name="data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__data_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_size(self):
    self.__data_size = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'16..17512']}), is_leaf=True, yang_name="data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_response_data_size(self):
    """
    Getter method for response_data_size, mapped from YANG variable /devices/device/ip_sla/sla/response_data_size (uint32)

    YANG Description: <20-17512>  Data Size in bytes 
    """
    return self.__response_data_size
      
  def _set_response_data_size(self, v, load=False):
    """
    Setter method for response_data_size, mapped from YANG variable /devices/device/ip_sla/sla/response_data_size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_response_data_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_response_data_size() directly.

    YANG Description: <20-17512>  Data Size in bytes 
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'20..17512']}), is_leaf=True, yang_name="response-data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """response_data_size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'20..17512']}), is_leaf=True, yang_name="response-data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__response_data_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_response_data_size(self):
    self.__response_data_size = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'20..17512']}), is_leaf=True, yang_name="response-data-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /devices/device/ip_sla/sla/frequency (uint32)

    YANG Description: <1-604800> Frequency in seconds
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /devices/device/ip_sla/sla/frequency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: <1-604800> Frequency in seconds
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..604800']}), is_leaf=True, yang_name="frequency", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..604800']}), is_leaf=True, yang_name="frequency", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'1..604800']}), is_leaf=True, yang_name="frequency", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_timeout(self):
    """
    Getter method for timeout, mapped from YANG variable /devices/device/ip_sla/sla/timeout (uint32)

    YANG Description: <0-604800000> Timeout in milliseconds
    """
    return self.__timeout
      
  def _set_timeout(self, v, load=False):
    """
    Setter method for timeout, mapped from YANG variable /devices/device/ip_sla/sla/timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timeout() directly.

    YANG Description: <0-604800000> Timeout in milliseconds
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..604800000']}), is_leaf=True, yang_name="timeout", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..604800000']}), is_leaf=True, yang_name="timeout", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timeout(self):
    self.__timeout = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': [u'0..604800000']}), is_leaf=True, yang_name="timeout", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /devices/device/ip_sla/sla/threshold (uint32)

    YANG Description: <0-60000> Threshold in milliseconds
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /devices/device/ip_sla/sla/threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: <0-60000> Threshold in milliseconds
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint32', is_config=True)


  def _get_destination_port(self):
    """
    Getter method for destination_port, mapped from YANG variable /devices/device/ip_sla/sla/destination_port (uint16)

    YANG Description: 1..65535
    """
    return self.__destination_port
      
  def _set_destination_port(self, v, load=False):
    """
    Setter method for destination_port, mapped from YANG variable /devices/device/ip_sla/sla/destination_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port() directly.

    YANG Description: 1..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="destination-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="destination-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__destination_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_port(self):
    self.__destination_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="destination-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_source_port(self):
    """
    Getter method for source_port, mapped from YANG variable /devices/device/ip_sla/sla/source_port (uint16)

    YANG Description: 1..65535
    """
    return self.__source_port
      
  def _set_source_port(self, v, load=False):
    """
    Setter method for source_port, mapped from YANG variable /devices/device/ip_sla/sla/source_port (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port() directly.

    YANG Description: 1..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="source-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_port must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="source-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__source_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_port(self):
    self.__source_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..65535']}), is_leaf=True, yang_name="source-port", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /devices/device/ip_sla/sla/interval (uint16)

    YANG Description: 4..60000
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /devices/device/ip_sla/sla/interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: 4..60000
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'4..60000']}), is_leaf=True, yang_name="interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'4..60000']}), is_leaf=True, yang_name="interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'4..60000']}), is_leaf=True, yang_name="interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_tos(self):
    """
    Getter method for tos, mapped from YANG variable /devices/device/ip_sla/sla/tos (uint8)

    YANG Description: 0..255
    """
    return self.__tos
      
  def _set_tos(self, v, load=False):
    """
    Setter method for tos, mapped from YANG variable /devices/device/ip_sla/sla/tos (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tos() directly.

    YANG Description: 0..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="tos", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tos must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="tos", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)""",
        })

    self.__tos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tos(self):
    self.__tos = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..255']}), is_leaf=True, yang_name="tos", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /devices/device/ip_sla/sla/tag (string)

    YANG Description: string
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /devices/device/ip_sla/sla/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(base=unicode, is_leaf=True, yang_name="tag", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_history_interval(self):
    """
    Getter method for history_interval, mapped from YANG variable /devices/device/ip_sla/sla/history_interval (uint16)

    YANG Description: 1..3600
    """
    return self.__history_interval
      
  def _set_history_interval(self, v, load=False):
    """
    Setter method for history_interval, mapped from YANG variable /devices/device/ip_sla/sla/history_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_history_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_history_interval() directly.

    YANG Description: 1..3600
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..3600']}), is_leaf=True, yang_name="history-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """history_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..3600']}), is_leaf=True, yang_name="history-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__history_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_history_interval(self):
    self.__history_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..3600']}), is_leaf=True, yang_name="history-interval", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_buckets_size(self):
    """
    Getter method for buckets_size, mapped from YANG variable /devices/device/ip_sla/sla/buckets_size (uint8)

    YANG Description: 1..100
    """
    return self.__buckets_size
      
  def _set_buckets_size(self, v, load=False):
    """
    Setter method for buckets_size, mapped from YANG variable /devices/device/ip_sla/sla/buckets_size (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_buckets_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_buckets_size() directly.

    YANG Description: 1..100
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..100']}), is_leaf=True, yang_name="buckets-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """buckets_size must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..100']}), is_leaf=True, yang_name="buckets-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)""",
        })

    self.__buckets_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_buckets_size(self):
    self.__buckets_size = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'1..100']}), is_leaf=True, yang_name="buckets-size", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint8', is_config=True)


  def _get_num_packets(self):
    """
    Getter method for num_packets, mapped from YANG variable /devices/device/ip_sla/sla/num_packets (uint16)

    YANG Description: 1..60000
    """
    return self.__num_packets
      
  def _set_num_packets(self, v, load=False):
    """
    Setter method for num_packets, mapped from YANG variable /devices/device/ip_sla/sla/num_packets (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_packets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_packets() directly.

    YANG Description: 1..60000
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..60000']}), is_leaf=True, yang_name="num-packets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_packets must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..60000']}), is_leaf=True, yang_name="num-packets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__num_packets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_packets(self):
    self.__num_packets = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..60000']}), is_leaf=True, yang_name="num-packets", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_down_delay_time(self):
    """
    Getter method for down_delay_time, mapped from YANG variable /devices/device/ip_sla/sla/down_delay_time (uint16)

    YANG Description: 1..180
    """
    return self.__down_delay_time
      
  def _set_down_delay_time(self, v, load=False):
    """
    Setter method for down_delay_time, mapped from YANG variable /devices/device/ip_sla/sla/down_delay_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down_delay_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down_delay_time() directly.

    YANG Description: 1..180
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="down-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down_delay_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="down-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__down_delay_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down_delay_time(self):
    self.__down_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="down-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)


  def _get_up_delay_time(self):
    """
    Getter method for up_delay_time, mapped from YANG variable /devices/device/ip_sla/sla/up_delay_time (uint16)

    YANG Description: 1..180
    """
    return self.__up_delay_time
      
  def _set_up_delay_time(self, v, load=False):
    """
    Setter method for up_delay_time, mapped from YANG variable /devices/device/ip_sla/sla/up_delay_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_delay_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_delay_time() directly.

    YANG Description: 1..180
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="up-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_delay_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="up-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)""",
        })

    self.__up_delay_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_delay_time(self):
    self.__up_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'1..180']}), is_leaf=True, yang_name="up-delay-time", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='uint16', is_config=True)

  entry_number = __builtin__.property(_get_entry_number, _set_entry_number)
  vrf_name = __builtin__.property(_get_vrf_name, _set_vrf_name)
  operation_type = __builtin__.property(_get_operation_type, _set_operation_type)
  http_request_type = __builtin__.property(_get_http_request_type, _set_http_request_type)
  http_url = __builtin__.property(_get_http_url, _set_http_url)
  http_raw_request = __builtin__.property(_get_http_raw_request, _set_http_raw_request)
  destination = __builtin__.property(_get_destination, _set_destination)
  source = __builtin__.property(_get_source, _set_source)
  source_interface_name = __builtin__.property(_get_source_interface_name, _set_source_interface_name)
  source_interface_ip = __builtin__.property(_get_source_interface_ip, _set_source_interface_ip)
  data_size = __builtin__.property(_get_data_size, _set_data_size)
  response_data_size = __builtin__.property(_get_response_data_size, _set_response_data_size)
  frequency = __builtin__.property(_get_frequency, _set_frequency)
  timeout = __builtin__.property(_get_timeout, _set_timeout)
  threshold = __builtin__.property(_get_threshold, _set_threshold)
  destination_port = __builtin__.property(_get_destination_port, _set_destination_port)
  source_port = __builtin__.property(_get_source_port, _set_source_port)
  interval = __builtin__.property(_get_interval, _set_interval)
  tos = __builtin__.property(_get_tos, _set_tos)
  tag = __builtin__.property(_get_tag, _set_tag)
  history_interval = __builtin__.property(_get_history_interval, _set_history_interval)
  buckets_size = __builtin__.property(_get_buckets_size, _set_buckets_size)
  num_packets = __builtin__.property(_get_num_packets, _set_num_packets)
  down_delay_time = __builtin__.property(_get_down_delay_time, _set_down_delay_time)
  up_delay_time = __builtin__.property(_get_up_delay_time, _set_up_delay_time)


  _pyangbind_elements = collections.OrderedDict([('entry_number', entry_number), ('vrf_name', vrf_name), ('operation_type', operation_type), ('http_request_type', http_request_type), ('http_url', http_url), ('http_raw_request', http_raw_request), ('destination', destination), ('source', source), ('source_interface_name', source_interface_name), ('source_interface_ip', source_interface_ip), ('data_size', data_size), ('response_data_size', response_data_size), ('frequency', frequency), ('timeout', timeout), ('threshold', threshold), ('destination_port', destination_port), ('source_port', source_port), ('interval', interval), ('tos', tos), ('tag', tag), ('history_interval', history_interval), ('buckets_size', buckets_size), ('num_packets', num_packets), ('down_delay_time', down_delay_time), ('up_delay_time', up_delay_time), ])


