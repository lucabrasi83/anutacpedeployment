
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import interface
import user
import resourceclass_member
import monitor_interface
import managementaccess_interface
import sshaccess_interface
import telnetaccess_interface
import interfaces
import static_routes
import router_ospf
import snmp
import ssh
import logging
import tacacs_conf
import network_objects
import object_groups
import nat_object_groups
import ti_class_maps
import ti_policy_maps
import access_lists
import security_rules
import vrfs
import zones
import applications
import addresses
import address_sets
class virtual_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/virtual-devices/virtual-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__transit_vlanId','__file_store','__visible_interface','__interface','__permit_internal_network_traffic','__failovergroup','__nat_control','__is_commit','__hostname','__user','__resourceclass_member','__monitor_interface','__managementaccess_interface','__sshaccess_interface','__telnetaccess_interface','__interfaces','__static_routes','__router_ospf','__snmp','__ssh','__logging','__tacacs_conf','__network_objects','__object_groups','__nat_object_groups','__ti_class_maps','__ti_policy_maps','__access_lists','__security_rules','__vrfs','__zones','__applications','__addresses','__address_sets',)

  _yang_name = 'virtual-device'
  _module_name = 'firewall'
  _namespace = 'http://anutanetworks.com/firewall'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__network_objects = YANGDynClass(base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__nat_control = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nat-control", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    self.__zones = YANGDynClass(base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__security_rules = YANGDynClass(base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__permit_internal_network_traffic = YANGDynClass(base=unicode, is_leaf=True, yang_name="permit-internal-network-traffic", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__transit_vlanId = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-vlanId", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__resourceclass_member = YANGDynClass(base=YANGListType("resourceclass_member",resourceclass_member.resourceclass_member, yang_name="resourceclass-member", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='resourceclass-member'), is_container='list', yang_name="resourceclass-member", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__hostname = YANGDynClass(base=unicode, is_leaf=True, yang_name="hostname", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__snmp = YANGDynClass(base=YANGListType("community",snmp.snmp, yang_name="snmp", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='community'), is_container='list', yang_name="snmp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__is_commit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-commit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    self.__ti_policy_maps = YANGDynClass(base=ti_policy_maps.ti_policy_maps, is_container='container', yang_name="ti-policy-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__router_ospf = YANGDynClass(base=router_ospf.router_ospf, is_container='container', yang_name="router-ospf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__file_store = YANGDynClass(base=unicode, is_leaf=True, yang_name="file-store", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__failovergroup = YANGDynClass(base=unicode, is_leaf=True, yang_name="failovergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    self.__monitor_interface = YANGDynClass(base=YANGListType("monitor_interface",monitor_interface.monitor_interface, yang_name="monitor-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='monitor-interface'), is_container='list', yang_name="monitor-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__object_groups = YANGDynClass(base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__address_sets = YANGDynClass(base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__tacacs_conf = YANGDynClass(base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__telnetaccess_interface = YANGDynClass(base=YANGListType("interface_nameif",telnetaccess_interface.telnetaccess_interface, yang_name="telnetaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="telnetaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__ti_class_maps = YANGDynClass(base=ti_class_maps.ti_class_maps, is_container='container', yang_name="ti-class-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__access_lists = YANGDynClass(base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__applications = YANGDynClass(base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__ssh = YANGDynClass(base=ssh.ssh, is_container='container', yang_name="ssh", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__interface = YANGDynClass(base=YANGListType("interface_name",interface.interface, yang_name="interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name'), is_container='list', yang_name="interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__managementaccess_interface = YANGDynClass(base=YANGListType("interface_nameif ip_address echo_type",managementaccess_interface.managementaccess_interface, yang_name="managementaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif ip-address echo-type'), is_container='list', yang_name="managementaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__static_routes = YANGDynClass(base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__nat_object_groups = YANGDynClass(base=nat_object_groups.nat_object_groups, is_container='container', yang_name="nat-object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__visible_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__vrfs = YANGDynClass(base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__sshaccess_interface = YANGDynClass(base=YANGListType("interface_nameif",sshaccess_interface.sshaccess_interface, yang_name="sshaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="sshaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    self.__user = YANGDynClass(base=user.user, is_container='container', yang_name="user", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'virtual-devices', u'virtual-device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_transit_vlanId(self):
    """
    Getter method for transit_vlanId, mapped from YANG variable /devices/device/virtual_devices/virtual_device/transit_vlanId (uint32)

    YANG Description: 0..4294967295
    """
    return self.__transit_vlanId
      
  def _set_transit_vlanId(self, v, load=False):
    """
    Setter method for transit_vlanId, mapped from YANG variable /devices/device/virtual_devices/virtual_device/transit_vlanId (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_vlanId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_vlanId() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-vlanId", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_vlanId must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-vlanId", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__transit_vlanId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_vlanId(self):
    self.__transit_vlanId = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="transit-vlanId", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_file_store(self):
    """
    Getter method for file_store, mapped from YANG variable /devices/device/virtual_devices/virtual_device/file_store (string)

    YANG Description: string
    """
    return self.__file_store
      
  def _set_file_store(self, v, load=False):
    """
    Setter method for file_store, mapped from YANG variable /devices/device/virtual_devices/virtual_device/file_store (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_file_store is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_file_store() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="file-store", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """file_store must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="file-store", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__file_store = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_file_store(self):
    self.__file_store = YANGDynClass(base=unicode, is_leaf=True, yang_name="file-store", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_visible_interface(self):
    """
    Getter method for visible_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/visible_interface (string)

    YANG Description: string
    """
    return self.__visible_interface
      
  def _set_visible_interface(self, v, load=False):
    """
    Setter method for visible_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/visible_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_visible_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_visible_interface() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """visible_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__visible_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_visible_interface(self):
    self.__visible_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interface (list)
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("interface_name",interface.interface, yang_name="interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name'), is_container='list', yang_name="interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_name",interface.interface, yang_name="interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name'), is_container='list', yang_name="interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("interface_name",interface.interface, yang_name="interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-name'), is_container='list', yang_name="interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_permit_internal_network_traffic(self):
    """
    Getter method for permit_internal_network_traffic, mapped from YANG variable /devices/device/virtual_devices/virtual_device/permit_internal_network_traffic (string)

    YANG Description: string
    """
    return self.__permit_internal_network_traffic
      
  def _set_permit_internal_network_traffic(self, v, load=False):
    """
    Setter method for permit_internal_network_traffic, mapped from YANG variable /devices/device/virtual_devices/virtual_device/permit_internal_network_traffic (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_permit_internal_network_traffic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_permit_internal_network_traffic() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="permit-internal-network-traffic", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """permit_internal_network_traffic must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="permit-internal-network-traffic", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__permit_internal_network_traffic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_permit_internal_network_traffic(self):
    self.__permit_internal_network_traffic = YANGDynClass(base=unicode, is_leaf=True, yang_name="permit-internal-network-traffic", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_failovergroup(self):
    """
    Getter method for failovergroup, mapped from YANG variable /devices/device/virtual_devices/virtual_device/failovergroup (leafref)

    YANG Description: failovergroup
    """
    return self.__failovergroup
      
  def _set_failovergroup(self, v, load=False):
    """
    Setter method for failovergroup, mapped from YANG variable /devices/device/virtual_devices/virtual_device/failovergroup (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_failovergroup is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_failovergroup() directly.

    YANG Description: failovergroup
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="failovergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """failovergroup must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="failovergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)""",
        })

    self.__failovergroup = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_failovergroup(self):
    self.__failovergroup = YANGDynClass(base=unicode, is_leaf=True, yang_name="failovergroup", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)


  def _get_nat_control(self):
    """
    Getter method for nat_control, mapped from YANG variable /devices/device/virtual_devices/virtual_device/nat_control (boolean)

    YANG Description: nat-control: True/False
    """
    return self.__nat_control
      
  def _set_nat_control(self, v, load=False):
    """
    Setter method for nat_control, mapped from YANG variable /devices/device/virtual_devices/virtual_device/nat_control (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nat_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nat_control() directly.

    YANG Description: nat-control: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nat-control", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nat_control must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nat-control", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__nat_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nat_control(self):
    self.__nat_control = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nat-control", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_is_commit(self):
    """
    Getter method for is_commit, mapped from YANG variable /devices/device/virtual_devices/virtual_device/is_commit (boolean)

    YANG Description: is-commit: True/False
    """
    return self.__is_commit
      
  def _set_is_commit(self, v, load=False):
    """
    Setter method for is_commit, mapped from YANG variable /devices/device/virtual_devices/virtual_device/is_commit (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_commit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_commit() directly.

    YANG Description: is-commit: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-commit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_commit must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-commit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__is_commit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_commit(self):
    self.__is_commit = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-commit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /devices/device/virtual_devices/virtual_device/hostname (string)

    YANG Description: string
    """
    return self.__hostname
      
  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /devices/device/virtual_devices/virtual_device/hostname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="hostname", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="hostname", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=unicode, is_leaf=True, yang_name="hostname", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_user(self):
    """
    Getter method for user, mapped from YANG variable /devices/device/virtual_devices/virtual_device/user (container)
    """
    return self.__user
      
  def _set_user(self, v, load=False):
    """
    Setter method for user, mapped from YANG variable /devices/device/virtual_devices/virtual_device/user (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=user.user, is_container='container', yang_name="user", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=user.user, is_container='container', yang_name="user", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user(self):
    self.__user = YANGDynClass(base=user.user, is_container='container', yang_name="user", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_resourceclass_member(self):
    """
    Getter method for resourceclass_member, mapped from YANG variable /devices/device/virtual_devices/virtual_device/resourceclass_member (list)
    """
    return self.__resourceclass_member
      
  def _set_resourceclass_member(self, v, load=False):
    """
    Setter method for resourceclass_member, mapped from YANG variable /devices/device/virtual_devices/virtual_device/resourceclass_member (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resourceclass_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resourceclass_member() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("resourceclass_member",resourceclass_member.resourceclass_member, yang_name="resourceclass-member", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='resourceclass-member'), is_container='list', yang_name="resourceclass-member", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resourceclass_member must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("resourceclass_member",resourceclass_member.resourceclass_member, yang_name="resourceclass-member", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='resourceclass-member'), is_container='list', yang_name="resourceclass-member", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__resourceclass_member = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resourceclass_member(self):
    self.__resourceclass_member = YANGDynClass(base=YANGListType("resourceclass_member",resourceclass_member.resourceclass_member, yang_name="resourceclass-member", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='resourceclass-member'), is_container='list', yang_name="resourceclass-member", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_monitor_interface(self):
    """
    Getter method for monitor_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/monitor_interface (list)
    """
    return self.__monitor_interface
      
  def _set_monitor_interface(self, v, load=False):
    """
    Setter method for monitor_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/monitor_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor_interface() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("monitor_interface",monitor_interface.monitor_interface, yang_name="monitor-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='monitor-interface'), is_container='list', yang_name="monitor-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("monitor_interface",monitor_interface.monitor_interface, yang_name="monitor-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='monitor-interface'), is_container='list', yang_name="monitor-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__monitor_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor_interface(self):
    self.__monitor_interface = YANGDynClass(base=YANGListType("monitor_interface",monitor_interface.monitor_interface, yang_name="monitor-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='monitor-interface'), is_container='list', yang_name="monitor-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_managementaccess_interface(self):
    """
    Getter method for managementaccess_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/managementaccess_interface (list)
    """
    return self.__managementaccess_interface
      
  def _set_managementaccess_interface(self, v, load=False):
    """
    Setter method for managementaccess_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/managementaccess_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managementaccess_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managementaccess_interface() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("interface_nameif ip_address echo_type",managementaccess_interface.managementaccess_interface, yang_name="managementaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif ip-address echo-type'), is_container='list', yang_name="managementaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managementaccess_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_nameif ip_address echo_type",managementaccess_interface.managementaccess_interface, yang_name="managementaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif ip-address echo-type'), is_container='list', yang_name="managementaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__managementaccess_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managementaccess_interface(self):
    self.__managementaccess_interface = YANGDynClass(base=YANGListType("interface_nameif ip_address echo_type",managementaccess_interface.managementaccess_interface, yang_name="managementaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif ip-address echo-type'), is_container='list', yang_name="managementaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_sshaccess_interface(self):
    """
    Getter method for sshaccess_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/sshaccess_interface (list)
    """
    return self.__sshaccess_interface
      
  def _set_sshaccess_interface(self, v, load=False):
    """
    Setter method for sshaccess_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/sshaccess_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sshaccess_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sshaccess_interface() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("interface_nameif",sshaccess_interface.sshaccess_interface, yang_name="sshaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="sshaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sshaccess_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_nameif",sshaccess_interface.sshaccess_interface, yang_name="sshaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="sshaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__sshaccess_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sshaccess_interface(self):
    self.__sshaccess_interface = YANGDynClass(base=YANGListType("interface_nameif",sshaccess_interface.sshaccess_interface, yang_name="sshaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="sshaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_telnetaccess_interface(self):
    """
    Getter method for telnetaccess_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/telnetaccess_interface (list)
    """
    return self.__telnetaccess_interface
      
  def _set_telnetaccess_interface(self, v, load=False):
    """
    Setter method for telnetaccess_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/telnetaccess_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telnetaccess_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telnetaccess_interface() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("interface_nameif",telnetaccess_interface.telnetaccess_interface, yang_name="telnetaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="telnetaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telnetaccess_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interface_nameif",telnetaccess_interface.telnetaccess_interface, yang_name="telnetaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="telnetaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__telnetaccess_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telnetaccess_interface(self):
    self.__telnetaccess_interface = YANGDynClass(base=YANGListType("interface_nameif",telnetaccess_interface.telnetaccess_interface, yang_name="telnetaccess-interface", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interface-nameif'), is_container='list', yang_name="telnetaccess-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces (container)
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_static_routes(self):
    """
    Getter method for static_routes, mapped from YANG variable /devices/device/virtual_devices/virtual_device/static_routes (container)
    """
    return self.__static_routes
      
  def _set_static_routes(self, v, load=False):
    """
    Setter method for static_routes, mapped from YANG variable /devices/device/virtual_devices/virtual_device/static_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_routes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__static_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_routes(self):
    self.__static_routes = YANGDynClass(base=static_routes.static_routes, is_container='container', yang_name="static-routes", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_router_ospf(self):
    """
    Getter method for router_ospf, mapped from YANG variable /devices/device/virtual_devices/virtual_device/router_ospf (container)
    """
    return self.__router_ospf
      
  def _set_router_ospf(self, v, load=False):
    """
    Setter method for router_ospf, mapped from YANG variable /devices/device/virtual_devices/virtual_device/router_ospf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_ospf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_ospf() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=router_ospf.router_ospf, is_container='container', yang_name="router-ospf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_ospf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=router_ospf.router_ospf, is_container='container', yang_name="router-ospf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__router_ospf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_ospf(self):
    self.__router_ospf = YANGDynClass(base=router_ospf.router_ospf, is_container='container', yang_name="router-ospf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_snmp(self):
    """
    Getter method for snmp, mapped from YANG variable /devices/device/virtual_devices/virtual_device/snmp (list)
    """
    return self.__snmp
      
  def _set_snmp(self, v, load=False):
    """
    Setter method for snmp, mapped from YANG variable /devices/device/virtual_devices/virtual_device/snmp (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("community",snmp.snmp, yang_name="snmp", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='community'), is_container='list', yang_name="snmp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("community",snmp.snmp, yang_name="snmp", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='community'), is_container='list', yang_name="snmp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)""",
        })

    self.__snmp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp(self):
    self.__snmp = YANGDynClass(base=YANGListType("community",snmp.snmp, yang_name="snmp", module_name="firewall", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='community'), is_container='list', yang_name="snmp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='list', is_config=True)


  def _get_ssh(self):
    """
    Getter method for ssh, mapped from YANG variable /devices/device/virtual_devices/virtual_device/ssh (container)
    """
    return self.__ssh
      
  def _set_ssh(self, v, load=False):
    """
    Setter method for ssh, mapped from YANG variable /devices/device/virtual_devices/virtual_device/ssh (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ssh.ssh, is_container='container', yang_name="ssh", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssh.ssh, is_container='container', yang_name="ssh", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__ssh = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh(self):
    self.__ssh = YANGDynClass(base=ssh.ssh, is_container='container', yang_name="ssh", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /devices/device/virtual_devices/virtual_device/logging (container)
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /devices/device/virtual_devices/virtual_device/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=logging.logging, is_container='container', yang_name="logging", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_tacacs_conf(self):
    """
    Getter method for tacacs_conf, mapped from YANG variable /devices/device/virtual_devices/virtual_device/tacacs_conf (container)
    """
    return self.__tacacs_conf
      
  def _set_tacacs_conf(self, v, load=False):
    """
    Setter method for tacacs_conf, mapped from YANG variable /devices/device/virtual_devices/virtual_device/tacacs_conf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tacacs_conf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tacacs_conf() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tacacs_conf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__tacacs_conf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tacacs_conf(self):
    self.__tacacs_conf = YANGDynClass(base=tacacs_conf.tacacs_conf, is_container='container', yang_name="tacacs-conf", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_network_objects(self):
    """
    Getter method for network_objects, mapped from YANG variable /devices/device/virtual_devices/virtual_device/network_objects (container)
    """
    return self.__network_objects
      
  def _set_network_objects(self, v, load=False):
    """
    Setter method for network_objects, mapped from YANG variable /devices/device/virtual_devices/virtual_device/network_objects (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_objects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_objects() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_objects must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__network_objects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_objects(self):
    self.__network_objects = YANGDynClass(base=network_objects.network_objects, is_container='container', yang_name="network-objects", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_object_groups(self):
    """
    Getter method for object_groups, mapped from YANG variable /devices/device/virtual_devices/virtual_device/object_groups (container)
    """
    return self.__object_groups
      
  def _set_object_groups(self, v, load=False):
    """
    Setter method for object_groups, mapped from YANG variable /devices/device/virtual_devices/virtual_device/object_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """object_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__object_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_object_groups(self):
    self.__object_groups = YANGDynClass(base=object_groups.object_groups, is_container='container', yang_name="object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_nat_object_groups(self):
    """
    Getter method for nat_object_groups, mapped from YANG variable /devices/device/virtual_devices/virtual_device/nat_object_groups (container)
    """
    return self.__nat_object_groups
      
  def _set_nat_object_groups(self, v, load=False):
    """
    Setter method for nat_object_groups, mapped from YANG variable /devices/device/virtual_devices/virtual_device/nat_object_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nat_object_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nat_object_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=nat_object_groups.nat_object_groups, is_container='container', yang_name="nat-object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nat_object_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nat_object_groups.nat_object_groups, is_container='container', yang_name="nat-object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__nat_object_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nat_object_groups(self):
    self.__nat_object_groups = YANGDynClass(base=nat_object_groups.nat_object_groups, is_container='container', yang_name="nat-object-groups", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_ti_class_maps(self):
    """
    Getter method for ti_class_maps, mapped from YANG variable /devices/device/virtual_devices/virtual_device/ti_class_maps (container)
    """
    return self.__ti_class_maps
      
  def _set_ti_class_maps(self, v, load=False):
    """
    Setter method for ti_class_maps, mapped from YANG variable /devices/device/virtual_devices/virtual_device/ti_class_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ti_class_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ti_class_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ti_class_maps.ti_class_maps, is_container='container', yang_name="ti-class-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ti_class_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ti_class_maps.ti_class_maps, is_container='container', yang_name="ti-class-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__ti_class_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ti_class_maps(self):
    self.__ti_class_maps = YANGDynClass(base=ti_class_maps.ti_class_maps, is_container='container', yang_name="ti-class-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_ti_policy_maps(self):
    """
    Getter method for ti_policy_maps, mapped from YANG variable /devices/device/virtual_devices/virtual_device/ti_policy_maps (container)
    """
    return self.__ti_policy_maps
      
  def _set_ti_policy_maps(self, v, load=False):
    """
    Setter method for ti_policy_maps, mapped from YANG variable /devices/device/virtual_devices/virtual_device/ti_policy_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ti_policy_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ti_policy_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ti_policy_maps.ti_policy_maps, is_container='container', yang_name="ti-policy-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ti_policy_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ti_policy_maps.ti_policy_maps, is_container='container', yang_name="ti-policy-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__ti_policy_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ti_policy_maps(self):
    self.__ti_policy_maps = YANGDynClass(base=ti_policy_maps.ti_policy_maps, is_container='container', yang_name="ti-policy-maps", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_access_lists(self):
    """
    Getter method for access_lists, mapped from YANG variable /devices/device/virtual_devices/virtual_device/access_lists (container)
    """
    return self.__access_lists
      
  def _set_access_lists(self, v, load=False):
    """
    Setter method for access_lists, mapped from YANG variable /devices/device/virtual_devices/virtual_device/access_lists (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_lists is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_lists() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_lists must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__access_lists = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_lists(self):
    self.__access_lists = YANGDynClass(base=access_lists.access_lists, is_container='container', yang_name="access-lists", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_security_rules(self):
    """
    Getter method for security_rules, mapped from YANG variable /devices/device/virtual_devices/virtual_device/security_rules (container)
    """
    return self.__security_rules
      
  def _set_security_rules(self, v, load=False):
    """
    Setter method for security_rules, mapped from YANG variable /devices/device/virtual_devices/virtual_device/security_rules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_rules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_rules() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security_rules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__security_rules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security_rules(self):
    self.__security_rules = YANGDynClass(base=security_rules.security_rules, is_container='container', yang_name="security-rules", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_vrfs(self):
    """
    Getter method for vrfs, mapped from YANG variable /devices/device/virtual_devices/virtual_device/vrfs (container)
    """
    return self.__vrfs
      
  def _set_vrfs(self, v, load=False):
    """
    Setter method for vrfs, mapped from YANG variable /devices/device/virtual_devices/virtual_device/vrfs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrfs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrfs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrfs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__vrfs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrfs(self):
    self.__vrfs = YANGDynClass(base=vrfs.vrfs, is_container='container', yang_name="vrfs", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_zones(self):
    """
    Getter method for zones, mapped from YANG variable /devices/device/virtual_devices/virtual_device/zones (container)
    """
    return self.__zones
      
  def _set_zones(self, v, load=False):
    """
    Setter method for zones, mapped from YANG variable /devices/device/virtual_devices/virtual_device/zones (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_zones is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_zones() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """zones must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__zones = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_zones(self):
    self.__zones = YANGDynClass(base=zones.zones, is_container='container', yang_name="zones", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_applications(self):
    """
    Getter method for applications, mapped from YANG variable /devices/device/virtual_devices/virtual_device/applications (container)
    """
    return self.__applications
      
  def _set_applications(self, v, load=False):
    """
    Setter method for applications, mapped from YANG variable /devices/device/virtual_devices/virtual_device/applications (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_applications is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_applications() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """applications must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__applications = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_applications(self):
    self.__applications = YANGDynClass(base=applications.applications, is_container='container', yang_name="applications", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /devices/device/virtual_devices/virtual_device/addresses (container)
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /devices/device/virtual_devices/virtual_device/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=addresses.addresses, is_container='container', yang_name="addresses", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_address_sets(self):
    """
    Getter method for address_sets, mapped from YANG variable /devices/device/virtual_devices/virtual_device/address_sets (container)
    """
    return self.__address_sets
      
  def _set_address_sets(self, v, load=False):
    """
    Setter method for address_sets, mapped from YANG variable /devices/device/virtual_devices/virtual_device/address_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_sets() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__address_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_sets(self):
    self.__address_sets = YANGDynClass(base=address_sets.address_sets, is_container='container', yang_name="address-sets", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  transit_vlanId = __builtin__.property(_get_transit_vlanId, _set_transit_vlanId)
  file_store = __builtin__.property(_get_file_store, _set_file_store)
  visible_interface = __builtin__.property(_get_visible_interface, _set_visible_interface)
  interface = __builtin__.property(_get_interface, _set_interface)
  permit_internal_network_traffic = __builtin__.property(_get_permit_internal_network_traffic, _set_permit_internal_network_traffic)
  failovergroup = __builtin__.property(_get_failovergroup, _set_failovergroup)
  nat_control = __builtin__.property(_get_nat_control, _set_nat_control)
  is_commit = __builtin__.property(_get_is_commit, _set_is_commit)
  hostname = __builtin__.property(_get_hostname, _set_hostname)
  user = __builtin__.property(_get_user, _set_user)
  resourceclass_member = __builtin__.property(_get_resourceclass_member, _set_resourceclass_member)
  monitor_interface = __builtin__.property(_get_monitor_interface, _set_monitor_interface)
  managementaccess_interface = __builtin__.property(_get_managementaccess_interface, _set_managementaccess_interface)
  sshaccess_interface = __builtin__.property(_get_sshaccess_interface, _set_sshaccess_interface)
  telnetaccess_interface = __builtin__.property(_get_telnetaccess_interface, _set_telnetaccess_interface)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)
  static_routes = __builtin__.property(_get_static_routes, _set_static_routes)
  router_ospf = __builtin__.property(_get_router_ospf, _set_router_ospf)
  snmp = __builtin__.property(_get_snmp, _set_snmp)
  ssh = __builtin__.property(_get_ssh, _set_ssh)
  logging = __builtin__.property(_get_logging, _set_logging)
  tacacs_conf = __builtin__.property(_get_tacacs_conf, _set_tacacs_conf)
  network_objects = __builtin__.property(_get_network_objects, _set_network_objects)
  object_groups = __builtin__.property(_get_object_groups, _set_object_groups)
  nat_object_groups = __builtin__.property(_get_nat_object_groups, _set_nat_object_groups)
  ti_class_maps = __builtin__.property(_get_ti_class_maps, _set_ti_class_maps)
  ti_policy_maps = __builtin__.property(_get_ti_policy_maps, _set_ti_policy_maps)
  access_lists = __builtin__.property(_get_access_lists, _set_access_lists)
  security_rules = __builtin__.property(_get_security_rules, _set_security_rules)
  vrfs = __builtin__.property(_get_vrfs, _set_vrfs)
  zones = __builtin__.property(_get_zones, _set_zones)
  applications = __builtin__.property(_get_applications, _set_applications)
  addresses = __builtin__.property(_get_addresses, _set_addresses)
  address_sets = __builtin__.property(_get_address_sets, _set_address_sets)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('transit_vlanId', transit_vlanId), ('file_store', file_store), ('visible_interface', visible_interface), ('interface', interface), ('permit_internal_network_traffic', permit_internal_network_traffic), ('failovergroup', failovergroup), ('nat_control', nat_control), ('is_commit', is_commit), ('hostname', hostname), ('user', user), ('resourceclass_member', resourceclass_member), ('monitor_interface', monitor_interface), ('managementaccess_interface', managementaccess_interface), ('sshaccess_interface', sshaccess_interface), ('telnetaccess_interface', telnetaccess_interface), ('interfaces', interfaces), ('static_routes', static_routes), ('router_ospf', router_ospf), ('snmp', snmp), ('ssh', ssh), ('logging', logging), ('tacacs_conf', tacacs_conf), ('network_objects', network_objects), ('object_groups', object_groups), ('nat_object_groups', nat_object_groups), ('ti_class_maps', ti_class_maps), ('ti_policy_maps', ti_policy_maps), ('access_lists', access_lists), ('security_rules', security_rules), ('vrfs', vrfs), ('zones', zones), ('applications', applications), ('addresses', addresses), ('address_sets', address_sets), ])


