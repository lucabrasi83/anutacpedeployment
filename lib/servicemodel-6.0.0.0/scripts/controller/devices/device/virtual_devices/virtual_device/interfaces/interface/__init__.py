
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import additional_ipv4_address
import mls_qos
import srr_queue
import additional_ipv6_address
class interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/virtual-devices/virtual-device/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__long_name','__if_index','__description','__mode','__mtu','__hold_time_up','__hold_time_down','__physical_address','__rnc_name','__port','__dhcp','__inpath_optimisation','__ip_address','__netmask','__ipv4_prefix_length','__ipv6_address','__ipv6_prefix_length','__alias_address','__gateway','__inpath_gateway','__primaryip','__secondaryip','__admin_state','__operation_state','__out_bandwidth','__in_bandwidth','__speed','__native_vlan','__portfast','__service','__cdp','__bpduguard','__broadcast','__nonegotiate','__power_inline','__value','__priority_queue','__voice_vlan','__level','__speed_unit','__policer_name','__additional_ipv4_address','__mls_qos','__srr_queue','__additional_ipv6_address','__vlan','__visible_interface','__inside_name','__security_level_inside','__acl_inbound_name','__acl_outbound_name','__peer_unit',)

  _yang_name = 'interface'
  _module_name = 'firewall'
  _namespace = 'http://anutanetworks.com/firewall'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)
    self.__secondaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv6-address', is_config=True)
    self.__mls_qos = YANGDynClass(base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__operation_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-operation-state', is_config=False)
    self.__alias_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="alias-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__long_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="long-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__rnc_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="rnc-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__cdp = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    self.__additional_ipv6_address = YANGDynClass(base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__voice_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)
    self.__gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    self.__inside_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="inside-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__peer_unit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__service = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)
    self.__speed_unit = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    self.__port = YANGDynClass(base=unicode, is_leaf=True, yang_name="port", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__visible_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__additional_ipv4_address = YANGDynClass(base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__in_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)
    self.__dhcp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    self.__acl_inbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__physical_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__hold_time_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__priority_queue = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    self.__out_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)
    self.__vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__security_level_inside = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__broadcast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-admin-state', is_config=True)
    self.__power_inline = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    self.__primaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    self.__inpath_gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    self.__srr_queue = YANGDynClass(base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    self.__ipv6_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='nt:ipv6-prefix-length', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__inpath_optimisation = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    self.__policer_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__acl_outbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    self.__ipv4_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint8', is_config=True)
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__bpduguard = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    self.__nonegotiate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-mode', is_config=True)
    self.__hold_time_down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    self.__portfast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="portfast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'virtual-devices', u'virtual-device', u'interfaces', u'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/name (string)

    YANG Description: Name of the interface. Typically maps to the short name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interface. Typically maps to the short name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_long_name(self):
    """
    Getter method for long_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/long_name (string)

    YANG Description: Complete name of the interface.
    """
    return self.__long_name
      
  def _set_long_name(self, v, load=False):
    """
    Setter method for long_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/long_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_long_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_long_name() directly.

    YANG Description: Complete name of the interface.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="long-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """long_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="long-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__long_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_long_name(self):
    self.__long_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="long-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/if_index (uint32)

    YANG Description: SNMP index of the interface.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/if_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: SNMP index of the interface.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/mode (interface-mode)

    YANG Description: trunk
access
vlan
voice
sub-interface
l3-interface
l2-interface
l2-sub-interface
loopback-interface
tunnel
rnc-interface
l3vpn-interface

    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/mode (interface-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: trunk
access
vlan
voice
sub-interface
l3-interface
l2-interface
l2-sub-interface
loopback-interface
tunnel
rnc-interface
l3vpn-interface

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with interface-mode""",
          'defined-type': "firewall:interface-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-mode', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/mtu (uint32)

    YANG Description: 0..4294967295
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_hold_time_up(self):
    """
    Getter method for hold_time_up, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/hold_time_up (uint32)

    YANG Description: 0..4294967295
    """
    return self.__hold_time_up
      
  def _set_hold_time_up(self, v, load=False):
    """
    Setter method for hold_time_up, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/hold_time_up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_up() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__hold_time_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_up(self):
    self.__hold_time_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_hold_time_down(self):
    """
    Getter method for hold_time_down, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/hold_time_down (uint32)

    YANG Description: 0..4294967295
    """
    return self.__hold_time_down
      
  def _set_hold_time_down(self, v, load=False):
    """
    Setter method for hold_time_down, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/hold_time_down (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_down() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_down must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__hold_time_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_down(self):
    self.__hold_time_down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_physical_address(self):
    """
    Getter method for physical_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/physical_address (string)

    YANG Description: string
    """
    return self.__physical_address
      
  def _set_physical_address(self, v, load=False):
    """
    Setter method for physical_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/physical_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_address() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="physical-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__physical_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_address(self):
    self.__physical_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_rnc_name(self):
    """
    Getter method for rnc_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/rnc_name (string)

    YANG Description: string
    """
    return self.__rnc_name
      
  def _set_rnc_name(self, v, load=False):
    """
    Setter method for rnc_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/rnc_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rnc_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rnc_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rnc-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rnc_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rnc-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__rnc_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rnc_name(self):
    self.__rnc_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="rnc-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/port (string)

    YANG Description: string
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/port (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=unicode, is_leaf=True, yang_name="port", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_dhcp(self):
    """
    Getter method for dhcp, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/dhcp (boolean)

    YANG Description: dhcp: True/False
    """
    return self.__dhcp
      
  def _set_dhcp(self, v, load=False):
    """
    Setter method for dhcp, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/dhcp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp() directly.

    YANG Description: dhcp: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp(self):
    self.__dhcp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_inpath_optimisation(self):
    """
    Getter method for inpath_optimisation, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/inpath_optimisation (enumeration)

    YANG Description: enable inpath optimisation: Enable
    """
    return self.__inpath_optimisation
      
  def _set_inpath_optimisation(self, v, load=False):
    """
    Setter method for inpath_optimisation, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/inpath_optimisation (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inpath_optimisation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inpath_optimisation() directly.

    YANG Description: enable inpath optimisation: Enable
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inpath_optimisation must be of a type compatible with enumeration""",
          'defined-type': "firewall:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)""",
        })

    self.__inpath_optimisation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inpath_optimisation(self):
    self.__inpath_optimisation = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ip_address (inet:ipv4-address)

    YANG Description: IPv4 Address of the interface
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ip_address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IPv4 Address of the interface
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ip-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/netmask (inet:ipv4-address)

    YANG Description: Netmask of of the interface in dotted quad notation.
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/netmask (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: Netmask of of the interface in dotted quad notation.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv4-address', is_config=True)


  def _get_ipv4_prefix_length(self):
    """
    Getter method for ipv4_prefix_length, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ipv4_prefix_length (uint8)

    YANG Description: IPv4 netmask in CIDR notation.
    """
    return self.__ipv4_prefix_length
      
  def _set_ipv4_prefix_length(self, v, load=False):
    """
    Setter method for ipv4_prefix_length, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ipv4_prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_prefix_length() directly.

    YANG Description: IPv4 netmask in CIDR notation.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint8', is_config=True)""",
        })

    self.__ipv4_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_prefix_length(self):
    self.__ipv4_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint8', is_config=True)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ipv6_address (inet:ipv6-address)

    YANG Description: IPv6 Address of the interface
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ipv6_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: IPv6 Address of the interface
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ipv6-address', is_config=True)


  def _get_ipv6_prefix_length(self):
    """
    Getter method for ipv6_prefix_length, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ipv6_prefix_length (nt:ipv6-prefix-length)

    YANG Description: IPv6 netmask in CIDR notation.
    """
    return self.__ipv6_prefix_length
      
  def _set_ipv6_prefix_length(self, v, load=False):
    """
    Setter method for ipv6_prefix_length, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/ipv6_prefix_length (nt:ipv6-prefix-length)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_prefix_length() directly.

    YANG Description: IPv6 netmask in CIDR notation.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='nt:ipv6-prefix-length', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_prefix_length must be of a type compatible with nt:ipv6-prefix-length""",
          'defined-type': "nt:ipv6-prefix-length",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='nt:ipv6-prefix-length', is_config=True)""",
        })

    self.__ipv6_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_prefix_length(self):
    self.__ipv6_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='nt:ipv6-prefix-length', is_config=True)


  def _get_alias_address(self):
    """
    Getter method for alias_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/alias_address (string)

    YANG Description: string
    """
    return self.__alias_address
      
  def _set_alias_address(self, v, load=False):
    """
    Setter method for alias_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/alias_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alias_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alias_address() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="alias-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alias_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="alias-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__alias_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alias_address(self):
    self.__alias_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="alias-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/gateway (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/gateway (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)


  def _get_inpath_gateway(self):
    """
    Getter method for inpath_gateway, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/inpath_gateway (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__inpath_gateway
      
  def _set_inpath_gateway(self, v, load=False):
    """
    Setter method for inpath_gateway, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/inpath_gateway (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inpath_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inpath_gateway() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inpath_gateway must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__inpath_gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inpath_gateway(self):
    self.__inpath_gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)


  def _get_primaryip(self):
    """
    Getter method for primaryip, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/primaryip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__primaryip
      
  def _set_primaryip(self, v, load=False):
    """
    Setter method for primaryip, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/primaryip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primaryip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primaryip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primaryip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__primaryip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primaryip(self):
    self.__primaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)


  def _get_secondaryip(self):
    """
    Getter method for secondaryip, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/secondaryip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__secondaryip
      
  def _set_secondaryip(self, v, load=False):
    """
    Setter method for secondaryip, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/secondaryip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondaryip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondaryip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondaryip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__secondaryip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondaryip(self):
    self.__secondaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='inet:ip-address', is_config=True)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/admin_state (interface-admin-state)

    YANG Description: UP
DOWN
TESTING

    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/admin_state (interface-admin-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: UP
DOWN
TESTING

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-admin-state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with interface-admin-state""",
          'defined-type': "firewall:interface-admin-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-admin-state', is_config=True)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-admin-state', is_config=True)


  def _get_operation_state(self):
    """
    Getter method for operation_state, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/operation_state (interface-operation-state)

    YANG Description: UP
DOWN
TESTING
UNKNOWN
DORMANT
NOTPRESENT
LOWERLAYERDOWN
INVALID

    """
    return self.__operation_state
      
  def _set_operation_state(self, v, load=False):
    """
    Setter method for operation_state, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/operation_state (interface-operation-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation_state() directly.

    YANG Description: UP
DOWN
TESTING
UNKNOWN
DORMANT
NOTPRESENT
LOWERLAYERDOWN
INVALID

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-operation-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation_state must be of a type compatible with interface-operation-state""",
          'defined-type': "firewall:interface-operation-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-operation-state', is_config=False)""",
        })

    self.__operation_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation_state(self):
    self.__operation_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='interface-operation-state', is_config=False)


  def _get_out_bandwidth(self):
    """
    Getter method for out_bandwidth, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/out_bandwidth (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__out_bandwidth
      
  def _set_out_bandwidth(self, v, load=False):
    """
    Setter method for out_bandwidth, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/out_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_bandwidth() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)""",
        })

    self.__out_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_bandwidth(self):
    self.__out_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)


  def _get_in_bandwidth(self):
    """
    Getter method for in_bandwidth, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/in_bandwidth (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__in_bandwidth
      
  def _set_in_bandwidth(self, v, load=False):
    """
    Setter method for in_bandwidth, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/in_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_bandwidth() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)""",
        })

    self.__in_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_bandwidth(self):
    self.__in_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)


  def _get_speed(self):
    """
    Getter method for speed, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/speed (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__speed
      
  def _set_speed(self, v, load=False):
    """
    Setter method for speed, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/speed (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)""",
        })

    self.__speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed(self):
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint64', is_config=True)


  def _get_native_vlan(self):
    """
    Getter method for native_vlan, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/native_vlan (uint16)

    YANG Description: Native-vlan
    """
    return self.__native_vlan
      
  def _set_native_vlan(self, v, load=False):
    """
    Setter method for native_vlan, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/native_vlan (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_vlan() directly.

    YANG Description: Native-vlan
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_vlan must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)""",
        })

    self.__native_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_vlan(self):
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)


  def _get_portfast(self):
    """
    Getter method for portfast, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/portfast (boolean)

    YANG Description: portfast should be enable or not
    """
    return self.__portfast
      
  def _set_portfast(self, v, load=False):
    """
    Setter method for portfast, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/portfast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_portfast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_portfast() directly.

    YANG Description: portfast should be enable or not
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="portfast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """portfast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="portfast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__portfast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_portfast(self):
    self.__portfast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="portfast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/service (enumeration)

    YANG Description: disable
trunk

    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/service (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.

    YANG Description: disable
trunk

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with enumeration""",
          'defined-type': "firewall:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)


  def _get_cdp(self):
    """
    Getter method for cdp, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/cdp (enumeration)

    YANG Description: enable
disable

    """
    return self.__cdp
      
  def _set_cdp(self, v, load=False):
    """
    Setter method for cdp, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/cdp (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cdp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cdp() directly.

    YANG Description: enable
disable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cdp must be of a type compatible with enumeration""",
          'defined-type': "firewall:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)""",
        })

    self.__cdp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cdp(self):
    self.__cdp = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)


  def _get_bpduguard(self):
    """
    Getter method for bpduguard, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/bpduguard (boolean)

    YANG Description: bpduguard should be enable or not
    """
    return self.__bpduguard
      
  def _set_bpduguard(self, v, load=False):
    """
    Setter method for bpduguard, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/bpduguard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bpduguard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bpduguard() directly.

    YANG Description: bpduguard should be enable or not
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bpduguard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__bpduguard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bpduguard(self):
    self.__bpduguard = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_broadcast(self):
    """
    Getter method for broadcast, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/broadcast (boolean)

    YANG Description: bpduguard should be enable or not
    """
    return self.__broadcast
      
  def _set_broadcast(self, v, load=False):
    """
    Setter method for broadcast, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/broadcast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_broadcast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_broadcast() directly.

    YANG Description: bpduguard should be enable or not
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """broadcast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__broadcast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_broadcast(self):
    self.__broadcast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_nonegotiate(self):
    """
    Getter method for nonegotiate, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/nonegotiate (boolean)

    YANG Description: nonegotiate: True/False
    """
    return self.__nonegotiate
      
  def _set_nonegotiate(self, v, load=False):
    """
    Setter method for nonegotiate, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/nonegotiate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nonegotiate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nonegotiate() directly.

    YANG Description: nonegotiate: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nonegotiate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)""",
        })

    self.__nonegotiate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nonegotiate(self):
    self.__nonegotiate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='boolean', is_config=True)


  def _get_power_inline(self):
    """
    Getter method for power_inline, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/power_inline (enumeration)

    YANG Description: auto
never
static

    """
    return self.__power_inline
      
  def _set_power_inline(self, v, load=False):
    """
    Setter method for power_inline, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/power_inline (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_inline is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_inline() directly.

    YANG Description: auto
never
static

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_inline must be of a type compatible with enumeration""",
          'defined-type': "firewall:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)""",
        })

    self.__power_inline = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_inline(self):
    self.__power_inline = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/value (uint16)

    YANG Description: 0..65535
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/value (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)


  def _get_priority_queue(self):
    """
    Getter method for priority_queue, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/priority_queue (enumeration)

    YANG Description: out

    """
    return self.__priority_queue
      
  def _set_priority_queue(self, v, load=False):
    """
    Setter method for priority_queue, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/priority_queue (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_queue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_queue() directly.

    YANG Description: out

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_queue must be of a type compatible with enumeration""",
          'defined-type': "firewall:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)""",
        })

    self.__priority_queue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_queue(self):
    self.__priority_queue = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)


  def _get_voice_vlan(self):
    """
    Getter method for voice_vlan, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/voice_vlan (uint16)

    YANG Description: vlan
    """
    return self.__voice_vlan
      
  def _set_voice_vlan(self, v, load=False):
    """
    Setter method for voice_vlan, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/voice_vlan (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_voice_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_voice_vlan() directly.

    YANG Description: vlan
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """voice_vlan must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)""",
        })

    self.__voice_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_voice_vlan(self):
    self.__voice_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint16', is_config=True)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/level (uint32)

    YANG Description: broadcast level
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/level (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: broadcast level
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_speed_unit(self):
    """
    Getter method for speed_unit, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/speed_unit (enumeration)

    YANG Description: BPS
KBPS
MBPS
GBPS
TBPS

    """
    return self.__speed_unit
      
  def _set_speed_unit(self, v, load=False):
    """
    Setter method for speed_unit, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/speed_unit (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed_unit() directly.

    YANG Description: BPS
KBPS
MBPS
GBPS
TBPS

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed_unit must be of a type compatible with enumeration""",
          'defined-type': "firewall:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)""",
        })

    self.__speed_unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed_unit(self):
    self.__speed_unit = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='enumeration', is_config=True)


  def _get_policer_name(self):
    """
    Getter method for policer_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/policer_name (string)

    YANG Description: string
    """
    return self.__policer_name
      
  def _set_policer_name(self, v, load=False):
    """
    Setter method for policer_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/policer_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policer_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policer_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="policer-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policer_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__policer_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policer_name(self):
    self.__policer_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_additional_ipv4_address(self):
    """
    Getter method for additional_ipv4_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/additional_ipv4_address (container)
    """
    return self.__additional_ipv4_address
      
  def _set_additional_ipv4_address(self, v, load=False):
    """
    Setter method for additional_ipv4_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/additional_ipv4_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additional_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additional_ipv4_address() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """additional_ipv4_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__additional_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_additional_ipv4_address(self):
    self.__additional_ipv4_address = YANGDynClass(base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_mls_qos(self):
    """
    Getter method for mls_qos, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/mls_qos (container)
    """
    return self.__mls_qos
      
  def _set_mls_qos(self, v, load=False):
    """
    Setter method for mls_qos, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/mls_qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mls_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mls_qos() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mls_qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__mls_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mls_qos(self):
    self.__mls_qos = YANGDynClass(base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_srr_queue(self):
    """
    Getter method for srr_queue, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/srr_queue (container)
    """
    return self.__srr_queue
      
  def _set_srr_queue(self, v, load=False):
    """
    Setter method for srr_queue, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/srr_queue (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srr_queue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srr_queue() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srr_queue must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__srr_queue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srr_queue(self):
    self.__srr_queue = YANGDynClass(base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_additional_ipv6_address(self):
    """
    Getter method for additional_ipv6_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/additional_ipv6_address (container)
    """
    return self.__additional_ipv6_address
      
  def _set_additional_ipv6_address(self, v, load=False):
    """
    Setter method for additional_ipv6_address, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/additional_ipv6_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additional_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additional_ipv6_address() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """additional_ipv6_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)""",
        })

    self.__additional_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_additional_ipv6_address(self):
    self.__additional_ipv6_address = YANGDynClass(base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='container', is_config=True)


  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/vlan (string)

    YANG Description: string
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/vlan (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_visible_interface(self):
    """
    Getter method for visible_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/visible_interface (string)

    YANG Description: string
    """
    return self.__visible_interface
      
  def _set_visible_interface(self, v, load=False):
    """
    Setter method for visible_interface, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/visible_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_visible_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_visible_interface() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """visible_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__visible_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_visible_interface(self):
    self.__visible_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_inside_name(self):
    """
    Getter method for inside_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/inside_name (string)

    YANG Description: string
    """
    return self.__inside_name
      
  def _set_inside_name(self, v, load=False):
    """
    Setter method for inside_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/inside_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inside_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inside_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inside-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inside_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inside-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__inside_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inside_name(self):
    self.__inside_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="inside-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_security_level_inside(self):
    """
    Getter method for security_level_inside, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/security_level_inside (uint32)

    YANG Description: 0..4294967295
    """
    return self.__security_level_inside
      
  def _set_security_level_inside(self, v, load=False):
    """
    Setter method for security_level_inside, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/security_level_inside (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_level_inside is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_level_inside() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security_level_inside must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__security_level_inside = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security_level_inside(self):
    self.__security_level_inside = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)


  def _get_acl_inbound_name(self):
    """
    Getter method for acl_inbound_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/acl_inbound_name (string)

    YANG Description: string
    """
    return self.__acl_inbound_name
      
  def _set_acl_inbound_name(self, v, load=False):
    """
    Setter method for acl_inbound_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/acl_inbound_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_inbound_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_inbound_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_inbound_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__acl_inbound_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_inbound_name(self):
    self.__acl_inbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_acl_outbound_name(self):
    """
    Getter method for acl_outbound_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/acl_outbound_name (string)

    YANG Description: string
    """
    return self.__acl_outbound_name
      
  def _set_acl_outbound_name(self, v, load=False):
    """
    Setter method for acl_outbound_name, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/acl_outbound_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_outbound_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_outbound_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_outbound_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)""",
        })

    self.__acl_outbound_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_outbound_name(self):
    self.__acl_outbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='string', is_config=True)


  def _get_peer_unit(self):
    """
    Getter method for peer_unit, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/peer_unit (uint32)

    YANG Description: 0..4294967295
    """
    return self.__peer_unit
      
  def _set_peer_unit(self, v, load=False):
    """
    Setter method for peer_unit, mapped from YANG variable /devices/device/virtual_devices/virtual_device/interfaces/interface/peer_unit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_unit() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_unit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)""",
        })

    self.__peer_unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_unit(self):
    self.__peer_unit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-unit", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='uint32', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  long_name = __builtin__.property(_get_long_name, _set_long_name)
  if_index = __builtin__.property(_get_if_index, _set_if_index)
  description = __builtin__.property(_get_description, _set_description)
  mode = __builtin__.property(_get_mode, _set_mode)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  hold_time_up = __builtin__.property(_get_hold_time_up, _set_hold_time_up)
  hold_time_down = __builtin__.property(_get_hold_time_down, _set_hold_time_down)
  physical_address = __builtin__.property(_get_physical_address, _set_physical_address)
  rnc_name = __builtin__.property(_get_rnc_name, _set_rnc_name)
  port = __builtin__.property(_get_port, _set_port)
  dhcp = __builtin__.property(_get_dhcp, _set_dhcp)
  inpath_optimisation = __builtin__.property(_get_inpath_optimisation, _set_inpath_optimisation)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  ipv4_prefix_length = __builtin__.property(_get_ipv4_prefix_length, _set_ipv4_prefix_length)
  ipv6_address = __builtin__.property(_get_ipv6_address, _set_ipv6_address)
  ipv6_prefix_length = __builtin__.property(_get_ipv6_prefix_length, _set_ipv6_prefix_length)
  alias_address = __builtin__.property(_get_alias_address, _set_alias_address)
  gateway = __builtin__.property(_get_gateway, _set_gateway)
  inpath_gateway = __builtin__.property(_get_inpath_gateway, _set_inpath_gateway)
  primaryip = __builtin__.property(_get_primaryip, _set_primaryip)
  secondaryip = __builtin__.property(_get_secondaryip, _set_secondaryip)
  admin_state = __builtin__.property(_get_admin_state, _set_admin_state)
  operation_state = __builtin__.property(_get_operation_state)
  out_bandwidth = __builtin__.property(_get_out_bandwidth, _set_out_bandwidth)
  in_bandwidth = __builtin__.property(_get_in_bandwidth, _set_in_bandwidth)
  speed = __builtin__.property(_get_speed, _set_speed)
  native_vlan = __builtin__.property(_get_native_vlan, _set_native_vlan)
  portfast = __builtin__.property(_get_portfast, _set_portfast)
  service = __builtin__.property(_get_service, _set_service)
  cdp = __builtin__.property(_get_cdp, _set_cdp)
  bpduguard = __builtin__.property(_get_bpduguard, _set_bpduguard)
  broadcast = __builtin__.property(_get_broadcast, _set_broadcast)
  nonegotiate = __builtin__.property(_get_nonegotiate, _set_nonegotiate)
  power_inline = __builtin__.property(_get_power_inline, _set_power_inline)
  value = __builtin__.property(_get_value, _set_value)
  priority_queue = __builtin__.property(_get_priority_queue, _set_priority_queue)
  voice_vlan = __builtin__.property(_get_voice_vlan, _set_voice_vlan)
  level = __builtin__.property(_get_level, _set_level)
  speed_unit = __builtin__.property(_get_speed_unit, _set_speed_unit)
  policer_name = __builtin__.property(_get_policer_name, _set_policer_name)
  additional_ipv4_address = __builtin__.property(_get_additional_ipv4_address, _set_additional_ipv4_address)
  mls_qos = __builtin__.property(_get_mls_qos, _set_mls_qos)
  srr_queue = __builtin__.property(_get_srr_queue, _set_srr_queue)
  additional_ipv6_address = __builtin__.property(_get_additional_ipv6_address, _set_additional_ipv6_address)
  vlan = __builtin__.property(_get_vlan, _set_vlan)
  visible_interface = __builtin__.property(_get_visible_interface, _set_visible_interface)
  inside_name = __builtin__.property(_get_inside_name, _set_inside_name)
  security_level_inside = __builtin__.property(_get_security_level_inside, _set_security_level_inside)
  acl_inbound_name = __builtin__.property(_get_acl_inbound_name, _set_acl_inbound_name)
  acl_outbound_name = __builtin__.property(_get_acl_outbound_name, _set_acl_outbound_name)
  peer_unit = __builtin__.property(_get_peer_unit, _set_peer_unit)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('long_name', long_name), ('if_index', if_index), ('description', description), ('mode', mode), ('mtu', mtu), ('hold_time_up', hold_time_up), ('hold_time_down', hold_time_down), ('physical_address', physical_address), ('rnc_name', rnc_name), ('port', port), ('dhcp', dhcp), ('inpath_optimisation', inpath_optimisation), ('ip_address', ip_address), ('netmask', netmask), ('ipv4_prefix_length', ipv4_prefix_length), ('ipv6_address', ipv6_address), ('ipv6_prefix_length', ipv6_prefix_length), ('alias_address', alias_address), ('gateway', gateway), ('inpath_gateway', inpath_gateway), ('primaryip', primaryip), ('secondaryip', secondaryip), ('admin_state', admin_state), ('operation_state', operation_state), ('out_bandwidth', out_bandwidth), ('in_bandwidth', in_bandwidth), ('speed', speed), ('native_vlan', native_vlan), ('portfast', portfast), ('service', service), ('cdp', cdp), ('bpduguard', bpduguard), ('broadcast', broadcast), ('nonegotiate', nonegotiate), ('power_inline', power_inline), ('value', value), ('priority_queue', priority_queue), ('voice_vlan', voice_vlan), ('level', level), ('speed_unit', speed_unit), ('policer_name', policer_name), ('additional_ipv4_address', additional_ipv4_address), ('mls_qos', mls_qos), ('srr_queue', srr_queue), ('additional_ipv6_address', additional_ipv6_address), ('vlan', vlan), ('visible_interface', visible_interface), ('inside_name', inside_name), ('security_level_inside', security_level_inside), ('acl_inbound_name', acl_inbound_name), ('acl_outbound_name', acl_outbound_name), ('peer_unit', peer_unit), ])


