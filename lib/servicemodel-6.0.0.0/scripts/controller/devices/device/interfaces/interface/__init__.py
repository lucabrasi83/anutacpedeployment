
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import additional_ipv4_address
import mls_qos
import srr_queue
import additional_ipv6_address
import port_security
import allowed_vlans
import ospf
import eigrp
import vrrp
import hsrp
class interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /devices/device/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__long_name','__name','__if_index','__description','__mode','__mtu','__hold_time_up','__hold_time_down','__physical_address','__rnc_name','__port','__dhcp','__inpath_optimisation','__ip_address','__netmask','__ipv4_prefix_length','__ipv6_address','__ipv6_prefix_length','__alias_address','__gateway','__inpath_gateway','__primaryip','__secondaryip','__admin_state','__operation_state','__out_bandwidth','__in_bandwidth','__speed','__native_vlan','__portfast','__service','__cdp','__bpduguard','__broadcast','__nonegotiate','__power_inline','__value','__priority_queue','__voice_vlan','__level','__speed_unit','__policer_name','__additional_ipv4_address','__mls_qos','__srr_queue','__additional_ipv6_address','__mace_enable','__port_security','__allowed_vlans','__ospf','__eigrp','__unit','__vlan_count','__context_name','__visible_interface','__inside_name','__security_level_inside','__mpls_device_role','__inner_vlan','__outbound_qos','__inbound_qos','__load_interval_delay','__bridge_group','__bridge_acl_inbound','__in_queue_length','__out_queue_length','__link_negotiation','__vrf_receive','__bgp_policy','__bgp_policy_qos','__pbr_policy','__vrf_definition_mode','__encap_mode','__port_number','__mgmt_profile','__address1_comment','__address2_comment','__rpf_check','__postscrub_unit','__keepalive_time','__virtual_ethernet_number','__ethernet_number_vpls','__cos','__port_number_vpls','__slot_number','__full_slot_number','__slot_module_number','__vpn_instance_name','__vsi_vlan_name','__port_type','__if_type','__arp_timeout','__port_number_vlan','__vpls_name','__bandwidth','__delay','__maximum_segment_size','__nat_name','__minimum_links','__link_speed','__duplex','__fcoe_lag','__lacp_active_enable','__lacp_active_periodic_fast','__vlan','__port_channel_name','__channel_group_mode','__channel_protocol','__vrf','__bfd_name','__vrrp','__acl_inbound_name','__acl_outbound_name','__context_name','__source_ip','__destination_ip','__destination_vrf','__port_qos_group_template','__port_qos_scheduler_policy','__rate_limit','__hsrp',)

  _yang_name = 'interface'
  _module_name = 'interface'
  _namespace = 'http://anutanetworks.com/interface'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bfd_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bfd-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    self.__alias_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="alias-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__vsi_vlan_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vsi-vlan-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__cdp = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__port_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'MANAGEMENT': {}, u'SERVICELINK': {}, u'WANINTERFACE': {}, u'DOWNLINK': {}, u'OTHER': {}, u'ACCESS': {}, u'EXTERNAL_TO_PUBLIC': {}, u'TRUNK': {}, u'PEER': {}, u'EXTERNAL_TO_MPLS': {}, u'VOICE': {}, u'UPLINK': {}},), is_leaf=True, yang_name="port-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='rnc-type', is_config=True)
    self.__additional_ipv6_address = YANGDynClass(base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__allowed_vlans = YANGDynClass(base=allowed_vlans.allowed_vlans, is_container='container', yang_name="allowed-vlans", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__vrf_definition_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__bridge_acl_inbound = YANGDynClass(base=unicode, is_leaf=True, yang_name="bridge-acl-inbound", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__duplex = YANGDynClass(base=unicode, is_leaf=True, yang_name="duplex", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__port_number_vpls = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__in_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)
    self.__mace_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mace-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__acl_inbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)
    self.__rpf_check = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rpf-check", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__destination_ip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)
    self.__fcoe_lag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fcoe-lag", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__source_ip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)
    self.__bgp_policy_qos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp-policy-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'negotiated': {}},),], is_leaf=True, yang_name="ip-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='union', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__address1_comment = YANGDynClass(base=unicode, is_leaf=True, yang_name="address1-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__ipv4_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)
    self.__nonegotiate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-mode', is_config=True)
    self.__full_slot_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="full-slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__port_qos_group_template = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-qos-group-template", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv6-address', is_config=True)
    self.__rate_limit = YANGDynClass(base=unicode, is_leaf=True, yang_name="rate-limit", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)
    self.__port_channel_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-channel-name", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)
    self.__postscrub_unit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="postscrub-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__voice_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    self.__in_queue_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__port = YANGDynClass(base=unicode, is_leaf=True, yang_name="port", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__lacp_active_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lacp-active-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__inner_vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="inner-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__vrrp = YANGDynClass(base=vrrp.vrrp, is_container='container', yang_name="vrrp", module_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vrrp', defining_module='vrrp', yang_type='container', is_config=True)
    self.__additional_ipv4_address = YANGDynClass(base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__dhcp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__physical_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__hold_time_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__inside_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="inside-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__priority_queue = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__out_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-admin-state', is_config=True)
    self.__vrf = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    self.__channel_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lacp': {}, u'pagp': {}},), is_leaf=True, yang_name="channel-protocol", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)
    self.__encap_mode = YANGDynClass(base=unicode, is_leaf=True, yang_name="encap-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__out_queue_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__inpath_gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    self.__srr_queue = YANGDynClass(base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__cos = YANGDynClass(base=unicode, is_leaf=True, yang_name="cos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__acl_outbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)
    self.__policer_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__slot_module_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="slot-module-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__ospf = YANGDynClass(base=ospf.ospf, is_container='container', yang_name="ospf", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__mls_qos = YANGDynClass(base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__destination_vrf = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-vrf", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='leafref', is_config=True)
    self.__long_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="long-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__outbound_qos = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__port_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="port-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__lacp_active_periodic_fast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lacp-active-periodic-fast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    self.__unit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__service = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__primaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    self.__ethernet_number_vpls = YANGDynClass(base=unicode, is_leaf=True, yang_name="ethernet-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__vrf_receive = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-receive", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__channel_group_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'active': {}, u'auto': {}, u'desirable': {}, u'passive': {}, u'on': {}},), is_leaf=True, yang_name="channel-group-mode", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)
    self.__power_inline = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__rnc_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="rnc-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__pbr_policy = YANGDynClass(base=unicode, is_leaf=True, yang_name="pbr-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__hsrp = YANGDynClass(base=hsrp.hsrp, is_container='container', yang_name="hsrp", module_name="hsrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/hsrp', defining_module='hsrp', yang_type='container', is_config=True)
    self.__broadcast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv4-address', is_config=True)
    self.__port_security = YANGDynClass(base=port_security.port_security, is_container='container', yang_name="port-security", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__mgmt_profile = YANGDynClass(base=unicode, is_leaf=True, yang_name="mgmt-profile", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__load_interval_delay = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval-delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    self.__vpls_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__ipv6_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nt:ipv6-prefix-length', is_config=True)
    self.__nat_name = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inside': {}, u'outside': {}},), is_leaf=True, yang_name="nat-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nat-type', is_config=True)
    self.__keepalive_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-time", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__vpn_instance_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpn-instance-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__eigrp = YANGDynClass(base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    self.__visible_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'voiceFXO': {'value': 101}, u'atmVciEndPt': {'value': 194}, u'propBWAp2Mp': {'value': 184}, u'propDocsWirelessDownstream': {'value': 181}, u'v11': {'value': 64}, u'softwareLoopback': {'value': 24}, u'hdlc': {'value': 118}, u'voiceFGDOS': {'value': 235}, u'fastEtherFX': {'value': 69}, u'dvbTdm': {'value': 240}, u'nfas': {'value': 175}, u'ifPwType': {'value': 246}, u'l2vlan': {'value': 135}, u'adsl2plus': {'value': 238}, u'ieee802154': {'value': 259}, u'voiceFXS': {'value': 102}, u'dvbRcsMacLayer': {'value': 239}, u'idsl': {'value': 154}, u'infiniband': {'value': 199}, u'ddnX25': {'value': 4}, u'wwanPP2': {'value': 244}, u'docsCableUpstream': {'value': 129}, u'ethernet3Mbit': {'value': 26}, u'digitalPowerline': {'value': 138}, u'h323Proxy': {'value': 165}, u'gtp': {'value': 216}, u'ipOverAtm': {'value': 114}, u'aluEpon': {'value': 266}, u'imt': {'value': 190}, u'ipSwitch': {'value': 78}, u'msdsl': {'value': 143}, u'dvbRccMacLayer': {'value': 146}, u'smdsDxi': {'value': 43}, u'voiceOverAtm': {'value': 152}, u'arap': {'value': 88}, u'fastEther': {'value': 62}, u'mpc': {'value': 113}, u'linegroup': {'value': 210}, u'hippi': {'value': 47}, u'rpr': {'value': 225}, u'ds1FDL': {'value': 170}, u'sonetVT': {'value': 51}, u'aluGponPhysicalUni': {'value': 271}, u'ss7SigLink': {'value': 156}, u'arcnet': {'value': 35}, u'actelisMetaLOOP': {'value': 223}, u'qllc': {'value': 68}, u'rfc877x25': {'value': 5}, u'mpegTransport': {'value': 214}, u'x25mlp': {'value': 121}, u'virtualTg': {'value': 202}, u'hostPad': {'value': 90}, u'starLan': {'value': 11}, u'iso88025Dtr': {'value': 86}, u'ibm370parChan': {'value': 72}, u'adsl2': {'value': 230}, u'otnOtu': {'value': 261}, u'propWirelessP2P': {'value': 157}, u'interleave': {'value': 124}, u'isup': {'value': 179}, u'regular1822': {'value': 2}, u'gr303RDT': {'value': 177}, u'propDocsWirelessMaclayer': {'value': 180}, u'async': {'value': 84}, u'radioMAC': {'value': 188}, u'opticalChannelGroup': {'value': 219}, u'sixToFour': {'value': 215}, u'propDocsWirelessUpstream': {'value': 182}, u'q2931': {'value': 201}, u'fddi': {'value': 15}, u'propCnls': {'value': 89}, u'aal2': {'value': 187}, u'dvbAsiOut': {'value': 173}, u'aluELP': {'value': 249}, u'ciscoISLvlan': {'value': 222}, u'docsCableUpstreamRfPort': {'value': 256}, u'aal5': {'value': 49}, u'frDlciEndPt': {'value': 193}, u'hippiInterface': {'value': 57}, u'l3ipvlan': {'value': 136}, u'miox25': {'value': 38}, u'hssi': {'value': 46}, u'fastdsl': {'value': 282}, u'atmVirtual': {'value': 149}, u'aluGponOnu': {'value': 270}, u'rfc1483': {'value': 159}, u'cnr': {'value': 85}, u'sipSig': {'value': 204}, u'myrinet': {'value': 99}, u'dlsw': {'value': 74}, u'gigabitEthernet': {'value': 117}, u'x25ple': {'value': 40}, u'lmp': {'value': 227}, u'opticalTransport': {'value': 196}, u'sdlc': {'value': 17}, u'voiceEM': {'value': 100}, u'x86Laps': {'value': 242}, u'g9982': {'value': 264}, u'iso88022llc': {'value': 41}, u'dvbAsiIn': {'value': 172}, u'bgppolicyaccounting': {'value': 162}, u'aluEponOnu': {'value': 267}, u'mfSigLink': {'value': 167}, u'dcn': {'value': 141}, u'atmDxi': {'value': 105}, u'voiceOverFrameRelay': {'value': 153}, u'gfp': {'value': 221}, u'sonetOverheadChannel': {'value': 185}, u'vmwareVirtualNic': {'value': 258}, u'fcipLink': {'value': 224}, u'ipOverClaw': {'value': 110}, u'coffee': {'value': 132}, u'radsl': {'value': 95}, u'gfast': {'value': 279}, u'vdsl2': {'value': 251}, u'rs232': {'value': 33}, u'e1': {'value': 19}, u'reachDSL': {'value': 192}, u'xboxWireless': {'value': 281}, u'voiceOverCable': {'value': 198}, u'tr008': {'value': 176}, u'voiceOverIp': {'value': 104}, u'atm': {'value': 37}, u'ds3': {'value': 30}, u'ds0': {'value': 81}, u'ds1': {'value': 18}, u'srp': {'value': 151}, u'docsCableDownstream': {'value': 128}, u'dvbRcsTdma': {'value': 241}, u'g9983': {'value': 265}, u'plc': {'value': 174}, u'frameRelayMPI': {'value': 92}, u'mvl': {'value': 191}, u'propMultiplexor': {'value': 54}, u'voiceDID': {'value': 213}, u'compositeLink': {'value': 155}, u'proteon10Mbit': {'value': 12}, u'atmbond': {'value': 234}, u'frf16MfrBundle': {'value': 163}, u'cctEmul': {'value': 61}, u'mplsTunnel': {'value': 150}, u'gpon': {'value': 250}, u'vdsl': {'value': 97}, u'pos': {'value': 171}, u'ieee8023adLag': {'value': 161}, u'docsCableMaclayer': {'value': 127}, u'docsCableMCmtsDownstream': {'value': 229}, u'ppp': {'value': 23}, u'frameRelay': {'value': 32}, u'eplrs': {'value': 87}, u'vmwareNicTeam': {'value': 272}, u'cableDownstreamRfPort': {'value': 257}, u'macSecUncontrolledIF': {'value': 232}, u'iso88023Csmacd': {'value': 7}, u'usb': {'value': 160}, u'atmFuni': {'value': 106}, u'teLink': {'value': 200}, u'pon622': {'value': 208}, u'econet': {'value': 206}, u'tdlc': {'value': 116}, u'ds0Bundle': {'value': 82}, u'fast': {'value': 125}, u'ieee1394': {'value': 144}, u'cblVectaStar': {'value': 228}, u'rsrb': {'value': 79}, u'frameRelayInterconnect': {'value': 58}, u'isdns': {'value': 75}, u'pppMultilinkBundle': {'value': 108}, u'aflane8025': {'value': 60}, u'lapb': {'value': 16}, u'aflane8023': {'value': 59}, u'lapd': {'value': 77}, u'isdnu': {'value': 76}, u'lapf': {'value': 119}, u'capwapWtpVirtualRadio': {'value': 254}, u'ifVfiType': {'value': 262}, u'x25huntGroup': {'value': 122}, u'para': {'value': 34}, u'macSecControlledIF': {'value': 231}, u'iso88024TokenBus': {'value': 8}, u'localTalk': {'value': 42}, u'hyperchannel': {'value': 14}, u'mediaMailOverIp': {'value': 139}, u'if-gsn': {'value': 145}, u'capwapDot11Profile': {'value': 252}, u'l3ipxvlan': {'value': 137}, u'atmSubInterface': {'value': 134}, u'primaryISDN': {'value': 21}, u'proteon80Mbit': {'value': 13}, u'iso88026Man': {'value': 10}, u'digitalWrapperOverheadChannel': {'value': 186}, u'docsCableUpstreamChannel': {'value': 205}, u'opticalChannel': {'value': 195}, u'ethernetCsmacd': {'value': 6}, u'bits': {'value': 255}, u'tunnel': {'value': 131}, u'hdsl2': {'value': 168}, u'frameRelayService': {'value': 44}, u'mpls': {'value': 166}, u'ieee80211': {'value': 71}, u'ieee80212': {'value': 55}, u'mocaVersion1': {'value': 236}, u'sonet': {'value': 39}, u'escon': {'value': 73}, u'aluEponLogicalLink': {'value': 269}, u'g703at2mb': {'value': 67}, u'ultra': {'value': 29}, u'dvbRccDownstream': {'value': 147}, u'sipTg': {'value': 203}, u'smdsIcip': {'value': 52}, u'bridge': {'value': 209}, u'atmLogical': {'value': 80}, u'propPointToPointSerial': {'value': 22}, u'v35': {'value': 45}, u'v36': {'value': 65}, u'v37': {'value': 120}, u'ip': {'value': 126}, u'gr303IDT': {'value': 178}, u'basicISDN': {'value': 20}, u'g703at64k': {'value': 66}, u'arcnetPlus': {'value': 36}, u'pip': {'value': 248}, u'dtm': {'value': 140}, u'slip': {'value': 28}, u'hiperlan2': {'value': 183}, u'adsl': {'value': 94}, u'ieee80216WMAN': {'value': 237}, u'atmIma': {'value': 107}, u'isdn': {'value': 63}, u'capwapDot11Bss': {'value': 253}, u'sip': {'value': 31}, u'pdnEtherLoop2': {'value': 218}, u'voiceEBS': {'value': 245}, u'ipForward': {'value': 142}, u'iso88025CRFPInt': {'value': 98}, u'propVirtual': {'value': 53}, u'wwanPP': {'value': 243}, u'docsOfdmaUpstream': {'value': 278}, u'other': {'value': 1}, u'pon155': {'value': 207}, u'voiceEncap': {'value': 103}, u'qam': {'value': 226}, u'otnOdu': {'value': 260}, u'iso88025Fiber': {'value': 115}, u'channel': {'value': 70}, u'voiceEMFGD': {'value': 211}, u'sdci': {'value': 280}, u'a12MppSwitch': {'value': 130}, u'ilan': {'value': 247}, u'pdnEtherLoop1': {'value': 217}, u'x213': {'value': 93}, u'sonetPath': {'value': 50}, u'voiceFGDEANA': {'value': 212}, u'iso88025TokenRing': {'value': 9}, u'propAtm': {'value': 197}, u'aluEponPhysicalUni': {'value': 268}, u'stackToStack': {'value': 111}, u'frForward': {'value': 158}, u'homepna': {'value': 220}, u'sdsl': {'value': 96}, u'virtualIpAddress': {'value': 112}, u'bsc': {'value': 83}, u'atmRadio': {'value': 189}, u'aviciOpticalEther': {'value': 233}, u'g9981': {'value': 263}, u'docsOfdmDownstream': {'value': 277}, u'fibreChannel': {'value': 56}, u'shdsl': {'value': 169}, u'eon': {'value': 25}, u'h323Gatekeeper': {'value': 164}, u'hdh1822': {'value': 3}, u'dvbRccUpstream': {'value': 148}, u'nsip': {'value': 27}, u'transpHdlc': {'value': 123}, u'termPad': {'value': 91}, u'ipOverCdlc': {'value': 109}, u'ces': {'value': 133}, u'modem': {'value': 48}},), is_leaf=True, yang_name="if-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='ift:if-type', is_config=True)
    self.__link_negotiation = YANGDynClass(base=unicode, is_leaf=True, yang_name="link-negotiation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__portfast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="portfast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__port_number_vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-number-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__operation_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-operation-state', is_config=False)
    self.__minimum_links = YANGDynClass(base=unicode, is_leaf=True, yang_name="minimum-links", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__address2_comment = YANGDynClass(base=unicode, is_leaf=True, yang_name="address2-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__arp_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="arp-timeout", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__bpduguard = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__mpls_device_role = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'P': {}, u'None': {}, u'PE-RR': {}, u'RR': {}, u'PE': {}},), is_leaf=True, yang_name="mpls-device-role", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__context_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    self.__delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__vlan_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vlan-count", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='int32', is_config=False)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)
    self.__maximum_segment_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-segment-size", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__security_level_inside = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__port_qos_scheduler_policy = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-qos-scheduler-policy", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)
    self.__link_speed = YANGDynClass(base=unicode, is_leaf=True, yang_name="link-speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__slot_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__speed_unit = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__hold_time_down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    self.__bgp_policy = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    self.__inpath_optimisation = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    self.__virtual_ethernet_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-ethernet-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__inbound_qos = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    self.__bridge_group = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bridge-group", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)
    self.__secondaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'devices', u'device', u'interfaces', u'interface']

  def _get_long_name(self):
    """
    Getter method for long_name, mapped from YANG variable /devices/device/interfaces/interface/long_name (string)

    YANG Description: Complete name of the interface.
    """
    return self.__long_name
      
  def _set_long_name(self, v, load=False):
    """
    Setter method for long_name, mapped from YANG variable /devices/device/interfaces/interface/long_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_long_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_long_name() directly.

    YANG Description: Complete name of the interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="long-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """long_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="long-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__long_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_long_name(self):
    self.__long_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="long-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/interfaces/interface/name (string)

    YANG Description: Name of the interface. Typically maps to the short name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/interfaces/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interface. Typically maps to the short name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_if_index(self):
    """
    Getter method for if_index, mapped from YANG variable /devices/device/interfaces/interface/if_index (uint32)

    YANG Description: SNMP index of the interface.
    """
    return self.__if_index
      
  def _set_if_index(self, v, load=False):
    """
    Setter method for if_index, mapped from YANG variable /devices/device/interfaces/interface/if_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_index() directly.

    YANG Description: SNMP index of the interface.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__if_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_index(self):
    self.__if_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="if-index", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /devices/device/interfaces/interface/description (string)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /devices/device/interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /devices/device/interfaces/interface/mode (interface-mode)

    YANG Description: trunk
access
vlan
voice
sub-interface
l3-interface
l2-interface
l2-sub-interface
loopback-interface
tunnel
rnc-interface
l3vpn-interface

    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /devices/device/interfaces/interface/mode (interface-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: trunk
access
vlan
voice
sub-interface
l3-interface
l2-interface
l2-sub-interface
loopback-interface
tunnel
rnc-interface
l3vpn-interface

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with interface-mode""",
          'defined-type': "interface:interface-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rnc-interface': {}, u'l2-sub-interface': {}, u'loopback-interface': {}, u'sub-interface': {}, u'tunnel': {}, u'vlan': {}, u'l3vpn-interface': {}, u'reset': {}, u'access': {}, u'l2-interface': {}, u'trunk': {}, u'voice': {}, u'l3-interface': {}},), is_leaf=True, yang_name="mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-mode', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /devices/device/interfaces/interface/mtu (uint32)

    YANG Description: 0..4294967295
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /devices/device/interfaces/interface/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_hold_time_up(self):
    """
    Getter method for hold_time_up, mapped from YANG variable /devices/device/interfaces/interface/hold_time_up (uint32)

    YANG Description: 0..4294967295
    """
    return self.__hold_time_up
      
  def _set_hold_time_up(self, v, load=False):
    """
    Setter method for hold_time_up, mapped from YANG variable /devices/device/interfaces/interface/hold_time_up (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_up is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_up() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_up must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__hold_time_up = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_up(self):
    self.__hold_time_up = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-up", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_hold_time_down(self):
    """
    Getter method for hold_time_down, mapped from YANG variable /devices/device/interfaces/interface/hold_time_down (uint32)

    YANG Description: 0..4294967295
    """
    return self.__hold_time_down
      
  def _set_hold_time_down(self, v, load=False):
    """
    Setter method for hold_time_down, mapped from YANG variable /devices/device/interfaces/interface/hold_time_down (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time_down() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time_down must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__hold_time_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time_down(self):
    self.__hold_time_down = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-time-down", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_physical_address(self):
    """
    Getter method for physical_address, mapped from YANG variable /devices/device/interfaces/interface/physical_address (string)

    YANG Description: string
    """
    return self.__physical_address
      
  def _set_physical_address(self, v, load=False):
    """
    Setter method for physical_address, mapped from YANG variable /devices/device/interfaces/interface/physical_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_address() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="physical-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__physical_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_address(self):
    self.__physical_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_rnc_name(self):
    """
    Getter method for rnc_name, mapped from YANG variable /devices/device/interfaces/interface/rnc_name (string)

    YANG Description: string
    """
    return self.__rnc_name
      
  def _set_rnc_name(self, v, load=False):
    """
    Setter method for rnc_name, mapped from YANG variable /devices/device/interfaces/interface/rnc_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rnc_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rnc_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rnc-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rnc_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rnc-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__rnc_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rnc_name(self):
    self.__rnc_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="rnc-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /devices/device/interfaces/interface/port (string)

    YANG Description: string
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /devices/device/interfaces/interface/port (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=unicode, is_leaf=True, yang_name="port", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_dhcp(self):
    """
    Getter method for dhcp, mapped from YANG variable /devices/device/interfaces/interface/dhcp (boolean)

    YANG Description: dhcp: True/False
    """
    return self.__dhcp
      
  def _set_dhcp(self, v, load=False):
    """
    Setter method for dhcp, mapped from YANG variable /devices/device/interfaces/interface/dhcp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp() directly.

    YANG Description: dhcp: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__dhcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp(self):
    self.__dhcp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dhcp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_inpath_optimisation(self):
    """
    Getter method for inpath_optimisation, mapped from YANG variable /devices/device/interfaces/interface/inpath_optimisation (enumeration)

    YANG Description: enable inpath optimisation: Enable
    """
    return self.__inpath_optimisation
      
  def _set_inpath_optimisation(self, v, load=False):
    """
    Setter method for inpath_optimisation, mapped from YANG variable /devices/device/interfaces/interface/inpath_optimisation (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inpath_optimisation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inpath_optimisation() directly.

    YANG Description: enable inpath optimisation: Enable
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inpath_optimisation must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__inpath_optimisation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inpath_optimisation(self):
    self.__inpath_optimisation = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}},), is_leaf=True, yang_name="inpath-optimisation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /devices/device/interfaces/interface/ip_address (union)

    YANG Description: IPv4 Address of the interface. (Only certain interfaces can take the value 'negotitated')
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /devices/device/interfaces/interface/ip_address (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IPv4 Address of the interface. (Only certain interfaces can take the value 'negotitated')
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'negotiated': {}},),], is_leaf=True, yang_name="ip-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with union""",
          'defined-type': "interface:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'negotiated': {}},),], is_leaf=True, yang_name="ip-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='union', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'negotiated': {}},),], is_leaf=True, yang_name="ip-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='union', is_config=True)


  def _get_netmask(self):
    """
    Getter method for netmask, mapped from YANG variable /devices/device/interfaces/interface/netmask (inet:ipv4-address)

    YANG Description: Netmask of of the interface in dotted quad notation.
    """
    return self.__netmask
      
  def _set_netmask(self, v, load=False):
    """
    Setter method for netmask, mapped from YANG variable /devices/device/interfaces/interface/netmask (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netmask() directly.

    YANG Description: Netmask of of the interface in dotted quad notation.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netmask must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netmask(self):
    self.__netmask = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="netmask", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv4-address', is_config=True)


  def _get_ipv4_prefix_length(self):
    """
    Getter method for ipv4_prefix_length, mapped from YANG variable /devices/device/interfaces/interface/ipv4_prefix_length (uint8)

    YANG Description: IPv4 netmask in CIDR notation.
    """
    return self.__ipv4_prefix_length
      
  def _set_ipv4_prefix_length(self, v, load=False):
    """
    Setter method for ipv4_prefix_length, mapped from YANG variable /devices/device/interfaces/interface/ipv4_prefix_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_prefix_length() directly.

    YANG Description: IPv4 netmask in CIDR notation.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_prefix_length must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)""",
        })

    self.__ipv4_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_prefix_length(self):
    self.__ipv4_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..32']}), is_leaf=True, yang_name="ipv4-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)


  def _get_ipv6_address(self):
    """
    Getter method for ipv6_address, mapped from YANG variable /devices/device/interfaces/interface/ipv6_address (inet:ipv6-address)

    YANG Description: IPv6 Address of the interface
    """
    return self.__ipv6_address
      
  def _set_ipv6_address(self, v, load=False):
    """
    Setter method for ipv6_address, mapped from YANG variable /devices/device/interfaces/interface/ipv6_address (inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address() directly.

    YANG Description: IPv6 Address of the interface
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv6-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_address must be of a type compatible with inet:ipv6-address""",
          'defined-type': "inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv6-address', is_config=True)""",
        })

    self.__ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_address(self):
    self.__ipv6_address = YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ipv6-address', is_config=True)


  def _get_ipv6_prefix_length(self):
    """
    Getter method for ipv6_prefix_length, mapped from YANG variable /devices/device/interfaces/interface/ipv6_prefix_length (nt:ipv6-prefix-length)

    YANG Description: IPv6 netmask in CIDR notation.
    """
    return self.__ipv6_prefix_length
      
  def _set_ipv6_prefix_length(self, v, load=False):
    """
    Setter method for ipv6_prefix_length, mapped from YANG variable /devices/device/interfaces/interface/ipv6_prefix_length (nt:ipv6-prefix-length)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_prefix_length() directly.

    YANG Description: IPv6 netmask in CIDR notation.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nt:ipv6-prefix-length', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_prefix_length must be of a type compatible with nt:ipv6-prefix-length""",
          'defined-type': "nt:ipv6-prefix-length",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nt:ipv6-prefix-length', is_config=True)""",
        })

    self.__ipv6_prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_prefix_length(self):
    self.__ipv6_prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': [u'0..128']}), is_leaf=True, yang_name="ipv6-prefix-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nt:ipv6-prefix-length', is_config=True)


  def _get_alias_address(self):
    """
    Getter method for alias_address, mapped from YANG variable /devices/device/interfaces/interface/alias_address (string)

    YANG Description: string
    """
    return self.__alias_address
      
  def _set_alias_address(self, v, load=False):
    """
    Setter method for alias_address, mapped from YANG variable /devices/device/interfaces/interface/alias_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alias_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alias_address() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="alias-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alias_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="alias-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__alias_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alias_address(self):
    self.__alias_address = YANGDynClass(base=unicode, is_leaf=True, yang_name="alias-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /devices/device/interfaces/interface/gateway (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /devices/device/interfaces/interface/gateway (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)


  def _get_inpath_gateway(self):
    """
    Getter method for inpath_gateway, mapped from YANG variable /devices/device/interfaces/interface/inpath_gateway (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__inpath_gateway
      
  def _set_inpath_gateway(self, v, load=False):
    """
    Setter method for inpath_gateway, mapped from YANG variable /devices/device/interfaces/interface/inpath_gateway (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inpath_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inpath_gateway() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inpath_gateway must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__inpath_gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inpath_gateway(self):
    self.__inpath_gateway = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="inpath-gateway", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)


  def _get_primaryip(self):
    """
    Getter method for primaryip, mapped from YANG variable /devices/device/interfaces/interface/primaryip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__primaryip
      
  def _set_primaryip(self, v, load=False):
    """
    Setter method for primaryip, mapped from YANG variable /devices/device/interfaces/interface/primaryip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primaryip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primaryip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primaryip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__primaryip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primaryip(self):
    self.__primaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="primaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)


  def _get_secondaryip(self):
    """
    Getter method for secondaryip, mapped from YANG variable /devices/device/interfaces/interface/secondaryip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__secondaryip
      
  def _set_secondaryip(self, v, load=False):
    """
    Setter method for secondaryip, mapped from YANG variable /devices/device/interfaces/interface/secondaryip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondaryip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondaryip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondaryip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__secondaryip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondaryip(self):
    self.__secondaryip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="secondaryip", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)


  def _get_admin_state(self):
    """
    Getter method for admin_state, mapped from YANG variable /devices/device/interfaces/interface/admin_state (interface-admin-state)

    YANG Description: UP
DOWN
TESTING

    """
    return self.__admin_state
      
  def _set_admin_state(self, v, load=False):
    """
    Setter method for admin_state, mapped from YANG variable /devices/device/interfaces/interface/admin_state (interface-admin-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_state() directly.

    YANG Description: UP
DOWN
TESTING

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-admin-state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_state must be of a type compatible with interface-admin-state""",
          'defined-type': "interface:interface-admin-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-admin-state', is_config=True)""",
        })

    self.__admin_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_state(self):
    self.__admin_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DOWN': {}, u'TESTING': {}, u'UP': {}},), is_leaf=True, yang_name="admin-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-admin-state', is_config=True)


  def _get_operation_state(self):
    """
    Getter method for operation_state, mapped from YANG variable /devices/device/interfaces/interface/operation_state (interface-operation-state)

    YANG Description: UP
DOWN
TESTING
UNKNOWN
DORMANT
NOTPRESENT
LOWERLAYERDOWN
INVALID

    """
    return self.__operation_state
      
  def _set_operation_state(self, v, load=False):
    """
    Setter method for operation_state, mapped from YANG variable /devices/device/interfaces/interface/operation_state (interface-operation-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation_state() directly.

    YANG Description: UP
DOWN
TESTING
UNKNOWN
DORMANT
NOTPRESENT
LOWERLAYERDOWN
INVALID

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-operation-state', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation_state must be of a type compatible with interface-operation-state""",
          'defined-type': "interface:interface-operation-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-operation-state', is_config=False)""",
        })

    self.__operation_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation_state(self):
    self.__operation_state = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DORMANT': {}, u'LOWERLAYERDOWN': {}, u'UNKNOWN': {}, u'TESTING': {}, u'UP': {}, u'INVALID': {}, u'DOWN': {}, u'NOTPRESENT': {}},), is_leaf=True, yang_name="operation-state", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='interface-operation-state', is_config=False)


  def _get_out_bandwidth(self):
    """
    Getter method for out_bandwidth, mapped from YANG variable /devices/device/interfaces/interface/out_bandwidth (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__out_bandwidth
      
  def _set_out_bandwidth(self, v, load=False):
    """
    Setter method for out_bandwidth, mapped from YANG variable /devices/device/interfaces/interface/out_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_bandwidth() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)""",
        })

    self.__out_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_bandwidth(self):
    self.__out_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)


  def _get_in_bandwidth(self):
    """
    Getter method for in_bandwidth, mapped from YANG variable /devices/device/interfaces/interface/in_bandwidth (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__in_bandwidth
      
  def _set_in_bandwidth(self, v, load=False):
    """
    Setter method for in_bandwidth, mapped from YANG variable /devices/device/interfaces/interface/in_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_bandwidth() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_bandwidth must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)""",
        })

    self.__in_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_bandwidth(self):
    self.__in_bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)


  def _get_speed(self):
    """
    Getter method for speed, mapped from YANG variable /devices/device/interfaces/interface/speed (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__speed
      
  def _set_speed(self, v, load=False):
    """
    Setter method for speed, mapped from YANG variable /devices/device/interfaces/interface/speed (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)""",
        })

    self.__speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed(self):
    self.__speed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint64', is_config=True)


  def _get_native_vlan(self):
    """
    Getter method for native_vlan, mapped from YANG variable /devices/device/interfaces/interface/native_vlan (uint16)

    YANG Description: Native-vlan
    """
    return self.__native_vlan
      
  def _set_native_vlan(self, v, load=False):
    """
    Setter method for native_vlan, mapped from YANG variable /devices/device/interfaces/interface/native_vlan (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_native_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_native_vlan() directly.

    YANG Description: Native-vlan
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """native_vlan must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)""",
        })

    self.__native_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_native_vlan(self):
    self.__native_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="native-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)


  def _get_portfast(self):
    """
    Getter method for portfast, mapped from YANG variable /devices/device/interfaces/interface/portfast (boolean)

    YANG Description: portfast should be enable or not
    """
    return self.__portfast
      
  def _set_portfast(self, v, load=False):
    """
    Setter method for portfast, mapped from YANG variable /devices/device/interfaces/interface/portfast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_portfast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_portfast() directly.

    YANG Description: portfast should be enable or not
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="portfast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """portfast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="portfast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__portfast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_portfast(self):
    self.__portfast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="portfast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /devices/device/interfaces/interface/service (enumeration)

    YANG Description: disable
trunk

    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /devices/device/interfaces/interface/service (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.

    YANG Description: disable
trunk

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disable': {}, u'trunk': {}},), is_leaf=True, yang_name="service", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_cdp(self):
    """
    Getter method for cdp, mapped from YANG variable /devices/device/interfaces/interface/cdp (enumeration)

    YANG Description: enable
disable

    """
    return self.__cdp
      
  def _set_cdp(self, v, load=False):
    """
    Setter method for cdp, mapped from YANG variable /devices/device/interfaces/interface/cdp (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cdp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cdp() directly.

    YANG Description: enable
disable

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cdp must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__cdp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cdp(self):
    self.__cdp = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'enable': {}, u'disable': {}},), is_leaf=True, yang_name="cdp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_bpduguard(self):
    """
    Getter method for bpduguard, mapped from YANG variable /devices/device/interfaces/interface/bpduguard (boolean)

    YANG Description: bpduguard should be enable or not
    """
    return self.__bpduguard
      
  def _set_bpduguard(self, v, load=False):
    """
    Setter method for bpduguard, mapped from YANG variable /devices/device/interfaces/interface/bpduguard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bpduguard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bpduguard() directly.

    YANG Description: bpduguard should be enable or not
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bpduguard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__bpduguard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bpduguard(self):
    self.__bpduguard = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bpduguard", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_broadcast(self):
    """
    Getter method for broadcast, mapped from YANG variable /devices/device/interfaces/interface/broadcast (boolean)

    YANG Description: bpduguard should be enable or not
    """
    return self.__broadcast
      
  def _set_broadcast(self, v, load=False):
    """
    Setter method for broadcast, mapped from YANG variable /devices/device/interfaces/interface/broadcast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_broadcast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_broadcast() directly.

    YANG Description: bpduguard should be enable or not
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """broadcast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__broadcast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_broadcast(self):
    self.__broadcast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="broadcast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_nonegotiate(self):
    """
    Getter method for nonegotiate, mapped from YANG variable /devices/device/interfaces/interface/nonegotiate (boolean)

    YANG Description: nonegotiate: True/False
    """
    return self.__nonegotiate
      
  def _set_nonegotiate(self, v, load=False):
    """
    Setter method for nonegotiate, mapped from YANG variable /devices/device/interfaces/interface/nonegotiate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nonegotiate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nonegotiate() directly.

    YANG Description: nonegotiate: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nonegotiate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__nonegotiate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nonegotiate(self):
    self.__nonegotiate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="nonegotiate", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_power_inline(self):
    """
    Getter method for power_inline, mapped from YANG variable /devices/device/interfaces/interface/power_inline (enumeration)

    YANG Description: auto
never
static

    """
    return self.__power_inline
      
  def _set_power_inline(self, v, load=False):
    """
    Setter method for power_inline, mapped from YANG variable /devices/device/interfaces/interface/power_inline (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_inline is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_inline() directly.

    YANG Description: auto
never
static

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_inline must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__power_inline = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_inline(self):
    self.__power_inline = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'auto': {}, u'never': {}, u'static': {}},), is_leaf=True, yang_name="power-inline", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /devices/device/interfaces/interface/value (uint16)

    YANG Description: 0..65535
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /devices/device/interfaces/interface/value (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="value", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)


  def _get_priority_queue(self):
    """
    Getter method for priority_queue, mapped from YANG variable /devices/device/interfaces/interface/priority_queue (enumeration)

    YANG Description: out

    """
    return self.__priority_queue
      
  def _set_priority_queue(self, v, load=False):
    """
    Setter method for priority_queue, mapped from YANG variable /devices/device/interfaces/interface/priority_queue (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority_queue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority_queue() directly.

    YANG Description: out

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority_queue must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__priority_queue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority_queue(self):
    self.__priority_queue = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'out': {}},), is_leaf=True, yang_name="priority-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_voice_vlan(self):
    """
    Getter method for voice_vlan, mapped from YANG variable /devices/device/interfaces/interface/voice_vlan (uint16)

    YANG Description: vlan
    """
    return self.__voice_vlan
      
  def _set_voice_vlan(self, v, load=False):
    """
    Setter method for voice_vlan, mapped from YANG variable /devices/device/interfaces/interface/voice_vlan (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_voice_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_voice_vlan() directly.

    YANG Description: vlan
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """voice_vlan must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)""",
        })

    self.__voice_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_voice_vlan(self):
    self.__voice_vlan = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="voice-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /devices/device/interfaces/interface/level (uint32)

    YANG Description: broadcast level
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /devices/device/interfaces/interface/level (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: broadcast level
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="level", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_speed_unit(self):
    """
    Getter method for speed_unit, mapped from YANG variable /devices/device/interfaces/interface/speed_unit (enumeration)

    YANG Description: BPS
KBPS
MBPS
GBPS
TBPS

    """
    return self.__speed_unit
      
  def _set_speed_unit(self, v, load=False):
    """
    Setter method for speed_unit, mapped from YANG variable /devices/device/interfaces/interface/speed_unit (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_speed_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_speed_unit() directly.

    YANG Description: BPS
KBPS
MBPS
GBPS
TBPS

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """speed_unit must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__speed_unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_speed_unit(self):
    self.__speed_unit = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GBPS': {}, u'TBPS': {}, u'BPS': {}, u'KBPS': {}, u'MBPS': {}},), default=unicode("MBPS"), is_leaf=True, yang_name="speed-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_policer_name(self):
    """
    Getter method for policer_name, mapped from YANG variable /devices/device/interfaces/interface/policer_name (string)

    YANG Description: string
    """
    return self.__policer_name
      
  def _set_policer_name(self, v, load=False):
    """
    Setter method for policer_name, mapped from YANG variable /devices/device/interfaces/interface/policer_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policer_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policer_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="policer-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policer_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__policer_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policer_name(self):
    self.__policer_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="policer-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_additional_ipv4_address(self):
    """
    Getter method for additional_ipv4_address, mapped from YANG variable /devices/device/interfaces/interface/additional_ipv4_address (container)
    """
    return self.__additional_ipv4_address
      
  def _set_additional_ipv4_address(self, v, load=False):
    """
    Setter method for additional_ipv4_address, mapped from YANG variable /devices/device/interfaces/interface/additional_ipv4_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additional_ipv4_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additional_ipv4_address() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """additional_ipv4_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__additional_ipv4_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_additional_ipv4_address(self):
    self.__additional_ipv4_address = YANGDynClass(base=additional_ipv4_address.additional_ipv4_address, is_container='container', yang_name="additional-ipv4-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_mls_qos(self):
    """
    Getter method for mls_qos, mapped from YANG variable /devices/device/interfaces/interface/mls_qos (container)
    """
    return self.__mls_qos
      
  def _set_mls_qos(self, v, load=False):
    """
    Setter method for mls_qos, mapped from YANG variable /devices/device/interfaces/interface/mls_qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mls_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mls_qos() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mls_qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__mls_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mls_qos(self):
    self.__mls_qos = YANGDynClass(base=mls_qos.mls_qos, is_container='container', yang_name="mls-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_srr_queue(self):
    """
    Getter method for srr_queue, mapped from YANG variable /devices/device/interfaces/interface/srr_queue (container)
    """
    return self.__srr_queue
      
  def _set_srr_queue(self, v, load=False):
    """
    Setter method for srr_queue, mapped from YANG variable /devices/device/interfaces/interface/srr_queue (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srr_queue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srr_queue() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srr_queue must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__srr_queue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srr_queue(self):
    self.__srr_queue = YANGDynClass(base=srr_queue.srr_queue, is_container='container', yang_name="srr-queue", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_additional_ipv6_address(self):
    """
    Getter method for additional_ipv6_address, mapped from YANG variable /devices/device/interfaces/interface/additional_ipv6_address (container)
    """
    return self.__additional_ipv6_address
      
  def _set_additional_ipv6_address(self, v, load=False):
    """
    Setter method for additional_ipv6_address, mapped from YANG variable /devices/device/interfaces/interface/additional_ipv6_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additional_ipv6_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additional_ipv6_address() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """additional_ipv6_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__additional_ipv6_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_additional_ipv6_address(self):
    self.__additional_ipv6_address = YANGDynClass(base=additional_ipv6_address.additional_ipv6_address, is_container='container', yang_name="additional-ipv6-address", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_mace_enable(self):
    """
    Getter method for mace_enable, mapped from YANG variable /devices/device/interfaces/interface/mace_enable (boolean)

    YANG Description: enabling mace-enable for interface
    """
    return self.__mace_enable
      
  def _set_mace_enable(self, v, load=False):
    """
    Setter method for mace_enable, mapped from YANG variable /devices/device/interfaces/interface/mace_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mace_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mace_enable() directly.

    YANG Description: enabling mace-enable for interface
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="mace-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mace_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mace-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__mace_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mace_enable(self):
    self.__mace_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mace-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_port_security(self):
    """
    Getter method for port_security, mapped from YANG variable /devices/device/interfaces/interface/port_security (container)
    """
    return self.__port_security
      
  def _set_port_security(self, v, load=False):
    """
    Setter method for port_security, mapped from YANG variable /devices/device/interfaces/interface/port_security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=port_security.port_security, is_container='container', yang_name="port-security", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=port_security.port_security, is_container='container', yang_name="port-security", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__port_security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_security(self):
    self.__port_security = YANGDynClass(base=port_security.port_security, is_container='container', yang_name="port-security", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_allowed_vlans(self):
    """
    Getter method for allowed_vlans, mapped from YANG variable /devices/device/interfaces/interface/allowed_vlans (container)
    """
    return self.__allowed_vlans
      
  def _set_allowed_vlans(self, v, load=False):
    """
    Setter method for allowed_vlans, mapped from YANG variable /devices/device/interfaces/interface/allowed_vlans (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allowed_vlans is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allowed_vlans() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=allowed_vlans.allowed_vlans, is_container='container', yang_name="allowed-vlans", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allowed_vlans must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=allowed_vlans.allowed_vlans, is_container='container', yang_name="allowed-vlans", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__allowed_vlans = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allowed_vlans(self):
    self.__allowed_vlans = YANGDynClass(base=allowed_vlans.allowed_vlans, is_container='container', yang_name="allowed-vlans", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_ospf(self):
    """
    Getter method for ospf, mapped from YANG variable /devices/device/interfaces/interface/ospf (container)
    """
    return self.__ospf
      
  def _set_ospf(self, v, load=False):
    """
    Setter method for ospf, mapped from YANG variable /devices/device/interfaces/interface/ospf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ospf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ospf() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ospf.ospf, is_container='container', yang_name="ospf", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ospf must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ospf.ospf, is_container='container', yang_name="ospf", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__ospf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ospf(self):
    self.__ospf = YANGDynClass(base=ospf.ospf, is_container='container', yang_name="ospf", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_eigrp(self):
    """
    Getter method for eigrp, mapped from YANG variable /devices/device/interfaces/interface/eigrp (container)
    """
    return self.__eigrp
      
  def _set_eigrp(self, v, load=False):
    """
    Setter method for eigrp, mapped from YANG variable /devices/device/interfaces/interface/eigrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eigrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eigrp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eigrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)""",
        })

    self.__eigrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eigrp(self):
    self.__eigrp = YANGDynClass(base=eigrp.eigrp, is_container='container', yang_name="eigrp", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='container', is_config=True)


  def _get_unit(self):
    """
    Getter method for unit, mapped from YANG variable /devices/device/interfaces/interface/unit (uint32)

    YANG Description: 0..4294967295
    """
    return self.__unit
      
  def _set_unit(self, v, load=False):
    """
    Setter method for unit, mapped from YANG variable /devices/device/interfaces/interface/unit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unit() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unit(self):
    self.__unit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_vlan_count(self):
    """
    Getter method for vlan_count, mapped from YANG variable /devices/device/interfaces/interface/vlan_count (int32)

    YANG Description: -2147483648..2147483647
    """
    return self.__vlan_count
      
  def _set_vlan_count(self, v, load=False):
    """
    Setter method for vlan_count, mapped from YANG variable /devices/device/interfaces/interface/vlan_count (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_count() directly.

    YANG Description: -2147483648..2147483647
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vlan-count", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_count must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vlan-count", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='int32', is_config=False)""",
        })

    self.__vlan_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_count(self):
    self.__vlan_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="vlan-count", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='int32', is_config=False)


  def _get_context_name(self):
    """
    Getter method for context_name, mapped from YANG variable /devices/device/interfaces/interface/context_name (string)

    YANG Description: string
    """
    return self.__context_name
      
  def _set_context_name(self, v, load=False):
    """
    Setter method for context_name, mapped from YANG variable /devices/device/interfaces/interface/context_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_context_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_context_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """context_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)""",
        })

    self.__context_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_context_name(self):
    self.__context_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)


  def _get_visible_interface(self):
    """
    Getter method for visible_interface, mapped from YANG variable /devices/device/interfaces/interface/visible_interface (string)

    YANG Description: string
    """
    return self.__visible_interface
      
  def _set_visible_interface(self, v, load=False):
    """
    Setter method for visible_interface, mapped from YANG variable /devices/device/interfaces/interface/visible_interface (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_visible_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_visible_interface() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="visible-interface", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """visible_interface must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__visible_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_visible_interface(self):
    self.__visible_interface = YANGDynClass(base=unicode, is_leaf=True, yang_name="visible-interface", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_inside_name(self):
    """
    Getter method for inside_name, mapped from YANG variable /devices/device/interfaces/interface/inside_name (string)

    YANG Description: string
    """
    return self.__inside_name
      
  def _set_inside_name(self, v, load=False):
    """
    Setter method for inside_name, mapped from YANG variable /devices/device/interfaces/interface/inside_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inside_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inside_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inside-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inside_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inside-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__inside_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inside_name(self):
    self.__inside_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="inside-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_security_level_inside(self):
    """
    Getter method for security_level_inside, mapped from YANG variable /devices/device/interfaces/interface/security_level_inside (uint32)

    YANG Description: 0..4294967295
    """
    return self.__security_level_inside
      
  def _set_security_level_inside(self, v, load=False):
    """
    Setter method for security_level_inside, mapped from YANG variable /devices/device/interfaces/interface/security_level_inside (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_level_inside is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_level_inside() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security_level_inside must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__security_level_inside = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security_level_inside(self):
    self.__security_level_inside = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="security-level-inside", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_mpls_device_role(self):
    """
    Getter method for mpls_device_role, mapped from YANG variable /devices/device/interfaces/interface/mpls_device_role (enumeration)

    YANG Description: PE
P
PE-RR
RR
None

    """
    return self.__mpls_device_role
      
  def _set_mpls_device_role(self, v, load=False):
    """
    Setter method for mpls_device_role, mapped from YANG variable /devices/device/interfaces/interface/mpls_device_role (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mpls_device_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mpls_device_role() directly.

    YANG Description: PE
P
PE-RR
RR
None

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'P': {}, u'None': {}, u'PE-RR': {}, u'RR': {}, u'PE': {}},), is_leaf=True, yang_name="mpls-device-role", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mpls_device_role must be of a type compatible with enumeration""",
          'defined-type': "interface:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'P': {}, u'None': {}, u'PE-RR': {}, u'RR': {}, u'PE': {}},), is_leaf=True, yang_name="mpls-device-role", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
        })

    self.__mpls_device_role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mpls_device_role(self):
    self.__mpls_device_role = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'P': {}, u'None': {}, u'PE-RR': {}, u'RR': {}, u'PE': {}},), is_leaf=True, yang_name="mpls-device-role", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='enumeration', is_config=True)


  def _get_inner_vlan(self):
    """
    Getter method for inner_vlan, mapped from YANG variable /devices/device/interfaces/interface/inner_vlan (string)

    YANG Description:  VLAN IDs e.g. 100,200-300,400,500-600 or 
any
    """
    return self.__inner_vlan
      
  def _set_inner_vlan(self, v, load=False):
    """
    Setter method for inner_vlan, mapped from YANG variable /devices/device/interfaces/interface/inner_vlan (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_vlan() directly.

    YANG Description:  VLAN IDs e.g. 100,200-300,400,500-600 or 
any
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inner-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_vlan must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inner-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__inner_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_vlan(self):
    self.__inner_vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="inner-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_outbound_qos(self):
    """
    Getter method for outbound_qos, mapped from YANG variable /devices/device/interfaces/interface/outbound_qos (string)

    YANG Description: string
    """
    return self.__outbound_qos
      
  def _set_outbound_qos(self, v, load=False):
    """
    Setter method for outbound_qos, mapped from YANG variable /devices/device/interfaces/interface/outbound_qos (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outbound_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outbound_qos() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="outbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outbound_qos must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__outbound_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outbound_qos(self):
    self.__outbound_qos = YANGDynClass(base=unicode, is_leaf=True, yang_name="outbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_inbound_qos(self):
    """
    Getter method for inbound_qos, mapped from YANG variable /devices/device/interfaces/interface/inbound_qos (string)

    YANG Description: string
    """
    return self.__inbound_qos
      
  def _set_inbound_qos(self, v, load=False):
    """
    Setter method for inbound_qos, mapped from YANG variable /devices/device/interfaces/interface/inbound_qos (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inbound_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inbound_qos() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="inbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inbound_qos must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__inbound_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inbound_qos(self):
    self.__inbound_qos = YANGDynClass(base=unicode, is_leaf=True, yang_name="inbound-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_load_interval_delay(self):
    """
    Getter method for load_interval_delay, mapped from YANG variable /devices/device/interfaces/interface/load_interval_delay (uint16)

    YANG Description: 0..65535
    """
    return self.__load_interval_delay
      
  def _set_load_interval_delay(self, v, load=False):
    """
    Setter method for load_interval_delay, mapped from YANG variable /devices/device/interfaces/interface/load_interval_delay (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_interval_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_interval_delay() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval-delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_interval_delay must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval-delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)""",
        })

    self.__load_interval_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_interval_delay(self):
    self.__load_interval_delay = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="load-interval-delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint16', is_config=True)


  def _get_bridge_group(self):
    """
    Getter method for bridge_group, mapped from YANG variable /devices/device/interfaces/interface/bridge_group (uint8)

    YANG Description: 0..255
    """
    return self.__bridge_group
      
  def _set_bridge_group(self, v, load=False):
    """
    Setter method for bridge_group, mapped from YANG variable /devices/device/interfaces/interface/bridge_group (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_group() directly.

    YANG Description: 0..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bridge-group", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_group must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bridge-group", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)""",
        })

    self.__bridge_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_group(self):
    self.__bridge_group = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="bridge-group", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint8', is_config=True)


  def _get_bridge_acl_inbound(self):
    """
    Getter method for bridge_acl_inbound, mapped from YANG variable /devices/device/interfaces/interface/bridge_acl_inbound (string)

    YANG Description: string
    """
    return self.__bridge_acl_inbound
      
  def _set_bridge_acl_inbound(self, v, load=False):
    """
    Setter method for bridge_acl_inbound, mapped from YANG variable /devices/device/interfaces/interface/bridge_acl_inbound (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bridge_acl_inbound is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bridge_acl_inbound() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bridge-acl-inbound", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bridge_acl_inbound must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bridge-acl-inbound", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__bridge_acl_inbound = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bridge_acl_inbound(self):
    self.__bridge_acl_inbound = YANGDynClass(base=unicode, is_leaf=True, yang_name="bridge-acl-inbound", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_in_queue_length(self):
    """
    Getter method for in_queue_length, mapped from YANG variable /devices/device/interfaces/interface/in_queue_length (uint32)

    YANG Description: 0..4294967295
    """
    return self.__in_queue_length
      
  def _set_in_queue_length(self, v, load=False):
    """
    Setter method for in_queue_length, mapped from YANG variable /devices/device/interfaces/interface/in_queue_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_queue_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_queue_length() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_queue_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__in_queue_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_queue_length(self):
    self.__in_queue_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_out_queue_length(self):
    """
    Getter method for out_queue_length, mapped from YANG variable /devices/device/interfaces/interface/out_queue_length (uint32)

    YANG Description: 0..4294967295
    """
    return self.__out_queue_length
      
  def _set_out_queue_length(self, v, load=False):
    """
    Setter method for out_queue_length, mapped from YANG variable /devices/device/interfaces/interface/out_queue_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_queue_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_queue_length() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_queue_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__out_queue_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_queue_length(self):
    self.__out_queue_length = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-queue-length", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_link_negotiation(self):
    """
    Getter method for link_negotiation, mapped from YANG variable /devices/device/interfaces/interface/link_negotiation (string)

    YANG Description: string
    """
    return self.__link_negotiation
      
  def _set_link_negotiation(self, v, load=False):
    """
    Setter method for link_negotiation, mapped from YANG variable /devices/device/interfaces/interface/link_negotiation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_negotiation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_negotiation() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="link-negotiation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_negotiation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="link-negotiation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__link_negotiation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_negotiation(self):
    self.__link_negotiation = YANGDynClass(base=unicode, is_leaf=True, yang_name="link-negotiation", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_vrf_receive(self):
    """
    Getter method for vrf_receive, mapped from YANG variable /devices/device/interfaces/interface/vrf_receive (string)

    YANG Description: string
    """
    return self.__vrf_receive
      
  def _set_vrf_receive(self, v, load=False):
    """
    Setter method for vrf_receive, mapped from YANG variable /devices/device/interfaces/interface/vrf_receive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_receive() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vrf-receive", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_receive must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-receive", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__vrf_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_receive(self):
    self.__vrf_receive = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf-receive", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_bgp_policy(self):
    """
    Getter method for bgp_policy, mapped from YANG variable /devices/device/interfaces/interface/bgp_policy (boolean)

    YANG Description: bgp-policy: True/False
    """
    return self.__bgp_policy
      
  def _set_bgp_policy(self, v, load=False):
    """
    Setter method for bgp_policy, mapped from YANG variable /devices/device/interfaces/interface/bgp_policy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_policy() directly.

    YANG Description: bgp-policy: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bgp-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_policy must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__bgp_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_policy(self):
    self.__bgp_policy = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_bgp_policy_qos(self):
    """
    Getter method for bgp_policy_qos, mapped from YANG variable /devices/device/interfaces/interface/bgp_policy_qos (boolean)

    YANG Description: bgp-policy-qos: True/False
    """
    return self.__bgp_policy_qos
      
  def _set_bgp_policy_qos(self, v, load=False):
    """
    Setter method for bgp_policy_qos, mapped from YANG variable /devices/device/interfaces/interface/bgp_policy_qos (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_policy_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_policy_qos() directly.

    YANG Description: bgp-policy-qos: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="bgp-policy-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_policy_qos must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp-policy-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__bgp_policy_qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_policy_qos(self):
    self.__bgp_policy_qos = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="bgp-policy-qos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_pbr_policy(self):
    """
    Getter method for pbr_policy, mapped from YANG variable /devices/device/interfaces/interface/pbr_policy (string)

    YANG Description: string
    """
    return self.__pbr_policy
      
  def _set_pbr_policy(self, v, load=False):
    """
    Setter method for pbr_policy, mapped from YANG variable /devices/device/interfaces/interface/pbr_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pbr_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pbr_policy() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="pbr-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pbr_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="pbr-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__pbr_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pbr_policy(self):
    self.__pbr_policy = YANGDynClass(base=unicode, is_leaf=True, yang_name="pbr-policy", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_vrf_definition_mode(self):
    """
    Getter method for vrf_definition_mode, mapped from YANG variable /devices/device/interfaces/interface/vrf_definition_mode (boolean)

    YANG Description: vrf-definition-mode: True/False
    """
    return self.__vrf_definition_mode
      
  def _set_vrf_definition_mode(self, v, load=False):
    """
    Setter method for vrf_definition_mode, mapped from YANG variable /devices/device/interfaces/interface/vrf_definition_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_definition_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_definition_mode() directly.

    YANG Description: vrf-definition-mode: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_definition_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__vrf_definition_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_definition_mode(self):
    self.__vrf_definition_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vrf-definition-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_encap_mode(self):
    """
    Getter method for encap_mode, mapped from YANG variable /devices/device/interfaces/interface/encap_mode (string)

    YANG Description: string
    """
    return self.__encap_mode
      
  def _set_encap_mode(self, v, load=False):
    """
    Setter method for encap_mode, mapped from YANG variable /devices/device/interfaces/interface/encap_mode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encap_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encap_mode() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="encap-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encap_mode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="encap-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__encap_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encap_mode(self):
    self.__encap_mode = YANGDynClass(base=unicode, is_leaf=True, yang_name="encap-mode", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_port_number(self):
    """
    Getter method for port_number, mapped from YANG variable /devices/device/interfaces/interface/port_number (uint32)

    YANG Description: 0..4294967295
    """
    return self.__port_number
      
  def _set_port_number(self, v, load=False):
    """
    Setter method for port_number, mapped from YANG variable /devices/device/interfaces/interface/port_number (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_number() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="port-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_number must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="port-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__port_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_number(self):
    self.__port_number = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="port-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_mgmt_profile(self):
    """
    Getter method for mgmt_profile, mapped from YANG variable /devices/device/interfaces/interface/mgmt_profile (string)

    YANG Description: string
    """
    return self.__mgmt_profile
      
  def _set_mgmt_profile(self, v, load=False):
    """
    Setter method for mgmt_profile, mapped from YANG variable /devices/device/interfaces/interface/mgmt_profile (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_profile() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mgmt-profile", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_profile must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mgmt-profile", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__mgmt_profile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_profile(self):
    self.__mgmt_profile = YANGDynClass(base=unicode, is_leaf=True, yang_name="mgmt-profile", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_address1_comment(self):
    """
    Getter method for address1_comment, mapped from YANG variable /devices/device/interfaces/interface/address1_comment (string)

    YANG Description: string
    """
    return self.__address1_comment
      
  def _set_address1_comment(self, v, load=False):
    """
    Setter method for address1_comment, mapped from YANG variable /devices/device/interfaces/interface/address1_comment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address1_comment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address1_comment() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="address1-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address1_comment must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="address1-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__address1_comment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address1_comment(self):
    self.__address1_comment = YANGDynClass(base=unicode, is_leaf=True, yang_name="address1-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_address2_comment(self):
    """
    Getter method for address2_comment, mapped from YANG variable /devices/device/interfaces/interface/address2_comment (string)

    YANG Description: string
    """
    return self.__address2_comment
      
  def _set_address2_comment(self, v, load=False):
    """
    Setter method for address2_comment, mapped from YANG variable /devices/device/interfaces/interface/address2_comment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address2_comment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address2_comment() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="address2-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address2_comment must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="address2-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__address2_comment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address2_comment(self):
    self.__address2_comment = YANGDynClass(base=unicode, is_leaf=True, yang_name="address2-comment", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_rpf_check(self):
    """
    Getter method for rpf_check, mapped from YANG variable /devices/device/interfaces/interface/rpf_check (boolean)

    YANG Description: rpf-check: True/False
    """
    return self.__rpf_check
      
  def _set_rpf_check(self, v, load=False):
    """
    Setter method for rpf_check, mapped from YANG variable /devices/device/interfaces/interface/rpf_check (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rpf_check is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rpf_check() directly.

    YANG Description: rpf-check: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="rpf-check", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rpf_check must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rpf-check", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__rpf_check = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rpf_check(self):
    self.__rpf_check = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rpf-check", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_postscrub_unit(self):
    """
    Getter method for postscrub_unit, mapped from YANG variable /devices/device/interfaces/interface/postscrub_unit (uint32)

    YANG Description: 0..4294967295
    """
    return self.__postscrub_unit
      
  def _set_postscrub_unit(self, v, load=False):
    """
    Setter method for postscrub_unit, mapped from YANG variable /devices/device/interfaces/interface/postscrub_unit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_postscrub_unit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_postscrub_unit() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="postscrub-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """postscrub_unit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="postscrub-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__postscrub_unit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_postscrub_unit(self):
    self.__postscrub_unit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="postscrub-unit", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_keepalive_time(self):
    """
    Getter method for keepalive_time, mapped from YANG variable /devices/device/interfaces/interface/keepalive_time (uint32)

    YANG Description: 0..4294967295
    """
    return self.__keepalive_time
      
  def _set_keepalive_time(self, v, load=False):
    """
    Setter method for keepalive_time, mapped from YANG variable /devices/device/interfaces/interface/keepalive_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepalive_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepalive_time() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-time", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepalive_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-time", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__keepalive_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepalive_time(self):
    self.__keepalive_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="keepalive-time", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_virtual_ethernet_number(self):
    """
    Getter method for virtual_ethernet_number, mapped from YANG variable /devices/device/interfaces/interface/virtual_ethernet_number (string)

    YANG Description: string
    """
    return self.__virtual_ethernet_number
      
  def _set_virtual_ethernet_number(self, v, load=False):
    """
    Setter method for virtual_ethernet_number, mapped from YANG variable /devices/device/interfaces/interface/virtual_ethernet_number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_ethernet_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_ethernet_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="virtual-ethernet-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_ethernet_number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-ethernet-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__virtual_ethernet_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_ethernet_number(self):
    self.__virtual_ethernet_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="virtual-ethernet-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_ethernet_number_vpls(self):
    """
    Getter method for ethernet_number_vpls, mapped from YANG variable /devices/device/interfaces/interface/ethernet_number_vpls (string)

    YANG Description: string
    """
    return self.__ethernet_number_vpls
      
  def _set_ethernet_number_vpls(self, v, load=False):
    """
    Setter method for ethernet_number_vpls, mapped from YANG variable /devices/device/interfaces/interface/ethernet_number_vpls (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_number_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_number_vpls() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="ethernet-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_number_vpls must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ethernet-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__ethernet_number_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_number_vpls(self):
    self.__ethernet_number_vpls = YANGDynClass(base=unicode, is_leaf=True, yang_name="ethernet-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_cos(self):
    """
    Getter method for cos, mapped from YANG variable /devices/device/interfaces/interface/cos (string)

    YANG Description: string
    """
    return self.__cos
      
  def _set_cos(self, v, load=False):
    """
    Setter method for cos, mapped from YANG variable /devices/device/interfaces/interface/cos (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cos() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="cos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cos must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__cos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cos(self):
    self.__cos = YANGDynClass(base=unicode, is_leaf=True, yang_name="cos", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_port_number_vpls(self):
    """
    Getter method for port_number_vpls, mapped from YANG variable /devices/device/interfaces/interface/port_number_vpls (string)

    YANG Description: string
    """
    return self.__port_number_vpls
      
  def _set_port_number_vpls(self, v, load=False):
    """
    Setter method for port_number_vpls, mapped from YANG variable /devices/device/interfaces/interface/port_number_vpls (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_number_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_number_vpls() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_number_vpls must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__port_number_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_number_vpls(self):
    self.__port_number_vpls = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-number-vpls", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_slot_number(self):
    """
    Getter method for slot_number, mapped from YANG variable /devices/device/interfaces/interface/slot_number (string)

    YANG Description: string
    """
    return self.__slot_number
      
  def _set_slot_number(self, v, load=False):
    """
    Setter method for slot_number, mapped from YANG variable /devices/device/interfaces/interface/slot_number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot_number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__slot_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot_number(self):
    self.__slot_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_full_slot_number(self):
    """
    Getter method for full_slot_number, mapped from YANG variable /devices/device/interfaces/interface/full_slot_number (string)

    YANG Description: string
    """
    return self.__full_slot_number
      
  def _set_full_slot_number(self, v, load=False):
    """
    Setter method for full_slot_number, mapped from YANG variable /devices/device/interfaces/interface/full_slot_number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_full_slot_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_full_slot_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="full-slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """full_slot_number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="full-slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__full_slot_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_full_slot_number(self):
    self.__full_slot_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="full-slot-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_slot_module_number(self):
    """
    Getter method for slot_module_number, mapped from YANG variable /devices/device/interfaces/interface/slot_module_number (string)

    YANG Description: string
    """
    return self.__slot_module_number
      
  def _set_slot_module_number(self, v, load=False):
    """
    Setter method for slot_module_number, mapped from YANG variable /devices/device/interfaces/interface/slot_module_number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot_module_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot_module_number() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="slot-module-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot_module_number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="slot-module-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__slot_module_number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot_module_number(self):
    self.__slot_module_number = YANGDynClass(base=unicode, is_leaf=True, yang_name="slot-module-number", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_vpn_instance_name(self):
    """
    Getter method for vpn_instance_name, mapped from YANG variable /devices/device/interfaces/interface/vpn_instance_name (string)

    YANG Description: string
    """
    return self.__vpn_instance_name
      
  def _set_vpn_instance_name(self, v, load=False):
    """
    Setter method for vpn_instance_name, mapped from YANG variable /devices/device/interfaces/interface/vpn_instance_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_instance_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_instance_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vpn-instance-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_instance_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vpn-instance-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__vpn_instance_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_instance_name(self):
    self.__vpn_instance_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpn-instance-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_vsi_vlan_name(self):
    """
    Getter method for vsi_vlan_name, mapped from YANG variable /devices/device/interfaces/interface/vsi_vlan_name (string)

    YANG Description: string
    """
    return self.__vsi_vlan_name
      
  def _set_vsi_vlan_name(self, v, load=False):
    """
    Setter method for vsi_vlan_name, mapped from YANG variable /devices/device/interfaces/interface/vsi_vlan_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vsi_vlan_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vsi_vlan_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vsi-vlan-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vsi_vlan_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vsi-vlan-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__vsi_vlan_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vsi_vlan_name(self):
    self.__vsi_vlan_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vsi-vlan-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_port_type(self):
    """
    Getter method for port_type, mapped from YANG variable /devices/device/interfaces/interface/port_type (rnc-type)

    YANG Description: EXTERNAL_TO_PUBLIC
EXTERNAL_TO_MPLS
MANAGEMENT
UPLINK
DOWNLINK
OTHER
PEER
SERVICELINK
WANINTERFACE
ACCESS
TRUNK
VOICE

    """
    return self.__port_type
      
  def _set_port_type(self, v, load=False):
    """
    Setter method for port_type, mapped from YANG variable /devices/device/interfaces/interface/port_type (rnc-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_type() directly.

    YANG Description: EXTERNAL_TO_PUBLIC
EXTERNAL_TO_MPLS
MANAGEMENT
UPLINK
DOWNLINK
OTHER
PEER
SERVICELINK
WANINTERFACE
ACCESS
TRUNK
VOICE

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'MANAGEMENT': {}, u'SERVICELINK': {}, u'WANINTERFACE': {}, u'DOWNLINK': {}, u'OTHER': {}, u'ACCESS': {}, u'EXTERNAL_TO_PUBLIC': {}, u'TRUNK': {}, u'PEER': {}, u'EXTERNAL_TO_MPLS': {}, u'VOICE': {}, u'UPLINK': {}},), is_leaf=True, yang_name="port-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='rnc-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_type must be of a type compatible with rnc-type""",
          'defined-type': "interface:rnc-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'MANAGEMENT': {}, u'SERVICELINK': {}, u'WANINTERFACE': {}, u'DOWNLINK': {}, u'OTHER': {}, u'ACCESS': {}, u'EXTERNAL_TO_PUBLIC': {}, u'TRUNK': {}, u'PEER': {}, u'EXTERNAL_TO_MPLS': {}, u'VOICE': {}, u'UPLINK': {}},), is_leaf=True, yang_name="port-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='rnc-type', is_config=True)""",
        })

    self.__port_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_type(self):
    self.__port_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'MANAGEMENT': {}, u'SERVICELINK': {}, u'WANINTERFACE': {}, u'DOWNLINK': {}, u'OTHER': {}, u'ACCESS': {}, u'EXTERNAL_TO_PUBLIC': {}, u'TRUNK': {}, u'PEER': {}, u'EXTERNAL_TO_MPLS': {}, u'VOICE': {}, u'UPLINK': {}},), is_leaf=True, yang_name="port-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='rnc-type', is_config=True)


  def _get_if_type(self):
    """
    Getter method for if_type, mapped from YANG variable /devices/device/interfaces/interface/if_type (ift:if-type)

    YANG Description: other
regular1822
hdh1822
ddnX25
rfc877x25
ethernetCsmacd
iso88023Csmacd
iso88024TokenBus
iso88025TokenRing
iso88026Man
starLan
proteon10Mbit
proteon80Mbit
hyperchannel
fddi
lapb
sdlc
ds1
e1
basicISDN
primaryISDN
propPointToPointSerial
ppp
softwareLoopback
eon
ethernet3Mbit
nsip
slip
ultra
ds3
sip
frameRelay
rs232
para
arcnet
arcnetPlus
atm
miox25
sonet
x25ple
iso88022llc
localTalk
smdsDxi
frameRelayService
v35
hssi
hippi
modem
aal5
sonetPath
sonetVT
smdsIcip
propVirtual
propMultiplexor
ieee80212
fibreChannel
hippiInterface
frameRelayInterconnect
aflane8023
aflane8025
cctEmul
fastEther
isdn
v11
v36
g703at64k
g703at2mb
qllc
fastEtherFX
channel
ieee80211
ibm370parChan
escon
dlsw
isdns
isdnu
lapd
ipSwitch
rsrb
atmLogical
ds0
ds0Bundle
bsc
async
cnr
iso88025Dtr
eplrs
arap
propCnls
hostPad
termPad
frameRelayMPI
x213
adsl
radsl
sdsl
vdsl
iso88025CRFPInt
myrinet
voiceEM
voiceFXO
voiceFXS
voiceEncap
voiceOverIp
atmDxi
atmFuni
atmIma
pppMultilinkBundle
ipOverCdlc
ipOverClaw
stackToStack
virtualIpAddress
mpc
ipOverAtm
iso88025Fiber
tdlc
gigabitEthernet
hdlc
lapf
v37
x25mlp
x25huntGroup
transpHdlc
interleave
fast
ip
docsCableMaclayer
docsCableDownstream
docsCableUpstream
a12MppSwitch
tunnel
coffee
ces
atmSubInterface
l2vlan
l3ipvlan
l3ipxvlan
digitalPowerline
mediaMailOverIp
dtm
dcn
ipForward
msdsl
ieee1394
if-gsn
dvbRccMacLayer
dvbRccDownstream
dvbRccUpstream
atmVirtual
mplsTunnel
srp
voiceOverAtm
voiceOverFrameRelay
idsl
compositeLink
ss7SigLink
propWirelessP2P
frForward
rfc1483
usb
ieee8023adLag
bgppolicyaccounting
frf16MfrBundle
h323Gatekeeper
h323Proxy
mpls
mfSigLink
hdsl2
shdsl
ds1FDL
pos
dvbAsiIn
dvbAsiOut
plc
nfas
tr008
gr303RDT
gr303IDT
isup
propDocsWirelessMaclayer
propDocsWirelessDownstream
propDocsWirelessUpstream
hiperlan2
propBWAp2Mp
sonetOverheadChannel
digitalWrapperOverheadChannel
aal2
radioMAC
atmRadio
imt
mvl
reachDSL
frDlciEndPt
atmVciEndPt
opticalChannel
opticalTransport
propAtm
voiceOverCable
infiniband
teLink
q2931
virtualTg
sipTg
sipSig
docsCableUpstreamChannel
econet
pon155
pon622
bridge
linegroup
voiceEMFGD
voiceFGDEANA
voiceDID
mpegTransport
sixToFour
gtp
pdnEtherLoop1
pdnEtherLoop2
opticalChannelGroup
homepna
gfp
ciscoISLvlan
actelisMetaLOOP
fcipLink
rpr
qam
lmp
cblVectaStar
docsCableMCmtsDownstream
adsl2
macSecControlledIF
macSecUncontrolledIF
aviciOpticalEther
atmbond
voiceFGDOS
mocaVersion1
ieee80216WMAN
adsl2plus
dvbRcsMacLayer
dvbTdm
dvbRcsTdma
x86Laps
wwanPP
wwanPP2
voiceEBS
ifPwType
ilan
pip
aluELP
gpon
vdsl2
capwapDot11Profile
capwapDot11Bss
capwapWtpVirtualRadio
bits
docsCableUpstreamRfPort
cableDownstreamRfPort
vmwareVirtualNic
ieee802154
otnOdu
otnOtu
ifVfiType
g9981
g9982
g9983
aluEpon
aluEponOnu
aluEponPhysicalUni
aluEponLogicalLink
aluGponOnu
aluGponPhysicalUni
vmwareNicTeam
docsOfdmDownstream
docsOfdmaUpstream
gfast
sdci
xboxWireless
fastdsl

    """
    return self.__if_type
      
  def _set_if_type(self, v, load=False):
    """
    Setter method for if_type, mapped from YANG variable /devices/device/interfaces/interface/if_type (ift:if-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_if_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_if_type() directly.

    YANG Description: other
regular1822
hdh1822
ddnX25
rfc877x25
ethernetCsmacd
iso88023Csmacd
iso88024TokenBus
iso88025TokenRing
iso88026Man
starLan
proteon10Mbit
proteon80Mbit
hyperchannel
fddi
lapb
sdlc
ds1
e1
basicISDN
primaryISDN
propPointToPointSerial
ppp
softwareLoopback
eon
ethernet3Mbit
nsip
slip
ultra
ds3
sip
frameRelay
rs232
para
arcnet
arcnetPlus
atm
miox25
sonet
x25ple
iso88022llc
localTalk
smdsDxi
frameRelayService
v35
hssi
hippi
modem
aal5
sonetPath
sonetVT
smdsIcip
propVirtual
propMultiplexor
ieee80212
fibreChannel
hippiInterface
frameRelayInterconnect
aflane8023
aflane8025
cctEmul
fastEther
isdn
v11
v36
g703at64k
g703at2mb
qllc
fastEtherFX
channel
ieee80211
ibm370parChan
escon
dlsw
isdns
isdnu
lapd
ipSwitch
rsrb
atmLogical
ds0
ds0Bundle
bsc
async
cnr
iso88025Dtr
eplrs
arap
propCnls
hostPad
termPad
frameRelayMPI
x213
adsl
radsl
sdsl
vdsl
iso88025CRFPInt
myrinet
voiceEM
voiceFXO
voiceFXS
voiceEncap
voiceOverIp
atmDxi
atmFuni
atmIma
pppMultilinkBundle
ipOverCdlc
ipOverClaw
stackToStack
virtualIpAddress
mpc
ipOverAtm
iso88025Fiber
tdlc
gigabitEthernet
hdlc
lapf
v37
x25mlp
x25huntGroup
transpHdlc
interleave
fast
ip
docsCableMaclayer
docsCableDownstream
docsCableUpstream
a12MppSwitch
tunnel
coffee
ces
atmSubInterface
l2vlan
l3ipvlan
l3ipxvlan
digitalPowerline
mediaMailOverIp
dtm
dcn
ipForward
msdsl
ieee1394
if-gsn
dvbRccMacLayer
dvbRccDownstream
dvbRccUpstream
atmVirtual
mplsTunnel
srp
voiceOverAtm
voiceOverFrameRelay
idsl
compositeLink
ss7SigLink
propWirelessP2P
frForward
rfc1483
usb
ieee8023adLag
bgppolicyaccounting
frf16MfrBundle
h323Gatekeeper
h323Proxy
mpls
mfSigLink
hdsl2
shdsl
ds1FDL
pos
dvbAsiIn
dvbAsiOut
plc
nfas
tr008
gr303RDT
gr303IDT
isup
propDocsWirelessMaclayer
propDocsWirelessDownstream
propDocsWirelessUpstream
hiperlan2
propBWAp2Mp
sonetOverheadChannel
digitalWrapperOverheadChannel
aal2
radioMAC
atmRadio
imt
mvl
reachDSL
frDlciEndPt
atmVciEndPt
opticalChannel
opticalTransport
propAtm
voiceOverCable
infiniband
teLink
q2931
virtualTg
sipTg
sipSig
docsCableUpstreamChannel
econet
pon155
pon622
bridge
linegroup
voiceEMFGD
voiceFGDEANA
voiceDID
mpegTransport
sixToFour
gtp
pdnEtherLoop1
pdnEtherLoop2
opticalChannelGroup
homepna
gfp
ciscoISLvlan
actelisMetaLOOP
fcipLink
rpr
qam
lmp
cblVectaStar
docsCableMCmtsDownstream
adsl2
macSecControlledIF
macSecUncontrolledIF
aviciOpticalEther
atmbond
voiceFGDOS
mocaVersion1
ieee80216WMAN
adsl2plus
dvbRcsMacLayer
dvbTdm
dvbRcsTdma
x86Laps
wwanPP
wwanPP2
voiceEBS
ifPwType
ilan
pip
aluELP
gpon
vdsl2
capwapDot11Profile
capwapDot11Bss
capwapWtpVirtualRadio
bits
docsCableUpstreamRfPort
cableDownstreamRfPort
vmwareVirtualNic
ieee802154
otnOdu
otnOtu
ifVfiType
g9981
g9982
g9983
aluEpon
aluEponOnu
aluEponPhysicalUni
aluEponLogicalLink
aluGponOnu
aluGponPhysicalUni
vmwareNicTeam
docsOfdmDownstream
docsOfdmaUpstream
gfast
sdci
xboxWireless
fastdsl

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'voiceFXO': {'value': 101}, u'atmVciEndPt': {'value': 194}, u'propBWAp2Mp': {'value': 184}, u'propDocsWirelessDownstream': {'value': 181}, u'v11': {'value': 64}, u'softwareLoopback': {'value': 24}, u'hdlc': {'value': 118}, u'voiceFGDOS': {'value': 235}, u'fastEtherFX': {'value': 69}, u'dvbTdm': {'value': 240}, u'nfas': {'value': 175}, u'ifPwType': {'value': 246}, u'l2vlan': {'value': 135}, u'adsl2plus': {'value': 238}, u'ieee802154': {'value': 259}, u'voiceFXS': {'value': 102}, u'dvbRcsMacLayer': {'value': 239}, u'idsl': {'value': 154}, u'infiniband': {'value': 199}, u'ddnX25': {'value': 4}, u'wwanPP2': {'value': 244}, u'docsCableUpstream': {'value': 129}, u'ethernet3Mbit': {'value': 26}, u'digitalPowerline': {'value': 138}, u'h323Proxy': {'value': 165}, u'gtp': {'value': 216}, u'ipOverAtm': {'value': 114}, u'aluEpon': {'value': 266}, u'imt': {'value': 190}, u'ipSwitch': {'value': 78}, u'msdsl': {'value': 143}, u'dvbRccMacLayer': {'value': 146}, u'smdsDxi': {'value': 43}, u'voiceOverAtm': {'value': 152}, u'arap': {'value': 88}, u'fastEther': {'value': 62}, u'mpc': {'value': 113}, u'linegroup': {'value': 210}, u'hippi': {'value': 47}, u'rpr': {'value': 225}, u'ds1FDL': {'value': 170}, u'sonetVT': {'value': 51}, u'aluGponPhysicalUni': {'value': 271}, u'ss7SigLink': {'value': 156}, u'arcnet': {'value': 35}, u'actelisMetaLOOP': {'value': 223}, u'qllc': {'value': 68}, u'rfc877x25': {'value': 5}, u'mpegTransport': {'value': 214}, u'x25mlp': {'value': 121}, u'virtualTg': {'value': 202}, u'hostPad': {'value': 90}, u'starLan': {'value': 11}, u'iso88025Dtr': {'value': 86}, u'ibm370parChan': {'value': 72}, u'adsl2': {'value': 230}, u'otnOtu': {'value': 261}, u'propWirelessP2P': {'value': 157}, u'interleave': {'value': 124}, u'isup': {'value': 179}, u'regular1822': {'value': 2}, u'gr303RDT': {'value': 177}, u'propDocsWirelessMaclayer': {'value': 180}, u'async': {'value': 84}, u'radioMAC': {'value': 188}, u'opticalChannelGroup': {'value': 219}, u'sixToFour': {'value': 215}, u'propDocsWirelessUpstream': {'value': 182}, u'q2931': {'value': 201}, u'fddi': {'value': 15}, u'propCnls': {'value': 89}, u'aal2': {'value': 187}, u'dvbAsiOut': {'value': 173}, u'aluELP': {'value': 249}, u'ciscoISLvlan': {'value': 222}, u'docsCableUpstreamRfPort': {'value': 256}, u'aal5': {'value': 49}, u'frDlciEndPt': {'value': 193}, u'hippiInterface': {'value': 57}, u'l3ipvlan': {'value': 136}, u'miox25': {'value': 38}, u'hssi': {'value': 46}, u'fastdsl': {'value': 282}, u'atmVirtual': {'value': 149}, u'aluGponOnu': {'value': 270}, u'rfc1483': {'value': 159}, u'cnr': {'value': 85}, u'sipSig': {'value': 204}, u'myrinet': {'value': 99}, u'dlsw': {'value': 74}, u'gigabitEthernet': {'value': 117}, u'x25ple': {'value': 40}, u'lmp': {'value': 227}, u'opticalTransport': {'value': 196}, u'sdlc': {'value': 17}, u'voiceEM': {'value': 100}, u'x86Laps': {'value': 242}, u'g9982': {'value': 264}, u'iso88022llc': {'value': 41}, u'dvbAsiIn': {'value': 172}, u'bgppolicyaccounting': {'value': 162}, u'aluEponOnu': {'value': 267}, u'mfSigLink': {'value': 167}, u'dcn': {'value': 141}, u'atmDxi': {'value': 105}, u'voiceOverFrameRelay': {'value': 153}, u'gfp': {'value': 221}, u'sonetOverheadChannel': {'value': 185}, u'vmwareVirtualNic': {'value': 258}, u'fcipLink': {'value': 224}, u'ipOverClaw': {'value': 110}, u'coffee': {'value': 132}, u'radsl': {'value': 95}, u'gfast': {'value': 279}, u'vdsl2': {'value': 251}, u'rs232': {'value': 33}, u'e1': {'value': 19}, u'reachDSL': {'value': 192}, u'xboxWireless': {'value': 281}, u'voiceOverCable': {'value': 198}, u'tr008': {'value': 176}, u'voiceOverIp': {'value': 104}, u'atm': {'value': 37}, u'ds3': {'value': 30}, u'ds0': {'value': 81}, u'ds1': {'value': 18}, u'srp': {'value': 151}, u'docsCableDownstream': {'value': 128}, u'dvbRcsTdma': {'value': 241}, u'g9983': {'value': 265}, u'plc': {'value': 174}, u'frameRelayMPI': {'value': 92}, u'mvl': {'value': 191}, u'propMultiplexor': {'value': 54}, u'voiceDID': {'value': 213}, u'compositeLink': {'value': 155}, u'proteon10Mbit': {'value': 12}, u'atmbond': {'value': 234}, u'frf16MfrBundle': {'value': 163}, u'cctEmul': {'value': 61}, u'mplsTunnel': {'value': 150}, u'gpon': {'value': 250}, u'vdsl': {'value': 97}, u'pos': {'value': 171}, u'ieee8023adLag': {'value': 161}, u'docsCableMaclayer': {'value': 127}, u'docsCableMCmtsDownstream': {'value': 229}, u'ppp': {'value': 23}, u'frameRelay': {'value': 32}, u'eplrs': {'value': 87}, u'vmwareNicTeam': {'value': 272}, u'cableDownstreamRfPort': {'value': 257}, u'macSecUncontrolledIF': {'value': 232}, u'iso88023Csmacd': {'value': 7}, u'usb': {'value': 160}, u'atmFuni': {'value': 106}, u'teLink': {'value': 200}, u'pon622': {'value': 208}, u'econet': {'value': 206}, u'tdlc': {'value': 116}, u'ds0Bundle': {'value': 82}, u'fast': {'value': 125}, u'ieee1394': {'value': 144}, u'cblVectaStar': {'value': 228}, u'rsrb': {'value': 79}, u'frameRelayInterconnect': {'value': 58}, u'isdns': {'value': 75}, u'pppMultilinkBundle': {'value': 108}, u'aflane8025': {'value': 60}, u'lapb': {'value': 16}, u'aflane8023': {'value': 59}, u'lapd': {'value': 77}, u'isdnu': {'value': 76}, u'lapf': {'value': 119}, u'capwapWtpVirtualRadio': {'value': 254}, u'ifVfiType': {'value': 262}, u'x25huntGroup': {'value': 122}, u'para': {'value': 34}, u'macSecControlledIF': {'value': 231}, u'iso88024TokenBus': {'value': 8}, u'localTalk': {'value': 42}, u'hyperchannel': {'value': 14}, u'mediaMailOverIp': {'value': 139}, u'if-gsn': {'value': 145}, u'capwapDot11Profile': {'value': 252}, u'l3ipxvlan': {'value': 137}, u'atmSubInterface': {'value': 134}, u'primaryISDN': {'value': 21}, u'proteon80Mbit': {'value': 13}, u'iso88026Man': {'value': 10}, u'digitalWrapperOverheadChannel': {'value': 186}, u'docsCableUpstreamChannel': {'value': 205}, u'opticalChannel': {'value': 195}, u'ethernetCsmacd': {'value': 6}, u'bits': {'value': 255}, u'tunnel': {'value': 131}, u'hdsl2': {'value': 168}, u'frameRelayService': {'value': 44}, u'mpls': {'value': 166}, u'ieee80211': {'value': 71}, u'ieee80212': {'value': 55}, u'mocaVersion1': {'value': 236}, u'sonet': {'value': 39}, u'escon': {'value': 73}, u'aluEponLogicalLink': {'value': 269}, u'g703at2mb': {'value': 67}, u'ultra': {'value': 29}, u'dvbRccDownstream': {'value': 147}, u'sipTg': {'value': 203}, u'smdsIcip': {'value': 52}, u'bridge': {'value': 209}, u'atmLogical': {'value': 80}, u'propPointToPointSerial': {'value': 22}, u'v35': {'value': 45}, u'v36': {'value': 65}, u'v37': {'value': 120}, u'ip': {'value': 126}, u'gr303IDT': {'value': 178}, u'basicISDN': {'value': 20}, u'g703at64k': {'value': 66}, u'arcnetPlus': {'value': 36}, u'pip': {'value': 248}, u'dtm': {'value': 140}, u'slip': {'value': 28}, u'hiperlan2': {'value': 183}, u'adsl': {'value': 94}, u'ieee80216WMAN': {'value': 237}, u'atmIma': {'value': 107}, u'isdn': {'value': 63}, u'capwapDot11Bss': {'value': 253}, u'sip': {'value': 31}, u'pdnEtherLoop2': {'value': 218}, u'voiceEBS': {'value': 245}, u'ipForward': {'value': 142}, u'iso88025CRFPInt': {'value': 98}, u'propVirtual': {'value': 53}, u'wwanPP': {'value': 243}, u'docsOfdmaUpstream': {'value': 278}, u'other': {'value': 1}, u'pon155': {'value': 207}, u'voiceEncap': {'value': 103}, u'qam': {'value': 226}, u'otnOdu': {'value': 260}, u'iso88025Fiber': {'value': 115}, u'channel': {'value': 70}, u'voiceEMFGD': {'value': 211}, u'sdci': {'value': 280}, u'a12MppSwitch': {'value': 130}, u'ilan': {'value': 247}, u'pdnEtherLoop1': {'value': 217}, u'x213': {'value': 93}, u'sonetPath': {'value': 50}, u'voiceFGDEANA': {'value': 212}, u'iso88025TokenRing': {'value': 9}, u'propAtm': {'value': 197}, u'aluEponPhysicalUni': {'value': 268}, u'stackToStack': {'value': 111}, u'frForward': {'value': 158}, u'homepna': {'value': 220}, u'sdsl': {'value': 96}, u'virtualIpAddress': {'value': 112}, u'bsc': {'value': 83}, u'atmRadio': {'value': 189}, u'aviciOpticalEther': {'value': 233}, u'g9981': {'value': 263}, u'docsOfdmDownstream': {'value': 277}, u'fibreChannel': {'value': 56}, u'shdsl': {'value': 169}, u'eon': {'value': 25}, u'h323Gatekeeper': {'value': 164}, u'hdh1822': {'value': 3}, u'dvbRccUpstream': {'value': 148}, u'nsip': {'value': 27}, u'transpHdlc': {'value': 123}, u'termPad': {'value': 91}, u'ipOverCdlc': {'value': 109}, u'ces': {'value': 133}, u'modem': {'value': 48}},), is_leaf=True, yang_name="if-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='ift:if-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """if_type must be of a type compatible with ift:if-type""",
          'defined-type': "ift:if-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'voiceFXO': {'value': 101}, u'atmVciEndPt': {'value': 194}, u'propBWAp2Mp': {'value': 184}, u'propDocsWirelessDownstream': {'value': 181}, u'v11': {'value': 64}, u'softwareLoopback': {'value': 24}, u'hdlc': {'value': 118}, u'voiceFGDOS': {'value': 235}, u'fastEtherFX': {'value': 69}, u'dvbTdm': {'value': 240}, u'nfas': {'value': 175}, u'ifPwType': {'value': 246}, u'l2vlan': {'value': 135}, u'adsl2plus': {'value': 238}, u'ieee802154': {'value': 259}, u'voiceFXS': {'value': 102}, u'dvbRcsMacLayer': {'value': 239}, u'idsl': {'value': 154}, u'infiniband': {'value': 199}, u'ddnX25': {'value': 4}, u'wwanPP2': {'value': 244}, u'docsCableUpstream': {'value': 129}, u'ethernet3Mbit': {'value': 26}, u'digitalPowerline': {'value': 138}, u'h323Proxy': {'value': 165}, u'gtp': {'value': 216}, u'ipOverAtm': {'value': 114}, u'aluEpon': {'value': 266}, u'imt': {'value': 190}, u'ipSwitch': {'value': 78}, u'msdsl': {'value': 143}, u'dvbRccMacLayer': {'value': 146}, u'smdsDxi': {'value': 43}, u'voiceOverAtm': {'value': 152}, u'arap': {'value': 88}, u'fastEther': {'value': 62}, u'mpc': {'value': 113}, u'linegroup': {'value': 210}, u'hippi': {'value': 47}, u'rpr': {'value': 225}, u'ds1FDL': {'value': 170}, u'sonetVT': {'value': 51}, u'aluGponPhysicalUni': {'value': 271}, u'ss7SigLink': {'value': 156}, u'arcnet': {'value': 35}, u'actelisMetaLOOP': {'value': 223}, u'qllc': {'value': 68}, u'rfc877x25': {'value': 5}, u'mpegTransport': {'value': 214}, u'x25mlp': {'value': 121}, u'virtualTg': {'value': 202}, u'hostPad': {'value': 90}, u'starLan': {'value': 11}, u'iso88025Dtr': {'value': 86}, u'ibm370parChan': {'value': 72}, u'adsl2': {'value': 230}, u'otnOtu': {'value': 261}, u'propWirelessP2P': {'value': 157}, u'interleave': {'value': 124}, u'isup': {'value': 179}, u'regular1822': {'value': 2}, u'gr303RDT': {'value': 177}, u'propDocsWirelessMaclayer': {'value': 180}, u'async': {'value': 84}, u'radioMAC': {'value': 188}, u'opticalChannelGroup': {'value': 219}, u'sixToFour': {'value': 215}, u'propDocsWirelessUpstream': {'value': 182}, u'q2931': {'value': 201}, u'fddi': {'value': 15}, u'propCnls': {'value': 89}, u'aal2': {'value': 187}, u'dvbAsiOut': {'value': 173}, u'aluELP': {'value': 249}, u'ciscoISLvlan': {'value': 222}, u'docsCableUpstreamRfPort': {'value': 256}, u'aal5': {'value': 49}, u'frDlciEndPt': {'value': 193}, u'hippiInterface': {'value': 57}, u'l3ipvlan': {'value': 136}, u'miox25': {'value': 38}, u'hssi': {'value': 46}, u'fastdsl': {'value': 282}, u'atmVirtual': {'value': 149}, u'aluGponOnu': {'value': 270}, u'rfc1483': {'value': 159}, u'cnr': {'value': 85}, u'sipSig': {'value': 204}, u'myrinet': {'value': 99}, u'dlsw': {'value': 74}, u'gigabitEthernet': {'value': 117}, u'x25ple': {'value': 40}, u'lmp': {'value': 227}, u'opticalTransport': {'value': 196}, u'sdlc': {'value': 17}, u'voiceEM': {'value': 100}, u'x86Laps': {'value': 242}, u'g9982': {'value': 264}, u'iso88022llc': {'value': 41}, u'dvbAsiIn': {'value': 172}, u'bgppolicyaccounting': {'value': 162}, u'aluEponOnu': {'value': 267}, u'mfSigLink': {'value': 167}, u'dcn': {'value': 141}, u'atmDxi': {'value': 105}, u'voiceOverFrameRelay': {'value': 153}, u'gfp': {'value': 221}, u'sonetOverheadChannel': {'value': 185}, u'vmwareVirtualNic': {'value': 258}, u'fcipLink': {'value': 224}, u'ipOverClaw': {'value': 110}, u'coffee': {'value': 132}, u'radsl': {'value': 95}, u'gfast': {'value': 279}, u'vdsl2': {'value': 251}, u'rs232': {'value': 33}, u'e1': {'value': 19}, u'reachDSL': {'value': 192}, u'xboxWireless': {'value': 281}, u'voiceOverCable': {'value': 198}, u'tr008': {'value': 176}, u'voiceOverIp': {'value': 104}, u'atm': {'value': 37}, u'ds3': {'value': 30}, u'ds0': {'value': 81}, u'ds1': {'value': 18}, u'srp': {'value': 151}, u'docsCableDownstream': {'value': 128}, u'dvbRcsTdma': {'value': 241}, u'g9983': {'value': 265}, u'plc': {'value': 174}, u'frameRelayMPI': {'value': 92}, u'mvl': {'value': 191}, u'propMultiplexor': {'value': 54}, u'voiceDID': {'value': 213}, u'compositeLink': {'value': 155}, u'proteon10Mbit': {'value': 12}, u'atmbond': {'value': 234}, u'frf16MfrBundle': {'value': 163}, u'cctEmul': {'value': 61}, u'mplsTunnel': {'value': 150}, u'gpon': {'value': 250}, u'vdsl': {'value': 97}, u'pos': {'value': 171}, u'ieee8023adLag': {'value': 161}, u'docsCableMaclayer': {'value': 127}, u'docsCableMCmtsDownstream': {'value': 229}, u'ppp': {'value': 23}, u'frameRelay': {'value': 32}, u'eplrs': {'value': 87}, u'vmwareNicTeam': {'value': 272}, u'cableDownstreamRfPort': {'value': 257}, u'macSecUncontrolledIF': {'value': 232}, u'iso88023Csmacd': {'value': 7}, u'usb': {'value': 160}, u'atmFuni': {'value': 106}, u'teLink': {'value': 200}, u'pon622': {'value': 208}, u'econet': {'value': 206}, u'tdlc': {'value': 116}, u'ds0Bundle': {'value': 82}, u'fast': {'value': 125}, u'ieee1394': {'value': 144}, u'cblVectaStar': {'value': 228}, u'rsrb': {'value': 79}, u'frameRelayInterconnect': {'value': 58}, u'isdns': {'value': 75}, u'pppMultilinkBundle': {'value': 108}, u'aflane8025': {'value': 60}, u'lapb': {'value': 16}, u'aflane8023': {'value': 59}, u'lapd': {'value': 77}, u'isdnu': {'value': 76}, u'lapf': {'value': 119}, u'capwapWtpVirtualRadio': {'value': 254}, u'ifVfiType': {'value': 262}, u'x25huntGroup': {'value': 122}, u'para': {'value': 34}, u'macSecControlledIF': {'value': 231}, u'iso88024TokenBus': {'value': 8}, u'localTalk': {'value': 42}, u'hyperchannel': {'value': 14}, u'mediaMailOverIp': {'value': 139}, u'if-gsn': {'value': 145}, u'capwapDot11Profile': {'value': 252}, u'l3ipxvlan': {'value': 137}, u'atmSubInterface': {'value': 134}, u'primaryISDN': {'value': 21}, u'proteon80Mbit': {'value': 13}, u'iso88026Man': {'value': 10}, u'digitalWrapperOverheadChannel': {'value': 186}, u'docsCableUpstreamChannel': {'value': 205}, u'opticalChannel': {'value': 195}, u'ethernetCsmacd': {'value': 6}, u'bits': {'value': 255}, u'tunnel': {'value': 131}, u'hdsl2': {'value': 168}, u'frameRelayService': {'value': 44}, u'mpls': {'value': 166}, u'ieee80211': {'value': 71}, u'ieee80212': {'value': 55}, u'mocaVersion1': {'value': 236}, u'sonet': {'value': 39}, u'escon': {'value': 73}, u'aluEponLogicalLink': {'value': 269}, u'g703at2mb': {'value': 67}, u'ultra': {'value': 29}, u'dvbRccDownstream': {'value': 147}, u'sipTg': {'value': 203}, u'smdsIcip': {'value': 52}, u'bridge': {'value': 209}, u'atmLogical': {'value': 80}, u'propPointToPointSerial': {'value': 22}, u'v35': {'value': 45}, u'v36': {'value': 65}, u'v37': {'value': 120}, u'ip': {'value': 126}, u'gr303IDT': {'value': 178}, u'basicISDN': {'value': 20}, u'g703at64k': {'value': 66}, u'arcnetPlus': {'value': 36}, u'pip': {'value': 248}, u'dtm': {'value': 140}, u'slip': {'value': 28}, u'hiperlan2': {'value': 183}, u'adsl': {'value': 94}, u'ieee80216WMAN': {'value': 237}, u'atmIma': {'value': 107}, u'isdn': {'value': 63}, u'capwapDot11Bss': {'value': 253}, u'sip': {'value': 31}, u'pdnEtherLoop2': {'value': 218}, u'voiceEBS': {'value': 245}, u'ipForward': {'value': 142}, u'iso88025CRFPInt': {'value': 98}, u'propVirtual': {'value': 53}, u'wwanPP': {'value': 243}, u'docsOfdmaUpstream': {'value': 278}, u'other': {'value': 1}, u'pon155': {'value': 207}, u'voiceEncap': {'value': 103}, u'qam': {'value': 226}, u'otnOdu': {'value': 260}, u'iso88025Fiber': {'value': 115}, u'channel': {'value': 70}, u'voiceEMFGD': {'value': 211}, u'sdci': {'value': 280}, u'a12MppSwitch': {'value': 130}, u'ilan': {'value': 247}, u'pdnEtherLoop1': {'value': 217}, u'x213': {'value': 93}, u'sonetPath': {'value': 50}, u'voiceFGDEANA': {'value': 212}, u'iso88025TokenRing': {'value': 9}, u'propAtm': {'value': 197}, u'aluEponPhysicalUni': {'value': 268}, u'stackToStack': {'value': 111}, u'frForward': {'value': 158}, u'homepna': {'value': 220}, u'sdsl': {'value': 96}, u'virtualIpAddress': {'value': 112}, u'bsc': {'value': 83}, u'atmRadio': {'value': 189}, u'aviciOpticalEther': {'value': 233}, u'g9981': {'value': 263}, u'docsOfdmDownstream': {'value': 277}, u'fibreChannel': {'value': 56}, u'shdsl': {'value': 169}, u'eon': {'value': 25}, u'h323Gatekeeper': {'value': 164}, u'hdh1822': {'value': 3}, u'dvbRccUpstream': {'value': 148}, u'nsip': {'value': 27}, u'transpHdlc': {'value': 123}, u'termPad': {'value': 91}, u'ipOverCdlc': {'value': 109}, u'ces': {'value': 133}, u'modem': {'value': 48}},), is_leaf=True, yang_name="if-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='ift:if-type', is_config=True)""",
        })

    self.__if_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_if_type(self):
    self.__if_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'voiceFXO': {'value': 101}, u'atmVciEndPt': {'value': 194}, u'propBWAp2Mp': {'value': 184}, u'propDocsWirelessDownstream': {'value': 181}, u'v11': {'value': 64}, u'softwareLoopback': {'value': 24}, u'hdlc': {'value': 118}, u'voiceFGDOS': {'value': 235}, u'fastEtherFX': {'value': 69}, u'dvbTdm': {'value': 240}, u'nfas': {'value': 175}, u'ifPwType': {'value': 246}, u'l2vlan': {'value': 135}, u'adsl2plus': {'value': 238}, u'ieee802154': {'value': 259}, u'voiceFXS': {'value': 102}, u'dvbRcsMacLayer': {'value': 239}, u'idsl': {'value': 154}, u'infiniband': {'value': 199}, u'ddnX25': {'value': 4}, u'wwanPP2': {'value': 244}, u'docsCableUpstream': {'value': 129}, u'ethernet3Mbit': {'value': 26}, u'digitalPowerline': {'value': 138}, u'h323Proxy': {'value': 165}, u'gtp': {'value': 216}, u'ipOverAtm': {'value': 114}, u'aluEpon': {'value': 266}, u'imt': {'value': 190}, u'ipSwitch': {'value': 78}, u'msdsl': {'value': 143}, u'dvbRccMacLayer': {'value': 146}, u'smdsDxi': {'value': 43}, u'voiceOverAtm': {'value': 152}, u'arap': {'value': 88}, u'fastEther': {'value': 62}, u'mpc': {'value': 113}, u'linegroup': {'value': 210}, u'hippi': {'value': 47}, u'rpr': {'value': 225}, u'ds1FDL': {'value': 170}, u'sonetVT': {'value': 51}, u'aluGponPhysicalUni': {'value': 271}, u'ss7SigLink': {'value': 156}, u'arcnet': {'value': 35}, u'actelisMetaLOOP': {'value': 223}, u'qllc': {'value': 68}, u'rfc877x25': {'value': 5}, u'mpegTransport': {'value': 214}, u'x25mlp': {'value': 121}, u'virtualTg': {'value': 202}, u'hostPad': {'value': 90}, u'starLan': {'value': 11}, u'iso88025Dtr': {'value': 86}, u'ibm370parChan': {'value': 72}, u'adsl2': {'value': 230}, u'otnOtu': {'value': 261}, u'propWirelessP2P': {'value': 157}, u'interleave': {'value': 124}, u'isup': {'value': 179}, u'regular1822': {'value': 2}, u'gr303RDT': {'value': 177}, u'propDocsWirelessMaclayer': {'value': 180}, u'async': {'value': 84}, u'radioMAC': {'value': 188}, u'opticalChannelGroup': {'value': 219}, u'sixToFour': {'value': 215}, u'propDocsWirelessUpstream': {'value': 182}, u'q2931': {'value': 201}, u'fddi': {'value': 15}, u'propCnls': {'value': 89}, u'aal2': {'value': 187}, u'dvbAsiOut': {'value': 173}, u'aluELP': {'value': 249}, u'ciscoISLvlan': {'value': 222}, u'docsCableUpstreamRfPort': {'value': 256}, u'aal5': {'value': 49}, u'frDlciEndPt': {'value': 193}, u'hippiInterface': {'value': 57}, u'l3ipvlan': {'value': 136}, u'miox25': {'value': 38}, u'hssi': {'value': 46}, u'fastdsl': {'value': 282}, u'atmVirtual': {'value': 149}, u'aluGponOnu': {'value': 270}, u'rfc1483': {'value': 159}, u'cnr': {'value': 85}, u'sipSig': {'value': 204}, u'myrinet': {'value': 99}, u'dlsw': {'value': 74}, u'gigabitEthernet': {'value': 117}, u'x25ple': {'value': 40}, u'lmp': {'value': 227}, u'opticalTransport': {'value': 196}, u'sdlc': {'value': 17}, u'voiceEM': {'value': 100}, u'x86Laps': {'value': 242}, u'g9982': {'value': 264}, u'iso88022llc': {'value': 41}, u'dvbAsiIn': {'value': 172}, u'bgppolicyaccounting': {'value': 162}, u'aluEponOnu': {'value': 267}, u'mfSigLink': {'value': 167}, u'dcn': {'value': 141}, u'atmDxi': {'value': 105}, u'voiceOverFrameRelay': {'value': 153}, u'gfp': {'value': 221}, u'sonetOverheadChannel': {'value': 185}, u'vmwareVirtualNic': {'value': 258}, u'fcipLink': {'value': 224}, u'ipOverClaw': {'value': 110}, u'coffee': {'value': 132}, u'radsl': {'value': 95}, u'gfast': {'value': 279}, u'vdsl2': {'value': 251}, u'rs232': {'value': 33}, u'e1': {'value': 19}, u'reachDSL': {'value': 192}, u'xboxWireless': {'value': 281}, u'voiceOverCable': {'value': 198}, u'tr008': {'value': 176}, u'voiceOverIp': {'value': 104}, u'atm': {'value': 37}, u'ds3': {'value': 30}, u'ds0': {'value': 81}, u'ds1': {'value': 18}, u'srp': {'value': 151}, u'docsCableDownstream': {'value': 128}, u'dvbRcsTdma': {'value': 241}, u'g9983': {'value': 265}, u'plc': {'value': 174}, u'frameRelayMPI': {'value': 92}, u'mvl': {'value': 191}, u'propMultiplexor': {'value': 54}, u'voiceDID': {'value': 213}, u'compositeLink': {'value': 155}, u'proteon10Mbit': {'value': 12}, u'atmbond': {'value': 234}, u'frf16MfrBundle': {'value': 163}, u'cctEmul': {'value': 61}, u'mplsTunnel': {'value': 150}, u'gpon': {'value': 250}, u'vdsl': {'value': 97}, u'pos': {'value': 171}, u'ieee8023adLag': {'value': 161}, u'docsCableMaclayer': {'value': 127}, u'docsCableMCmtsDownstream': {'value': 229}, u'ppp': {'value': 23}, u'frameRelay': {'value': 32}, u'eplrs': {'value': 87}, u'vmwareNicTeam': {'value': 272}, u'cableDownstreamRfPort': {'value': 257}, u'macSecUncontrolledIF': {'value': 232}, u'iso88023Csmacd': {'value': 7}, u'usb': {'value': 160}, u'atmFuni': {'value': 106}, u'teLink': {'value': 200}, u'pon622': {'value': 208}, u'econet': {'value': 206}, u'tdlc': {'value': 116}, u'ds0Bundle': {'value': 82}, u'fast': {'value': 125}, u'ieee1394': {'value': 144}, u'cblVectaStar': {'value': 228}, u'rsrb': {'value': 79}, u'frameRelayInterconnect': {'value': 58}, u'isdns': {'value': 75}, u'pppMultilinkBundle': {'value': 108}, u'aflane8025': {'value': 60}, u'lapb': {'value': 16}, u'aflane8023': {'value': 59}, u'lapd': {'value': 77}, u'isdnu': {'value': 76}, u'lapf': {'value': 119}, u'capwapWtpVirtualRadio': {'value': 254}, u'ifVfiType': {'value': 262}, u'x25huntGroup': {'value': 122}, u'para': {'value': 34}, u'macSecControlledIF': {'value': 231}, u'iso88024TokenBus': {'value': 8}, u'localTalk': {'value': 42}, u'hyperchannel': {'value': 14}, u'mediaMailOverIp': {'value': 139}, u'if-gsn': {'value': 145}, u'capwapDot11Profile': {'value': 252}, u'l3ipxvlan': {'value': 137}, u'atmSubInterface': {'value': 134}, u'primaryISDN': {'value': 21}, u'proteon80Mbit': {'value': 13}, u'iso88026Man': {'value': 10}, u'digitalWrapperOverheadChannel': {'value': 186}, u'docsCableUpstreamChannel': {'value': 205}, u'opticalChannel': {'value': 195}, u'ethernetCsmacd': {'value': 6}, u'bits': {'value': 255}, u'tunnel': {'value': 131}, u'hdsl2': {'value': 168}, u'frameRelayService': {'value': 44}, u'mpls': {'value': 166}, u'ieee80211': {'value': 71}, u'ieee80212': {'value': 55}, u'mocaVersion1': {'value': 236}, u'sonet': {'value': 39}, u'escon': {'value': 73}, u'aluEponLogicalLink': {'value': 269}, u'g703at2mb': {'value': 67}, u'ultra': {'value': 29}, u'dvbRccDownstream': {'value': 147}, u'sipTg': {'value': 203}, u'smdsIcip': {'value': 52}, u'bridge': {'value': 209}, u'atmLogical': {'value': 80}, u'propPointToPointSerial': {'value': 22}, u'v35': {'value': 45}, u'v36': {'value': 65}, u'v37': {'value': 120}, u'ip': {'value': 126}, u'gr303IDT': {'value': 178}, u'basicISDN': {'value': 20}, u'g703at64k': {'value': 66}, u'arcnetPlus': {'value': 36}, u'pip': {'value': 248}, u'dtm': {'value': 140}, u'slip': {'value': 28}, u'hiperlan2': {'value': 183}, u'adsl': {'value': 94}, u'ieee80216WMAN': {'value': 237}, u'atmIma': {'value': 107}, u'isdn': {'value': 63}, u'capwapDot11Bss': {'value': 253}, u'sip': {'value': 31}, u'pdnEtherLoop2': {'value': 218}, u'voiceEBS': {'value': 245}, u'ipForward': {'value': 142}, u'iso88025CRFPInt': {'value': 98}, u'propVirtual': {'value': 53}, u'wwanPP': {'value': 243}, u'docsOfdmaUpstream': {'value': 278}, u'other': {'value': 1}, u'pon155': {'value': 207}, u'voiceEncap': {'value': 103}, u'qam': {'value': 226}, u'otnOdu': {'value': 260}, u'iso88025Fiber': {'value': 115}, u'channel': {'value': 70}, u'voiceEMFGD': {'value': 211}, u'sdci': {'value': 280}, u'a12MppSwitch': {'value': 130}, u'ilan': {'value': 247}, u'pdnEtherLoop1': {'value': 217}, u'x213': {'value': 93}, u'sonetPath': {'value': 50}, u'voiceFGDEANA': {'value': 212}, u'iso88025TokenRing': {'value': 9}, u'propAtm': {'value': 197}, u'aluEponPhysicalUni': {'value': 268}, u'stackToStack': {'value': 111}, u'frForward': {'value': 158}, u'homepna': {'value': 220}, u'sdsl': {'value': 96}, u'virtualIpAddress': {'value': 112}, u'bsc': {'value': 83}, u'atmRadio': {'value': 189}, u'aviciOpticalEther': {'value': 233}, u'g9981': {'value': 263}, u'docsOfdmDownstream': {'value': 277}, u'fibreChannel': {'value': 56}, u'shdsl': {'value': 169}, u'eon': {'value': 25}, u'h323Gatekeeper': {'value': 164}, u'hdh1822': {'value': 3}, u'dvbRccUpstream': {'value': 148}, u'nsip': {'value': 27}, u'transpHdlc': {'value': 123}, u'termPad': {'value': 91}, u'ipOverCdlc': {'value': 109}, u'ces': {'value': 133}, u'modem': {'value': 48}},), is_leaf=True, yang_name="if-type", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='ift:if-type', is_config=True)


  def _get_arp_timeout(self):
    """
    Getter method for arp_timeout, mapped from YANG variable /devices/device/interfaces/interface/arp_timeout (uint32)

    YANG Description: 0..4294967295
    """
    return self.__arp_timeout
      
  def _set_arp_timeout(self, v, load=False):
    """
    Setter method for arp_timeout, mapped from YANG variable /devices/device/interfaces/interface/arp_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_arp_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_arp_timeout() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="arp-timeout", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """arp_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="arp-timeout", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__arp_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_arp_timeout(self):
    self.__arp_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="arp-timeout", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_port_number_vlan(self):
    """
    Getter method for port_number_vlan, mapped from YANG variable /devices/device/interfaces/interface/port_number_vlan (string)

    YANG Description: string
    """
    return self.__port_number_vlan
      
  def _set_port_number_vlan(self, v, load=False):
    """
    Setter method for port_number_vlan, mapped from YANG variable /devices/device/interfaces/interface/port_number_vlan (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_number_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_number_vlan() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port-number-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_number_vlan must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port-number-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__port_number_vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_number_vlan(self):
    self.__port_number_vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-number-vlan", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_vpls_name(self):
    """
    Getter method for vpls_name, mapped from YANG variable /devices/device/interfaces/interface/vpls_name (string)

    YANG Description: string
    """
    return self.__vpls_name
      
  def _set_vpls_name(self, v, load=False):
    """
    Setter method for vpls_name, mapped from YANG variable /devices/device/interfaces/interface/vpls_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpls_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpls_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vpls-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpls_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__vpls_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpls_name(self):
    self.__vpls_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="vpls-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /devices/device/interfaces/interface/bandwidth (uint32)

    YANG Description: 0..4294967295
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /devices/device/interfaces/interface/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="bandwidth", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_delay(self):
    """
    Getter method for delay, mapped from YANG variable /devices/device/interfaces/interface/delay (uint32)

    YANG Description: 0..4294967295
    """
    return self.__delay
      
  def _set_delay(self, v, load=False):
    """
    Setter method for delay, mapped from YANG variable /devices/device/interfaces/interface/delay (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delay() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delay must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delay(self):
    self.__delay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="delay", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_maximum_segment_size(self):
    """
    Getter method for maximum_segment_size, mapped from YANG variable /devices/device/interfaces/interface/maximum_segment_size (uint32)

    YANG Description: 0..4294967295
    """
    return self.__maximum_segment_size
      
  def _set_maximum_segment_size(self, v, load=False):
    """
    Setter method for maximum_segment_size, mapped from YANG variable /devices/device/interfaces/interface/maximum_segment_size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_segment_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_segment_size() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-segment-size", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_segment_size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-segment-size", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_segment_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_segment_size(self):
    self.__maximum_segment_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maximum-segment-size", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='uint32', is_config=True)


  def _get_nat_name(self):
    """
    Getter method for nat_name, mapped from YANG variable /devices/device/interfaces/interface/nat_name (nat-type)

    YANG Description: inside
outside

    """
    return self.__nat_name
      
  def _set_nat_name(self, v, load=False):
    """
    Setter method for nat_name, mapped from YANG variable /devices/device/interfaces/interface/nat_name (nat-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nat_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nat_name() directly.

    YANG Description: inside
outside

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inside': {}, u'outside': {}},), is_leaf=True, yang_name="nat-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nat-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nat_name must be of a type compatible with nat-type""",
          'defined-type': "interface:nat-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inside': {}, u'outside': {}},), is_leaf=True, yang_name="nat-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nat-type', is_config=True)""",
        })

    self.__nat_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nat_name(self):
    self.__nat_name = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'inside': {}, u'outside': {}},), is_leaf=True, yang_name="nat-name", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='nat-type', is_config=True)


  def _get_minimum_links(self):
    """
    Getter method for minimum_links, mapped from YANG variable /devices/device/interfaces/interface/minimum_links (string)

    YANG Description: string
    """
    return self.__minimum_links
      
  def _set_minimum_links(self, v, load=False):
    """
    Setter method for minimum_links, mapped from YANG variable /devices/device/interfaces/interface/minimum_links (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minimum_links is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minimum_links() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="minimum-links", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minimum_links must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="minimum-links", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__minimum_links = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minimum_links(self):
    self.__minimum_links = YANGDynClass(base=unicode, is_leaf=True, yang_name="minimum-links", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_link_speed(self):
    """
    Getter method for link_speed, mapped from YANG variable /devices/device/interfaces/interface/link_speed (string)

    YANG Description: string
    """
    return self.__link_speed
      
  def _set_link_speed(self, v, load=False):
    """
    Setter method for link_speed, mapped from YANG variable /devices/device/interfaces/interface/link_speed (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_speed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_speed() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="link-speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_speed must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="link-speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__link_speed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_speed(self):
    self.__link_speed = YANGDynClass(base=unicode, is_leaf=True, yang_name="link-speed", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_duplex(self):
    """
    Getter method for duplex, mapped from YANG variable /devices/device/interfaces/interface/duplex (string)

    YANG Description: string
    """
    return self.__duplex
      
  def _set_duplex(self, v, load=False):
    """
    Setter method for duplex, mapped from YANG variable /devices/device/interfaces/interface/duplex (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_duplex is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_duplex() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="duplex", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """duplex must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="duplex", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)""",
        })

    self.__duplex = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_duplex(self):
    self.__duplex = YANGDynClass(base=unicode, is_leaf=True, yang_name="duplex", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='string', is_config=True)


  def _get_fcoe_lag(self):
    """
    Getter method for fcoe_lag, mapped from YANG variable /devices/device/interfaces/interface/fcoe_lag (boolean)

    YANG Description: fcoe-lag: True/False
    """
    return self.__fcoe_lag
      
  def _set_fcoe_lag(self, v, load=False):
    """
    Setter method for fcoe_lag, mapped from YANG variable /devices/device/interfaces/interface/fcoe_lag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fcoe_lag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fcoe_lag() directly.

    YANG Description: fcoe-lag: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fcoe-lag", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fcoe_lag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fcoe-lag", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__fcoe_lag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fcoe_lag(self):
    self.__fcoe_lag = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fcoe-lag", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_lacp_active_enable(self):
    """
    Getter method for lacp_active_enable, mapped from YANG variable /devices/device/interfaces/interface/lacp_active_enable (boolean)

    YANG Description: lacp-active-enable: True/False
    """
    return self.__lacp_active_enable
      
  def _set_lacp_active_enable(self, v, load=False):
    """
    Setter method for lacp_active_enable, mapped from YANG variable /devices/device/interfaces/interface/lacp_active_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lacp_active_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lacp_active_enable() directly.

    YANG Description: lacp-active-enable: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lacp-active-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lacp_active_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lacp-active-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__lacp_active_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lacp_active_enable(self):
    self.__lacp_active_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lacp-active-enable", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_lacp_active_periodic_fast(self):
    """
    Getter method for lacp_active_periodic_fast, mapped from YANG variable /devices/device/interfaces/interface/lacp_active_periodic_fast (boolean)

    YANG Description: lacp-active-periodic-fast: True/False
    """
    return self.__lacp_active_periodic_fast
      
  def _set_lacp_active_periodic_fast(self, v, load=False):
    """
    Setter method for lacp_active_periodic_fast, mapped from YANG variable /devices/device/interfaces/interface/lacp_active_periodic_fast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lacp_active_periodic_fast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lacp_active_periodic_fast() directly.

    YANG Description: lacp-active-periodic-fast: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="lacp-active-periodic-fast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lacp_active_periodic_fast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lacp-active-periodic-fast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)""",
        })

    self.__lacp_active_periodic_fast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lacp_active_periodic_fast(self):
    self.__lacp_active_periodic_fast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="lacp-active-periodic-fast", module_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/interface', defining_module='interface', yang_type='boolean', is_config=True)


  def _get_vlan(self):
    """
    Getter method for vlan, mapped from YANG variable /devices/device/interfaces/interface/vlan (leafref)

    YANG Description: vlan
    """
    return self.__vlan
      
  def _set_vlan(self, v, load=False):
    """
    Setter method for vlan, mapped from YANG variable /devices/device/interfaces/interface/vlan (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan() directly.

    YANG Description: vlan
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vlan", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)""",
        })

    self.__vlan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan(self):
    self.__vlan = YANGDynClass(base=unicode, is_leaf=True, yang_name="vlan", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)


  def _get_port_channel_name(self):
    """
    Getter method for port_channel_name, mapped from YANG variable /devices/device/interfaces/interface/port_channel_name (leafref)

    YANG Description: port-channel-name
    """
    return self.__port_channel_name
      
  def _set_port_channel_name(self, v, load=False):
    """
    Setter method for port_channel_name, mapped from YANG variable /devices/device/interfaces/interface/port_channel_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_channel_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_channel_name() directly.

    YANG Description: port-channel-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port-channel-name", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_channel_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port-channel-name", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)""",
        })

    self.__port_channel_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_channel_name(self):
    self.__port_channel_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-channel-name", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='leafref', is_config=True)


  def _get_channel_group_mode(self):
    """
    Getter method for channel_group_mode, mapped from YANG variable /devices/device/interfaces/interface/channel_group_mode (enumeration)

    YANG Description: active
auto
desirable
on
passive

    """
    return self.__channel_group_mode
      
  def _set_channel_group_mode(self, v, load=False):
    """
    Setter method for channel_group_mode, mapped from YANG variable /devices/device/interfaces/interface/channel_group_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_group_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_group_mode() directly.

    YANG Description: active
auto
desirable
on
passive

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'active': {}, u'auto': {}, u'desirable': {}, u'passive': {}, u'on': {}},), is_leaf=True, yang_name="channel-group-mode", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_group_mode must be of a type compatible with enumeration""",
          'defined-type': "l2features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'active': {}, u'auto': {}, u'desirable': {}, u'passive': {}, u'on': {}},), is_leaf=True, yang_name="channel-group-mode", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)""",
        })

    self.__channel_group_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_group_mode(self):
    self.__channel_group_mode = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'active': {}, u'auto': {}, u'desirable': {}, u'passive': {}, u'on': {}},), is_leaf=True, yang_name="channel-group-mode", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)


  def _get_channel_protocol(self):
    """
    Getter method for channel_protocol, mapped from YANG variable /devices/device/interfaces/interface/channel_protocol (enumeration)

    YANG Description: lacp
pagp

    """
    return self.__channel_protocol
      
  def _set_channel_protocol(self, v, load=False):
    """
    Setter method for channel_protocol, mapped from YANG variable /devices/device/interfaces/interface/channel_protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_protocol() directly.

    YANG Description: lacp
pagp

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lacp': {}, u'pagp': {}},), is_leaf=True, yang_name="channel-protocol", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_protocol must be of a type compatible with enumeration""",
          'defined-type': "l2features:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lacp': {}, u'pagp': {}},), is_leaf=True, yang_name="channel-protocol", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)""",
        })

    self.__channel_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_protocol(self):
    self.__channel_protocol = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'lacp': {}, u'pagp': {}},), is_leaf=True, yang_name="channel-protocol", module_name="l2features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l2features', defining_module='l2features', yang_type='enumeration', is_config=True)


  def _get_vrf(self):
    """
    Getter method for vrf, mapped from YANG variable /devices/device/interfaces/interface/vrf (string)

    YANG Description: string
    """
    return self.__vrf
      
  def _set_vrf(self, v, load=False):
    """
    Setter method for vrf, mapped from YANG variable /devices/device/interfaces/interface/vrf (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="vrf", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)""",
        })

    self.__vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf(self):
    self.__vrf = YANGDynClass(base=unicode, is_leaf=True, yang_name="vrf", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='string', is_config=True)


  def _get_bfd_name(self):
    """
    Getter method for bfd_name, mapped from YANG variable /devices/device/interfaces/interface/bfd_name (leafref)

    YANG Description: bfd-name
    """
    return self.__bfd_name
      
  def _set_bfd_name(self, v, load=False):
    """
    Setter method for bfd_name, mapped from YANG variable /devices/device/interfaces/interface/bfd_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd_name() directly.

    YANG Description: bfd-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="bfd-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="bfd-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)""",
        })

    self.__bfd_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd_name(self):
    self.__bfd_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="bfd-name", module_name="l3features", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/l3features', defining_module='l3features', yang_type='leafref', is_config=True)


  def _get_vrrp(self):
    """
    Getter method for vrrp, mapped from YANG variable /devices/device/interfaces/interface/vrrp (container)
    """
    return self.__vrrp
      
  def _set_vrrp(self, v, load=False):
    """
    Setter method for vrrp, mapped from YANG variable /devices/device/interfaces/interface/vrrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrrp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vrrp.vrrp, is_container='container', yang_name="vrrp", module_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vrrp', defining_module='vrrp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vrrp.vrrp, is_container='container', yang_name="vrrp", module_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vrrp', defining_module='vrrp', yang_type='container', is_config=True)""",
        })

    self.__vrrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrrp(self):
    self.__vrrp = YANGDynClass(base=vrrp.vrrp, is_container='container', yang_name="vrrp", module_name="vrrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vrrp', defining_module='vrrp', yang_type='container', is_config=True)


  def _get_acl_inbound_name(self):
    """
    Getter method for acl_inbound_name, mapped from YANG variable /devices/device/interfaces/interface/acl_inbound_name (leafref)

    YANG Description: acl-inbound-name
    """
    return self.__acl_inbound_name
      
  def _set_acl_inbound_name(self, v, load=False):
    """
    Setter method for acl_inbound_name, mapped from YANG variable /devices/device/interfaces/interface/acl_inbound_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_inbound_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_inbound_name() directly.

    YANG Description: acl-inbound-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_inbound_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)""",
        })

    self.__acl_inbound_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_inbound_name(self):
    self.__acl_inbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-inbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)


  def _get_acl_outbound_name(self):
    """
    Getter method for acl_outbound_name, mapped from YANG variable /devices/device/interfaces/interface/acl_outbound_name (leafref)

    YANG Description: acl-outbound-name
    """
    return self.__acl_outbound_name
      
  def _set_acl_outbound_name(self, v, load=False):
    """
    Setter method for acl_outbound_name, mapped from YANG variable /devices/device/interfaces/interface/acl_outbound_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl_outbound_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl_outbound_name() directly.

    YANG Description: acl-outbound-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl_outbound_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)""",
        })

    self.__acl_outbound_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl_outbound_name(self):
    self.__acl_outbound_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="acl-outbound-name", module_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/acl', defining_module='acl', yang_type='leafref', is_config=True)


  def _get_context_name(self):
    """
    Getter method for context_name, mapped from YANG variable /devices/device/interfaces/interface/context_name (leafref)

    YANG Description: string
    """
    return self.__context_name
      
  def _set_context_name(self, v, load=False):
    """
    Setter method for context_name, mapped from YANG variable /devices/device/interfaces/interface/context_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_context_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_context_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """context_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)""",
        })

    self.__context_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_context_name(self):
    self.__context_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="context-name", module_name="firewall", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/firewall', defining_module='firewall', yang_type='leafref', is_config=True)


  def _get_source_ip(self):
    """
    Getter method for source_ip, mapped from YANG variable /devices/device/interfaces/interface/source_ip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__source_ip
      
  def _set_source_ip(self, v, load=False):
    """
    Setter method for source_ip, mapped from YANG variable /devices/device/interfaces/interface/source_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__source_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_ip(self):
    self.__source_ip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)


  def _get_destination_ip(self):
    """
    Getter method for destination_ip, mapped from YANG variable /devices/device/interfaces/interface/destination_ip (inet:ip-address)

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    return self.__destination_ip
      
  def _set_destination_ip(self, v, load=False):
    """
    Setter method for destination_ip, mapped from YANG variable /devices/device/interfaces/interface/destination_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ip() directly.

    YANG Description: Valid IPv4/v6 Address (A.B.C.D for e.x: 172.16.1.1 or X::Y for e.x: 2001::1)
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__destination_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_ip(self):
    self.__destination_ip = YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='inet:ip-address', is_config=True)


  def _get_destination_vrf(self):
    """
    Getter method for destination_vrf, mapped from YANG variable /devices/device/interfaces/interface/destination_vrf (leafref)

    YANG Description: destination-vrf
    """
    return self.__destination_vrf
      
  def _set_destination_vrf(self, v, load=False):
    """
    Setter method for destination_vrf, mapped from YANG variable /devices/device/interfaces/interface/destination_vrf (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_vrf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_vrf() directly.

    YANG Description: destination-vrf
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="destination-vrf", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination_vrf must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-vrf", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='leafref', is_config=True)""",
        })

    self.__destination_vrf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination_vrf(self):
    self.__destination_vrf = YANGDynClass(base=unicode, is_leaf=True, yang_name="destination-vrf", module_name="gre-tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/gre-tunnel', defining_module='gre-tunnel', yang_type='leafref', is_config=True)


  def _get_port_qos_group_template(self):
    """
    Getter method for port_qos_group_template, mapped from YANG variable /devices/device/interfaces/interface/port_qos_group_template (leafref)

    YANG Description: port-qos-group-template
    """
    return self.__port_qos_group_template
      
  def _set_port_qos_group_template(self, v, load=False):
    """
    Setter method for port_qos_group_template, mapped from YANG variable /devices/device/interfaces/interface/port_qos_group_template (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_qos_group_template is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_qos_group_template() directly.

    YANG Description: port-qos-group-template
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port-qos-group-template", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_qos_group_template must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port-qos-group-template", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)""",
        })

    self.__port_qos_group_template = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_qos_group_template(self):
    self.__port_qos_group_template = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-qos-group-template", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)


  def _get_port_qos_scheduler_policy(self):
    """
    Getter method for port_qos_scheduler_policy, mapped from YANG variable /devices/device/interfaces/interface/port_qos_scheduler_policy (leafref)

    YANG Description: port-qos-scheduler-policy
    """
    return self.__port_qos_scheduler_policy
      
  def _set_port_qos_scheduler_policy(self, v, load=False):
    """
    Setter method for port_qos_scheduler_policy, mapped from YANG variable /devices/device/interfaces/interface/port_qos_scheduler_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_qos_scheduler_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_qos_scheduler_policy() directly.

    YANG Description: port-qos-scheduler-policy
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="port-qos-scheduler-policy", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_qos_scheduler_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="port-qos-scheduler-policy", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)""",
        })

    self.__port_qos_scheduler_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_qos_scheduler_policy(self):
    self.__port_qos_scheduler_policy = YANGDynClass(base=unicode, is_leaf=True, yang_name="port-qos-scheduler-policy", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)


  def _get_rate_limit(self):
    """
    Getter method for rate_limit, mapped from YANG variable /devices/device/interfaces/interface/rate_limit (leafref)

    YANG Description: rate-limit
    """
    return self.__rate_limit
      
  def _set_rate_limit(self, v, load=False):
    """
    Setter method for rate_limit, mapped from YANG variable /devices/device/interfaces/interface/rate_limit (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rate_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rate_limit() directly.

    YANG Description: rate-limit
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rate-limit", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rate_limit must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rate-limit", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)""",
        })

    self.__rate_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rate_limit(self):
    self.__rate_limit = YANGDynClass(base=unicode, is_leaf=True, yang_name="rate-limit", module_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/qos', defining_module='qos', yang_type='leafref', is_config=True)


  def _get_hsrp(self):
    """
    Getter method for hsrp, mapped from YANG variable /devices/device/interfaces/interface/hsrp (container)
    """
    return self.__hsrp
      
  def _set_hsrp(self, v, load=False):
    """
    Setter method for hsrp, mapped from YANG variable /devices/device/interfaces/interface/hsrp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hsrp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hsrp() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=hsrp.hsrp, is_container='container', yang_name="hsrp", module_name="hsrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/hsrp', defining_module='hsrp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hsrp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hsrp.hsrp, is_container='container', yang_name="hsrp", module_name="hsrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/hsrp', defining_module='hsrp', yang_type='container', is_config=True)""",
        })

    self.__hsrp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hsrp(self):
    self.__hsrp = YANGDynClass(base=hsrp.hsrp, is_container='container', yang_name="hsrp", module_name="hsrp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/hsrp', defining_module='hsrp', yang_type='container', is_config=True)

  long_name = __builtin__.property(_get_long_name, _set_long_name)
  name = __builtin__.property(_get_name, _set_name)
  if_index = __builtin__.property(_get_if_index, _set_if_index)
  description = __builtin__.property(_get_description, _set_description)
  mode = __builtin__.property(_get_mode, _set_mode)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  hold_time_up = __builtin__.property(_get_hold_time_up, _set_hold_time_up)
  hold_time_down = __builtin__.property(_get_hold_time_down, _set_hold_time_down)
  physical_address = __builtin__.property(_get_physical_address, _set_physical_address)
  rnc_name = __builtin__.property(_get_rnc_name, _set_rnc_name)
  port = __builtin__.property(_get_port, _set_port)
  dhcp = __builtin__.property(_get_dhcp, _set_dhcp)
  inpath_optimisation = __builtin__.property(_get_inpath_optimisation, _set_inpath_optimisation)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  netmask = __builtin__.property(_get_netmask, _set_netmask)
  ipv4_prefix_length = __builtin__.property(_get_ipv4_prefix_length, _set_ipv4_prefix_length)
  ipv6_address = __builtin__.property(_get_ipv6_address, _set_ipv6_address)
  ipv6_prefix_length = __builtin__.property(_get_ipv6_prefix_length, _set_ipv6_prefix_length)
  alias_address = __builtin__.property(_get_alias_address, _set_alias_address)
  gateway = __builtin__.property(_get_gateway, _set_gateway)
  inpath_gateway = __builtin__.property(_get_inpath_gateway, _set_inpath_gateway)
  primaryip = __builtin__.property(_get_primaryip, _set_primaryip)
  secondaryip = __builtin__.property(_get_secondaryip, _set_secondaryip)
  admin_state = __builtin__.property(_get_admin_state, _set_admin_state)
  operation_state = __builtin__.property(_get_operation_state)
  out_bandwidth = __builtin__.property(_get_out_bandwidth, _set_out_bandwidth)
  in_bandwidth = __builtin__.property(_get_in_bandwidth, _set_in_bandwidth)
  speed = __builtin__.property(_get_speed, _set_speed)
  native_vlan = __builtin__.property(_get_native_vlan, _set_native_vlan)
  portfast = __builtin__.property(_get_portfast, _set_portfast)
  service = __builtin__.property(_get_service, _set_service)
  cdp = __builtin__.property(_get_cdp, _set_cdp)
  bpduguard = __builtin__.property(_get_bpduguard, _set_bpduguard)
  broadcast = __builtin__.property(_get_broadcast, _set_broadcast)
  nonegotiate = __builtin__.property(_get_nonegotiate, _set_nonegotiate)
  power_inline = __builtin__.property(_get_power_inline, _set_power_inline)
  value = __builtin__.property(_get_value, _set_value)
  priority_queue = __builtin__.property(_get_priority_queue, _set_priority_queue)
  voice_vlan = __builtin__.property(_get_voice_vlan, _set_voice_vlan)
  level = __builtin__.property(_get_level, _set_level)
  speed_unit = __builtin__.property(_get_speed_unit, _set_speed_unit)
  policer_name = __builtin__.property(_get_policer_name, _set_policer_name)
  additional_ipv4_address = __builtin__.property(_get_additional_ipv4_address, _set_additional_ipv4_address)
  mls_qos = __builtin__.property(_get_mls_qos, _set_mls_qos)
  srr_queue = __builtin__.property(_get_srr_queue, _set_srr_queue)
  additional_ipv6_address = __builtin__.property(_get_additional_ipv6_address, _set_additional_ipv6_address)
  mace_enable = __builtin__.property(_get_mace_enable, _set_mace_enable)
  port_security = __builtin__.property(_get_port_security, _set_port_security)
  allowed_vlans = __builtin__.property(_get_allowed_vlans, _set_allowed_vlans)
  ospf = __builtin__.property(_get_ospf, _set_ospf)
  eigrp = __builtin__.property(_get_eigrp, _set_eigrp)
  unit = __builtin__.property(_get_unit, _set_unit)
  vlan_count = __builtin__.property(_get_vlan_count)
  context_name = __builtin__.property(_get_context_name, _set_context_name)
  visible_interface = __builtin__.property(_get_visible_interface, _set_visible_interface)
  inside_name = __builtin__.property(_get_inside_name, _set_inside_name)
  security_level_inside = __builtin__.property(_get_security_level_inside, _set_security_level_inside)
  mpls_device_role = __builtin__.property(_get_mpls_device_role, _set_mpls_device_role)
  inner_vlan = __builtin__.property(_get_inner_vlan, _set_inner_vlan)
  outbound_qos = __builtin__.property(_get_outbound_qos, _set_outbound_qos)
  inbound_qos = __builtin__.property(_get_inbound_qos, _set_inbound_qos)
  load_interval_delay = __builtin__.property(_get_load_interval_delay, _set_load_interval_delay)
  bridge_group = __builtin__.property(_get_bridge_group, _set_bridge_group)
  bridge_acl_inbound = __builtin__.property(_get_bridge_acl_inbound, _set_bridge_acl_inbound)
  in_queue_length = __builtin__.property(_get_in_queue_length, _set_in_queue_length)
  out_queue_length = __builtin__.property(_get_out_queue_length, _set_out_queue_length)
  link_negotiation = __builtin__.property(_get_link_negotiation, _set_link_negotiation)
  vrf_receive = __builtin__.property(_get_vrf_receive, _set_vrf_receive)
  bgp_policy = __builtin__.property(_get_bgp_policy, _set_bgp_policy)
  bgp_policy_qos = __builtin__.property(_get_bgp_policy_qos, _set_bgp_policy_qos)
  pbr_policy = __builtin__.property(_get_pbr_policy, _set_pbr_policy)
  vrf_definition_mode = __builtin__.property(_get_vrf_definition_mode, _set_vrf_definition_mode)
  encap_mode = __builtin__.property(_get_encap_mode, _set_encap_mode)
  port_number = __builtin__.property(_get_port_number, _set_port_number)
  mgmt_profile = __builtin__.property(_get_mgmt_profile, _set_mgmt_profile)
  address1_comment = __builtin__.property(_get_address1_comment, _set_address1_comment)
  address2_comment = __builtin__.property(_get_address2_comment, _set_address2_comment)
  rpf_check = __builtin__.property(_get_rpf_check, _set_rpf_check)
  postscrub_unit = __builtin__.property(_get_postscrub_unit, _set_postscrub_unit)
  keepalive_time = __builtin__.property(_get_keepalive_time, _set_keepalive_time)
  virtual_ethernet_number = __builtin__.property(_get_virtual_ethernet_number, _set_virtual_ethernet_number)
  ethernet_number_vpls = __builtin__.property(_get_ethernet_number_vpls, _set_ethernet_number_vpls)
  cos = __builtin__.property(_get_cos, _set_cos)
  port_number_vpls = __builtin__.property(_get_port_number_vpls, _set_port_number_vpls)
  slot_number = __builtin__.property(_get_slot_number, _set_slot_number)
  full_slot_number = __builtin__.property(_get_full_slot_number, _set_full_slot_number)
  slot_module_number = __builtin__.property(_get_slot_module_number, _set_slot_module_number)
  vpn_instance_name = __builtin__.property(_get_vpn_instance_name, _set_vpn_instance_name)
  vsi_vlan_name = __builtin__.property(_get_vsi_vlan_name, _set_vsi_vlan_name)
  port_type = __builtin__.property(_get_port_type, _set_port_type)
  if_type = __builtin__.property(_get_if_type, _set_if_type)
  arp_timeout = __builtin__.property(_get_arp_timeout, _set_arp_timeout)
  port_number_vlan = __builtin__.property(_get_port_number_vlan, _set_port_number_vlan)
  vpls_name = __builtin__.property(_get_vpls_name, _set_vpls_name)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  delay = __builtin__.property(_get_delay, _set_delay)
  maximum_segment_size = __builtin__.property(_get_maximum_segment_size, _set_maximum_segment_size)
  nat_name = __builtin__.property(_get_nat_name, _set_nat_name)
  minimum_links = __builtin__.property(_get_minimum_links, _set_minimum_links)
  link_speed = __builtin__.property(_get_link_speed, _set_link_speed)
  duplex = __builtin__.property(_get_duplex, _set_duplex)
  fcoe_lag = __builtin__.property(_get_fcoe_lag, _set_fcoe_lag)
  lacp_active_enable = __builtin__.property(_get_lacp_active_enable, _set_lacp_active_enable)
  lacp_active_periodic_fast = __builtin__.property(_get_lacp_active_periodic_fast, _set_lacp_active_periodic_fast)
  vlan = __builtin__.property(_get_vlan, _set_vlan)
  port_channel_name = __builtin__.property(_get_port_channel_name, _set_port_channel_name)
  channel_group_mode = __builtin__.property(_get_channel_group_mode, _set_channel_group_mode)
  channel_protocol = __builtin__.property(_get_channel_protocol, _set_channel_protocol)
  vrf = __builtin__.property(_get_vrf, _set_vrf)
  bfd_name = __builtin__.property(_get_bfd_name, _set_bfd_name)
  vrrp = __builtin__.property(_get_vrrp, _set_vrrp)
  acl_inbound_name = __builtin__.property(_get_acl_inbound_name, _set_acl_inbound_name)
  acl_outbound_name = __builtin__.property(_get_acl_outbound_name, _set_acl_outbound_name)
  context_name = __builtin__.property(_get_context_name, _set_context_name)
  source_ip = __builtin__.property(_get_source_ip, _set_source_ip)
  destination_ip = __builtin__.property(_get_destination_ip, _set_destination_ip)
  destination_vrf = __builtin__.property(_get_destination_vrf, _set_destination_vrf)
  port_qos_group_template = __builtin__.property(_get_port_qos_group_template, _set_port_qos_group_template)
  port_qos_scheduler_policy = __builtin__.property(_get_port_qos_scheduler_policy, _set_port_qos_scheduler_policy)
  rate_limit = __builtin__.property(_get_rate_limit, _set_rate_limit)
  hsrp = __builtin__.property(_get_hsrp, _set_hsrp)


  _pyangbind_elements = collections.OrderedDict([('long_name', long_name), ('name', name), ('if_index', if_index), ('description', description), ('mode', mode), ('mtu', mtu), ('hold_time_up', hold_time_up), ('hold_time_down', hold_time_down), ('physical_address', physical_address), ('rnc_name', rnc_name), ('port', port), ('dhcp', dhcp), ('inpath_optimisation', inpath_optimisation), ('ip_address', ip_address), ('netmask', netmask), ('ipv4_prefix_length', ipv4_prefix_length), ('ipv6_address', ipv6_address), ('ipv6_prefix_length', ipv6_prefix_length), ('alias_address', alias_address), ('gateway', gateway), ('inpath_gateway', inpath_gateway), ('primaryip', primaryip), ('secondaryip', secondaryip), ('admin_state', admin_state), ('operation_state', operation_state), ('out_bandwidth', out_bandwidth), ('in_bandwidth', in_bandwidth), ('speed', speed), ('native_vlan', native_vlan), ('portfast', portfast), ('service', service), ('cdp', cdp), ('bpduguard', bpduguard), ('broadcast', broadcast), ('nonegotiate', nonegotiate), ('power_inline', power_inline), ('value', value), ('priority_queue', priority_queue), ('voice_vlan', voice_vlan), ('level', level), ('speed_unit', speed_unit), ('policer_name', policer_name), ('additional_ipv4_address', additional_ipv4_address), ('mls_qos', mls_qos), ('srr_queue', srr_queue), ('additional_ipv6_address', additional_ipv6_address), ('mace_enable', mace_enable), ('port_security', port_security), ('allowed_vlans', allowed_vlans), ('ospf', ospf), ('eigrp', eigrp), ('unit', unit), ('vlan_count', vlan_count), ('context_name', context_name), ('visible_interface', visible_interface), ('inside_name', inside_name), ('security_level_inside', security_level_inside), ('mpls_device_role', mpls_device_role), ('inner_vlan', inner_vlan), ('outbound_qos', outbound_qos), ('inbound_qos', inbound_qos), ('load_interval_delay', load_interval_delay), ('bridge_group', bridge_group), ('bridge_acl_inbound', bridge_acl_inbound), ('in_queue_length', in_queue_length), ('out_queue_length', out_queue_length), ('link_negotiation', link_negotiation), ('vrf_receive', vrf_receive), ('bgp_policy', bgp_policy), ('bgp_policy_qos', bgp_policy_qos), ('pbr_policy', pbr_policy), ('vrf_definition_mode', vrf_definition_mode), ('encap_mode', encap_mode), ('port_number', port_number), ('mgmt_profile', mgmt_profile), ('address1_comment', address1_comment), ('address2_comment', address2_comment), ('rpf_check', rpf_check), ('postscrub_unit', postscrub_unit), ('keepalive_time', keepalive_time), ('virtual_ethernet_number', virtual_ethernet_number), ('ethernet_number_vpls', ethernet_number_vpls), ('cos', cos), ('port_number_vpls', port_number_vpls), ('slot_number', slot_number), ('full_slot_number', full_slot_number), ('slot_module_number', slot_module_number), ('vpn_instance_name', vpn_instance_name), ('vsi_vlan_name', vsi_vlan_name), ('port_type', port_type), ('if_type', if_type), ('arp_timeout', arp_timeout), ('port_number_vlan', port_number_vlan), ('vpls_name', vpls_name), ('bandwidth', bandwidth), ('delay', delay), ('maximum_segment_size', maximum_segment_size), ('nat_name', nat_name), ('minimum_links', minimum_links), ('link_speed', link_speed), ('duplex', duplex), ('fcoe_lag', fcoe_lag), ('lacp_active_enable', lacp_active_enable), ('lacp_active_periodic_fast', lacp_active_periodic_fast), ('vlan', vlan), ('port_channel_name', port_channel_name), ('channel_group_mode', channel_group_mode), ('channel_protocol', channel_protocol), ('vrf', vrf), ('bfd_name', bfd_name), ('vrrp', vrrp), ('acl_inbound_name', acl_inbound_name), ('acl_outbound_name', acl_outbound_name), ('context_name', context_name), ('source_ip', source_ip), ('destination_ip', destination_ip), ('destination_vrf', destination_vrf), ('port_qos_group_template', port_qos_group_template), ('port_qos_scheduler_policy', port_qos_scheduler_policy), ('rate_limit', rate_limit), ('hsrp', hsrp), ])


