
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import get_network_by_type_and_cidn
import get_network_by_ipaddress
import get_ipaddresses_from_network
import get_context_outside_ipaddresses
import get_context_inside_ipaddresses
import get_all_reservations
import create_cpe_nat_reservation
import get_all_network_containers
import add_a_network_container
import delete_network_container
import delete_a_record
import delete_network
import delete_host_record
import get_specific_host_by_ip_address
import get_all_hosts
import get_specific_a_record_by_ip_address
import get_all_a_records
import next_available_customer_network
import get_common_customer_subnet
import get_customer_specific_network_container
import get_customer_specific_network
import add_network_to_infoblox
import next_available_ips
import reserve_host_record_with_ext_attributes
import get_network_list
import get_network_list_with_ext_attributes
import get_network_containers_with_ext_attributes
import get_network_container_by_specific_ext_attribute
import get_network_by_specific_ext_attribute
import reserve_a_record_with_ext_attributes
import create_context_inside_reservation
import create_dns_host_reservation
import create_dns_a_reservation
import delete_dns_host_reservation
import delete_dns_a_reservation
class infoblox(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infoblox - based on the path /infoblox_rpc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__get_network_by_type_and_cidn','__get_network_by_ipaddress','__get_ipaddresses_from_network','__get_context_outside_ipaddresses','__get_context_inside_ipaddresses','__get_all_reservations','__create_cpe_nat_reservation','__get_all_network_containers','__add_a_network_container','__delete_network_container','__delete_a_record','__delete_network','__delete_host_record','__get_specific_host_by_ip_address','__get_all_hosts','__get_specific_a_record_by_ip_address','__get_all_a_records','__next_available_customer_network','__get_common_customer_subnet','__get_customer_specific_network_container','__get_customer_specific_network','__add_network_to_infoblox','__next_available_ips','__reserve_host_record_with_ext_attributes','__get_network_list','__get_network_list_with_ext_attributes','__get_network_containers_with_ext_attributes','__get_network_container_by_specific_ext_attribute','__get_network_by_specific_ext_attribute','__reserve_a_record_with_ext_attributes','__create_context_inside_reservation','__create_dns_host_reservation','__create_dns_a_reservation','__delete_dns_host_reservation','__delete_dns_a_reservation',)

  _yang_name = 'infoblox'
  _module_name = 'infoblox'
  _namespace = 'http://anutanetworks.com/infoblox'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__get_context_outside_ipaddresses = YANGDynClass(base=get_context_outside_ipaddresses.get_context_outside_ipaddresses, is_leaf=True, yang_name="get-context-outside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__delete_network = YANGDynClass(base=delete_network.delete_network, is_leaf=True, yang_name="delete-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_by_ipaddress = YANGDynClass(base=get_network_by_ipaddress.get_network_by_ipaddress, is_leaf=True, yang_name="get-network-by-ipaddress", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__create_cpe_nat_reservation = YANGDynClass(base=create_cpe_nat_reservation.create_cpe_nat_reservation, is_leaf=True, yang_name="create-cpe-nat-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__create_context_inside_reservation = YANGDynClass(base=create_context_inside_reservation.create_context_inside_reservation, is_leaf=True, yang_name="create-context-inside-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_by_type_and_cidn = YANGDynClass(base=get_network_by_type_and_cidn.get_network_by_type_and_cidn, is_leaf=True, yang_name="get-network-by-type-and-cidn", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_specific_a_record_by_ip_address = YANGDynClass(base=get_specific_a_record_by_ip_address.get_specific_a_record_by_ip_address, is_leaf=True, yang_name="get-specific-a-record-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_by_specific_ext_attribute = YANGDynClass(base=get_network_by_specific_ext_attribute.get_network_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__add_network_to_infoblox = YANGDynClass(base=add_network_to_infoblox.add_network_to_infoblox, is_leaf=True, yang_name="add-network-to-infoblox", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_context_inside_ipaddresses = YANGDynClass(base=get_context_inside_ipaddresses.get_context_inside_ipaddresses, is_leaf=True, yang_name="get-context-inside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__reserve_host_record_with_ext_attributes = YANGDynClass(base=reserve_host_record_with_ext_attributes.reserve_host_record_with_ext_attributes, is_leaf=True, yang_name="reserve-host-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__next_available_customer_network = YANGDynClass(base=next_available_customer_network.next_available_customer_network, is_leaf=True, yang_name="next-available-customer-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_all_network_containers = YANGDynClass(base=get_all_network_containers.get_all_network_containers, is_leaf=True, yang_name="get-all-network-containers", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__add_a_network_container = YANGDynClass(base=add_a_network_container.add_a_network_container, is_leaf=True, yang_name="add-a-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__delete_a_record = YANGDynClass(base=delete_a_record.delete_a_record, is_leaf=True, yang_name="delete-a-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__create_dns_host_reservation = YANGDynClass(base=create_dns_host_reservation.create_dns_host_reservation, is_leaf=True, yang_name="create-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_container_by_specific_ext_attribute = YANGDynClass(base=get_network_container_by_specific_ext_attribute.get_network_container_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-container-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_specific_host_by_ip_address = YANGDynClass(base=get_specific_host_by_ip_address.get_specific_host_by_ip_address, is_leaf=True, yang_name="get-specific-host-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__create_dns_a_reservation = YANGDynClass(base=create_dns_a_reservation.create_dns_a_reservation, is_leaf=True, yang_name="create-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_containers_with_ext_attributes = YANGDynClass(base=get_network_containers_with_ext_attributes.get_network_containers_with_ext_attributes, is_leaf=True, yang_name="get-network-containers-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_list = YANGDynClass(base=get_network_list.get_network_list, is_leaf=True, yang_name="get-network-list", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_ipaddresses_from_network = YANGDynClass(base=get_ipaddresses_from_network.get_ipaddresses_from_network, is_leaf=True, yang_name="get-ipaddresses-from-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__next_available_ips = YANGDynClass(base=next_available_ips.next_available_ips, is_leaf=True, yang_name="next-available-ips", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__delete_network_container = YANGDynClass(base=delete_network_container.delete_network_container, is_leaf=True, yang_name="delete-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__delete_host_record = YANGDynClass(base=delete_host_record.delete_host_record, is_leaf=True, yang_name="delete-host-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_customer_specific_network_container = YANGDynClass(base=get_customer_specific_network_container.get_customer_specific_network_container, is_leaf=True, yang_name="get-customer-specific-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__reserve_a_record_with_ext_attributes = YANGDynClass(base=reserve_a_record_with_ext_attributes.reserve_a_record_with_ext_attributes, is_leaf=True, yang_name="reserve-a-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_all_a_records = YANGDynClass(base=get_all_a_records.get_all_a_records, is_leaf=True, yang_name="get-all-a-records", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_all_hosts = YANGDynClass(base=get_all_hosts.get_all_hosts, is_leaf=True, yang_name="get-all-hosts", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__delete_dns_a_reservation = YANGDynClass(base=delete_dns_a_reservation.delete_dns_a_reservation, is_leaf=True, yang_name="delete-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_common_customer_subnet = YANGDynClass(base=get_common_customer_subnet.get_common_customer_subnet, is_leaf=True, yang_name="get-common-customer-subnet", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__delete_dns_host_reservation = YANGDynClass(base=delete_dns_host_reservation.delete_dns_host_reservation, is_leaf=True, yang_name="delete-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_all_reservations = YANGDynClass(base=get_all_reservations.get_all_reservations, is_leaf=True, yang_name="get-all-reservations", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_network_list_with_ext_attributes = YANGDynClass(base=get_network_list_with_ext_attributes.get_network_list_with_ext_attributes, is_leaf=True, yang_name="get-network-list-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    self.__get_customer_specific_network = YANGDynClass(base=get_customer_specific_network.get_customer_specific_network, is_leaf=True, yang_name="get-customer-specific-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'infoblox_rpc']

  def _get_get_network_by_type_and_cidn(self):
    """
    Getter method for get_network_by_type_and_cidn, mapped from YANG variable /infoblox_rpc/get_network_by_type_and_cidn (rpc)
    """
    return self.__get_network_by_type_and_cidn
      
  def _set_get_network_by_type_and_cidn(self, v, load=False):
    """
    Setter method for get_network_by_type_and_cidn, mapped from YANG variable /infoblox_rpc/get_network_by_type_and_cidn (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_by_type_and_cidn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_by_type_and_cidn() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_by_type_and_cidn.get_network_by_type_and_cidn, is_leaf=True, yang_name="get-network-by-type-and-cidn", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_by_type_and_cidn must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_by_type_and_cidn.get_network_by_type_and_cidn, is_leaf=True, yang_name="get-network-by-type-and-cidn", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_by_type_and_cidn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_by_type_and_cidn(self):
    self.__get_network_by_type_and_cidn = YANGDynClass(base=get_network_by_type_and_cidn.get_network_by_type_and_cidn, is_leaf=True, yang_name="get-network-by-type-and-cidn", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_network_by_ipaddress(self):
    """
    Getter method for get_network_by_ipaddress, mapped from YANG variable /infoblox_rpc/get_network_by_ipaddress (rpc)
    """
    return self.__get_network_by_ipaddress
      
  def _set_get_network_by_ipaddress(self, v, load=False):
    """
    Setter method for get_network_by_ipaddress, mapped from YANG variable /infoblox_rpc/get_network_by_ipaddress (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_by_ipaddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_by_ipaddress() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_by_ipaddress.get_network_by_ipaddress, is_leaf=True, yang_name="get-network-by-ipaddress", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_by_ipaddress must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_by_ipaddress.get_network_by_ipaddress, is_leaf=True, yang_name="get-network-by-ipaddress", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_by_ipaddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_by_ipaddress(self):
    self.__get_network_by_ipaddress = YANGDynClass(base=get_network_by_ipaddress.get_network_by_ipaddress, is_leaf=True, yang_name="get-network-by-ipaddress", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_ipaddresses_from_network(self):
    """
    Getter method for get_ipaddresses_from_network, mapped from YANG variable /infoblox_rpc/get_ipaddresses_from_network (rpc)
    """
    return self.__get_ipaddresses_from_network
      
  def _set_get_ipaddresses_from_network(self, v, load=False):
    """
    Setter method for get_ipaddresses_from_network, mapped from YANG variable /infoblox_rpc/get_ipaddresses_from_network (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_ipaddresses_from_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_ipaddresses_from_network() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_ipaddresses_from_network.get_ipaddresses_from_network, is_leaf=True, yang_name="get-ipaddresses-from-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_ipaddresses_from_network must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_ipaddresses_from_network.get_ipaddresses_from_network, is_leaf=True, yang_name="get-ipaddresses-from-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_ipaddresses_from_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_ipaddresses_from_network(self):
    self.__get_ipaddresses_from_network = YANGDynClass(base=get_ipaddresses_from_network.get_ipaddresses_from_network, is_leaf=True, yang_name="get-ipaddresses-from-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_context_outside_ipaddresses(self):
    """
    Getter method for get_context_outside_ipaddresses, mapped from YANG variable /infoblox_rpc/get_context_outside_ipaddresses (rpc)
    """
    return self.__get_context_outside_ipaddresses
      
  def _set_get_context_outside_ipaddresses(self, v, load=False):
    """
    Setter method for get_context_outside_ipaddresses, mapped from YANG variable /infoblox_rpc/get_context_outside_ipaddresses (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_context_outside_ipaddresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_context_outside_ipaddresses() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_context_outside_ipaddresses.get_context_outside_ipaddresses, is_leaf=True, yang_name="get-context-outside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_context_outside_ipaddresses must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_context_outside_ipaddresses.get_context_outside_ipaddresses, is_leaf=True, yang_name="get-context-outside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_context_outside_ipaddresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_context_outside_ipaddresses(self):
    self.__get_context_outside_ipaddresses = YANGDynClass(base=get_context_outside_ipaddresses.get_context_outside_ipaddresses, is_leaf=True, yang_name="get-context-outside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_context_inside_ipaddresses(self):
    """
    Getter method for get_context_inside_ipaddresses, mapped from YANG variable /infoblox_rpc/get_context_inside_ipaddresses (rpc)
    """
    return self.__get_context_inside_ipaddresses
      
  def _set_get_context_inside_ipaddresses(self, v, load=False):
    """
    Setter method for get_context_inside_ipaddresses, mapped from YANG variable /infoblox_rpc/get_context_inside_ipaddresses (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_context_inside_ipaddresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_context_inside_ipaddresses() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_context_inside_ipaddresses.get_context_inside_ipaddresses, is_leaf=True, yang_name="get-context-inside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_context_inside_ipaddresses must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_context_inside_ipaddresses.get_context_inside_ipaddresses, is_leaf=True, yang_name="get-context-inside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_context_inside_ipaddresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_context_inside_ipaddresses(self):
    self.__get_context_inside_ipaddresses = YANGDynClass(base=get_context_inside_ipaddresses.get_context_inside_ipaddresses, is_leaf=True, yang_name="get-context-inside-ipaddresses", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_all_reservations(self):
    """
    Getter method for get_all_reservations, mapped from YANG variable /infoblox_rpc/get_all_reservations (rpc)
    """
    return self.__get_all_reservations
      
  def _set_get_all_reservations(self, v, load=False):
    """
    Setter method for get_all_reservations, mapped from YANG variable /infoblox_rpc/get_all_reservations (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_all_reservations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_all_reservations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_all_reservations.get_all_reservations, is_leaf=True, yang_name="get-all-reservations", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_all_reservations must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_all_reservations.get_all_reservations, is_leaf=True, yang_name="get-all-reservations", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_all_reservations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_all_reservations(self):
    self.__get_all_reservations = YANGDynClass(base=get_all_reservations.get_all_reservations, is_leaf=True, yang_name="get-all-reservations", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_create_cpe_nat_reservation(self):
    """
    Getter method for create_cpe_nat_reservation, mapped from YANG variable /infoblox_rpc/create_cpe_nat_reservation (rpc)
    """
    return self.__create_cpe_nat_reservation
      
  def _set_create_cpe_nat_reservation(self, v, load=False):
    """
    Setter method for create_cpe_nat_reservation, mapped from YANG variable /infoblox_rpc/create_cpe_nat_reservation (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_cpe_nat_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_cpe_nat_reservation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=create_cpe_nat_reservation.create_cpe_nat_reservation, is_leaf=True, yang_name="create-cpe-nat-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_cpe_nat_reservation must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=create_cpe_nat_reservation.create_cpe_nat_reservation, is_leaf=True, yang_name="create-cpe-nat-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__create_cpe_nat_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_cpe_nat_reservation(self):
    self.__create_cpe_nat_reservation = YANGDynClass(base=create_cpe_nat_reservation.create_cpe_nat_reservation, is_leaf=True, yang_name="create-cpe-nat-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_all_network_containers(self):
    """
    Getter method for get_all_network_containers, mapped from YANG variable /infoblox_rpc/get_all_network_containers (rpc)
    """
    return self.__get_all_network_containers
      
  def _set_get_all_network_containers(self, v, load=False):
    """
    Setter method for get_all_network_containers, mapped from YANG variable /infoblox_rpc/get_all_network_containers (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_all_network_containers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_all_network_containers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_all_network_containers.get_all_network_containers, is_leaf=True, yang_name="get-all-network-containers", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_all_network_containers must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_all_network_containers.get_all_network_containers, is_leaf=True, yang_name="get-all-network-containers", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_all_network_containers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_all_network_containers(self):
    self.__get_all_network_containers = YANGDynClass(base=get_all_network_containers.get_all_network_containers, is_leaf=True, yang_name="get-all-network-containers", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_add_a_network_container(self):
    """
    Getter method for add_a_network_container, mapped from YANG variable /infoblox_rpc/add_a_network_container (rpc)
    """
    return self.__add_a_network_container
      
  def _set_add_a_network_container(self, v, load=False):
    """
    Setter method for add_a_network_container, mapped from YANG variable /infoblox_rpc/add_a_network_container (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_add_a_network_container is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_add_a_network_container() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=add_a_network_container.add_a_network_container, is_leaf=True, yang_name="add-a-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """add_a_network_container must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=add_a_network_container.add_a_network_container, is_leaf=True, yang_name="add-a-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__add_a_network_container = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_add_a_network_container(self):
    self.__add_a_network_container = YANGDynClass(base=add_a_network_container.add_a_network_container, is_leaf=True, yang_name="add-a-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_delete_network_container(self):
    """
    Getter method for delete_network_container, mapped from YANG variable /infoblox_rpc/delete_network_container (rpc)
    """
    return self.__delete_network_container
      
  def _set_delete_network_container(self, v, load=False):
    """
    Setter method for delete_network_container, mapped from YANG variable /infoblox_rpc/delete_network_container (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delete_network_container is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delete_network_container() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=delete_network_container.delete_network_container, is_leaf=True, yang_name="delete-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delete_network_container must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=delete_network_container.delete_network_container, is_leaf=True, yang_name="delete-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__delete_network_container = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delete_network_container(self):
    self.__delete_network_container = YANGDynClass(base=delete_network_container.delete_network_container, is_leaf=True, yang_name="delete-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_delete_a_record(self):
    """
    Getter method for delete_a_record, mapped from YANG variable /infoblox_rpc/delete_a_record (rpc)
    """
    return self.__delete_a_record
      
  def _set_delete_a_record(self, v, load=False):
    """
    Setter method for delete_a_record, mapped from YANG variable /infoblox_rpc/delete_a_record (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delete_a_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delete_a_record() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=delete_a_record.delete_a_record, is_leaf=True, yang_name="delete-a-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delete_a_record must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=delete_a_record.delete_a_record, is_leaf=True, yang_name="delete-a-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__delete_a_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delete_a_record(self):
    self.__delete_a_record = YANGDynClass(base=delete_a_record.delete_a_record, is_leaf=True, yang_name="delete-a-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_delete_network(self):
    """
    Getter method for delete_network, mapped from YANG variable /infoblox_rpc/delete_network (rpc)
    """
    return self.__delete_network
      
  def _set_delete_network(self, v, load=False):
    """
    Setter method for delete_network, mapped from YANG variable /infoblox_rpc/delete_network (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delete_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delete_network() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=delete_network.delete_network, is_leaf=True, yang_name="delete-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delete_network must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=delete_network.delete_network, is_leaf=True, yang_name="delete-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__delete_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delete_network(self):
    self.__delete_network = YANGDynClass(base=delete_network.delete_network, is_leaf=True, yang_name="delete-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_delete_host_record(self):
    """
    Getter method for delete_host_record, mapped from YANG variable /infoblox_rpc/delete_host_record (rpc)
    """
    return self.__delete_host_record
      
  def _set_delete_host_record(self, v, load=False):
    """
    Setter method for delete_host_record, mapped from YANG variable /infoblox_rpc/delete_host_record (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delete_host_record is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delete_host_record() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=delete_host_record.delete_host_record, is_leaf=True, yang_name="delete-host-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delete_host_record must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=delete_host_record.delete_host_record, is_leaf=True, yang_name="delete-host-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__delete_host_record = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delete_host_record(self):
    self.__delete_host_record = YANGDynClass(base=delete_host_record.delete_host_record, is_leaf=True, yang_name="delete-host-record", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_specific_host_by_ip_address(self):
    """
    Getter method for get_specific_host_by_ip_address, mapped from YANG variable /infoblox_rpc/get_specific_host_by_ip_address (rpc)
    """
    return self.__get_specific_host_by_ip_address
      
  def _set_get_specific_host_by_ip_address(self, v, load=False):
    """
    Setter method for get_specific_host_by_ip_address, mapped from YANG variable /infoblox_rpc/get_specific_host_by_ip_address (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_specific_host_by_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_specific_host_by_ip_address() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_specific_host_by_ip_address.get_specific_host_by_ip_address, is_leaf=True, yang_name="get-specific-host-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_specific_host_by_ip_address must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_specific_host_by_ip_address.get_specific_host_by_ip_address, is_leaf=True, yang_name="get-specific-host-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_specific_host_by_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_specific_host_by_ip_address(self):
    self.__get_specific_host_by_ip_address = YANGDynClass(base=get_specific_host_by_ip_address.get_specific_host_by_ip_address, is_leaf=True, yang_name="get-specific-host-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_all_hosts(self):
    """
    Getter method for get_all_hosts, mapped from YANG variable /infoblox_rpc/get_all_hosts (rpc)
    """
    return self.__get_all_hosts
      
  def _set_get_all_hosts(self, v, load=False):
    """
    Setter method for get_all_hosts, mapped from YANG variable /infoblox_rpc/get_all_hosts (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_all_hosts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_all_hosts() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_all_hosts.get_all_hosts, is_leaf=True, yang_name="get-all-hosts", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_all_hosts must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_all_hosts.get_all_hosts, is_leaf=True, yang_name="get-all-hosts", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_all_hosts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_all_hosts(self):
    self.__get_all_hosts = YANGDynClass(base=get_all_hosts.get_all_hosts, is_leaf=True, yang_name="get-all-hosts", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_specific_a_record_by_ip_address(self):
    """
    Getter method for get_specific_a_record_by_ip_address, mapped from YANG variable /infoblox_rpc/get_specific_a_record_by_ip_address (rpc)
    """
    return self.__get_specific_a_record_by_ip_address
      
  def _set_get_specific_a_record_by_ip_address(self, v, load=False):
    """
    Setter method for get_specific_a_record_by_ip_address, mapped from YANG variable /infoblox_rpc/get_specific_a_record_by_ip_address (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_specific_a_record_by_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_specific_a_record_by_ip_address() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_specific_a_record_by_ip_address.get_specific_a_record_by_ip_address, is_leaf=True, yang_name="get-specific-a-record-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_specific_a_record_by_ip_address must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_specific_a_record_by_ip_address.get_specific_a_record_by_ip_address, is_leaf=True, yang_name="get-specific-a-record-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_specific_a_record_by_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_specific_a_record_by_ip_address(self):
    self.__get_specific_a_record_by_ip_address = YANGDynClass(base=get_specific_a_record_by_ip_address.get_specific_a_record_by_ip_address, is_leaf=True, yang_name="get-specific-a-record-by-ip-address", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_all_a_records(self):
    """
    Getter method for get_all_a_records, mapped from YANG variable /infoblox_rpc/get_all_a_records (rpc)
    """
    return self.__get_all_a_records
      
  def _set_get_all_a_records(self, v, load=False):
    """
    Setter method for get_all_a_records, mapped from YANG variable /infoblox_rpc/get_all_a_records (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_all_a_records is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_all_a_records() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_all_a_records.get_all_a_records, is_leaf=True, yang_name="get-all-a-records", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_all_a_records must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_all_a_records.get_all_a_records, is_leaf=True, yang_name="get-all-a-records", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_all_a_records = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_all_a_records(self):
    self.__get_all_a_records = YANGDynClass(base=get_all_a_records.get_all_a_records, is_leaf=True, yang_name="get-all-a-records", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_next_available_customer_network(self):
    """
    Getter method for next_available_customer_network, mapped from YANG variable /infoblox_rpc/next_available_customer_network (rpc)
    """
    return self.__next_available_customer_network
      
  def _set_next_available_customer_network(self, v, load=False):
    """
    Setter method for next_available_customer_network, mapped from YANG variable /infoblox_rpc/next_available_customer_network (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_available_customer_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_available_customer_network() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=next_available_customer_network.next_available_customer_network, is_leaf=True, yang_name="next-available-customer-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_available_customer_network must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=next_available_customer_network.next_available_customer_network, is_leaf=True, yang_name="next-available-customer-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__next_available_customer_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_available_customer_network(self):
    self.__next_available_customer_network = YANGDynClass(base=next_available_customer_network.next_available_customer_network, is_leaf=True, yang_name="next-available-customer-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_common_customer_subnet(self):
    """
    Getter method for get_common_customer_subnet, mapped from YANG variable /infoblox_rpc/get_common_customer_subnet (rpc)
    """
    return self.__get_common_customer_subnet
      
  def _set_get_common_customer_subnet(self, v, load=False):
    """
    Setter method for get_common_customer_subnet, mapped from YANG variable /infoblox_rpc/get_common_customer_subnet (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_common_customer_subnet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_common_customer_subnet() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_common_customer_subnet.get_common_customer_subnet, is_leaf=True, yang_name="get-common-customer-subnet", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_common_customer_subnet must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_common_customer_subnet.get_common_customer_subnet, is_leaf=True, yang_name="get-common-customer-subnet", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_common_customer_subnet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_common_customer_subnet(self):
    self.__get_common_customer_subnet = YANGDynClass(base=get_common_customer_subnet.get_common_customer_subnet, is_leaf=True, yang_name="get-common-customer-subnet", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_customer_specific_network_container(self):
    """
    Getter method for get_customer_specific_network_container, mapped from YANG variable /infoblox_rpc/get_customer_specific_network_container (rpc)
    """
    return self.__get_customer_specific_network_container
      
  def _set_get_customer_specific_network_container(self, v, load=False):
    """
    Setter method for get_customer_specific_network_container, mapped from YANG variable /infoblox_rpc/get_customer_specific_network_container (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_customer_specific_network_container is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_customer_specific_network_container() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_customer_specific_network_container.get_customer_specific_network_container, is_leaf=True, yang_name="get-customer-specific-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_customer_specific_network_container must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_customer_specific_network_container.get_customer_specific_network_container, is_leaf=True, yang_name="get-customer-specific-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_customer_specific_network_container = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_customer_specific_network_container(self):
    self.__get_customer_specific_network_container = YANGDynClass(base=get_customer_specific_network_container.get_customer_specific_network_container, is_leaf=True, yang_name="get-customer-specific-network-container", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_customer_specific_network(self):
    """
    Getter method for get_customer_specific_network, mapped from YANG variable /infoblox_rpc/get_customer_specific_network (rpc)
    """
    return self.__get_customer_specific_network
      
  def _set_get_customer_specific_network(self, v, load=False):
    """
    Setter method for get_customer_specific_network, mapped from YANG variable /infoblox_rpc/get_customer_specific_network (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_customer_specific_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_customer_specific_network() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_customer_specific_network.get_customer_specific_network, is_leaf=True, yang_name="get-customer-specific-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_customer_specific_network must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_customer_specific_network.get_customer_specific_network, is_leaf=True, yang_name="get-customer-specific-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_customer_specific_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_customer_specific_network(self):
    self.__get_customer_specific_network = YANGDynClass(base=get_customer_specific_network.get_customer_specific_network, is_leaf=True, yang_name="get-customer-specific-network", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_add_network_to_infoblox(self):
    """
    Getter method for add_network_to_infoblox, mapped from YANG variable /infoblox_rpc/add_network_to_infoblox (rpc)
    """
    return self.__add_network_to_infoblox
      
  def _set_add_network_to_infoblox(self, v, load=False):
    """
    Setter method for add_network_to_infoblox, mapped from YANG variable /infoblox_rpc/add_network_to_infoblox (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_add_network_to_infoblox is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_add_network_to_infoblox() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=add_network_to_infoblox.add_network_to_infoblox, is_leaf=True, yang_name="add-network-to-infoblox", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """add_network_to_infoblox must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=add_network_to_infoblox.add_network_to_infoblox, is_leaf=True, yang_name="add-network-to-infoblox", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__add_network_to_infoblox = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_add_network_to_infoblox(self):
    self.__add_network_to_infoblox = YANGDynClass(base=add_network_to_infoblox.add_network_to_infoblox, is_leaf=True, yang_name="add-network-to-infoblox", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_next_available_ips(self):
    """
    Getter method for next_available_ips, mapped from YANG variable /infoblox_rpc/next_available_ips (rpc)
    """
    return self.__next_available_ips
      
  def _set_next_available_ips(self, v, load=False):
    """
    Setter method for next_available_ips, mapped from YANG variable /infoblox_rpc/next_available_ips (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_available_ips is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_available_ips() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=next_available_ips.next_available_ips, is_leaf=True, yang_name="next-available-ips", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_available_ips must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=next_available_ips.next_available_ips, is_leaf=True, yang_name="next-available-ips", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__next_available_ips = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_available_ips(self):
    self.__next_available_ips = YANGDynClass(base=next_available_ips.next_available_ips, is_leaf=True, yang_name="next-available-ips", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_reserve_host_record_with_ext_attributes(self):
    """
    Getter method for reserve_host_record_with_ext_attributes, mapped from YANG variable /infoblox_rpc/reserve_host_record_with_ext_attributes (rpc)
    """
    return self.__reserve_host_record_with_ext_attributes
      
  def _set_reserve_host_record_with_ext_attributes(self, v, load=False):
    """
    Setter method for reserve_host_record_with_ext_attributes, mapped from YANG variable /infoblox_rpc/reserve_host_record_with_ext_attributes (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve_host_record_with_ext_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve_host_record_with_ext_attributes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=reserve_host_record_with_ext_attributes.reserve_host_record_with_ext_attributes, is_leaf=True, yang_name="reserve-host-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserve_host_record_with_ext_attributes must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=reserve_host_record_with_ext_attributes.reserve_host_record_with_ext_attributes, is_leaf=True, yang_name="reserve-host-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__reserve_host_record_with_ext_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserve_host_record_with_ext_attributes(self):
    self.__reserve_host_record_with_ext_attributes = YANGDynClass(base=reserve_host_record_with_ext_attributes.reserve_host_record_with_ext_attributes, is_leaf=True, yang_name="reserve-host-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_network_list(self):
    """
    Getter method for get_network_list, mapped from YANG variable /infoblox_rpc/get_network_list (rpc)
    """
    return self.__get_network_list
      
  def _set_get_network_list(self, v, load=False):
    """
    Setter method for get_network_list, mapped from YANG variable /infoblox_rpc/get_network_list (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_list() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_list.get_network_list, is_leaf=True, yang_name="get-network-list", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_list must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_list.get_network_list, is_leaf=True, yang_name="get-network-list", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_list(self):
    self.__get_network_list = YANGDynClass(base=get_network_list.get_network_list, is_leaf=True, yang_name="get-network-list", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_network_list_with_ext_attributes(self):
    """
    Getter method for get_network_list_with_ext_attributes, mapped from YANG variable /infoblox_rpc/get_network_list_with_ext_attributes (rpc)
    """
    return self.__get_network_list_with_ext_attributes
      
  def _set_get_network_list_with_ext_attributes(self, v, load=False):
    """
    Setter method for get_network_list_with_ext_attributes, mapped from YANG variable /infoblox_rpc/get_network_list_with_ext_attributes (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_list_with_ext_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_list_with_ext_attributes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_list_with_ext_attributes.get_network_list_with_ext_attributes, is_leaf=True, yang_name="get-network-list-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_list_with_ext_attributes must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_list_with_ext_attributes.get_network_list_with_ext_attributes, is_leaf=True, yang_name="get-network-list-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_list_with_ext_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_list_with_ext_attributes(self):
    self.__get_network_list_with_ext_attributes = YANGDynClass(base=get_network_list_with_ext_attributes.get_network_list_with_ext_attributes, is_leaf=True, yang_name="get-network-list-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_network_containers_with_ext_attributes(self):
    """
    Getter method for get_network_containers_with_ext_attributes, mapped from YANG variable /infoblox_rpc/get_network_containers_with_ext_attributes (rpc)
    """
    return self.__get_network_containers_with_ext_attributes
      
  def _set_get_network_containers_with_ext_attributes(self, v, load=False):
    """
    Setter method for get_network_containers_with_ext_attributes, mapped from YANG variable /infoblox_rpc/get_network_containers_with_ext_attributes (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_containers_with_ext_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_containers_with_ext_attributes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_containers_with_ext_attributes.get_network_containers_with_ext_attributes, is_leaf=True, yang_name="get-network-containers-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_containers_with_ext_attributes must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_containers_with_ext_attributes.get_network_containers_with_ext_attributes, is_leaf=True, yang_name="get-network-containers-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_containers_with_ext_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_containers_with_ext_attributes(self):
    self.__get_network_containers_with_ext_attributes = YANGDynClass(base=get_network_containers_with_ext_attributes.get_network_containers_with_ext_attributes, is_leaf=True, yang_name="get-network-containers-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_network_container_by_specific_ext_attribute(self):
    """
    Getter method for get_network_container_by_specific_ext_attribute, mapped from YANG variable /infoblox_rpc/get_network_container_by_specific_ext_attribute (rpc)
    """
    return self.__get_network_container_by_specific_ext_attribute
      
  def _set_get_network_container_by_specific_ext_attribute(self, v, load=False):
    """
    Setter method for get_network_container_by_specific_ext_attribute, mapped from YANG variable /infoblox_rpc/get_network_container_by_specific_ext_attribute (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_container_by_specific_ext_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_container_by_specific_ext_attribute() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_container_by_specific_ext_attribute.get_network_container_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-container-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_container_by_specific_ext_attribute must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_container_by_specific_ext_attribute.get_network_container_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-container-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_container_by_specific_ext_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_container_by_specific_ext_attribute(self):
    self.__get_network_container_by_specific_ext_attribute = YANGDynClass(base=get_network_container_by_specific_ext_attribute.get_network_container_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-container-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_get_network_by_specific_ext_attribute(self):
    """
    Getter method for get_network_by_specific_ext_attribute, mapped from YANG variable /infoblox_rpc/get_network_by_specific_ext_attribute (rpc)
    """
    return self.__get_network_by_specific_ext_attribute
      
  def _set_get_network_by_specific_ext_attribute(self, v, load=False):
    """
    Setter method for get_network_by_specific_ext_attribute, mapped from YANG variable /infoblox_rpc/get_network_by_specific_ext_attribute (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_network_by_specific_ext_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_network_by_specific_ext_attribute() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_network_by_specific_ext_attribute.get_network_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_network_by_specific_ext_attribute must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_network_by_specific_ext_attribute.get_network_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__get_network_by_specific_ext_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_network_by_specific_ext_attribute(self):
    self.__get_network_by_specific_ext_attribute = YANGDynClass(base=get_network_by_specific_ext_attribute.get_network_by_specific_ext_attribute, is_leaf=True, yang_name="get-network-by-specific-ext-attribute", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_reserve_a_record_with_ext_attributes(self):
    """
    Getter method for reserve_a_record_with_ext_attributes, mapped from YANG variable /infoblox_rpc/reserve_a_record_with_ext_attributes (rpc)
    """
    return self.__reserve_a_record_with_ext_attributes
      
  def _set_reserve_a_record_with_ext_attributes(self, v, load=False):
    """
    Setter method for reserve_a_record_with_ext_attributes, mapped from YANG variable /infoblox_rpc/reserve_a_record_with_ext_attributes (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve_a_record_with_ext_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve_a_record_with_ext_attributes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=reserve_a_record_with_ext_attributes.reserve_a_record_with_ext_attributes, is_leaf=True, yang_name="reserve-a-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserve_a_record_with_ext_attributes must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=reserve_a_record_with_ext_attributes.reserve_a_record_with_ext_attributes, is_leaf=True, yang_name="reserve-a-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__reserve_a_record_with_ext_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserve_a_record_with_ext_attributes(self):
    self.__reserve_a_record_with_ext_attributes = YANGDynClass(base=reserve_a_record_with_ext_attributes.reserve_a_record_with_ext_attributes, is_leaf=True, yang_name="reserve-a-record-with-ext-attributes", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_create_context_inside_reservation(self):
    """
    Getter method for create_context_inside_reservation, mapped from YANG variable /infoblox_rpc/create_context_inside_reservation (rpc)
    """
    return self.__create_context_inside_reservation
      
  def _set_create_context_inside_reservation(self, v, load=False):
    """
    Setter method for create_context_inside_reservation, mapped from YANG variable /infoblox_rpc/create_context_inside_reservation (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_context_inside_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_context_inside_reservation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=create_context_inside_reservation.create_context_inside_reservation, is_leaf=True, yang_name="create-context-inside-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_context_inside_reservation must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=create_context_inside_reservation.create_context_inside_reservation, is_leaf=True, yang_name="create-context-inside-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__create_context_inside_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_context_inside_reservation(self):
    self.__create_context_inside_reservation = YANGDynClass(base=create_context_inside_reservation.create_context_inside_reservation, is_leaf=True, yang_name="create-context-inside-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_create_dns_host_reservation(self):
    """
    Getter method for create_dns_host_reservation, mapped from YANG variable /infoblox_rpc/create_dns_host_reservation (rpc)
    """
    return self.__create_dns_host_reservation
      
  def _set_create_dns_host_reservation(self, v, load=False):
    """
    Setter method for create_dns_host_reservation, mapped from YANG variable /infoblox_rpc/create_dns_host_reservation (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_dns_host_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_dns_host_reservation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=create_dns_host_reservation.create_dns_host_reservation, is_leaf=True, yang_name="create-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_dns_host_reservation must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=create_dns_host_reservation.create_dns_host_reservation, is_leaf=True, yang_name="create-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__create_dns_host_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_dns_host_reservation(self):
    self.__create_dns_host_reservation = YANGDynClass(base=create_dns_host_reservation.create_dns_host_reservation, is_leaf=True, yang_name="create-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_create_dns_a_reservation(self):
    """
    Getter method for create_dns_a_reservation, mapped from YANG variable /infoblox_rpc/create_dns_a_reservation (rpc)
    """
    return self.__create_dns_a_reservation
      
  def _set_create_dns_a_reservation(self, v, load=False):
    """
    Setter method for create_dns_a_reservation, mapped from YANG variable /infoblox_rpc/create_dns_a_reservation (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_dns_a_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_dns_a_reservation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=create_dns_a_reservation.create_dns_a_reservation, is_leaf=True, yang_name="create-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_dns_a_reservation must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=create_dns_a_reservation.create_dns_a_reservation, is_leaf=True, yang_name="create-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__create_dns_a_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_dns_a_reservation(self):
    self.__create_dns_a_reservation = YANGDynClass(base=create_dns_a_reservation.create_dns_a_reservation, is_leaf=True, yang_name="create-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_delete_dns_host_reservation(self):
    """
    Getter method for delete_dns_host_reservation, mapped from YANG variable /infoblox_rpc/delete_dns_host_reservation (rpc)
    """
    return self.__delete_dns_host_reservation
      
  def _set_delete_dns_host_reservation(self, v, load=False):
    """
    Setter method for delete_dns_host_reservation, mapped from YANG variable /infoblox_rpc/delete_dns_host_reservation (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delete_dns_host_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delete_dns_host_reservation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=delete_dns_host_reservation.delete_dns_host_reservation, is_leaf=True, yang_name="delete-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delete_dns_host_reservation must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=delete_dns_host_reservation.delete_dns_host_reservation, is_leaf=True, yang_name="delete-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__delete_dns_host_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delete_dns_host_reservation(self):
    self.__delete_dns_host_reservation = YANGDynClass(base=delete_dns_host_reservation.delete_dns_host_reservation, is_leaf=True, yang_name="delete-dns-host-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)


  def _get_delete_dns_a_reservation(self):
    """
    Getter method for delete_dns_a_reservation, mapped from YANG variable /infoblox_rpc/delete_dns_a_reservation (rpc)
    """
    return self.__delete_dns_a_reservation
      
  def _set_delete_dns_a_reservation(self, v, load=False):
    """
    Setter method for delete_dns_a_reservation, mapped from YANG variable /infoblox_rpc/delete_dns_a_reservation (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delete_dns_a_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delete_dns_a_reservation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=delete_dns_a_reservation.delete_dns_a_reservation, is_leaf=True, yang_name="delete-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delete_dns_a_reservation must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=delete_dns_a_reservation.delete_dns_a_reservation, is_leaf=True, yang_name="delete-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)""",
        })

    self.__delete_dns_a_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delete_dns_a_reservation(self):
    self.__delete_dns_a_reservation = YANGDynClass(base=delete_dns_a_reservation.delete_dns_a_reservation, is_leaf=True, yang_name="delete-dns-a-reservation", module_name="infoblox", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/infoblox', defining_module='infoblox', yang_type='rpc', is_config=True)

  get_network_by_type_and_cidn = __builtin__.property(_get_get_network_by_type_and_cidn, _set_get_network_by_type_and_cidn)
  get_network_by_ipaddress = __builtin__.property(_get_get_network_by_ipaddress, _set_get_network_by_ipaddress)
  get_ipaddresses_from_network = __builtin__.property(_get_get_ipaddresses_from_network, _set_get_ipaddresses_from_network)
  get_context_outside_ipaddresses = __builtin__.property(_get_get_context_outside_ipaddresses, _set_get_context_outside_ipaddresses)
  get_context_inside_ipaddresses = __builtin__.property(_get_get_context_inside_ipaddresses, _set_get_context_inside_ipaddresses)
  get_all_reservations = __builtin__.property(_get_get_all_reservations, _set_get_all_reservations)
  create_cpe_nat_reservation = __builtin__.property(_get_create_cpe_nat_reservation, _set_create_cpe_nat_reservation)
  get_all_network_containers = __builtin__.property(_get_get_all_network_containers, _set_get_all_network_containers)
  add_a_network_container = __builtin__.property(_get_add_a_network_container, _set_add_a_network_container)
  delete_network_container = __builtin__.property(_get_delete_network_container, _set_delete_network_container)
  delete_a_record = __builtin__.property(_get_delete_a_record, _set_delete_a_record)
  delete_network = __builtin__.property(_get_delete_network, _set_delete_network)
  delete_host_record = __builtin__.property(_get_delete_host_record, _set_delete_host_record)
  get_specific_host_by_ip_address = __builtin__.property(_get_get_specific_host_by_ip_address, _set_get_specific_host_by_ip_address)
  get_all_hosts = __builtin__.property(_get_get_all_hosts, _set_get_all_hosts)
  get_specific_a_record_by_ip_address = __builtin__.property(_get_get_specific_a_record_by_ip_address, _set_get_specific_a_record_by_ip_address)
  get_all_a_records = __builtin__.property(_get_get_all_a_records, _set_get_all_a_records)
  next_available_customer_network = __builtin__.property(_get_next_available_customer_network, _set_next_available_customer_network)
  get_common_customer_subnet = __builtin__.property(_get_get_common_customer_subnet, _set_get_common_customer_subnet)
  get_customer_specific_network_container = __builtin__.property(_get_get_customer_specific_network_container, _set_get_customer_specific_network_container)
  get_customer_specific_network = __builtin__.property(_get_get_customer_specific_network, _set_get_customer_specific_network)
  add_network_to_infoblox = __builtin__.property(_get_add_network_to_infoblox, _set_add_network_to_infoblox)
  next_available_ips = __builtin__.property(_get_next_available_ips, _set_next_available_ips)
  reserve_host_record_with_ext_attributes = __builtin__.property(_get_reserve_host_record_with_ext_attributes, _set_reserve_host_record_with_ext_attributes)
  get_network_list = __builtin__.property(_get_get_network_list, _set_get_network_list)
  get_network_list_with_ext_attributes = __builtin__.property(_get_get_network_list_with_ext_attributes, _set_get_network_list_with_ext_attributes)
  get_network_containers_with_ext_attributes = __builtin__.property(_get_get_network_containers_with_ext_attributes, _set_get_network_containers_with_ext_attributes)
  get_network_container_by_specific_ext_attribute = __builtin__.property(_get_get_network_container_by_specific_ext_attribute, _set_get_network_container_by_specific_ext_attribute)
  get_network_by_specific_ext_attribute = __builtin__.property(_get_get_network_by_specific_ext_attribute, _set_get_network_by_specific_ext_attribute)
  reserve_a_record_with_ext_attributes = __builtin__.property(_get_reserve_a_record_with_ext_attributes, _set_reserve_a_record_with_ext_attributes)
  create_context_inside_reservation = __builtin__.property(_get_create_context_inside_reservation, _set_create_context_inside_reservation)
  create_dns_host_reservation = __builtin__.property(_get_create_dns_host_reservation, _set_create_dns_host_reservation)
  create_dns_a_reservation = __builtin__.property(_get_create_dns_a_reservation, _set_create_dns_a_reservation)
  delete_dns_host_reservation = __builtin__.property(_get_delete_dns_host_reservation, _set_delete_dns_host_reservation)
  delete_dns_a_reservation = __builtin__.property(_get_delete_dns_a_reservation, _set_delete_dns_a_reservation)


  _pyangbind_elements = collections.OrderedDict([('get_network_by_type_and_cidn', get_network_by_type_and_cidn), ('get_network_by_ipaddress', get_network_by_ipaddress), ('get_ipaddresses_from_network', get_ipaddresses_from_network), ('get_context_outside_ipaddresses', get_context_outside_ipaddresses), ('get_context_inside_ipaddresses', get_context_inside_ipaddresses), ('get_all_reservations', get_all_reservations), ('create_cpe_nat_reservation', create_cpe_nat_reservation), ('get_all_network_containers', get_all_network_containers), ('add_a_network_container', add_a_network_container), ('delete_network_container', delete_network_container), ('delete_a_record', delete_a_record), ('delete_network', delete_network), ('delete_host_record', delete_host_record), ('get_specific_host_by_ip_address', get_specific_host_by_ip_address), ('get_all_hosts', get_all_hosts), ('get_specific_a_record_by_ip_address', get_specific_a_record_by_ip_address), ('get_all_a_records', get_all_a_records), ('next_available_customer_network', next_available_customer_network), ('get_common_customer_subnet', get_common_customer_subnet), ('get_customer_specific_network_container', get_customer_specific_network_container), ('get_customer_specific_network', get_customer_specific_network), ('add_network_to_infoblox', add_network_to_infoblox), ('next_available_ips', next_available_ips), ('reserve_host_record_with_ext_attributes', reserve_host_record_with_ext_attributes), ('get_network_list', get_network_list), ('get_network_list_with_ext_attributes', get_network_list_with_ext_attributes), ('get_network_containers_with_ext_attributes', get_network_containers_with_ext_attributes), ('get_network_container_by_specific_ext_attribute', get_network_container_by_specific_ext_attribute), ('get_network_by_specific_ext_attribute', get_network_by_specific_ext_attribute), ('reserve_a_record_with_ext_attributes', reserve_a_record_with_ext_attributes), ('create_context_inside_reservation', create_context_inside_reservation), ('create_dns_host_reservation', create_dns_host_reservation), ('create_dns_a_reservation', create_dns_a_reservation), ('delete_dns_host_reservation', delete_dns_host_reservation), ('delete_dns_a_reservation', delete_dns_a_reservation), ])


