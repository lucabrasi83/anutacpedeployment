
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import policy
class template(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device-comp - based on the path /compliance-templates/template. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A compliance template is a definition of 
  what aspects of the configuration are being verified and 
  which standard (HIPAA, SOX etc) is being addressed by this template etc
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__description','__enabled','__reference','__policy',)

  _yang_name = 'template'
  _module_name = 'device-comp'
  _namespace = 'http://anutanetworks.com/device-comp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__policy = YANGDynClass(base=YANGListType("id",policy.policy, yang_name="policy", module_name="device-comp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="policy", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='list', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)
    self.__reference = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reference", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'compliance-templates', u'template']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /compliance_templates/template/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /compliance_templates/template/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /compliance_templates/template/description (ndt:cdata)

    YANG Description: string
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /compliance_templates/template/description (ndt:cdata)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="description", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with ndt:cdata""",
          'defined-type': "ndt:cdata",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=unicode, is_leaf=True, yang_name="description", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /compliance_templates/template/enabled (boolean)

    YANG Description: enabled: True/False
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /compliance_templates/template/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: enabled: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)


  def _get_reference(self):
    """
    Getter method for reference, mapped from YANG variable /compliance_templates/template/reference (ndt:cdata)

    YANG Description: Provide any references such as standard bodies that govern the compliance, such NSA HIPAA etc. 
It could be an internal specification too, if exists
    """
    return self.__reference
      
  def _set_reference(self, v, load=False):
    """
    Setter method for reference, mapped from YANG variable /compliance_templates/template/reference (ndt:cdata)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reference() directly.

    YANG Description: Provide any references such as standard bodies that govern the compliance, such NSA HIPAA etc. 
It could be an internal specification too, if exists
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reference", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reference must be of a type compatible with ndt:cdata""",
          'defined-type': "ndt:cdata",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reference", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)""",
        })

    self.__reference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reference(self):
    self.__reference = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reference", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='ndt:cdata', is_config=True)


  def _get_policy(self):
    """
    Getter method for policy, mapped from YANG variable /compliance_templates/template/policy (list)

    YANG Description: A compliance policy is made up of 
   1. An optional but recommonded documentation, 
   2. well defined rules and actions.
   When no explicit action is specified an implicit 'report' of the violations will be available.
    """
    return self.__policy
      
  def _set_policy(self, v, load=False):
    """
    Setter method for policy, mapped from YANG variable /compliance_templates/template/policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy() directly.

    YANG Description: A compliance policy is made up of 
   1. An optional but recommonded documentation, 
   2. well defined rules and actions.
   When no explicit action is specified an implicit 'report' of the violations will be available.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("id",policy.policy, yang_name="policy", module_name="device-comp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="policy", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",policy.policy, yang_name="policy", module_name="device-comp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="policy", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='list', is_config=True)""",
        })

    self.__policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy(self):
    self.__policy = YANGDynClass(base=YANGListType("id",policy.policy, yang_name="policy", module_name="device-comp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="policy", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  reference = __builtin__.property(_get_reference, _set_reference)
  policy = __builtin__.property(_get_policy, _set_policy)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('description', description), ('enabled', enabled), ('reference', reference), ('policy', policy), ])


