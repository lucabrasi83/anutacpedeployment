
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import doc
class policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device-comp - based on the path /compliance-templates/template/policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A compliance policy is made up of 
   1. An optional but recommonded documentation, 
   2. well defined rules and actions.
   When no explicit action is specified an implicit 'report' of the violations will be available.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__id','__enabled','__doc','__rule',)

  _yang_name = 'policy'
  _module_name = 'device-comp'
  _namespace = 'http://anutanetworks.com/device-comp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__doc = YANGDynClass(base=doc.doc, is_container='container', yang_name="doc", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)
    self.__rule = YANGDynClass(base=unicode, is_leaf=True, yang_name="rule", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'compliance-templates', u'template', u'policy']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /compliance_templates/template/policy/id (string)

    YANG Description: string
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /compliance_templates/template/policy/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="id", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='string', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /compliance_templates/template/policy/enabled (boolean)

    YANG Description: enabled: True/False
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /compliance_templates/template/policy/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: enabled: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='boolean', is_config=True)


  def _get_doc(self):
    """
    Getter method for doc, mapped from YANG variable /compliance_templates/template/policy/doc (container)

    YANG Description: Captures textual information of the policy. Useful in reporting and for policy authors/reviewers
    """
    return self.__doc
      
  def _set_doc(self, v, load=False):
    """
    Setter method for doc, mapped from YANG variable /compliance_templates/template/policy/doc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_doc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_doc() directly.

    YANG Description: Captures textual information of the policy. Useful in reporting and for policy authors/reviewers
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=doc.doc, is_container='container', yang_name="doc", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """doc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=doc.doc, is_container='container', yang_name="doc", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)""",
        })

    self.__doc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_doc(self):
    self.__doc = YANGDynClass(base=doc.doc, is_container='container', yang_name="doc", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)


  def _get_rule(self):
    """
    Getter method for rule, mapped from YANG variable /compliance_templates/template/policy/rule (leafref)

    YANG Description: rule
    """
    return self.__rule
      
  def _set_rule(self, v, load=False):
    """
    Setter method for rule, mapped from YANG variable /compliance_templates/template/policy/rule (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule() directly.

    YANG Description: rule
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="rule", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rule", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='leafref', is_config=True)""",
        })

    self.__rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule(self):
    self.__rule = YANGDynClass(base=unicode, is_leaf=True, yang_name="rule", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  doc = __builtin__.property(_get_doc, _set_doc)
  rule = __builtin__.property(_get_rule, _set_rule)


  _pyangbind_elements = collections.OrderedDict([('id', id), ('enabled', enabled), ('doc', doc), ('rule', rule), ])


