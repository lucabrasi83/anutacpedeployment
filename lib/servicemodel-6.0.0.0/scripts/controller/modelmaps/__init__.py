
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import map_
import enumMap
class modelmaps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /modelmaps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__enableSync','__map_','__enumMap',)

  _yang_name = 'modelmaps'
  _module_name = 'controller'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enableSync = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enableSync", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__enumMap = YANGDynClass(base=YANGListType("naasEnum",enumMap.enumMap, yang_name="enumMap", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='naasEnum'), is_container='list', yang_name="enumMap", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)
    self.__map_ = YANGDynClass(base=YANGListType("id",map_.map_, yang_name="map", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="map", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'modelmaps']

  def _get_enableSync(self):
    """
    Getter method for enableSync, mapped from YANG variable /modelmaps/enableSync (boolean)

    YANG Description: This property enables or disables synchronization of data between Yang data and non Yang data. When enabled, system will 
populate yang models with data from NCX tables. This process may take few minutes based on the amount of data there is.
    """
    return self.__enableSync
      
  def _set_enableSync(self, v, load=False):
    """
    Setter method for enableSync, mapped from YANG variable /modelmaps/enableSync (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enableSync is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enableSync() directly.

    YANG Description: This property enables or disables synchronization of data between Yang data and non Yang data. When enabled, system will 
populate yang models with data from NCX tables. This process may take few minutes based on the amount of data there is.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enableSync", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enableSync must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enableSync", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__enableSync = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enableSync(self):
    self.__enableSync = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enableSync", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_map_(self):
    """
    Getter method for map_, mapped from YANG variable /modelmaps/map (list)
    """
    return self.__map_
      
  def _set_map_(self, v, load=False):
    """
    Setter method for map_, mapped from YANG variable /modelmaps/map (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_map_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_map_() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("id",map_.map_, yang_name="map", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="map", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """map_ must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",map_.map_, yang_name="map", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="map", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)""",
        })

    self.__map_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_map_(self):
    self.__map_ = YANGDynClass(base=YANGListType("id",map_.map_, yang_name="map", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id'), is_container='list', yang_name="map", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)


  def _get_enumMap(self):
    """
    Getter method for enumMap, mapped from YANG variable /modelmaps/enumMap (list)
    """
    return self.__enumMap
      
  def _set_enumMap(self, v, load=False):
    """
    Setter method for enumMap, mapped from YANG variable /modelmaps/enumMap (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enumMap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enumMap() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("naasEnum",enumMap.enumMap, yang_name="enumMap", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='naasEnum'), is_container='list', yang_name="enumMap", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enumMap must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("naasEnum",enumMap.enumMap, yang_name="enumMap", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='naasEnum'), is_container='list', yang_name="enumMap", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)""",
        })

    self.__enumMap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enumMap(self):
    self.__enumMap = YANGDynClass(base=YANGListType("naasEnum",enumMap.enumMap, yang_name="enumMap", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='naasEnum'), is_container='list', yang_name="enumMap", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)

  enableSync = __builtin__.property(_get_enableSync, _set_enableSync)
  map_ = __builtin__.property(_get_map_, _set_map_)
  enumMap = __builtin__.property(_get_enumMap, _set_enumMap)


  _pyangbind_elements = collections.OrderedDict([('enableSync', enableSync), ('map_', map_), ('enumMap', enumMap), ])


