
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import get_current_ownership_assignments
import assign_owner_and_shared
import evaluate_xpath
import get_schema_nodes_from_package
import get_valid_identities
import upload_file
import download_file
import apply_data_grouping
import get_ip_from_hostname
import run_device_inventory
import run_extended_inventory
import run_diagnostic_inventory
import subscribe_snmp_traps
import subscribe_syslog_event
import unsubscribe_snmp_traps
import unsubscribe_syslog_event
import retrieve_configs
import mark_maintenance_mode
import clear_maintenance_mode
import show_device_config
import show_device_networkconnections
import load_package
import unload_package
import test_tacacs_connectivity
import test_ad_connectivity
import test_ldap_connectivity
import acknowledge_alarm
import unacknowledge_alarm
import check_connectivity
class controller(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /controller_rpc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__get_current_ownership_assignments','__assign_owner_and_shared','__evaluate_xpath','__get_schema_nodes_from_package','__get_valid_identities','__upload_file','__download_file','__apply_data_grouping','__get_ip_from_hostname','__run_device_inventory','__run_extended_inventory','__run_diagnostic_inventory','__subscribe_snmp_traps','__subscribe_syslog_event','__unsubscribe_snmp_traps','__unsubscribe_syslog_event','__retrieve_configs','__mark_maintenance_mode','__clear_maintenance_mode','__show_device_config','__show_device_networkconnections','__load_package','__unload_package','__test_tacacs_connectivity','__test_ad_connectivity','__test_ldap_connectivity','__acknowledge_alarm','__unacknowledge_alarm','__check_connectivity',)

  _yang_name = 'controller'
  _module_name = 'controller'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__test_ldap_connectivity = YANGDynClass(base=test_ldap_connectivity.test_ldap_connectivity, is_leaf=True, yang_name="test-ldap-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__get_schema_nodes_from_package = YANGDynClass(base=get_schema_nodes_from_package.get_schema_nodes_from_package, is_leaf=True, yang_name="get-schema-nodes-from-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__unacknowledge_alarm = YANGDynClass(base=unacknowledge_alarm.unacknowledge_alarm, is_leaf=True, yang_name="unacknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__show_device_networkconnections = YANGDynClass(base=show_device_networkconnections.show_device_networkconnections, is_leaf=True, yang_name="show-device-networkconnections", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__download_file = YANGDynClass(base=download_file.download_file, is_leaf=True, yang_name="download-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__acknowledge_alarm = YANGDynClass(base=acknowledge_alarm.acknowledge_alarm, is_leaf=True, yang_name="acknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__assign_owner_and_shared = YANGDynClass(base=assign_owner_and_shared.assign_owner_and_shared, is_leaf=True, yang_name="assign-owner-and-shared", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__mark_maintenance_mode = YANGDynClass(base=mark_maintenance_mode.mark_maintenance_mode, is_leaf=True, yang_name="mark-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__test_tacacs_connectivity = YANGDynClass(base=test_tacacs_connectivity.test_tacacs_connectivity, is_leaf=True, yang_name="test-tacacs-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__unsubscribe_snmp_traps = YANGDynClass(base=unsubscribe_snmp_traps.unsubscribe_snmp_traps, is_leaf=True, yang_name="unsubscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__show_device_config = YANGDynClass(base=show_device_config.show_device_config, is_leaf=True, yang_name="show-device-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__test_ad_connectivity = YANGDynClass(base=test_ad_connectivity.test_ad_connectivity, is_leaf=True, yang_name="test-ad-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__clear_maintenance_mode = YANGDynClass(base=clear_maintenance_mode.clear_maintenance_mode, is_leaf=True, yang_name="clear-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__unsubscribe_syslog_event = YANGDynClass(base=unsubscribe_syslog_event.unsubscribe_syslog_event, is_leaf=True, yang_name="unsubscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__apply_data_grouping = YANGDynClass(base=apply_data_grouping.apply_data_grouping, is_leaf=True, yang_name="apply-data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__subscribe_syslog_event = YANGDynClass(base=subscribe_syslog_event.subscribe_syslog_event, is_leaf=True, yang_name="subscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__load_package = YANGDynClass(base=load_package.load_package, is_leaf=True, yang_name="load-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__get_ip_from_hostname = YANGDynClass(base=get_ip_from_hostname.get_ip_from_hostname, is_leaf=True, yang_name="get-ip-from-hostname", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__run_device_inventory = YANGDynClass(base=run_device_inventory.run_device_inventory, is_leaf=True, yang_name="run-device-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__unload_package = YANGDynClass(base=unload_package.unload_package, is_leaf=True, yang_name="unload-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__get_current_ownership_assignments = YANGDynClass(base=get_current_ownership_assignments.get_current_ownership_assignments, is_leaf=True, yang_name="get-current-ownership-assignments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__upload_file = YANGDynClass(base=upload_file.upload_file, is_leaf=True, yang_name="upload-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__run_extended_inventory = YANGDynClass(base=run_extended_inventory.run_extended_inventory, is_leaf=True, yang_name="run-extended-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__subscribe_snmp_traps = YANGDynClass(base=subscribe_snmp_traps.subscribe_snmp_traps, is_leaf=True, yang_name="subscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__get_valid_identities = YANGDynClass(base=get_valid_identities.get_valid_identities, is_leaf=True, yang_name="get-valid-identities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__evaluate_xpath = YANGDynClass(base=evaluate_xpath.evaluate_xpath, is_leaf=True, yang_name="evaluate-xpath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__retrieve_configs = YANGDynClass(base=retrieve_configs.retrieve_configs, is_leaf=True, yang_name="retrieve-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__run_diagnostic_inventory = YANGDynClass(base=run_diagnostic_inventory.run_diagnostic_inventory, is_leaf=True, yang_name="run-diagnostic-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    self.__check_connectivity = YANGDynClass(base=check_connectivity.check_connectivity, is_leaf=True, yang_name="check-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'controller_rpc']

  def _get_get_current_ownership_assignments(self):
    """
    Getter method for get_current_ownership_assignments, mapped from YANG variable /controller_rpc/get_current_ownership_assignments (rpc)
    """
    return self.__get_current_ownership_assignments
      
  def _set_get_current_ownership_assignments(self, v, load=False):
    """
    Setter method for get_current_ownership_assignments, mapped from YANG variable /controller_rpc/get_current_ownership_assignments (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_current_ownership_assignments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_current_ownership_assignments() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_current_ownership_assignments.get_current_ownership_assignments, is_leaf=True, yang_name="get-current-ownership-assignments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_current_ownership_assignments must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_current_ownership_assignments.get_current_ownership_assignments, is_leaf=True, yang_name="get-current-ownership-assignments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__get_current_ownership_assignments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_current_ownership_assignments(self):
    self.__get_current_ownership_assignments = YANGDynClass(base=get_current_ownership_assignments.get_current_ownership_assignments, is_leaf=True, yang_name="get-current-ownership-assignments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_assign_owner_and_shared(self):
    """
    Getter method for assign_owner_and_shared, mapped from YANG variable /controller_rpc/assign_owner_and_shared (rpc)
    """
    return self.__assign_owner_and_shared
      
  def _set_assign_owner_and_shared(self, v, load=False):
    """
    Setter method for assign_owner_and_shared, mapped from YANG variable /controller_rpc/assign_owner_and_shared (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_assign_owner_and_shared is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_assign_owner_and_shared() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=assign_owner_and_shared.assign_owner_and_shared, is_leaf=True, yang_name="assign-owner-and-shared", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """assign_owner_and_shared must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=assign_owner_and_shared.assign_owner_and_shared, is_leaf=True, yang_name="assign-owner-and-shared", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__assign_owner_and_shared = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_assign_owner_and_shared(self):
    self.__assign_owner_and_shared = YANGDynClass(base=assign_owner_and_shared.assign_owner_and_shared, is_leaf=True, yang_name="assign-owner-and-shared", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_evaluate_xpath(self):
    """
    Getter method for evaluate_xpath, mapped from YANG variable /controller_rpc/evaluate_xpath (rpc)
    """
    return self.__evaluate_xpath
      
  def _set_evaluate_xpath(self, v, load=False):
    """
    Setter method for evaluate_xpath, mapped from YANG variable /controller_rpc/evaluate_xpath (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluate_xpath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluate_xpath() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=evaluate_xpath.evaluate_xpath, is_leaf=True, yang_name="evaluate-xpath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """evaluate_xpath must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=evaluate_xpath.evaluate_xpath, is_leaf=True, yang_name="evaluate-xpath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__evaluate_xpath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_evaluate_xpath(self):
    self.__evaluate_xpath = YANGDynClass(base=evaluate_xpath.evaluate_xpath, is_leaf=True, yang_name="evaluate-xpath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_get_schema_nodes_from_package(self):
    """
    Getter method for get_schema_nodes_from_package, mapped from YANG variable /controller_rpc/get_schema_nodes_from_package (rpc)
    """
    return self.__get_schema_nodes_from_package
      
  def _set_get_schema_nodes_from_package(self, v, load=False):
    """
    Setter method for get_schema_nodes_from_package, mapped from YANG variable /controller_rpc/get_schema_nodes_from_package (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_schema_nodes_from_package is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_schema_nodes_from_package() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_schema_nodes_from_package.get_schema_nodes_from_package, is_leaf=True, yang_name="get-schema-nodes-from-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_schema_nodes_from_package must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_schema_nodes_from_package.get_schema_nodes_from_package, is_leaf=True, yang_name="get-schema-nodes-from-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__get_schema_nodes_from_package = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_schema_nodes_from_package(self):
    self.__get_schema_nodes_from_package = YANGDynClass(base=get_schema_nodes_from_package.get_schema_nodes_from_package, is_leaf=True, yang_name="get-schema-nodes-from-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_get_valid_identities(self):
    """
    Getter method for get_valid_identities, mapped from YANG variable /controller_rpc/get_valid_identities (rpc)

    YANG Description: returns a list of identities valid for given identityref
    """
    return self.__get_valid_identities
      
  def _set_get_valid_identities(self, v, load=False):
    """
    Setter method for get_valid_identities, mapped from YANG variable /controller_rpc/get_valid_identities (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_valid_identities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_valid_identities() directly.

    YANG Description: returns a list of identities valid for given identityref
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_valid_identities.get_valid_identities, is_leaf=True, yang_name="get-valid-identities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_valid_identities must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_valid_identities.get_valid_identities, is_leaf=True, yang_name="get-valid-identities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__get_valid_identities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_valid_identities(self):
    self.__get_valid_identities = YANGDynClass(base=get_valid_identities.get_valid_identities, is_leaf=True, yang_name="get-valid-identities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_upload_file(self):
    """
    Getter method for upload_file, mapped from YANG variable /controller_rpc/upload_file (rpc)

    YANG Description: This rpc is used to upload the file to the mongoDB with the index of the dataNodeId for the specified DataNode rcpath
    """
    return self.__upload_file
      
  def _set_upload_file(self, v, load=False):
    """
    Setter method for upload_file, mapped from YANG variable /controller_rpc/upload_file (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upload_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upload_file() directly.

    YANG Description: This rpc is used to upload the file to the mongoDB with the index of the dataNodeId for the specified DataNode rcpath
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=upload_file.upload_file, is_leaf=True, yang_name="upload-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upload_file must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=upload_file.upload_file, is_leaf=True, yang_name="upload-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__upload_file = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upload_file(self):
    self.__upload_file = YANGDynClass(base=upload_file.upload_file, is_leaf=True, yang_name="upload-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_download_file(self):
    """
    Getter method for download_file, mapped from YANG variable /controller_rpc/download_file (rpc)

    YANG Description: This rpc is used to download the file from the MongoDB with the index of the DataNodeId for the specificed DataNode RcPath
    """
    return self.__download_file
      
  def _set_download_file(self, v, load=False):
    """
    Setter method for download_file, mapped from YANG variable /controller_rpc/download_file (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_download_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_download_file() directly.

    YANG Description: This rpc is used to download the file from the MongoDB with the index of the DataNodeId for the specificed DataNode RcPath
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=download_file.download_file, is_leaf=True, yang_name="download-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """download_file must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=download_file.download_file, is_leaf=True, yang_name="download-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__download_file = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_download_file(self):
    self.__download_file = YANGDynClass(base=download_file.download_file, is_leaf=True, yang_name="download-file", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_apply_data_grouping(self):
    """
    Getter method for apply_data_grouping, mapped from YANG variable /controller_rpc/apply_data_grouping (rpc)
    """
    return self.__apply_data_grouping
      
  def _set_apply_data_grouping(self, v, load=False):
    """
    Setter method for apply_data_grouping, mapped from YANG variable /controller_rpc/apply_data_grouping (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_data_grouping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_data_grouping() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=apply_data_grouping.apply_data_grouping, is_leaf=True, yang_name="apply-data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_data_grouping must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=apply_data_grouping.apply_data_grouping, is_leaf=True, yang_name="apply-data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__apply_data_grouping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_data_grouping(self):
    self.__apply_data_grouping = YANGDynClass(base=apply_data_grouping.apply_data_grouping, is_leaf=True, yang_name="apply-data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_get_ip_from_hostname(self):
    """
    Getter method for get_ip_from_hostname, mapped from YANG variable /controller_rpc/get_ip_from_hostname (rpc)
    """
    return self.__get_ip_from_hostname
      
  def _set_get_ip_from_hostname(self, v, load=False):
    """
    Setter method for get_ip_from_hostname, mapped from YANG variable /controller_rpc/get_ip_from_hostname (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_ip_from_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_ip_from_hostname() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_ip_from_hostname.get_ip_from_hostname, is_leaf=True, yang_name="get-ip-from-hostname", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_ip_from_hostname must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_ip_from_hostname.get_ip_from_hostname, is_leaf=True, yang_name="get-ip-from-hostname", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__get_ip_from_hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_ip_from_hostname(self):
    self.__get_ip_from_hostname = YANGDynClass(base=get_ip_from_hostname.get_ip_from_hostname, is_leaf=True, yang_name="get-ip-from-hostname", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_run_device_inventory(self):
    """
    Getter method for run_device_inventory, mapped from YANG variable /controller_rpc/run_device_inventory (rpc)
    """
    return self.__run_device_inventory
      
  def _set_run_device_inventory(self, v, load=False):
    """
    Setter method for run_device_inventory, mapped from YANG variable /controller_rpc/run_device_inventory (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_run_device_inventory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_run_device_inventory() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=run_device_inventory.run_device_inventory, is_leaf=True, yang_name="run-device-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """run_device_inventory must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=run_device_inventory.run_device_inventory, is_leaf=True, yang_name="run-device-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__run_device_inventory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_run_device_inventory(self):
    self.__run_device_inventory = YANGDynClass(base=run_device_inventory.run_device_inventory, is_leaf=True, yang_name="run-device-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_run_extended_inventory(self):
    """
    Getter method for run_extended_inventory, mapped from YANG variable /controller_rpc/run_extended_inventory (rpc)
    """
    return self.__run_extended_inventory
      
  def _set_run_extended_inventory(self, v, load=False):
    """
    Setter method for run_extended_inventory, mapped from YANG variable /controller_rpc/run_extended_inventory (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_run_extended_inventory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_run_extended_inventory() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=run_extended_inventory.run_extended_inventory, is_leaf=True, yang_name="run-extended-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """run_extended_inventory must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=run_extended_inventory.run_extended_inventory, is_leaf=True, yang_name="run-extended-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__run_extended_inventory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_run_extended_inventory(self):
    self.__run_extended_inventory = YANGDynClass(base=run_extended_inventory.run_extended_inventory, is_leaf=True, yang_name="run-extended-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_run_diagnostic_inventory(self):
    """
    Getter method for run_diagnostic_inventory, mapped from YANG variable /controller_rpc/run_diagnostic_inventory (rpc)
    """
    return self.__run_diagnostic_inventory
      
  def _set_run_diagnostic_inventory(self, v, load=False):
    """
    Setter method for run_diagnostic_inventory, mapped from YANG variable /controller_rpc/run_diagnostic_inventory (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_run_diagnostic_inventory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_run_diagnostic_inventory() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=run_diagnostic_inventory.run_diagnostic_inventory, is_leaf=True, yang_name="run-diagnostic-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """run_diagnostic_inventory must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=run_diagnostic_inventory.run_diagnostic_inventory, is_leaf=True, yang_name="run-diagnostic-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__run_diagnostic_inventory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_run_diagnostic_inventory(self):
    self.__run_diagnostic_inventory = YANGDynClass(base=run_diagnostic_inventory.run_diagnostic_inventory, is_leaf=True, yang_name="run-diagnostic-inventory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_subscribe_snmp_traps(self):
    """
    Getter method for subscribe_snmp_traps, mapped from YANG variable /controller_rpc/subscribe_snmp_traps (rpc)
    """
    return self.__subscribe_snmp_traps
      
  def _set_subscribe_snmp_traps(self, v, load=False):
    """
    Setter method for subscribe_snmp_traps, mapped from YANG variable /controller_rpc/subscribe_snmp_traps (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscribe_snmp_traps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscribe_snmp_traps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=subscribe_snmp_traps.subscribe_snmp_traps, is_leaf=True, yang_name="subscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscribe_snmp_traps must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=subscribe_snmp_traps.subscribe_snmp_traps, is_leaf=True, yang_name="subscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__subscribe_snmp_traps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscribe_snmp_traps(self):
    self.__subscribe_snmp_traps = YANGDynClass(base=subscribe_snmp_traps.subscribe_snmp_traps, is_leaf=True, yang_name="subscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_subscribe_syslog_event(self):
    """
    Getter method for subscribe_syslog_event, mapped from YANG variable /controller_rpc/subscribe_syslog_event (rpc)
    """
    return self.__subscribe_syslog_event
      
  def _set_subscribe_syslog_event(self, v, load=False):
    """
    Setter method for subscribe_syslog_event, mapped from YANG variable /controller_rpc/subscribe_syslog_event (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subscribe_syslog_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subscribe_syslog_event() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=subscribe_syslog_event.subscribe_syslog_event, is_leaf=True, yang_name="subscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subscribe_syslog_event must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=subscribe_syslog_event.subscribe_syslog_event, is_leaf=True, yang_name="subscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__subscribe_syslog_event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subscribe_syslog_event(self):
    self.__subscribe_syslog_event = YANGDynClass(base=subscribe_syslog_event.subscribe_syslog_event, is_leaf=True, yang_name="subscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_unsubscribe_snmp_traps(self):
    """
    Getter method for unsubscribe_snmp_traps, mapped from YANG variable /controller_rpc/unsubscribe_snmp_traps (rpc)
    """
    return self.__unsubscribe_snmp_traps
      
  def _set_unsubscribe_snmp_traps(self, v, load=False):
    """
    Setter method for unsubscribe_snmp_traps, mapped from YANG variable /controller_rpc/unsubscribe_snmp_traps (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsubscribe_snmp_traps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsubscribe_snmp_traps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unsubscribe_snmp_traps.unsubscribe_snmp_traps, is_leaf=True, yang_name="unsubscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsubscribe_snmp_traps must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=unsubscribe_snmp_traps.unsubscribe_snmp_traps, is_leaf=True, yang_name="unsubscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__unsubscribe_snmp_traps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsubscribe_snmp_traps(self):
    self.__unsubscribe_snmp_traps = YANGDynClass(base=unsubscribe_snmp_traps.unsubscribe_snmp_traps, is_leaf=True, yang_name="unsubscribe-snmp-traps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_unsubscribe_syslog_event(self):
    """
    Getter method for unsubscribe_syslog_event, mapped from YANG variable /controller_rpc/unsubscribe_syslog_event (rpc)
    """
    return self.__unsubscribe_syslog_event
      
  def _set_unsubscribe_syslog_event(self, v, load=False):
    """
    Setter method for unsubscribe_syslog_event, mapped from YANG variable /controller_rpc/unsubscribe_syslog_event (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unsubscribe_syslog_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unsubscribe_syslog_event() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unsubscribe_syslog_event.unsubscribe_syslog_event, is_leaf=True, yang_name="unsubscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unsubscribe_syslog_event must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=unsubscribe_syslog_event.unsubscribe_syslog_event, is_leaf=True, yang_name="unsubscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__unsubscribe_syslog_event = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unsubscribe_syslog_event(self):
    self.__unsubscribe_syslog_event = YANGDynClass(base=unsubscribe_syslog_event.unsubscribe_syslog_event, is_leaf=True, yang_name="unsubscribe-syslog-event", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_retrieve_configs(self):
    """
    Getter method for retrieve_configs, mapped from YANG variable /controller_rpc/retrieve_configs (rpc)
    """
    return self.__retrieve_configs
      
  def _set_retrieve_configs(self, v, load=False):
    """
    Setter method for retrieve_configs, mapped from YANG variable /controller_rpc/retrieve_configs (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_retrieve_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_retrieve_configs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=retrieve_configs.retrieve_configs, is_leaf=True, yang_name="retrieve-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """retrieve_configs must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=retrieve_configs.retrieve_configs, is_leaf=True, yang_name="retrieve-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__retrieve_configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_retrieve_configs(self):
    self.__retrieve_configs = YANGDynClass(base=retrieve_configs.retrieve_configs, is_leaf=True, yang_name="retrieve-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_mark_maintenance_mode(self):
    """
    Getter method for mark_maintenance_mode, mapped from YANG variable /controller_rpc/mark_maintenance_mode (rpc)
    """
    return self.__mark_maintenance_mode
      
  def _set_mark_maintenance_mode(self, v, load=False):
    """
    Setter method for mark_maintenance_mode, mapped from YANG variable /controller_rpc/mark_maintenance_mode (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mark_maintenance_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mark_maintenance_mode() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mark_maintenance_mode.mark_maintenance_mode, is_leaf=True, yang_name="mark-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mark_maintenance_mode must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=mark_maintenance_mode.mark_maintenance_mode, is_leaf=True, yang_name="mark-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__mark_maintenance_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mark_maintenance_mode(self):
    self.__mark_maintenance_mode = YANGDynClass(base=mark_maintenance_mode.mark_maintenance_mode, is_leaf=True, yang_name="mark-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_clear_maintenance_mode(self):
    """
    Getter method for clear_maintenance_mode, mapped from YANG variable /controller_rpc/clear_maintenance_mode (rpc)
    """
    return self.__clear_maintenance_mode
      
  def _set_clear_maintenance_mode(self, v, load=False):
    """
    Setter method for clear_maintenance_mode, mapped from YANG variable /controller_rpc/clear_maintenance_mode (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_maintenance_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_maintenance_mode() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=clear_maintenance_mode.clear_maintenance_mode, is_leaf=True, yang_name="clear-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_maintenance_mode must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=clear_maintenance_mode.clear_maintenance_mode, is_leaf=True, yang_name="clear-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__clear_maintenance_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_maintenance_mode(self):
    self.__clear_maintenance_mode = YANGDynClass(base=clear_maintenance_mode.clear_maintenance_mode, is_leaf=True, yang_name="clear-maintenance-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_show_device_config(self):
    """
    Getter method for show_device_config, mapped from YANG variable /controller_rpc/show_device_config (rpc)
    """
    return self.__show_device_config
      
  def _set_show_device_config(self, v, load=False):
    """
    Setter method for show_device_config, mapped from YANG variable /controller_rpc/show_device_config (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show_device_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show_device_config() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=show_device_config.show_device_config, is_leaf=True, yang_name="show-device-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show_device_config must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=show_device_config.show_device_config, is_leaf=True, yang_name="show-device-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__show_device_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show_device_config(self):
    self.__show_device_config = YANGDynClass(base=show_device_config.show_device_config, is_leaf=True, yang_name="show-device-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_show_device_networkconnections(self):
    """
    Getter method for show_device_networkconnections, mapped from YANG variable /controller_rpc/show_device_networkconnections (rpc)
    """
    return self.__show_device_networkconnections
      
  def _set_show_device_networkconnections(self, v, load=False):
    """
    Setter method for show_device_networkconnections, mapped from YANG variable /controller_rpc/show_device_networkconnections (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_show_device_networkconnections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_show_device_networkconnections() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=show_device_networkconnections.show_device_networkconnections, is_leaf=True, yang_name="show-device-networkconnections", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """show_device_networkconnections must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=show_device_networkconnections.show_device_networkconnections, is_leaf=True, yang_name="show-device-networkconnections", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__show_device_networkconnections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_show_device_networkconnections(self):
    self.__show_device_networkconnections = YANGDynClass(base=show_device_networkconnections.show_device_networkconnections, is_leaf=True, yang_name="show-device-networkconnections", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_load_package(self):
    """
    Getter method for load_package, mapped from YANG variable /controller_rpc/load_package (rpc)

    YANG Description: Deprecated April 15 2017. Use rpc packages:activate-package. 
    """
    return self.__load_package
      
  def _set_load_package(self, v, load=False):
    """
    Setter method for load_package, mapped from YANG variable /controller_rpc/load_package (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_package is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_package() directly.

    YANG Description: Deprecated April 15 2017. Use rpc packages:activate-package. 
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=load_package.load_package, is_leaf=True, yang_name="load-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_package must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=load_package.load_package, is_leaf=True, yang_name="load-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__load_package = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_package(self):
    self.__load_package = YANGDynClass(base=load_package.load_package, is_leaf=True, yang_name="load-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_unload_package(self):
    """
    Getter method for unload_package, mapped from YANG variable /controller_rpc/unload_package (rpc)

    YANG Description: Deprecated April 15 2017. Use rpc packages:deactivate-package. 
    """
    return self.__unload_package
      
  def _set_unload_package(self, v, load=False):
    """
    Setter method for unload_package, mapped from YANG variable /controller_rpc/unload_package (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unload_package is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unload_package() directly.

    YANG Description: Deprecated April 15 2017. Use rpc packages:deactivate-package. 
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unload_package.unload_package, is_leaf=True, yang_name="unload-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unload_package must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=unload_package.unload_package, is_leaf=True, yang_name="unload-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__unload_package = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unload_package(self):
    self.__unload_package = YANGDynClass(base=unload_package.unload_package, is_leaf=True, yang_name="unload-package", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_test_tacacs_connectivity(self):
    """
    Getter method for test_tacacs_connectivity, mapped from YANG variable /controller_rpc/test_tacacs_connectivity (rpc)
    """
    return self.__test_tacacs_connectivity
      
  def _set_test_tacacs_connectivity(self, v, load=False):
    """
    Setter method for test_tacacs_connectivity, mapped from YANG variable /controller_rpc/test_tacacs_connectivity (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_tacacs_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_tacacs_connectivity() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=test_tacacs_connectivity.test_tacacs_connectivity, is_leaf=True, yang_name="test-tacacs-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_tacacs_connectivity must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=test_tacacs_connectivity.test_tacacs_connectivity, is_leaf=True, yang_name="test-tacacs-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__test_tacacs_connectivity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_tacacs_connectivity(self):
    self.__test_tacacs_connectivity = YANGDynClass(base=test_tacacs_connectivity.test_tacacs_connectivity, is_leaf=True, yang_name="test-tacacs-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_test_ad_connectivity(self):
    """
    Getter method for test_ad_connectivity, mapped from YANG variable /controller_rpc/test_ad_connectivity (rpc)
    """
    return self.__test_ad_connectivity
      
  def _set_test_ad_connectivity(self, v, load=False):
    """
    Setter method for test_ad_connectivity, mapped from YANG variable /controller_rpc/test_ad_connectivity (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_ad_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_ad_connectivity() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=test_ad_connectivity.test_ad_connectivity, is_leaf=True, yang_name="test-ad-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_ad_connectivity must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=test_ad_connectivity.test_ad_connectivity, is_leaf=True, yang_name="test-ad-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__test_ad_connectivity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_ad_connectivity(self):
    self.__test_ad_connectivity = YANGDynClass(base=test_ad_connectivity.test_ad_connectivity, is_leaf=True, yang_name="test-ad-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_test_ldap_connectivity(self):
    """
    Getter method for test_ldap_connectivity, mapped from YANG variable /controller_rpc/test_ldap_connectivity (rpc)
    """
    return self.__test_ldap_connectivity
      
  def _set_test_ldap_connectivity(self, v, load=False):
    """
    Setter method for test_ldap_connectivity, mapped from YANG variable /controller_rpc/test_ldap_connectivity (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_ldap_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_ldap_connectivity() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=test_ldap_connectivity.test_ldap_connectivity, is_leaf=True, yang_name="test-ldap-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test_ldap_connectivity must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=test_ldap_connectivity.test_ldap_connectivity, is_leaf=True, yang_name="test-ldap-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__test_ldap_connectivity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test_ldap_connectivity(self):
    self.__test_ldap_connectivity = YANGDynClass(base=test_ldap_connectivity.test_ldap_connectivity, is_leaf=True, yang_name="test-ldap-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_acknowledge_alarm(self):
    """
    Getter method for acknowledge_alarm, mapped from YANG variable /controller_rpc/acknowledge_alarm (rpc)
    """
    return self.__acknowledge_alarm
      
  def _set_acknowledge_alarm(self, v, load=False):
    """
    Setter method for acknowledge_alarm, mapped from YANG variable /controller_rpc/acknowledge_alarm (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acknowledge_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acknowledge_alarm() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=acknowledge_alarm.acknowledge_alarm, is_leaf=True, yang_name="acknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acknowledge_alarm must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=acknowledge_alarm.acknowledge_alarm, is_leaf=True, yang_name="acknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__acknowledge_alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acknowledge_alarm(self):
    self.__acknowledge_alarm = YANGDynClass(base=acknowledge_alarm.acknowledge_alarm, is_leaf=True, yang_name="acknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_unacknowledge_alarm(self):
    """
    Getter method for unacknowledge_alarm, mapped from YANG variable /controller_rpc/unacknowledge_alarm (rpc)
    """
    return self.__unacknowledge_alarm
      
  def _set_unacknowledge_alarm(self, v, load=False):
    """
    Setter method for unacknowledge_alarm, mapped from YANG variable /controller_rpc/unacknowledge_alarm (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unacknowledge_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unacknowledge_alarm() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unacknowledge_alarm.unacknowledge_alarm, is_leaf=True, yang_name="unacknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unacknowledge_alarm must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=unacknowledge_alarm.unacknowledge_alarm, is_leaf=True, yang_name="unacknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__unacknowledge_alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unacknowledge_alarm(self):
    self.__unacknowledge_alarm = YANGDynClass(base=unacknowledge_alarm.unacknowledge_alarm, is_leaf=True, yang_name="unacknowledge-alarm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)


  def _get_check_connectivity(self):
    """
    Getter method for check_connectivity, mapped from YANG variable /controller_rpc/check_connectivity (rpc)
    """
    return self.__check_connectivity
      
  def _set_check_connectivity(self, v, load=False):
    """
    Setter method for check_connectivity, mapped from YANG variable /controller_rpc/check_connectivity (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_check_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_check_connectivity() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=check_connectivity.check_connectivity, is_leaf=True, yang_name="check-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """check_connectivity must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=check_connectivity.check_connectivity, is_leaf=True, yang_name="check-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)""",
        })

    self.__check_connectivity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_check_connectivity(self):
    self.__check_connectivity = YANGDynClass(base=check_connectivity.check_connectivity, is_leaf=True, yang_name="check-connectivity", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='rpc', is_config=True)

  get_current_ownership_assignments = __builtin__.property(_get_get_current_ownership_assignments, _set_get_current_ownership_assignments)
  assign_owner_and_shared = __builtin__.property(_get_assign_owner_and_shared, _set_assign_owner_and_shared)
  evaluate_xpath = __builtin__.property(_get_evaluate_xpath, _set_evaluate_xpath)
  get_schema_nodes_from_package = __builtin__.property(_get_get_schema_nodes_from_package, _set_get_schema_nodes_from_package)
  get_valid_identities = __builtin__.property(_get_get_valid_identities, _set_get_valid_identities)
  upload_file = __builtin__.property(_get_upload_file, _set_upload_file)
  download_file = __builtin__.property(_get_download_file, _set_download_file)
  apply_data_grouping = __builtin__.property(_get_apply_data_grouping, _set_apply_data_grouping)
  get_ip_from_hostname = __builtin__.property(_get_get_ip_from_hostname, _set_get_ip_from_hostname)
  run_device_inventory = __builtin__.property(_get_run_device_inventory, _set_run_device_inventory)
  run_extended_inventory = __builtin__.property(_get_run_extended_inventory, _set_run_extended_inventory)
  run_diagnostic_inventory = __builtin__.property(_get_run_diagnostic_inventory, _set_run_diagnostic_inventory)
  subscribe_snmp_traps = __builtin__.property(_get_subscribe_snmp_traps, _set_subscribe_snmp_traps)
  subscribe_syslog_event = __builtin__.property(_get_subscribe_syslog_event, _set_subscribe_syslog_event)
  unsubscribe_snmp_traps = __builtin__.property(_get_unsubscribe_snmp_traps, _set_unsubscribe_snmp_traps)
  unsubscribe_syslog_event = __builtin__.property(_get_unsubscribe_syslog_event, _set_unsubscribe_syslog_event)
  retrieve_configs = __builtin__.property(_get_retrieve_configs, _set_retrieve_configs)
  mark_maintenance_mode = __builtin__.property(_get_mark_maintenance_mode, _set_mark_maintenance_mode)
  clear_maintenance_mode = __builtin__.property(_get_clear_maintenance_mode, _set_clear_maintenance_mode)
  show_device_config = __builtin__.property(_get_show_device_config, _set_show_device_config)
  show_device_networkconnections = __builtin__.property(_get_show_device_networkconnections, _set_show_device_networkconnections)
  load_package = __builtin__.property(_get_load_package, _set_load_package)
  unload_package = __builtin__.property(_get_unload_package, _set_unload_package)
  test_tacacs_connectivity = __builtin__.property(_get_test_tacacs_connectivity, _set_test_tacacs_connectivity)
  test_ad_connectivity = __builtin__.property(_get_test_ad_connectivity, _set_test_ad_connectivity)
  test_ldap_connectivity = __builtin__.property(_get_test_ldap_connectivity, _set_test_ldap_connectivity)
  acknowledge_alarm = __builtin__.property(_get_acknowledge_alarm, _set_acknowledge_alarm)
  unacknowledge_alarm = __builtin__.property(_get_unacknowledge_alarm, _set_unacknowledge_alarm)
  check_connectivity = __builtin__.property(_get_check_connectivity, _set_check_connectivity)


  _pyangbind_elements = collections.OrderedDict([('get_current_ownership_assignments', get_current_ownership_assignments), ('assign_owner_and_shared', assign_owner_and_shared), ('evaluate_xpath', evaluate_xpath), ('get_schema_nodes_from_package', get_schema_nodes_from_package), ('get_valid_identities', get_valid_identities), ('upload_file', upload_file), ('download_file', download_file), ('apply_data_grouping', apply_data_grouping), ('get_ip_from_hostname', get_ip_from_hostname), ('run_device_inventory', run_device_inventory), ('run_extended_inventory', run_extended_inventory), ('run_diagnostic_inventory', run_diagnostic_inventory), ('subscribe_snmp_traps', subscribe_snmp_traps), ('subscribe_syslog_event', subscribe_syslog_event), ('unsubscribe_snmp_traps', unsubscribe_snmp_traps), ('unsubscribe_syslog_event', unsubscribe_syslog_event), ('retrieve_configs', retrieve_configs), ('mark_maintenance_mode', mark_maintenance_mode), ('clear_maintenance_mode', clear_maintenance_mode), ('show_device_config', show_device_config), ('show_device_networkconnections', show_device_networkconnections), ('load_package', load_package), ('unload_package', unload_package), ('test_tacacs_connectivity', test_tacacs_connectivity), ('test_ad_connectivity', test_ad_connectivity), ('test_ldap_connectivity', test_ldap_connectivity), ('acknowledge_alarm', acknowledge_alarm), ('unacknowledge_alarm', unacknowledge_alarm), ('check_connectivity', check_connectivity), ])


