
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class dci_resource_pool_setting(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dcinterconnect - based on the path /dci/dci-resource-pool-settings/dci-resource-pool-setting. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__id','__type','__prim_ip','__mgre_ip','__mgre_netmask','__pre_provisioned','__inject_default_route','__msdp_primary','__msdp_secondary','__enable_primary_rp','__secondary_rp','__tunnel_interface','__tunnel_key','__nhrp_key','__wan_inf_name','__wan_inf_ip','__wan_inf_netmask','__wan_gateway_ip','__primary_device','__secondary_device','__resource_pool','__dc_interconnect',)

  _yang_name = 'dci-resource-pool-setting'
  _module_name = 'dcinterconnect'
  _namespace = 'http://anutanetworks.com/dcinterconnect'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__msdp_secondary = YANGDynClass(base=unicode, is_leaf=True, yang_name="msdp-secondary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__dc_interconnect = YANGDynClass(base=unicode, is_leaf=True, yang_name="dc-interconnect", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__msdp_primary = YANGDynClass(base=unicode, is_leaf=True, yang_name="msdp-primary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__wan_gateway_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-gateway-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__inject_default_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inject-default-route", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    self.__nhrp_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="nhrp-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__tunnel_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='dmvpn-pod-type', is_config=True)
    self.__resource_pool = YANGDynClass(base=unicode, is_leaf=True, yang_name="resource-pool", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    self.__enable_primary_rp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-primary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    self.__wan_inf_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__secondary_rp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="secondary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    self.__mgre_netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="mgre-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__tunnel_interface = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-interface", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)
    self.__primary_device = YANGDynClass(base=unicode, is_leaf=True, yang_name="primary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    self.__mgre_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="mgre-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__wan_inf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-name", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__prim_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="prim-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__wan_inf_netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    self.__pre_provisioned = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="pre-provisioned", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    self.__secondary_device = YANGDynClass(base=unicode, is_leaf=True, yang_name="secondary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'dci', u'dci-resource-pool-settings', u'dci-resource-pool-setting']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/id (string)

    YANG Description: string
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="id", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=unicode, is_leaf=True, yang_name="id", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/type (dmvpn-pod-type)

    YANG Description: HUB
SPOKE

    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/type (dmvpn-pod-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: HUB
SPOKE

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='dmvpn-pod-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with dmvpn-pod-type""",
          'defined-type': "dcinterconnect:dmvpn-pod-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='dmvpn-pod-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SPOKE': {}, u'HUB': {}},), is_leaf=True, yang_name="type", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='dmvpn-pod-type', is_config=True)


  def _get_prim_ip(self):
    """
    Getter method for prim_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/prim_ip (string)

    YANG Description: string
    """
    return self.__prim_ip
      
  def _set_prim_ip(self, v, load=False):
    """
    Setter method for prim_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/prim_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prim_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prim_ip() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="prim-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prim_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="prim-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__prim_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prim_ip(self):
    self.__prim_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="prim-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_mgre_ip(self):
    """
    Getter method for mgre_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/mgre_ip (string)

    YANG Description: string
    """
    return self.__mgre_ip
      
  def _set_mgre_ip(self, v, load=False):
    """
    Setter method for mgre_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/mgre_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgre_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgre_ip() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mgre-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgre_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mgre-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__mgre_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgre_ip(self):
    self.__mgre_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="mgre-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_mgre_netmask(self):
    """
    Getter method for mgre_netmask, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/mgre_netmask (string)

    YANG Description: string
    """
    return self.__mgre_netmask
      
  def _set_mgre_netmask(self, v, load=False):
    """
    Setter method for mgre_netmask, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/mgre_netmask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgre_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgre_netmask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="mgre-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgre_netmask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mgre-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__mgre_netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgre_netmask(self):
    self.__mgre_netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="mgre-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_pre_provisioned(self):
    """
    Getter method for pre_provisioned, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/pre_provisioned (boolean)

    YANG Description: pre-provisioned: True/False
    """
    return self.__pre_provisioned
      
  def _set_pre_provisioned(self, v, load=False):
    """
    Setter method for pre_provisioned, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/pre_provisioned (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_provisioned is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_provisioned() directly.

    YANG Description: pre-provisioned: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="pre-provisioned", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_provisioned must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="pre-provisioned", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)""",
        })

    self.__pre_provisioned = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_provisioned(self):
    self.__pre_provisioned = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="pre-provisioned", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)


  def _get_inject_default_route(self):
    """
    Getter method for inject_default_route, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/inject_default_route (boolean)

    YANG Description: inject-default-route: True/False
    """
    return self.__inject_default_route
      
  def _set_inject_default_route(self, v, load=False):
    """
    Setter method for inject_default_route, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/inject_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inject_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inject_default_route() directly.

    YANG Description: inject-default-route: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="inject-default-route", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inject_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inject-default-route", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)""",
        })

    self.__inject_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inject_default_route(self):
    self.__inject_default_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="inject-default-route", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)


  def _get_msdp_primary(self):
    """
    Getter method for msdp_primary, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/msdp_primary (string)

    YANG Description: string
    """
    return self.__msdp_primary
      
  def _set_msdp_primary(self, v, load=False):
    """
    Setter method for msdp_primary, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/msdp_primary (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_msdp_primary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_msdp_primary() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="msdp-primary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """msdp_primary must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="msdp-primary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__msdp_primary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_msdp_primary(self):
    self.__msdp_primary = YANGDynClass(base=unicode, is_leaf=True, yang_name="msdp-primary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_msdp_secondary(self):
    """
    Getter method for msdp_secondary, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/msdp_secondary (string)

    YANG Description: string
    """
    return self.__msdp_secondary
      
  def _set_msdp_secondary(self, v, load=False):
    """
    Setter method for msdp_secondary, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/msdp_secondary (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_msdp_secondary is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_msdp_secondary() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="msdp-secondary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """msdp_secondary must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="msdp-secondary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__msdp_secondary = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_msdp_secondary(self):
    self.__msdp_secondary = YANGDynClass(base=unicode, is_leaf=True, yang_name="msdp-secondary", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_enable_primary_rp(self):
    """
    Getter method for enable_primary_rp, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/enable_primary_rp (boolean)

    YANG Description: enable-primary-rp: True/False
    """
    return self.__enable_primary_rp
      
  def _set_enable_primary_rp(self, v, load=False):
    """
    Setter method for enable_primary_rp, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/enable_primary_rp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_primary_rp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_primary_rp() directly.

    YANG Description: enable-primary-rp: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enable-primary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_primary_rp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-primary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)""",
        })

    self.__enable_primary_rp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_primary_rp(self):
    self.__enable_primary_rp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enable-primary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)


  def _get_secondary_rp(self):
    """
    Getter method for secondary_rp, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/secondary_rp (boolean)

    YANG Description: secondary-rp: True/False
    """
    return self.__secondary_rp
      
  def _set_secondary_rp(self, v, load=False):
    """
    Setter method for secondary_rp, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/secondary_rp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_rp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_rp() directly.

    YANG Description: secondary-rp: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="secondary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_rp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="secondary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)""",
        })

    self.__secondary_rp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_rp(self):
    self.__secondary_rp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="secondary-rp", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='boolean', is_config=True)


  def _get_tunnel_interface(self):
    """
    Getter method for tunnel_interface, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/tunnel_interface (uint16)

    YANG Description: 0..65535
    """
    return self.__tunnel_interface
      
  def _set_tunnel_interface(self, v, load=False):
    """
    Setter method for tunnel_interface, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/tunnel_interface (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_interface() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-interface", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_interface must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-interface", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)""",
        })

    self.__tunnel_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_interface(self):
    self.__tunnel_interface = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-interface", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)


  def _get_tunnel_key(self):
    """
    Getter method for tunnel_key, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/tunnel_key (uint16)

    YANG Description: 0..65535
    """
    return self.__tunnel_key
      
  def _set_tunnel_key(self, v, load=False):
    """
    Setter method for tunnel_key, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/tunnel_key (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_key() directly.

    YANG Description: 0..65535
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_key must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)""",
        })

    self.__tunnel_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_key(self):
    self.__tunnel_key = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tunnel-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='uint16', is_config=True)


  def _get_nhrp_key(self):
    """
    Getter method for nhrp_key, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/nhrp_key (string)

    YANG Description: string
    """
    return self.__nhrp_key
      
  def _set_nhrp_key(self, v, load=False):
    """
    Setter method for nhrp_key, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/nhrp_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nhrp_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nhrp_key() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="nhrp-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nhrp_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="nhrp-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__nhrp_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nhrp_key(self):
    self.__nhrp_key = YANGDynClass(base=unicode, is_leaf=True, yang_name="nhrp-key", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_wan_inf_name(self):
    """
    Getter method for wan_inf_name, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_inf_name (string)

    YANG Description: string
    """
    return self.__wan_inf_name
      
  def _set_wan_inf_name(self, v, load=False):
    """
    Setter method for wan_inf_name, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_inf_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wan_inf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wan_inf_name() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="wan-inf-name", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wan_inf_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-name", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__wan_inf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wan_inf_name(self):
    self.__wan_inf_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-name", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_wan_inf_ip(self):
    """
    Getter method for wan_inf_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_inf_ip (string)

    YANG Description: string
    """
    return self.__wan_inf_ip
      
  def _set_wan_inf_ip(self, v, load=False):
    """
    Setter method for wan_inf_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_inf_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wan_inf_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wan_inf_ip() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="wan-inf-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wan_inf_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__wan_inf_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wan_inf_ip(self):
    self.__wan_inf_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_wan_inf_netmask(self):
    """
    Getter method for wan_inf_netmask, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_inf_netmask (string)

    YANG Description: string
    """
    return self.__wan_inf_netmask
      
  def _set_wan_inf_netmask(self, v, load=False):
    """
    Setter method for wan_inf_netmask, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_inf_netmask (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wan_inf_netmask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wan_inf_netmask() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="wan-inf-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wan_inf_netmask must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__wan_inf_netmask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wan_inf_netmask(self):
    self.__wan_inf_netmask = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-inf-netmask", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_wan_gateway_ip(self):
    """
    Getter method for wan_gateway_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_gateway_ip (string)

    YANG Description: string
    """
    return self.__wan_gateway_ip
      
  def _set_wan_gateway_ip(self, v, load=False):
    """
    Setter method for wan_gateway_ip, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/wan_gateway_ip (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wan_gateway_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wan_gateway_ip() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="wan-gateway-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wan_gateway_ip must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-gateway-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)""",
        })

    self.__wan_gateway_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wan_gateway_ip(self):
    self.__wan_gateway_ip = YANGDynClass(base=unicode, is_leaf=True, yang_name="wan-gateway-ip", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='string', is_config=True)


  def _get_primary_device(self):
    """
    Getter method for primary_device, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/primary_device (leafref)

    YANG Description: primary-device
    """
    return self.__primary_device
      
  def _set_primary_device(self, v, load=False):
    """
    Setter method for primary_device, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/primary_device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_device() directly.

    YANG Description: primary-device
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="primary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="primary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)""",
        })

    self.__primary_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_device(self):
    self.__primary_device = YANGDynClass(base=unicode, is_leaf=True, yang_name="primary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)


  def _get_secondary_device(self):
    """
    Getter method for secondary_device, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/secondary_device (leafref)

    YANG Description: secondary-device
    """
    return self.__secondary_device
      
  def _set_secondary_device(self, v, load=False):
    """
    Setter method for secondary_device, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/secondary_device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_device() directly.

    YANG Description: secondary-device
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="secondary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="secondary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)""",
        })

    self.__secondary_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_device(self):
    self.__secondary_device = YANGDynClass(base=unicode, is_leaf=True, yang_name="secondary-device", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)


  def _get_resource_pool(self):
    """
    Getter method for resource_pool, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/resource_pool (leafref)

    YANG Description: resource-pool
    """
    return self.__resource_pool
      
  def _set_resource_pool(self, v, load=False):
    """
    Setter method for resource_pool, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/resource_pool (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resource_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resource_pool() directly.

    YANG Description: resource-pool
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="resource-pool", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resource_pool must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="resource-pool", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)""",
        })

    self.__resource_pool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resource_pool(self):
    self.__resource_pool = YANGDynClass(base=unicode, is_leaf=True, yang_name="resource-pool", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)


  def _get_dc_interconnect(self):
    """
    Getter method for dc_interconnect, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/dc_interconnect (leafref)

    YANG Description: dc-interconnect
    """
    return self.__dc_interconnect
      
  def _set_dc_interconnect(self, v, load=False):
    """
    Setter method for dc_interconnect, mapped from YANG variable /dci/dci_resource_pool_settings/dci_resource_pool_setting/dc_interconnect (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dc_interconnect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dc_interconnect() directly.

    YANG Description: dc-interconnect
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="dc-interconnect", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dc_interconnect must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="dc-interconnect", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)""",
        })

    self.__dc_interconnect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dc_interconnect(self):
    self.__dc_interconnect = YANGDynClass(base=unicode, is_leaf=True, yang_name="dc-interconnect", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='leafref', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type = __builtin__.property(_get_type, _set_type)
  prim_ip = __builtin__.property(_get_prim_ip, _set_prim_ip)
  mgre_ip = __builtin__.property(_get_mgre_ip, _set_mgre_ip)
  mgre_netmask = __builtin__.property(_get_mgre_netmask, _set_mgre_netmask)
  pre_provisioned = __builtin__.property(_get_pre_provisioned, _set_pre_provisioned)
  inject_default_route = __builtin__.property(_get_inject_default_route, _set_inject_default_route)
  msdp_primary = __builtin__.property(_get_msdp_primary, _set_msdp_primary)
  msdp_secondary = __builtin__.property(_get_msdp_secondary, _set_msdp_secondary)
  enable_primary_rp = __builtin__.property(_get_enable_primary_rp, _set_enable_primary_rp)
  secondary_rp = __builtin__.property(_get_secondary_rp, _set_secondary_rp)
  tunnel_interface = __builtin__.property(_get_tunnel_interface, _set_tunnel_interface)
  tunnel_key = __builtin__.property(_get_tunnel_key, _set_tunnel_key)
  nhrp_key = __builtin__.property(_get_nhrp_key, _set_nhrp_key)
  wan_inf_name = __builtin__.property(_get_wan_inf_name, _set_wan_inf_name)
  wan_inf_ip = __builtin__.property(_get_wan_inf_ip, _set_wan_inf_ip)
  wan_inf_netmask = __builtin__.property(_get_wan_inf_netmask, _set_wan_inf_netmask)
  wan_gateway_ip = __builtin__.property(_get_wan_gateway_ip, _set_wan_gateway_ip)
  primary_device = __builtin__.property(_get_primary_device, _set_primary_device)
  secondary_device = __builtin__.property(_get_secondary_device, _set_secondary_device)
  resource_pool = __builtin__.property(_get_resource_pool, _set_resource_pool)
  dc_interconnect = __builtin__.property(_get_dc_interconnect, _set_dc_interconnect)


  _pyangbind_elements = collections.OrderedDict([('id', id), ('type', type), ('prim_ip', prim_ip), ('mgre_ip', mgre_ip), ('mgre_netmask', mgre_netmask), ('pre_provisioned', pre_provisioned), ('inject_default_route', inject_default_route), ('msdp_primary', msdp_primary), ('msdp_secondary', msdp_secondary), ('enable_primary_rp', enable_primary_rp), ('secondary_rp', secondary_rp), ('tunnel_interface', tunnel_interface), ('tunnel_key', tunnel_key), ('nhrp_key', nhrp_key), ('wan_inf_name', wan_inf_name), ('wan_inf_ip', wan_inf_ip), ('wan_inf_netmask', wan_inf_netmask), ('wan_gateway_ip', wan_gateway_ip), ('primary_device', primary_device), ('secondary_device', secondary_device), ('resource_pool', resource_pool), ('dc_interconnect', dc_interconnect), ])


