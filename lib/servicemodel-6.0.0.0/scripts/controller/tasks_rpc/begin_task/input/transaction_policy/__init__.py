
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class transaction_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tasks - based on the path /tasks_rpc/begin-task/input/transaction-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__fail_fast','__validation_scope','__command_sequence_policy','__do_not_send_commands_to_devices',)

  _yang_name = 'transaction-policy'
  _module_name = 'tasks'
  _namespace = 'http://anutanetworks.com/tasks'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fail_fast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fail-fast", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)
    self.__validation_scope = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMMITTED_DATA': {}, u'UNCOMMITTED_DATA': {}},), is_leaf=True, yang_name="validation-scope", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='validation-scope-type', is_config=True)
    self.__command_sequence_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NONE': {}, u'DEPENDENCY_BASED': {}},), is_leaf=True, yang_name="command-sequence-policy", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='command-sequence-policy-type', is_config=True)
    self.__do_not_send_commands_to_devices = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="do-not-send-commands-to-devices", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'tasks_rpc', u'begin-task', u'input', u'transaction-policy']

  def _get_fail_fast(self):
    """
    Getter method for fail_fast, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/fail_fast (boolean)

    YANG Description: flag to control if reference validation to be done immediately. 'false' will defer the validation to after
commit-task
    """
    return self.__fail_fast
      
  def _set_fail_fast(self, v, load=False):
    """
    Setter method for fail_fast, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/fail_fast (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fail_fast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fail_fast() directly.

    YANG Description: flag to control if reference validation to be done immediately. 'false' will defer the validation to after
commit-task
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="fail-fast", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fail_fast must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fail-fast", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)""",
        })

    self.__fail_fast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fail_fast(self):
    self.__fail_fast = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="fail-fast", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)


  def _get_validation_scope(self):
    """
    Getter method for validation_scope, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/validation_scope (validation-scope-type)

    YANG Description: flag to control the data validation scope, this is similar transaction isolation
    """
    return self.__validation_scope
      
  def _set_validation_scope(self, v, load=False):
    """
    Setter method for validation_scope, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/validation_scope (validation-scope-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_validation_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_validation_scope() directly.

    YANG Description: flag to control the data validation scope, this is similar transaction isolation
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMMITTED_DATA': {}, u'UNCOMMITTED_DATA': {}},), is_leaf=True, yang_name="validation-scope", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='validation-scope-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """validation_scope must be of a type compatible with validation-scope-type""",
          'defined-type': "tasks:validation-scope-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMMITTED_DATA': {}, u'UNCOMMITTED_DATA': {}},), is_leaf=True, yang_name="validation-scope", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='validation-scope-type', is_config=True)""",
        })

    self.__validation_scope = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_validation_scope(self):
    self.__validation_scope = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COMMITTED_DATA': {}, u'UNCOMMITTED_DATA': {}},), is_leaf=True, yang_name="validation-scope", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='validation-scope-type', is_config=True)


  def _get_command_sequence_policy(self):
    """
    Getter method for command_sequence_policy, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/command_sequence_policy (command-sequence-policy-type)

    YANG Description: DEPENDENCY_BASED
NONE

    """
    return self.__command_sequence_policy
      
  def _set_command_sequence_policy(self, v, load=False):
    """
    Setter method for command_sequence_policy, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/command_sequence_policy (command-sequence-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_command_sequence_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_command_sequence_policy() directly.

    YANG Description: DEPENDENCY_BASED
NONE

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NONE': {}, u'DEPENDENCY_BASED': {}},), is_leaf=True, yang_name="command-sequence-policy", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='command-sequence-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """command_sequence_policy must be of a type compatible with command-sequence-policy-type""",
          'defined-type': "tasks:command-sequence-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NONE': {}, u'DEPENDENCY_BASED': {}},), is_leaf=True, yang_name="command-sequence-policy", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='command-sequence-policy-type', is_config=True)""",
        })

    self.__command_sequence_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_command_sequence_policy(self):
    self.__command_sequence_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NONE': {}, u'DEPENDENCY_BASED': {}},), is_leaf=True, yang_name="command-sequence-policy", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='command-sequence-policy-type', is_config=True)


  def _get_do_not_send_commands_to_devices(self):
    """
    Getter method for do_not_send_commands_to_devices, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/do_not_send_commands_to_devices (boolean)

    YANG Description: flag to control if commands can be sent to the device. 'true' will commit the data to NCX datastore, but no configuration changes will be applied on the device. Useful
for testing or in the case of a brown-field environment to create services. Note, this flag will be effective only if global dry-run flag is set to false
    """
    return self.__do_not_send_commands_to_devices
      
  def _set_do_not_send_commands_to_devices(self, v, load=False):
    """
    Setter method for do_not_send_commands_to_devices, mapped from YANG variable /tasks_rpc/begin_task/input/transaction_policy/do_not_send_commands_to_devices (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_do_not_send_commands_to_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_do_not_send_commands_to_devices() directly.

    YANG Description: flag to control if commands can be sent to the device. 'true' will commit the data to NCX datastore, but no configuration changes will be applied on the device. Useful
for testing or in the case of a brown-field environment to create services. Note, this flag will be effective only if global dry-run flag is set to false
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="do-not-send-commands-to-devices", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """do_not_send_commands_to_devices must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="do-not-send-commands-to-devices", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)""",
        })

    self.__do_not_send_commands_to_devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_do_not_send_commands_to_devices(self):
    self.__do_not_send_commands_to_devices = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="do-not-send-commands-to-devices", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='boolean', is_config=True)

  fail_fast = __builtin__.property(_get_fail_fast, _set_fail_fast)
  validation_scope = __builtin__.property(_get_validation_scope, _set_validation_scope)
  command_sequence_policy = __builtin__.property(_get_command_sequence_policy, _set_command_sequence_policy)
  do_not_send_commands_to_devices = __builtin__.property(_get_do_not_send_commands_to_devices, _set_do_not_send_commands_to_devices)


  _pyangbind_elements = collections.OrderedDict([('fail_fast', fail_fast), ('validation_scope', validation_scope), ('command_sequence_policy', command_sequence_policy), ('do_not_send_commands_to_devices', do_not_send_commands_to_devices), ])


