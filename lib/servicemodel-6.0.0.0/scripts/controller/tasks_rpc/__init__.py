
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import get_task_status
import get_approvers
import begin_task
import commit_task
import rollback_task
import cancel_task
import get_tasks_by_status
import get_active_datamodel_tasks
import get_basic_task_detail
import get_in_progress_datanodes
import get_full_task_detail
import resume_active_task
import unlock_active_task
import get_active_task_details
class tasks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tasks - based on the path /tasks_rpc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__get_task_status','__get_approvers','__begin_task','__commit_task','__rollback_task','__cancel_task','__get_tasks_by_status','__get_active_datamodel_tasks','__get_basic_task_detail','__get_in_progress_datanodes','__get_full_task_detail','__resume_active_task','__unlock_active_task','__get_active_task_details',)

  _yang_name = 'tasks'
  _module_name = 'tasks'
  _namespace = 'http://anutanetworks.com/tasks'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unlock_active_task = YANGDynClass(base=unlock_active_task.unlock_active_task, is_leaf=True, yang_name="unlock-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__commit_task = YANGDynClass(base=commit_task.commit_task, is_leaf=True, yang_name="commit-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__cancel_task = YANGDynClass(base=cancel_task.cancel_task, is_leaf=True, yang_name="cancel-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_task_status = YANGDynClass(base=get_task_status.get_task_status, is_leaf=True, yang_name="get-task-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__begin_task = YANGDynClass(base=begin_task.begin_task, is_leaf=True, yang_name="begin-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__resume_active_task = YANGDynClass(base=resume_active_task.resume_active_task, is_leaf=True, yang_name="resume-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__rollback_task = YANGDynClass(base=rollback_task.rollback_task, is_leaf=True, yang_name="rollback-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_basic_task_detail = YANGDynClass(base=get_basic_task_detail.get_basic_task_detail, is_leaf=True, yang_name="get-basic-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_in_progress_datanodes = YANGDynClass(base=get_in_progress_datanodes.get_in_progress_datanodes, is_leaf=True, yang_name="get-in-progress-datanodes", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_full_task_detail = YANGDynClass(base=get_full_task_detail.get_full_task_detail, is_leaf=True, yang_name="get-full-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_active_task_details = YANGDynClass(base=get_active_task_details.get_active_task_details, is_leaf=True, yang_name="get-active-task-details", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_tasks_by_status = YANGDynClass(base=get_tasks_by_status.get_tasks_by_status, is_leaf=True, yang_name="get-tasks-by-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_approvers = YANGDynClass(base=get_approvers.get_approvers, is_leaf=True, yang_name="get-approvers", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    self.__get_active_datamodel_tasks = YANGDynClass(base=get_active_datamodel_tasks.get_active_datamodel_tasks, is_leaf=True, yang_name="get-active-datamodel-tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'tasks_rpc']

  def _get_get_task_status(self):
    """
    Getter method for get_task_status, mapped from YANG variable /tasks_rpc/get_task_status (rpc)
    """
    return self.__get_task_status
      
  def _set_get_task_status(self, v, load=False):
    """
    Setter method for get_task_status, mapped from YANG variable /tasks_rpc/get_task_status (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_task_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_task_status() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_task_status.get_task_status, is_leaf=True, yang_name="get-task-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_task_status must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_task_status.get_task_status, is_leaf=True, yang_name="get-task-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_task_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_task_status(self):
    self.__get_task_status = YANGDynClass(base=get_task_status.get_task_status, is_leaf=True, yang_name="get-task-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_approvers(self):
    """
    Getter method for get_approvers, mapped from YANG variable /tasks_rpc/get_approvers (rpc)
    """
    return self.__get_approvers
      
  def _set_get_approvers(self, v, load=False):
    """
    Setter method for get_approvers, mapped from YANG variable /tasks_rpc/get_approvers (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_approvers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_approvers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_approvers.get_approvers, is_leaf=True, yang_name="get-approvers", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_approvers must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_approvers.get_approvers, is_leaf=True, yang_name="get-approvers", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_approvers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_approvers(self):
    self.__get_approvers = YANGDynClass(base=get_approvers.get_approvers, is_leaf=True, yang_name="get-approvers", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_begin_task(self):
    """
    Getter method for begin_task, mapped from YANG variable /tasks_rpc/begin_task (rpc)

    YANG Description: This protocol operation starts a new task and returns the task id. The client is required to quote the taskid for any operation that happens in a transaction
in this task
    """
    return self.__begin_task
      
  def _set_begin_task(self, v, load=False):
    """
    Setter method for begin_task, mapped from YANG variable /tasks_rpc/begin_task (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_begin_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_begin_task() directly.

    YANG Description: This protocol operation starts a new task and returns the task id. The client is required to quote the taskid for any operation that happens in a transaction
in this task
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=begin_task.begin_task, is_leaf=True, yang_name="begin-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """begin_task must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=begin_task.begin_task, is_leaf=True, yang_name="begin-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__begin_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_begin_task(self):
    self.__begin_task = YANGDynClass(base=begin_task.begin_task, is_leaf=True, yang_name="begin-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_commit_task(self):
    """
    Getter method for commit_task, mapped from YANG variable /tasks_rpc/commit_task (rpc)

    YANG Description: This protocol operation attempts to commit the task identified by the input parameter.
If the operation fails, will return the reason for failure and any relevant information if available.
    """
    return self.__commit_task
      
  def _set_commit_task(self, v, load=False):
    """
    Setter method for commit_task, mapped from YANG variable /tasks_rpc/commit_task (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_commit_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_commit_task() directly.

    YANG Description: This protocol operation attempts to commit the task identified by the input parameter.
If the operation fails, will return the reason for failure and any relevant information if available.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=commit_task.commit_task, is_leaf=True, yang_name="commit-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """commit_task must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=commit_task.commit_task, is_leaf=True, yang_name="commit-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__commit_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_commit_task(self):
    self.__commit_task = YANGDynClass(base=commit_task.commit_task, is_leaf=True, yang_name="commit-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_rollback_task(self):
    """
    Getter method for rollback_task, mapped from YANG variable /tasks_rpc/rollback_task (rpc)

    YANG Description: This protocol operation attempts at rolling back the changes occurred in the task. 
If force is true, application makes best effort and competes the task. Will report success/failure messages if any
    """
    return self.__rollback_task
      
  def _set_rollback_task(self, v, load=False):
    """
    Setter method for rollback_task, mapped from YANG variable /tasks_rpc/rollback_task (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rollback_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rollback_task() directly.

    YANG Description: This protocol operation attempts at rolling back the changes occurred in the task. 
If force is true, application makes best effort and competes the task. Will report success/failure messages if any
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rollback_task.rollback_task, is_leaf=True, yang_name="rollback-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rollback_task must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=rollback_task.rollback_task, is_leaf=True, yang_name="rollback-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__rollback_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rollback_task(self):
    self.__rollback_task = YANGDynClass(base=rollback_task.rollback_task, is_leaf=True, yang_name="rollback-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_cancel_task(self):
    """
    Getter method for cancel_task, mapped from YANG variable /tasks_rpc/cancel_task (rpc)

    YANG Description: This operation attempts to cancel an ongoing task
    """
    return self.__cancel_task
      
  def _set_cancel_task(self, v, load=False):
    """
    Setter method for cancel_task, mapped from YANG variable /tasks_rpc/cancel_task (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cancel_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cancel_task() directly.

    YANG Description: This operation attempts to cancel an ongoing task
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=cancel_task.cancel_task, is_leaf=True, yang_name="cancel-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cancel_task must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=cancel_task.cancel_task, is_leaf=True, yang_name="cancel-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__cancel_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cancel_task(self):
    self.__cancel_task = YANGDynClass(base=cancel_task.cancel_task, is_leaf=True, yang_name="cancel-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_tasks_by_status(self):
    """
    Getter method for get_tasks_by_status, mapped from YANG variable /tasks_rpc/get_tasks_by_status (rpc)

    YANG Description: returns a collection of task ids with the given status
    """
    return self.__get_tasks_by_status
      
  def _set_get_tasks_by_status(self, v, load=False):
    """
    Setter method for get_tasks_by_status, mapped from YANG variable /tasks_rpc/get_tasks_by_status (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_tasks_by_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_tasks_by_status() directly.

    YANG Description: returns a collection of task ids with the given status
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_tasks_by_status.get_tasks_by_status, is_leaf=True, yang_name="get-tasks-by-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_tasks_by_status must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_tasks_by_status.get_tasks_by_status, is_leaf=True, yang_name="get-tasks-by-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_tasks_by_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_tasks_by_status(self):
    self.__get_tasks_by_status = YANGDynClass(base=get_tasks_by_status.get_tasks_by_status, is_leaf=True, yang_name="get-tasks-by-status", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_active_datamodel_tasks(self):
    """
    Getter method for get_active_datamodel_tasks, mapped from YANG variable /tasks_rpc/get_active_datamodel_tasks (rpc)

    YANG Description: This gets the task details active on a given service
    """
    return self.__get_active_datamodel_tasks
      
  def _set_get_active_datamodel_tasks(self, v, load=False):
    """
    Setter method for get_active_datamodel_tasks, mapped from YANG variable /tasks_rpc/get_active_datamodel_tasks (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_active_datamodel_tasks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_active_datamodel_tasks() directly.

    YANG Description: This gets the task details active on a given service
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_active_datamodel_tasks.get_active_datamodel_tasks, is_leaf=True, yang_name="get-active-datamodel-tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_active_datamodel_tasks must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_active_datamodel_tasks.get_active_datamodel_tasks, is_leaf=True, yang_name="get-active-datamodel-tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_active_datamodel_tasks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_active_datamodel_tasks(self):
    self.__get_active_datamodel_tasks = YANGDynClass(base=get_active_datamodel_tasks.get_active_datamodel_tasks, is_leaf=True, yang_name="get-active-datamodel-tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_basic_task_detail(self):
    """
    Getter method for get_basic_task_detail, mapped from YANG variable /tasks_rpc/get_basic_task_detail (rpc)

    YANG Description: This operation gives basic Task information. For detailed task information that includes command logs, use getFullTaskDetail
    """
    return self.__get_basic_task_detail
      
  def _set_get_basic_task_detail(self, v, load=False):
    """
    Setter method for get_basic_task_detail, mapped from YANG variable /tasks_rpc/get_basic_task_detail (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_basic_task_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_basic_task_detail() directly.

    YANG Description: This operation gives basic Task information. For detailed task information that includes command logs, use getFullTaskDetail
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_basic_task_detail.get_basic_task_detail, is_leaf=True, yang_name="get-basic-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_basic_task_detail must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_basic_task_detail.get_basic_task_detail, is_leaf=True, yang_name="get-basic-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_basic_task_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_basic_task_detail(self):
    self.__get_basic_task_detail = YANGDynClass(base=get_basic_task_detail.get_basic_task_detail, is_leaf=True, yang_name="get-basic-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_in_progress_datanodes(self):
    """
    Getter method for get_in_progress_datanodes, mapped from YANG variable /tasks_rpc/get_in_progress_datanodes (rpc)

    YANG Description: testing purpose only
    """
    return self.__get_in_progress_datanodes
      
  def _set_get_in_progress_datanodes(self, v, load=False):
    """
    Setter method for get_in_progress_datanodes, mapped from YANG variable /tasks_rpc/get_in_progress_datanodes (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_in_progress_datanodes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_in_progress_datanodes() directly.

    YANG Description: testing purpose only
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_in_progress_datanodes.get_in_progress_datanodes, is_leaf=True, yang_name="get-in-progress-datanodes", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_in_progress_datanodes must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_in_progress_datanodes.get_in_progress_datanodes, is_leaf=True, yang_name="get-in-progress-datanodes", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_in_progress_datanodes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_in_progress_datanodes(self):
    self.__get_in_progress_datanodes = YANGDynClass(base=get_in_progress_datanodes.get_in_progress_datanodes, is_leaf=True, yang_name="get-in-progress-datanodes", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_full_task_detail(self):
    """
    Getter method for get_full_task_detail, mapped from YANG variable /tasks_rpc/get_full_task_detail (rpc)

    YANG Description: This operation comprehensive Task information. For basic task information that excludes command logs, use getBasicTaskDetail
    """
    return self.__get_full_task_detail
      
  def _set_get_full_task_detail(self, v, load=False):
    """
    Setter method for get_full_task_detail, mapped from YANG variable /tasks_rpc/get_full_task_detail (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_full_task_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_full_task_detail() directly.

    YANG Description: This operation comprehensive Task information. For basic task information that excludes command logs, use getBasicTaskDetail
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_full_task_detail.get_full_task_detail, is_leaf=True, yang_name="get-full-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_full_task_detail must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_full_task_detail.get_full_task_detail, is_leaf=True, yang_name="get-full-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_full_task_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_full_task_detail(self):
    self.__get_full_task_detail = YANGDynClass(base=get_full_task_detail.get_full_task_detail, is_leaf=True, yang_name="get-full-task-detail", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_resume_active_task(self):
    """
    Getter method for resume_active_task, mapped from YANG variable /tasks_rpc/resume_active_task (rpc)
    """
    return self.__resume_active_task
      
  def _set_resume_active_task(self, v, load=False):
    """
    Setter method for resume_active_task, mapped from YANG variable /tasks_rpc/resume_active_task (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resume_active_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resume_active_task() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=resume_active_task.resume_active_task, is_leaf=True, yang_name="resume-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resume_active_task must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=resume_active_task.resume_active_task, is_leaf=True, yang_name="resume-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__resume_active_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resume_active_task(self):
    self.__resume_active_task = YANGDynClass(base=resume_active_task.resume_active_task, is_leaf=True, yang_name="resume-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_unlock_active_task(self):
    """
    Getter method for unlock_active_task, mapped from YANG variable /tasks_rpc/unlock_active_task (rpc)
    """
    return self.__unlock_active_task
      
  def _set_unlock_active_task(self, v, load=False):
    """
    Setter method for unlock_active_task, mapped from YANG variable /tasks_rpc/unlock_active_task (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unlock_active_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unlock_active_task() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unlock_active_task.unlock_active_task, is_leaf=True, yang_name="unlock-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unlock_active_task must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=unlock_active_task.unlock_active_task, is_leaf=True, yang_name="unlock-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__unlock_active_task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unlock_active_task(self):
    self.__unlock_active_task = YANGDynClass(base=unlock_active_task.unlock_active_task, is_leaf=True, yang_name="unlock-active-task", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)


  def _get_get_active_task_details(self):
    """
    Getter method for get_active_task_details, mapped from YANG variable /tasks_rpc/get_active_task_details (rpc)
    """
    return self.__get_active_task_details
      
  def _set_get_active_task_details(self, v, load=False):
    """
    Setter method for get_active_task_details, mapped from YANG variable /tasks_rpc/get_active_task_details (rpc)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_get_active_task_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_get_active_task_details() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=get_active_task_details.get_active_task_details, is_leaf=True, yang_name="get-active-task-details", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """get_active_task_details must be of a type compatible with rpc""",
          'defined-type': "rpc",
          'generated-type': """YANGDynClass(base=get_active_task_details.get_active_task_details, is_leaf=True, yang_name="get-active-task-details", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)""",
        })

    self.__get_active_task_details = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_get_active_task_details(self):
    self.__get_active_task_details = YANGDynClass(base=get_active_task_details.get_active_task_details, is_leaf=True, yang_name="get-active-task-details", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=False, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='rpc', is_config=True)

  get_task_status = __builtin__.property(_get_get_task_status, _set_get_task_status)
  get_approvers = __builtin__.property(_get_get_approvers, _set_get_approvers)
  begin_task = __builtin__.property(_get_begin_task, _set_begin_task)
  commit_task = __builtin__.property(_get_commit_task, _set_commit_task)
  rollback_task = __builtin__.property(_get_rollback_task, _set_rollback_task)
  cancel_task = __builtin__.property(_get_cancel_task, _set_cancel_task)
  get_tasks_by_status = __builtin__.property(_get_get_tasks_by_status, _set_get_tasks_by_status)
  get_active_datamodel_tasks = __builtin__.property(_get_get_active_datamodel_tasks, _set_get_active_datamodel_tasks)
  get_basic_task_detail = __builtin__.property(_get_get_basic_task_detail, _set_get_basic_task_detail)
  get_in_progress_datanodes = __builtin__.property(_get_get_in_progress_datanodes, _set_get_in_progress_datanodes)
  get_full_task_detail = __builtin__.property(_get_get_full_task_detail, _set_get_full_task_detail)
  resume_active_task = __builtin__.property(_get_resume_active_task, _set_resume_active_task)
  unlock_active_task = __builtin__.property(_get_unlock_active_task, _set_unlock_active_task)
  get_active_task_details = __builtin__.property(_get_get_active_task_details, _set_get_active_task_details)


  _pyangbind_elements = collections.OrderedDict([('get_task_status', get_task_status), ('get_approvers', get_approvers), ('begin_task', begin_task), ('commit_task', commit_task), ('rollback_task', rollback_task), ('cancel_task', cancel_task), ('get_tasks_by_status', get_tasks_by_status), ('get_active_datamodel_tasks', get_active_datamodel_tasks), ('get_basic_task_detail', get_basic_task_detail), ('get_in_progress_datanodes', get_in_progress_datanodes), ('get_full_task_detail', get_full_task_detail), ('resume_active_task', resume_active_task), ('unlock_active_task', unlock_active_task), ('get_active_task_details', get_active_task_details), ])


