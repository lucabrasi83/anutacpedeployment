
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class property(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /view-templates/template/property. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__included_by_default','__default_width','__label','__displayFormat','__icon','__sortable','__hidden','__source',)

  _yang_name = 'property'
  _module_name = 'view-template'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sortable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sortable", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__default_width = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="default-width", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint8', is_config=True)
    self.__included_by_default = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="included-by-default", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__label = YANGDynClass(base=unicode, is_leaf=True, yang_name="label", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__source = YANGDynClass(base=unicode, is_leaf=True, yang_name="source", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__displayFormat = YANGDynClass(base=unicode, is_leaf=True, yang_name="displayFormat", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__icon = YANGDynClass(base=unicode, is_leaf=True, yang_name="icon", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'view-templates', u'template', u'property']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /view_templates/template/property/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /view_templates/template/property/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_included_by_default(self):
    """
    Getter method for included_by_default, mapped from YANG variable /view_templates/template/property/included_by_default (boolean)

    YANG Description: true would cause the property shown in the UI by default. 
                            false would not show by default, presuming user can customize the UI widget, for example, can shoose which columns to show up in a grid.
    """
    return self.__included_by_default
      
  def _set_included_by_default(self, v, load=False):
    """
    Setter method for included_by_default, mapped from YANG variable /view_templates/template/property/included_by_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_included_by_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_included_by_default() directly.

    YANG Description: true would cause the property shown in the UI by default. 
                            false would not show by default, presuming user can customize the UI widget, for example, can shoose which columns to show up in a grid.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="included-by-default", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """included_by_default must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="included-by-default", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__included_by_default = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_included_by_default(self):
    self.__included_by_default = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="included-by-default", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_default_width(self):
    """
    Getter method for default_width, mapped from YANG variable /view_templates/template/property/default_width (uint8)

    YANG Description: 0..255
    """
    return self.__default_width
      
  def _set_default_width(self, v, load=False):
    """
    Setter method for default_width, mapped from YANG variable /view_templates/template/property/default_width (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_width() directly.

    YANG Description: 0..255
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="default-width", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_width must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="default-width", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint8', is_config=True)""",
        })

    self.__default_width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_width(self):
    self.__default_width = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="default-width", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint8', is_config=True)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /view_templates/template/property/label (string)

    YANG Description: string
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /view_templates/template/property/label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="label", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="label", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=unicode, is_leaf=True, yang_name="label", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_displayFormat(self):
    """
    Getter method for displayFormat, mapped from YANG variable /view_templates/template/property/displayFormat (string)

    YANG Description: display formatting hints to UI
    """
    return self.__displayFormat
      
  def _set_displayFormat(self, v, load=False):
    """
    Setter method for displayFormat, mapped from YANG variable /view_templates/template/property/displayFormat (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_displayFormat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_displayFormat() directly.

    YANG Description: display formatting hints to UI
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="displayFormat", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """displayFormat must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="displayFormat", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__displayFormat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_displayFormat(self):
    self.__displayFormat = YANGDynClass(base=unicode, is_leaf=True, yang_name="displayFormat", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_icon(self):
    """
    Getter method for icon, mapped from YANG variable /view_templates/template/property/icon (string)

    YANG Description: string
    """
    return self.__icon
      
  def _set_icon(self, v, load=False):
    """
    Setter method for icon, mapped from YANG variable /view_templates/template/property/icon (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_icon is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_icon() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="icon", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """icon must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="icon", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__icon = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_icon(self):
    self.__icon = YANGDynClass(base=unicode, is_leaf=True, yang_name="icon", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_sortable(self):
    """
    Getter method for sortable, mapped from YANG variable /view_templates/template/property/sortable (boolean)

    YANG Description: sortable: True/False
    """
    return self.__sortable
      
  def _set_sortable(self, v, load=False):
    """
    Setter method for sortable, mapped from YANG variable /view_templates/template/property/sortable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sortable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sortable() directly.

    YANG Description: sortable: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sortable", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sortable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sortable", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__sortable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sortable(self):
    self.__sortable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sortable", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_hidden(self):
    """
    Getter method for hidden, mapped from YANG variable /view_templates/template/property/hidden (boolean)

    YANG Description: Sometimes certain properties are hidden, for example, the id of an entity
    """
    return self.__hidden
      
  def _set_hidden(self, v, load=False):
    """
    Setter method for hidden, mapped from YANG variable /view_templates/template/property/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: Sometimes certain properties are hidden, for example, the id of an entity
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hidden must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__hidden = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hidden(self):
    self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /view_templates/template/property/source (string)

    YANG Description: This is the source of information. The value should be something resolvable in the system
   It is quiet possible to think of various data sources; such as; 
   the value is a constant
   value may be an enum
   value may be retrieved from a DTO property
   value may be retrieved from a DO property
   value may be looked from a database query
   value may come from a rest call
   so on and so forth. 
   
   Obviously, the engine that fronts the resolution logic, has to know the nature of the source,
   meaning, some convention has to be followed.
   
   I am thinking of following convention, but, this really needs to evolve with the engine ..
   
   =abc   // take it as literal value abc
   dto:com.anuta.x.y/prop1          //prop1 of the dto instance of a com.anuta.x.y
   dataaccess:com.anuta.x.yDO/prop1 //prop1 of the DO instance of a com.anuta.x.yDO
   rcpath:
   xpath:
   rest:
   sql:  ? sql injection issues ..
   
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /view_templates/template/property/source (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: This is the source of information. The value should be something resolvable in the system
   It is quiet possible to think of various data sources; such as; 
   the value is a constant
   value may be an enum
   value may be retrieved from a DTO property
   value may be retrieved from a DO property
   value may be looked from a database query
   value may come from a rest call
   so on and so forth. 
   
   Obviously, the engine that fronts the resolution logic, has to know the nature of the source,
   meaning, some convention has to be followed.
   
   I am thinking of following convention, but, this really needs to evolve with the engine ..
   
   =abc   // take it as literal value abc
   dto:com.anuta.x.y/prop1          //prop1 of the dto instance of a com.anuta.x.y
   dataaccess:com.anuta.x.yDO/prop1 //prop1 of the DO instance of a com.anuta.x.yDO
   rcpath:
   xpath:
   rest:
   sql:  ? sql injection issues ..
   
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="source", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="source", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=unicode, is_leaf=True, yang_name="source", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  included_by_default = __builtin__.property(_get_included_by_default, _set_included_by_default)
  default_width = __builtin__.property(_get_default_width, _set_default_width)
  label = __builtin__.property(_get_label, _set_label)
  displayFormat = __builtin__.property(_get_displayFormat, _set_displayFormat)
  icon = __builtin__.property(_get_icon, _set_icon)
  sortable = __builtin__.property(_get_sortable, _set_sortable)
  hidden = __builtin__.property(_get_hidden, _set_hidden)
  source = __builtin__.property(_get_source, _set_source)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('included_by_default', included_by_default), ('default_width', default_width), ('label', label), ('displayFormat', displayFormat), ('icon', icon), ('sortable', sortable), ('hidden', hidden), ('source', source), ])


