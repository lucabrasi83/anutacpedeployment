
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class ownership_cascades(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /access-control/ownership-cascades. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
Background info:
      An entity instance is owned by a tenant. When a user/client code submits a payload, there is provision to specify which tenant will be the owner of the entities being created/updated.
      This is a finer level control. When the client code does not provide the owner explicitly, the platform is going to determine a default tenant (for the user making the api calls).
      There is also a provision to declare the ownership of a sub tree of objects to be inherited from a parent. For ex; say, you create a device and set owner as Acme. You could mark it as 'cascade-owner' to true
       to indicate that all the contents of the device are also owned by Acme.
Using this model, users/admins can designate which entities can be made to cascade their owners.
Platform is going to check this configuration when it needs to assign an owner and no explicit 'cascade' option is specified in the user/api payloads.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__schema_path',)

  _yang_name = 'ownership-cascades'
  _module_name = 'accesscontrol'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__schema_path = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="schema-path", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-control', u'ownership-cascades']

  def _get_schema_path(self):
    """
    Getter method for schema_path, mapped from YANG variable /access_control/ownership_cascades/schema_path (string)

    YANG Description: string
    """
    return self.__schema_path
      
  def _set_schema_path(self, v, load=False):
    """
    Setter method for schema_path, mapped from YANG variable /access_control/ownership_cascades/schema_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_path() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="schema-path", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema_path must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="schema-path", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__schema_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema_path(self):
    self.__schema_path = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="schema-path", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)

  schema_path = __builtin__.property(_get_schema_path, _set_schema_path)


  _pyangbind_elements = collections.OrderedDict([('schema_path', schema_path), ])


