
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import roles
import auth_priorities
import users
import ldaps
import tacacs
import active_directories
import ownership_cascades
class access_control(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /access-control. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__roles','__auth_priorities','__users','__ldaps','__tacacs','__active_directories','__ownership_cascades',)

  _yang_name = 'access-control'
  _module_name = 'controller'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__users = YANGDynClass(base=users.users, is_container='container', yang_name="users", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__roles = YANGDynClass(base=roles.roles, is_container='container', yang_name="roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__tacacs = YANGDynClass(base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ldaps = YANGDynClass(base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__auth_priorities = YANGDynClass(base=auth_priorities.auth_priorities, is_container='container', yang_name="auth-priorities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__active_directories = YANGDynClass(base=active_directories.active_directories, is_container='container', yang_name="active-directories", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ownership_cascades = YANGDynClass(base=ownership_cascades.ownership_cascades, is_container='container', yang_name="ownership-cascades", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'access-control']

  def _get_roles(self):
    """
    Getter method for roles, mapped from YANG variable /access_control/roles (container)
    """
    return self.__roles
      
  def _set_roles(self, v, load=False):
    """
    Setter method for roles, mapped from YANG variable /access_control/roles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_roles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_roles() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=roles.roles, is_container='container', yang_name="roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """roles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=roles.roles, is_container='container', yang_name="roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__roles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_roles(self):
    self.__roles = YANGDynClass(base=roles.roles, is_container='container', yang_name="roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_auth_priorities(self):
    """
    Getter method for auth_priorities, mapped from YANG variable /access_control/auth_priorities (container)
    """
    return self.__auth_priorities
      
  def _set_auth_priorities(self, v, load=False):
    """
    Setter method for auth_priorities, mapped from YANG variable /access_control/auth_priorities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_priorities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_priorities() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=auth_priorities.auth_priorities, is_container='container', yang_name="auth-priorities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_priorities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=auth_priorities.auth_priorities, is_container='container', yang_name="auth-priorities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__auth_priorities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_priorities(self):
    self.__auth_priorities = YANGDynClass(base=auth_priorities.auth_priorities, is_container='container', yang_name="auth-priorities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_users(self):
    """
    Getter method for users, mapped from YANG variable /access_control/users (container)
    """
    return self.__users
      
  def _set_users(self, v, load=False):
    """
    Setter method for users, mapped from YANG variable /access_control/users (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_users is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_users() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=users.users, is_container='container', yang_name="users", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """users must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=users.users, is_container='container', yang_name="users", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__users = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_users(self):
    self.__users = YANGDynClass(base=users.users, is_container='container', yang_name="users", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ldaps(self):
    """
    Getter method for ldaps, mapped from YANG variable /access_control/ldaps (container)
    """
    return self.__ldaps
      
  def _set_ldaps(self, v, load=False):
    """
    Setter method for ldaps, mapped from YANG variable /access_control/ldaps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldaps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldaps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldaps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ldaps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldaps(self):
    self.__ldaps = YANGDynClass(base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_tacacs(self):
    """
    Getter method for tacacs, mapped from YANG variable /access_control/tacacs (container)
    """
    return self.__tacacs
      
  def _set_tacacs(self, v, load=False):
    """
    Setter method for tacacs, mapped from YANG variable /access_control/tacacs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tacacs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tacacs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tacacs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__tacacs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tacacs(self):
    self.__tacacs = YANGDynClass(base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_active_directories(self):
    """
    Getter method for active_directories, mapped from YANG variable /access_control/active_directories (container)
    """
    return self.__active_directories
      
  def _set_active_directories(self, v, load=False):
    """
    Setter method for active_directories, mapped from YANG variable /access_control/active_directories (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_directories is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_directories() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=active_directories.active_directories, is_container='container', yang_name="active-directories", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_directories must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=active_directories.active_directories, is_container='container', yang_name="active-directories", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__active_directories = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_directories(self):
    self.__active_directories = YANGDynClass(base=active_directories.active_directories, is_container='container', yang_name="active-directories", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ownership_cascades(self):
    """
    Getter method for ownership_cascades, mapped from YANG variable /access_control/ownership_cascades (container)

    YANG Description: 
Background info:
      An entity instance is owned by a tenant. When a user/client code submits a payload, there is provision to specify which tenant will be the owner of the entities being created/updated.
      This is a finer level control. When the client code does not provide the owner explicitly, the platform is going to determine a default tenant (for the user making the api calls).
      There is also a provision to declare the ownership of a sub tree of objects to be inherited from a parent. For ex; say, you create a device and set owner as Acme. You could mark it as 'cascade-owner' to true
       to indicate that all the contents of the device are also owned by Acme.
Using this model, users/admins can designate which entities can be made to cascade their owners.
Platform is going to check this configuration when it needs to assign an owner and no explicit 'cascade' option is specified in the user/api payloads.
    """
    return self.__ownership_cascades
      
  def _set_ownership_cascades(self, v, load=False):
    """
    Setter method for ownership_cascades, mapped from YANG variable /access_control/ownership_cascades (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ownership_cascades is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ownership_cascades() directly.

    YANG Description: 
Background info:
      An entity instance is owned by a tenant. When a user/client code submits a payload, there is provision to specify which tenant will be the owner of the entities being created/updated.
      This is a finer level control. When the client code does not provide the owner explicitly, the platform is going to determine a default tenant (for the user making the api calls).
      There is also a provision to declare the ownership of a sub tree of objects to be inherited from a parent. For ex; say, you create a device and set owner as Acme. You could mark it as 'cascade-owner' to true
       to indicate that all the contents of the device are also owned by Acme.
Using this model, users/admins can designate which entities can be made to cascade their owners.
Platform is going to check this configuration when it needs to assign an owner and no explicit 'cascade' option is specified in the user/api payloads.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ownership_cascades.ownership_cascades, is_container='container', yang_name="ownership-cascades", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ownership_cascades must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ownership_cascades.ownership_cascades, is_container='container', yang_name="ownership-cascades", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ownership_cascades = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ownership_cascades(self):
    self.__ownership_cascades = YANGDynClass(base=ownership_cascades.ownership_cascades, is_container='container', yang_name="ownership-cascades", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

  roles = __builtin__.property(_get_roles, _set_roles)
  auth_priorities = __builtin__.property(_get_auth_priorities, _set_auth_priorities)
  users = __builtin__.property(_get_users, _set_users)
  ldaps = __builtin__.property(_get_ldaps, _set_ldaps)
  tacacs = __builtin__.property(_get_tacacs, _set_tacacs)
  active_directories = __builtin__.property(_get_active_directories, _set_active_directories)
  ownership_cascades = __builtin__.property(_get_ownership_cascades, _set_ownership_cascades)


  _pyangbind_elements = collections.OrderedDict([('roles', roles), ('auth_priorities', auth_priorities), ('users', users), ('ldaps', ldaps), ('tacacs', tacacs), ('active_directories', active_directories), ('ownership_cascades', ownership_cascades), ])


