
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import anuta_features
import syslog_event_specs
import snmp_attributes
import snmp_attribute_groups
import config_retrieval
import port_types
import dynamic_choices
import simple_typedefs
import dynamic_typedefs
import complex_typedefs
import service_icons
import feature_handlers
import event_rpc_maps
class network_functions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /network-functions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__anuta_features','__syslog_event_specs','__snmp_attributes','__snmp_attribute_groups','__config_retrieval','__port_types','__dynamic_choices','__simple_typedefs','__dynamic_typedefs','__complex_typedefs','__service_icons','__feature_handlers','__event_rpc_maps',)

  _yang_name = 'network-functions'
  _module_name = 'controller'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__event_rpc_maps = YANGDynClass(base=event_rpc_maps.event_rpc_maps, is_container='container', yang_name="event-rpc-maps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__snmp_attributes = YANGDynClass(base=snmp_attributes.snmp_attributes, is_container='container', yang_name="snmp-attributes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__dynamic_choices = YANGDynClass(base=dynamic_choices.dynamic_choices, is_container='container', yang_name="dynamic-choices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__feature_handlers = YANGDynClass(base=feature_handlers.feature_handlers, is_container='container', yang_name="feature-handlers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__syslog_event_specs = YANGDynClass(base=syslog_event_specs.syslog_event_specs, is_container='container', yang_name="syslog-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__complex_typedefs = YANGDynClass(base=complex_typedefs.complex_typedefs, is_container='container', yang_name="complex-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__port_types = YANGDynClass(base=port_types.port_types, is_container='container', yang_name="port-types", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__anuta_features = YANGDynClass(base=anuta_features.anuta_features, is_container='container', yang_name="anuta-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__dynamic_typedefs = YANGDynClass(base=dynamic_typedefs.dynamic_typedefs, is_container='container', yang_name="dynamic-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__config_retrieval = YANGDynClass(base=config_retrieval.config_retrieval, is_container='container', yang_name="config-retrieval", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__snmp_attribute_groups = YANGDynClass(base=snmp_attribute_groups.snmp_attribute_groups, is_container='container', yang_name="snmp-attribute-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__simple_typedefs = YANGDynClass(base=simple_typedefs.simple_typedefs, is_container='container', yang_name="simple-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__service_icons = YANGDynClass(base=service_icons.service_icons, is_container='container', yang_name="service-icons", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'network-functions']

  def _get_anuta_features(self):
    """
    Getter method for anuta_features, mapped from YANG variable /network_functions/anuta_features (container)
    """
    return self.__anuta_features
      
  def _set_anuta_features(self, v, load=False):
    """
    Setter method for anuta_features, mapped from YANG variable /network_functions/anuta_features (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_anuta_features is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_anuta_features() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=anuta_features.anuta_features, is_container='container', yang_name="anuta-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """anuta_features must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=anuta_features.anuta_features, is_container='container', yang_name="anuta-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__anuta_features = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_anuta_features(self):
    self.__anuta_features = YANGDynClass(base=anuta_features.anuta_features, is_container='container', yang_name="anuta-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_syslog_event_specs(self):
    """
    Getter method for syslog_event_specs, mapped from YANG variable /network_functions/syslog_event_specs (container)
    """
    return self.__syslog_event_specs
      
  def _set_syslog_event_specs(self, v, load=False):
    """
    Setter method for syslog_event_specs, mapped from YANG variable /network_functions/syslog_event_specs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_syslog_event_specs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_syslog_event_specs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=syslog_event_specs.syslog_event_specs, is_container='container', yang_name="syslog-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """syslog_event_specs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=syslog_event_specs.syslog_event_specs, is_container='container', yang_name="syslog-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__syslog_event_specs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_syslog_event_specs(self):
    self.__syslog_event_specs = YANGDynClass(base=syslog_event_specs.syslog_event_specs, is_container='container', yang_name="syslog-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_snmp_attributes(self):
    """
    Getter method for snmp_attributes, mapped from YANG variable /network_functions/snmp_attributes (container)
    """
    return self.__snmp_attributes
      
  def _set_snmp_attributes(self, v, load=False):
    """
    Setter method for snmp_attributes, mapped from YANG variable /network_functions/snmp_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp_attributes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=snmp_attributes.snmp_attributes, is_container='container', yang_name="snmp-attributes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=snmp_attributes.snmp_attributes, is_container='container', yang_name="snmp-attributes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__snmp_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp_attributes(self):
    self.__snmp_attributes = YANGDynClass(base=snmp_attributes.snmp_attributes, is_container='container', yang_name="snmp-attributes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_snmp_attribute_groups(self):
    """
    Getter method for snmp_attribute_groups, mapped from YANG variable /network_functions/snmp_attribute_groups (container)
    """
    return self.__snmp_attribute_groups
      
  def _set_snmp_attribute_groups(self, v, load=False):
    """
    Setter method for snmp_attribute_groups, mapped from YANG variable /network_functions/snmp_attribute_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp_attribute_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp_attribute_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=snmp_attribute_groups.snmp_attribute_groups, is_container='container', yang_name="snmp-attribute-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp_attribute_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=snmp_attribute_groups.snmp_attribute_groups, is_container='container', yang_name="snmp-attribute-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__snmp_attribute_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp_attribute_groups(self):
    self.__snmp_attribute_groups = YANGDynClass(base=snmp_attribute_groups.snmp_attribute_groups, is_container='container', yang_name="snmp-attribute-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_config_retrieval(self):
    """
    Getter method for config_retrieval, mapped from YANG variable /network_functions/config_retrieval (container)
    """
    return self.__config_retrieval
      
  def _set_config_retrieval(self, v, load=False):
    """
    Setter method for config_retrieval, mapped from YANG variable /network_functions/config_retrieval (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_retrieval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_retrieval() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=config_retrieval.config_retrieval, is_container='container', yang_name="config-retrieval", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config_retrieval must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config_retrieval.config_retrieval, is_container='container', yang_name="config-retrieval", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__config_retrieval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config_retrieval(self):
    self.__config_retrieval = YANGDynClass(base=config_retrieval.config_retrieval, is_container='container', yang_name="config-retrieval", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_port_types(self):
    """
    Getter method for port_types, mapped from YANG variable /network_functions/port_types (container)
    """
    return self.__port_types
      
  def _set_port_types(self, v, load=False):
    """
    Setter method for port_types, mapped from YANG variable /network_functions/port_types (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_types() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=port_types.port_types, is_container='container', yang_name="port-types", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_types must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=port_types.port_types, is_container='container', yang_name="port-types", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__port_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_types(self):
    self.__port_types = YANGDynClass(base=port_types.port_types, is_container='container', yang_name="port-types", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_dynamic_choices(self):
    """
    Getter method for dynamic_choices, mapped from YANG variable /network_functions/dynamic_choices (container)
    """
    return self.__dynamic_choices
      
  def _set_dynamic_choices(self, v, load=False):
    """
    Setter method for dynamic_choices, mapped from YANG variable /network_functions/dynamic_choices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_choices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_choices() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dynamic_choices.dynamic_choices, is_container='container', yang_name="dynamic-choices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_choices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dynamic_choices.dynamic_choices, is_container='container', yang_name="dynamic-choices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__dynamic_choices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_choices(self):
    self.__dynamic_choices = YANGDynClass(base=dynamic_choices.dynamic_choices, is_container='container', yang_name="dynamic-choices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_simple_typedefs(self):
    """
    Getter method for simple_typedefs, mapped from YANG variable /network_functions/simple_typedefs (container)
    """
    return self.__simple_typedefs
      
  def _set_simple_typedefs(self, v, load=False):
    """
    Setter method for simple_typedefs, mapped from YANG variable /network_functions/simple_typedefs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_simple_typedefs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_simple_typedefs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=simple_typedefs.simple_typedefs, is_container='container', yang_name="simple-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """simple_typedefs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=simple_typedefs.simple_typedefs, is_container='container', yang_name="simple-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__simple_typedefs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_simple_typedefs(self):
    self.__simple_typedefs = YANGDynClass(base=simple_typedefs.simple_typedefs, is_container='container', yang_name="simple-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_dynamic_typedefs(self):
    """
    Getter method for dynamic_typedefs, mapped from YANG variable /network_functions/dynamic_typedefs (container)
    """
    return self.__dynamic_typedefs
      
  def _set_dynamic_typedefs(self, v, load=False):
    """
    Setter method for dynamic_typedefs, mapped from YANG variable /network_functions/dynamic_typedefs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_typedefs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_typedefs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dynamic_typedefs.dynamic_typedefs, is_container='container', yang_name="dynamic-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_typedefs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dynamic_typedefs.dynamic_typedefs, is_container='container', yang_name="dynamic-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__dynamic_typedefs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_typedefs(self):
    self.__dynamic_typedefs = YANGDynClass(base=dynamic_typedefs.dynamic_typedefs, is_container='container', yang_name="dynamic-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_complex_typedefs(self):
    """
    Getter method for complex_typedefs, mapped from YANG variable /network_functions/complex_typedefs (container)
    """
    return self.__complex_typedefs
      
  def _set_complex_typedefs(self, v, load=False):
    """
    Setter method for complex_typedefs, mapped from YANG variable /network_functions/complex_typedefs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_complex_typedefs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_complex_typedefs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=complex_typedefs.complex_typedefs, is_container='container', yang_name="complex-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """complex_typedefs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=complex_typedefs.complex_typedefs, is_container='container', yang_name="complex-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__complex_typedefs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_complex_typedefs(self):
    self.__complex_typedefs = YANGDynClass(base=complex_typedefs.complex_typedefs, is_container='container', yang_name="complex-typedefs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_service_icons(self):
    """
    Getter method for service_icons, mapped from YANG variable /network_functions/service_icons (container)
    """
    return self.__service_icons
      
  def _set_service_icons(self, v, load=False):
    """
    Setter method for service_icons, mapped from YANG variable /network_functions/service_icons (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_icons is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_icons() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_icons.service_icons, is_container='container', yang_name="service-icons", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_icons must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_icons.service_icons, is_container='container', yang_name="service-icons", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__service_icons = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_icons(self):
    self.__service_icons = YANGDynClass(base=service_icons.service_icons, is_container='container', yang_name="service-icons", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_feature_handlers(self):
    """
    Getter method for feature_handlers, mapped from YANG variable /network_functions/feature_handlers (container)
    """
    return self.__feature_handlers
      
  def _set_feature_handlers(self, v, load=False):
    """
    Setter method for feature_handlers, mapped from YANG variable /network_functions/feature_handlers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature_handlers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature_handlers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=feature_handlers.feature_handlers, is_container='container', yang_name="feature-handlers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature_handlers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=feature_handlers.feature_handlers, is_container='container', yang_name="feature-handlers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__feature_handlers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature_handlers(self):
    self.__feature_handlers = YANGDynClass(base=feature_handlers.feature_handlers, is_container='container', yang_name="feature-handlers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_event_rpc_maps(self):
    """
    Getter method for event_rpc_maps, mapped from YANG variable /network_functions/event_rpc_maps (container)
    """
    return self.__event_rpc_maps
      
  def _set_event_rpc_maps(self, v, load=False):
    """
    Setter method for event_rpc_maps, mapped from YANG variable /network_functions/event_rpc_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_rpc_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_rpc_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=event_rpc_maps.event_rpc_maps, is_container='container', yang_name="event-rpc-maps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_rpc_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=event_rpc_maps.event_rpc_maps, is_container='container', yang_name="event-rpc-maps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__event_rpc_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_rpc_maps(self):
    self.__event_rpc_maps = YANGDynClass(base=event_rpc_maps.event_rpc_maps, is_container='container', yang_name="event-rpc-maps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

  anuta_features = __builtin__.property(_get_anuta_features, _set_anuta_features)
  syslog_event_specs = __builtin__.property(_get_syslog_event_specs, _set_syslog_event_specs)
  snmp_attributes = __builtin__.property(_get_snmp_attributes, _set_snmp_attributes)
  snmp_attribute_groups = __builtin__.property(_get_snmp_attribute_groups, _set_snmp_attribute_groups)
  config_retrieval = __builtin__.property(_get_config_retrieval, _set_config_retrieval)
  port_types = __builtin__.property(_get_port_types, _set_port_types)
  dynamic_choices = __builtin__.property(_get_dynamic_choices, _set_dynamic_choices)
  simple_typedefs = __builtin__.property(_get_simple_typedefs, _set_simple_typedefs)
  dynamic_typedefs = __builtin__.property(_get_dynamic_typedefs, _set_dynamic_typedefs)
  complex_typedefs = __builtin__.property(_get_complex_typedefs, _set_complex_typedefs)
  service_icons = __builtin__.property(_get_service_icons, _set_service_icons)
  feature_handlers = __builtin__.property(_get_feature_handlers, _set_feature_handlers)
  event_rpc_maps = __builtin__.property(_get_event_rpc_maps, _set_event_rpc_maps)


  _pyangbind_elements = collections.OrderedDict([('anuta_features', anuta_features), ('syslog_event_specs', syslog_event_specs), ('snmp_attributes', snmp_attributes), ('snmp_attribute_groups', snmp_attribute_groups), ('config_retrieval', config_retrieval), ('port_types', port_types), ('dynamic_choices', dynamic_choices), ('simple_typedefs', simple_typedefs), ('dynamic_typedefs', dynamic_typedefs), ('complex_typedefs', complex_typedefs), ('service_icons', service_icons), ('feature_handlers', feature_handlers), ('event_rpc_maps', event_rpc_maps), ])


