
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class vnfdriver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfdriver - based on the path /vnfdriver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import global_resource_pool_config
import resource_pools
class resourcepool(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module resourcepool - based on the path /resourcepool. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__global_resource_pool_config','__resource_pools',)

  _yang_name = 'resourcepool'
  _module_name = 'resourcepool'
  _namespace = 'http://anutanetworks.com/resourcepool'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_resource_pool_config = YANGDynClass(base=global_resource_pool_config.global_resource_pool_config, is_container='container', yang_name="global-resource-pool-config", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)
    self.__resource_pools = YANGDynClass(base=resource_pools.resource_pools, is_container='container', yang_name="resource-pools", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_global_resource_pool_config(self):
    """
    Getter method for global_resource_pool_config, mapped from YANG variable /global_resource_pool_config (container)
    """
    return self.__global_resource_pool_config
      
  def _set_global_resource_pool_config(self, v, load=False):
    """
    Setter method for global_resource_pool_config, mapped from YANG variable /global_resource_pool_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_resource_pool_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_resource_pool_config() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=global_resource_pool_config.global_resource_pool_config, is_container='container', yang_name="global-resource-pool-config", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_resource_pool_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=global_resource_pool_config.global_resource_pool_config, is_container='container', yang_name="global-resource-pool-config", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)""",
        })

    self.__global_resource_pool_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_resource_pool_config(self):
    self.__global_resource_pool_config = YANGDynClass(base=global_resource_pool_config.global_resource_pool_config, is_container='container', yang_name="global-resource-pool-config", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)


  def _get_resource_pools(self):
    """
    Getter method for resource_pools, mapped from YANG variable /resource_pools (container)
    """
    return self.__resource_pools
      
  def _set_resource_pools(self, v, load=False):
    """
    Setter method for resource_pools, mapped from YANG variable /resource_pools (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resource_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resource_pools() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=resource_pools.resource_pools, is_container='container', yang_name="resource-pools", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resource_pools must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=resource_pools.resource_pools, is_container='container', yang_name="resource-pools", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)""",
        })

    self.__resource_pools = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resource_pools(self):
    self.__resource_pools = YANGDynClass(base=resource_pools.resource_pools, is_container='container', yang_name="resource-pools", module_name="resourcepool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/resourcepool', defining_module='resourcepool', yang_type='container', is_config=True)

  global_resource_pool_config = __builtin__.property(_get_global_resource_pool_config, _set_global_resource_pool_config)
  resource_pools = __builtin__.property(_get_resource_pools, _set_resource_pools)


  _pyangbind_elements = collections.OrderedDict([('global_resource_pool_config', global_resource_pool_config), ('resource_pools', resource_pools), ])


import tasks_
class tasks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tasks - based on the path /tasks. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__tasks',)

  _yang_name = 'tasks'
  _module_name = 'tasks'
  _namespace = 'http://anutanetworks.com/tasks'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tasks = YANGDynClass(base=tasks_.tasks, is_container='container', yang_name="tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_tasks(self):
    """
    Getter method for tasks, mapped from YANG variable /tasks (container)
    """
    return self.__tasks
      
  def _set_tasks(self, v, load=False):
    """
    Setter method for tasks, mapped from YANG variable /tasks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tasks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tasks() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tasks_.tasks, is_container='container', yang_name="tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tasks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tasks_.tasks, is_container='container', yang_name="tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='container', is_config=True)""",
        })

    self.__tasks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tasks(self):
    self.__tasks = YANGDynClass(base=tasks_.tasks, is_container='container', yang_name="tasks", module_name="tasks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/tasks', defining_module='tasks', yang_type='container', is_config=True)

  tasks = __builtin__.property(_get_tasks, _set_tasks)


  _pyangbind_elements = collections.OrderedDict([('tasks', tasks), ])


class sciencelogic(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sciencelogic - based on the path /sciencelogic. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import identity_groups
import user_identity_groups
class identitygroups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module identitygroups - based on the path /identitygroups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__identity_groups','__user_identity_groups',)

  _yang_name = 'identitygroups'
  _module_name = 'identitygroups'
  _namespace = 'http://anutanetworks.com/identitygroups'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__identity_groups = YANGDynClass(base=identity_groups.identity_groups, is_container='container', yang_name="identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)
    self.__user_identity_groups = YANGDynClass(base=user_identity_groups.user_identity_groups, is_container='container', yang_name="user-identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_identity_groups(self):
    """
    Getter method for identity_groups, mapped from YANG variable /identity_groups (container)
    """
    return self.__identity_groups
      
  def _set_identity_groups(self, v, load=False):
    """
    Setter method for identity_groups, mapped from YANG variable /identity_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identity_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identity_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=identity_groups.identity_groups, is_container='container', yang_name="identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identity_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=identity_groups.identity_groups, is_container='container', yang_name="identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)""",
        })

    self.__identity_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identity_groups(self):
    self.__identity_groups = YANGDynClass(base=identity_groups.identity_groups, is_container='container', yang_name="identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)


  def _get_user_identity_groups(self):
    """
    Getter method for user_identity_groups, mapped from YANG variable /user_identity_groups (container)
    """
    return self.__user_identity_groups
      
  def _set_user_identity_groups(self, v, load=False):
    """
    Setter method for user_identity_groups, mapped from YANG variable /user_identity_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_identity_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_identity_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=user_identity_groups.user_identity_groups, is_container='container', yang_name="user-identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_identity_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=user_identity_groups.user_identity_groups, is_container='container', yang_name="user-identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)""",
        })

    self.__user_identity_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_identity_groups(self):
    self.__user_identity_groups = YANGDynClass(base=user_identity_groups.user_identity_groups, is_container='container', yang_name="user-identity-groups", module_name="identitygroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/identitygroups', defining_module='identitygroups', yang_type='container', is_config=True)

  identity_groups = __builtin__.property(_get_identity_groups, _set_identity_groups)
  user_identity_groups = __builtin__.property(_get_user_identity_groups, _set_user_identity_groups)


  _pyangbind_elements = collections.OrderedDict([('identity_groups', identity_groups), ('user_identity_groups', user_identity_groups), ])


class rule_engine_events(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module rule-engine-events - based on the path /rule-engine-events. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class servicemodel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module servicemodel - based on the path /servicemodel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class ncx_ui_utils(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-ui-utils - based on the path /ncx-ui-utils. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import set_community
import idtest
import uniontest
class testModule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module testModule - based on the path /testModule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__set_community','__idtest','__uniontest',)

  _yang_name = 'testModule'
  _module_name = 'testModule'
  _namespace = 'http://anutanetworks.com/testModule'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uniontest = YANGDynClass(base=uniontest.uniontest, is_container='container', yang_name="uniontest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)
    self.__idtest = YANGDynClass(base=idtest.idtest, is_container='container', yang_name="idtest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)
    self.__set_community = YANGDynClass(base=set_community.set_community, is_container='container', yang_name="set-community", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_set_community(self):
    """
    Getter method for set_community, mapped from YANG variable /set_community (container)

    YANG Description: action to set the community attributes of the route, along
with options to modify how the community is modified
    """
    return self.__set_community
      
  def _set_set_community(self, v, load=False):
    """
    Setter method for set_community, mapped from YANG variable /set_community (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_set_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_set_community() directly.

    YANG Description: action to set the community attributes of the route, along
with options to modify how the community is modified
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=set_community.set_community, is_container='container', yang_name="set-community", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """set_community must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=set_community.set_community, is_container='container', yang_name="set-community", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)""",
        })

    self.__set_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_set_community(self):
    self.__set_community = YANGDynClass(base=set_community.set_community, is_container='container', yang_name="set-community", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)


  def _get_idtest(self):
    """
    Getter method for idtest, mapped from YANG variable /idtest (container)
    """
    return self.__idtest
      
  def _set_idtest(self, v, load=False):
    """
    Setter method for idtest, mapped from YANG variable /idtest (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idtest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idtest() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=idtest.idtest, is_container='container', yang_name="idtest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idtest must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=idtest.idtest, is_container='container', yang_name="idtest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)""",
        })

    self.__idtest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idtest(self):
    self.__idtest = YANGDynClass(base=idtest.idtest, is_container='container', yang_name="idtest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)


  def _get_uniontest(self):
    """
    Getter method for uniontest, mapped from YANG variable /uniontest (container)
    """
    return self.__uniontest
      
  def _set_uniontest(self, v, load=False):
    """
    Setter method for uniontest, mapped from YANG variable /uniontest (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uniontest is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uniontest() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=uniontest.uniontest, is_container='container', yang_name="uniontest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uniontest must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=uniontest.uniontest, is_container='container', yang_name="uniontest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)""",
        })

    self.__uniontest = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uniontest(self):
    self.__uniontest = YANGDynClass(base=uniontest.uniontest, is_container='container', yang_name="uniontest", module_name="testModule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/testModule', defining_module='testModule', yang_type='container', is_config=True)

  set_community = __builtin__.property(_get_set_community, _set_set_community)
  idtest = __builtin__.property(_get_idtest, _set_idtest)
  uniontest = __builtin__.property(_get_uniontest, _set_uniontest)


  _pyangbind_elements = collections.OrderedDict([('set_community', set_community), ('idtest', idtest), ('uniontest', uniontest), ])


class basicconfigs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module basicconfigs - based on the path /basicconfigs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import cloudhosting_
class cloudhosting(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cloudhosting - based on the path /cloudhosting. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__cloudhosting',)

  _yang_name = 'cloudhosting'
  _module_name = 'cloudhosting'
  _namespace = 'http://anutanetworks.com/cloudhosting'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cloudhosting = YANGDynClass(base=cloudhosting_.cloudhosting, is_container='container', yang_name="cloudhosting", module_name="cloudhosting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cloudhosting', defining_module='cloudhosting', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_cloudhosting(self):
    """
    Getter method for cloudhosting, mapped from YANG variable /cloudhosting (container)
    """
    return self.__cloudhosting
      
  def _set_cloudhosting(self, v, load=False):
    """
    Setter method for cloudhosting, mapped from YANG variable /cloudhosting (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloudhosting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloudhosting() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=cloudhosting_.cloudhosting, is_container='container', yang_name="cloudhosting", module_name="cloudhosting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cloudhosting', defining_module='cloudhosting', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cloudhosting must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cloudhosting_.cloudhosting, is_container='container', yang_name="cloudhosting", module_name="cloudhosting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cloudhosting', defining_module='cloudhosting', yang_type='container', is_config=True)""",
        })

    self.__cloudhosting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cloudhosting(self):
    self.__cloudhosting = YANGDynClass(base=cloudhosting_.cloudhosting, is_container='container', yang_name="cloudhosting", module_name="cloudhosting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/cloudhosting', defining_module='cloudhosting', yang_type='container', is_config=True)

  cloudhosting = __builtin__.property(_get_cloudhosting, _set_cloudhosting)


  _pyangbind_elements = collections.OrderedDict([('cloudhosting', cloudhosting), ])


class migration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module migration - based on the path /migration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import dci
class dcinterconnect(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dcinterconnect - based on the path /dcinterconnect. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__dci',)

  _yang_name = 'dcinterconnect'
  _module_name = 'dcinterconnect'
  _namespace = 'http://anutanetworks.com/dcinterconnect'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dci = YANGDynClass(base=dci.dci, is_container='container', yang_name="dci", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_dci(self):
    """
    Getter method for dci, mapped from YANG variable /dci (container)
    """
    return self.__dci
      
  def _set_dci(self, v, load=False):
    """
    Setter method for dci, mapped from YANG variable /dci (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dci() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=dci.dci, is_container='container', yang_name="dci", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dci must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dci.dci, is_container='container', yang_name="dci", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='container', is_config=True)""",
        })

    self.__dci = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dci(self):
    self.__dci = YANGDynClass(base=dci.dci, is_container='container', yang_name="dci", module_name="dcinterconnect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/dcinterconnect', defining_module='dcinterconnect', yang_type='container', is_config=True)

  dci = __builtin__.property(_get_dci, _set_dci)


  _pyangbind_elements = collections.OrderedDict([('dci', dci), ])


import compliance
class ncx_compliance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-compliance - based on the path /ncx-compliance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__compliance',)

  _yang_name = 'ncx-compliance'
  _module_name = 'ncx-compliance'
  _namespace = 'http://anutanetworks.com/ncx-compliance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__compliance = YANGDynClass(base=compliance.compliance, is_container='container', yang_name="compliance", module_name="ncx-compliance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ncx-compliance', defining_module='ncx-compliance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_compliance(self):
    """
    Getter method for compliance, mapped from YANG variable /compliance (container)
    """
    return self.__compliance
      
  def _set_compliance(self, v, load=False):
    """
    Setter method for compliance, mapped from YANG variable /compliance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compliance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compliance() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=compliance.compliance, is_container='container', yang_name="compliance", module_name="ncx-compliance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ncx-compliance', defining_module='ncx-compliance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compliance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=compliance.compliance, is_container='container', yang_name="compliance", module_name="ncx-compliance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ncx-compliance', defining_module='ncx-compliance', yang_type='container', is_config=True)""",
        })

    self.__compliance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compliance(self):
    self.__compliance = YANGDynClass(base=compliance.compliance, is_container='container', yang_name="compliance", module_name="ncx-compliance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ncx-compliance', defining_module='ncx-compliance', yang_type='container', is_config=True)

  compliance = __builtin__.property(_get_compliance, _set_compliance)


  _pyangbind_elements = collections.OrderedDict([('compliance', compliance), ])


class devtools(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module devtools - based on the path /devtools. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class devicesupport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module devicesupport - based on the path /devicesupport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class ncx(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx - based on the path /ncx. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class reconciliation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module reconciliation - based on the path /reconciliation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class servicefeature(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module servicefeature - based on the path /servicefeature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class modelmapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module modelmapping - based on the path /modelmapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class workflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module workflow - based on the path /workflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module system - based on the path /system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class oids(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module oids - based on the path /oids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class cset(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cset - based on the path /cset. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class internal(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module internal - based on the path /internal. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import buildings
import rooms
import circuits
import circuits_info
import locations
class location(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module location - based on the path /location. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__buildings','__rooms','__circuits','__circuits_info','__locations',)

  _yang_name = 'location'
  _module_name = 'location'
  _namespace = 'http://anutanetworks.com/location'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__circuits = YANGDynClass(base=circuits.circuits, is_container='container', yang_name="circuits", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    self.__buildings = YANGDynClass(base=buildings.buildings, is_container='container', yang_name="buildings", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    self.__rooms = YANGDynClass(base=rooms.rooms, is_container='container', yang_name="rooms", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    self.__circuits_info = YANGDynClass(base=circuits_info.circuits_info, is_container='container', yang_name="circuits-info", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    self.__locations = YANGDynClass(base=locations.locations, is_container='container', yang_name="locations", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_buildings(self):
    """
    Getter method for buildings, mapped from YANG variable /buildings (container)
    """
    return self.__buildings
      
  def _set_buildings(self, v, load=False):
    """
    Setter method for buildings, mapped from YANG variable /buildings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_buildings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_buildings() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=buildings.buildings, is_container='container', yang_name="buildings", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """buildings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=buildings.buildings, is_container='container', yang_name="buildings", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)""",
        })

    self.__buildings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_buildings(self):
    self.__buildings = YANGDynClass(base=buildings.buildings, is_container='container', yang_name="buildings", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)


  def _get_rooms(self):
    """
    Getter method for rooms, mapped from YANG variable /rooms (container)
    """
    return self.__rooms
      
  def _set_rooms(self, v, load=False):
    """
    Setter method for rooms, mapped from YANG variable /rooms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rooms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rooms() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rooms.rooms, is_container='container', yang_name="rooms", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rooms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rooms.rooms, is_container='container', yang_name="rooms", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)""",
        })

    self.__rooms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rooms(self):
    self.__rooms = YANGDynClass(base=rooms.rooms, is_container='container', yang_name="rooms", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)


  def _get_circuits(self):
    """
    Getter method for circuits, mapped from YANG variable /circuits (container)
    """
    return self.__circuits
      
  def _set_circuits(self, v, load=False):
    """
    Setter method for circuits, mapped from YANG variable /circuits (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuits is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuits() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=circuits.circuits, is_container='container', yang_name="circuits", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuits must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=circuits.circuits, is_container='container', yang_name="circuits", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)""",
        })

    self.__circuits = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuits(self):
    self.__circuits = YANGDynClass(base=circuits.circuits, is_container='container', yang_name="circuits", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)


  def _get_circuits_info(self):
    """
    Getter method for circuits_info, mapped from YANG variable /circuits_info (container)
    """
    return self.__circuits_info
      
  def _set_circuits_info(self, v, load=False):
    """
    Setter method for circuits_info, mapped from YANG variable /circuits_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_circuits_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_circuits_info() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=circuits_info.circuits_info, is_container='container', yang_name="circuits-info", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """circuits_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=circuits_info.circuits_info, is_container='container', yang_name="circuits-info", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)""",
        })

    self.__circuits_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_circuits_info(self):
    self.__circuits_info = YANGDynClass(base=circuits_info.circuits_info, is_container='container', yang_name="circuits-info", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)


  def _get_locations(self):
    """
    Getter method for locations, mapped from YANG variable /locations (container)
    """
    return self.__locations
      
  def _set_locations(self, v, load=False):
    """
    Setter method for locations, mapped from YANG variable /locations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_locations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_locations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=locations.locations, is_container='container', yang_name="locations", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """locations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=locations.locations, is_container='container', yang_name="locations", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)""",
        })

    self.__locations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_locations(self):
    self.__locations = YANGDynClass(base=locations.locations, is_container='container', yang_name="locations", module_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/location', defining_module='location', yang_type='container', is_config=True)

  buildings = __builtin__.property(_get_buildings, _set_buildings)
  rooms = __builtin__.property(_get_rooms, _set_rooms)
  circuits = __builtin__.property(_get_circuits, _set_circuits)
  circuits_info = __builtin__.property(_get_circuits_info, _set_circuits_info)
  locations = __builtin__.property(_get_locations, _set_locations)


  _pyangbind_elements = collections.OrderedDict([('buildings', buildings), ('rooms', rooms), ('circuits', circuits), ('circuits_info', circuits_info), ('locations', locations), ])


import test_
class test(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module test - based on the path /test. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__test',)

  _yang_name = 'test'
  _module_name = 'test'
  _namespace = 'http://anutanetworks.com/test'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__test = YANGDynClass(base=test_.test, is_container='container', yang_name="test", module_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/test', defining_module='test', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_test(self):
    """
    Getter method for test, mapped from YANG variable /test (container)
    """
    return self.__test
      
  def _set_test(self, v, load=False):
    """
    Setter method for test, mapped from YANG variable /test (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=test_.test, is_container='container', yang_name="test", module_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/test', defining_module='test', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """test must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=test_.test, is_container='container', yang_name="test", module_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/test', defining_module='test', yang_type='container', is_config=True)""",
        })

    self.__test = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_test(self):
    self.__test = YANGDynClass(base=test_.test, is_container='container', yang_name="test", module_name="test", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/test', defining_module='test', yang_type='container', is_config=True)

  test = __builtin__.property(_get_test, _set_test)


  _pyangbind_elements = collections.OrderedDict([('test', test), ])


import network_connections
import module_connections
class topology(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module topology - based on the path /topology. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__network_connections','__module_connections',)

  _yang_name = 'topology'
  _module_name = 'topology'
  _namespace = 'http://anutanetworks.com/topology'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__module_connections = YANGDynClass(base=module_connections.module_connections, is_container='container', yang_name="module-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)
    self.__network_connections = YANGDynClass(base=network_connections.network_connections, is_container='container', yang_name="network-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_connections(self):
    """
    Getter method for network_connections, mapped from YANG variable /network_connections (container)
    """
    return self.__network_connections
      
  def _set_network_connections(self, v, load=False):
    """
    Setter method for network_connections, mapped from YANG variable /network_connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_connections() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=network_connections.network_connections, is_container='container', yang_name="network-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_connections.network_connections, is_container='container', yang_name="network-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)""",
        })

    self.__network_connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_connections(self):
    self.__network_connections = YANGDynClass(base=network_connections.network_connections, is_container='container', yang_name="network-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)


  def _get_module_connections(self):
    """
    Getter method for module_connections, mapped from YANG variable /module_connections (container)
    """
    return self.__module_connections
      
  def _set_module_connections(self, v, load=False):
    """
    Setter method for module_connections, mapped from YANG variable /module_connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module_connections() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=module_connections.module_connections, is_container='container', yang_name="module-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module_connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=module_connections.module_connections, is_container='container', yang_name="module-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)""",
        })

    self.__module_connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module_connections(self):
    self.__module_connections = YANGDynClass(base=module_connections.module_connections, is_container='container', yang_name="module-connections", module_name="topology", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/topology', defining_module='topology', yang_type='container', is_config=True)

  network_connections = __builtin__.property(_get_network_connections, _set_network_connections)
  module_connections = __builtin__.property(_get_module_connections, _set_module_connections)


  _pyangbind_elements = collections.OrderedDict([('network_connections', network_connections), ('module_connections', module_connections), ])


class ncx_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-types - based on the path /ncx-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class templates(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module templates - based on the path /templates. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class allocation_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module allocation-extensions - based on the path /allocation-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class thirdparty(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module thirdparty - based on the path /thirdparty. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import jobtype_rpc_maps
import oid_snmp_maps
class jobs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module jobs - based on the path /jobs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__jobtype_rpc_maps','__oid_snmp_maps',)

  _yang_name = 'jobs'
  _module_name = 'jobs'
  _namespace = 'http://anutanetworks.com/jobs'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oid_snmp_maps = YANGDynClass(base=oid_snmp_maps.oid_snmp_maps, is_container='container', yang_name="oid-snmp-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)
    self.__jobtype_rpc_maps = YANGDynClass(base=jobtype_rpc_maps.jobtype_rpc_maps, is_container='container', yang_name="jobtype-rpc-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_jobtype_rpc_maps(self):
    """
    Getter method for jobtype_rpc_maps, mapped from YANG variable /jobtype_rpc_maps (container)
    """
    return self.__jobtype_rpc_maps
      
  def _set_jobtype_rpc_maps(self, v, load=False):
    """
    Setter method for jobtype_rpc_maps, mapped from YANG variable /jobtype_rpc_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_jobtype_rpc_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_jobtype_rpc_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=jobtype_rpc_maps.jobtype_rpc_maps, is_container='container', yang_name="jobtype-rpc-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """jobtype_rpc_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=jobtype_rpc_maps.jobtype_rpc_maps, is_container='container', yang_name="jobtype-rpc-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)""",
        })

    self.__jobtype_rpc_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_jobtype_rpc_maps(self):
    self.__jobtype_rpc_maps = YANGDynClass(base=jobtype_rpc_maps.jobtype_rpc_maps, is_container='container', yang_name="jobtype-rpc-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)


  def _get_oid_snmp_maps(self):
    """
    Getter method for oid_snmp_maps, mapped from YANG variable /oid_snmp_maps (container)
    """
    return self.__oid_snmp_maps
      
  def _set_oid_snmp_maps(self, v, load=False):
    """
    Setter method for oid_snmp_maps, mapped from YANG variable /oid_snmp_maps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oid_snmp_maps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oid_snmp_maps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=oid_snmp_maps.oid_snmp_maps, is_container='container', yang_name="oid-snmp-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oid_snmp_maps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=oid_snmp_maps.oid_snmp_maps, is_container='container', yang_name="oid-snmp-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)""",
        })

    self.__oid_snmp_maps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oid_snmp_maps(self):
    self.__oid_snmp_maps = YANGDynClass(base=oid_snmp_maps.oid_snmp_maps, is_container='container', yang_name="oid-snmp-maps", module_name="jobs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/jobs', defining_module='jobs', yang_type='container', is_config=True)

  jobtype_rpc_maps = __builtin__.property(_get_jobtype_rpc_maps, _set_jobtype_rpc_maps)
  oid_snmp_maps = __builtin__.property(_get_oid_snmp_maps, _set_oid_snmp_maps)


  _pyangbind_elements = collections.OrderedDict([('jobtype_rpc_maps', jobtype_rpc_maps), ('oid_snmp_maps', oid_snmp_maps), ])


import alarmspectypes
import alarmspecs
import alarms_
class alarms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module alarms - based on the path /alarms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__alarmspectypes','__alarmspecs','__alarms',)

  _yang_name = 'alarms'
  _module_name = 'alarms'
  _namespace = 'http://anutanetworks.com/alarms'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__alarms = YANGDynClass(base=alarms_.alarms, is_container='container', yang_name="alarms", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)
    self.__alarmspectypes = YANGDynClass(base=alarmspectypes.alarmspectypes, is_container='container', yang_name="alarmspectypes", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)
    self.__alarmspecs = YANGDynClass(base=alarmspecs.alarmspecs, is_container='container', yang_name="alarmspecs", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_alarmspectypes(self):
    """
    Getter method for alarmspectypes, mapped from YANG variable /alarmspectypes (container)
    """
    return self.__alarmspectypes
      
  def _set_alarmspectypes(self, v, load=False):
    """
    Setter method for alarmspectypes, mapped from YANG variable /alarmspectypes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarmspectypes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarmspectypes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=alarmspectypes.alarmspectypes, is_container='container', yang_name="alarmspectypes", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarmspectypes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=alarmspectypes.alarmspectypes, is_container='container', yang_name="alarmspectypes", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)""",
        })

    self.__alarmspectypes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarmspectypes(self):
    self.__alarmspectypes = YANGDynClass(base=alarmspectypes.alarmspectypes, is_container='container', yang_name="alarmspectypes", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)


  def _get_alarmspecs(self):
    """
    Getter method for alarmspecs, mapped from YANG variable /alarmspecs (container)
    """
    return self.__alarmspecs
      
  def _set_alarmspecs(self, v, load=False):
    """
    Setter method for alarmspecs, mapped from YANG variable /alarmspecs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarmspecs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarmspecs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=alarmspecs.alarmspecs, is_container='container', yang_name="alarmspecs", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarmspecs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=alarmspecs.alarmspecs, is_container='container', yang_name="alarmspecs", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)""",
        })

    self.__alarmspecs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarmspecs(self):
    self.__alarmspecs = YANGDynClass(base=alarmspecs.alarmspecs, is_container='container', yang_name="alarmspecs", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)


  def _get_alarms(self):
    """
    Getter method for alarms, mapped from YANG variable /alarms (container)
    """
    return self.__alarms
      
  def _set_alarms(self, v, load=False):
    """
    Setter method for alarms, mapped from YANG variable /alarms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarms() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=alarms_.alarms, is_container='container', yang_name="alarms", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=alarms_.alarms, is_container='container', yang_name="alarms", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)""",
        })

    self.__alarms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarms(self):
    self.__alarms = YANGDynClass(base=alarms_.alarms, is_container='container', yang_name="alarms", module_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/alarms', defining_module='alarms', yang_type='container', is_config=True)

  alarmspectypes = __builtin__.property(_get_alarmspectypes, _set_alarmspectypes)
  alarmspecs = __builtin__.property(_get_alarmspecs, _set_alarmspecs)
  alarms = __builtin__.property(_get_alarms, _set_alarms)


  _pyangbind_elements = collections.OrderedDict([('alarmspectypes', alarmspectypes), ('alarmspecs', alarmspecs), ('alarms', alarms), ])


import rule_types
class rule_engine(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module rule-engine - based on the path /rule-engine. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__rule_types',)

  _yang_name = 'rule-engine'
  _module_name = 'rule-engine'
  _namespace = 'http://anutanetworks.com/rule-engine'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rule_types = YANGDynClass(base=rule_types.rule_types, is_container='container', yang_name="rule-types", module_name="rule-engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/rule-engine', defining_module='rule-engine', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_rule_types(self):
    """
    Getter method for rule_types, mapped from YANG variable /rule_types (container)
    """
    return self.__rule_types
      
  def _set_rule_types(self, v, load=False):
    """
    Setter method for rule_types, mapped from YANG variable /rule_types (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_types() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rule_types.rule_types, is_container='container', yang_name="rule-types", module_name="rule-engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/rule-engine', defining_module='rule-engine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_types must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rule_types.rule_types, is_container='container', yang_name="rule-types", module_name="rule-engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/rule-engine', defining_module='rule-engine', yang_type='container', is_config=True)""",
        })

    self.__rule_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_types(self):
    self.__rule_types = YANGDynClass(base=rule_types.rule_types, is_container='container', yang_name="rule-types", module_name="rule-engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/rule-engine', defining_module='rule-engine', yang_type='container', is_config=True)

  rule_types = __builtin__.property(_get_rule_types, _set_rule_types)


  _pyangbind_elements = collections.OrderedDict([('rule_types', rule_types), ])


class infoblox(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module infoblox - based on the path /infoblox. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class approvals(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module approvals - based on the path /approvals. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import capacities_
import capacity_types
import capacity_alarm_specs
import device_capacities
class capacities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module capacities - based on the path /capacities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__capacities','__capacity_types','__capacity_alarm_specs','__device_capacities',)

  _yang_name = 'capacities'
  _module_name = 'capacities'
  _namespace = 'http://anutanetworks.com/capacities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device_capacities = YANGDynClass(base=device_capacities.device_capacities, is_container='container', yang_name="device-capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    self.__capacities = YANGDynClass(base=capacities_.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    self.__capacity_alarm_specs = YANGDynClass(base=capacity_alarm_specs.capacity_alarm_specs, is_container='container', yang_name="capacity-alarm-specs", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    self.__capacity_types = YANGDynClass(base=capacity_types.capacity_types, is_container='container', yang_name="capacity-types", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_capacities(self):
    """
    Getter method for capacities, mapped from YANG variable /capacities (container)
    """
    return self.__capacities
      
  def _set_capacities(self, v, load=False):
    """
    Setter method for capacities, mapped from YANG variable /capacities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacities() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=capacities_.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capacities_.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)""",
        })

    self.__capacities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacities(self):
    self.__capacities = YANGDynClass(base=capacities_.capacities, is_container='container', yang_name="capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)


  def _get_capacity_types(self):
    """
    Getter method for capacity_types, mapped from YANG variable /capacity_types (container)
    """
    return self.__capacity_types
      
  def _set_capacity_types(self, v, load=False):
    """
    Setter method for capacity_types, mapped from YANG variable /capacity_types (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacity_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacity_types() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=capacity_types.capacity_types, is_container='container', yang_name="capacity-types", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacity_types must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capacity_types.capacity_types, is_container='container', yang_name="capacity-types", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)""",
        })

    self.__capacity_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacity_types(self):
    self.__capacity_types = YANGDynClass(base=capacity_types.capacity_types, is_container='container', yang_name="capacity-types", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)


  def _get_capacity_alarm_specs(self):
    """
    Getter method for capacity_alarm_specs, mapped from YANG variable /capacity_alarm_specs (container)
    """
    return self.__capacity_alarm_specs
      
  def _set_capacity_alarm_specs(self, v, load=False):
    """
    Setter method for capacity_alarm_specs, mapped from YANG variable /capacity_alarm_specs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacity_alarm_specs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacity_alarm_specs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=capacity_alarm_specs.capacity_alarm_specs, is_container='container', yang_name="capacity-alarm-specs", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacity_alarm_specs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capacity_alarm_specs.capacity_alarm_specs, is_container='container', yang_name="capacity-alarm-specs", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)""",
        })

    self.__capacity_alarm_specs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacity_alarm_specs(self):
    self.__capacity_alarm_specs = YANGDynClass(base=capacity_alarm_specs.capacity_alarm_specs, is_container='container', yang_name="capacity-alarm-specs", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)


  def _get_device_capacities(self):
    """
    Getter method for device_capacities, mapped from YANG variable /device_capacities (container)
    """
    return self.__device_capacities
      
  def _set_device_capacities(self, v, load=False):
    """
    Setter method for device_capacities, mapped from YANG variable /device_capacities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_capacities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_capacities() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_capacities.device_capacities, is_container='container', yang_name="device-capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_capacities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_capacities.device_capacities, is_container='container', yang_name="device-capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)""",
        })

    self.__device_capacities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_capacities(self):
    self.__device_capacities = YANGDynClass(base=device_capacities.device_capacities, is_container='container', yang_name="device-capacities", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='container', is_config=True)

  capacities = __builtin__.property(_get_capacities, _set_capacities)
  capacity_types = __builtin__.property(_get_capacity_types, _set_capacity_types)
  capacity_alarm_specs = __builtin__.property(_get_capacity_alarm_specs, _set_capacity_alarm_specs)
  device_capacities = __builtin__.property(_get_device_capacities, _set_device_capacities)


  _pyangbind_elements = collections.OrderedDict([('capacities', capacities), ('capacity_types', capacity_types), ('capacity_alarm_specs', capacity_alarm_specs), ('device_capacities', device_capacities), ])


class rbac(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module rbac - based on the path /rbac. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class servicemanager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module servicemanager - based on the path /servicemanager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import topology_layout
import device_support
import network_functions
import resource_notification
import devices
import ncx
import data_grouping
import service_features
import tenants
import packages
import service_manager
import bgp_as_numbers
import admin_settings
import templates
import reconciliation
import virtual_appliance
import system
import rule_engine
import rule_engine_events
import oids
import model_extension
import service_model
import modelmaps
import data_references
import configuration
import credentials
import view_templates
import view_actions
import nacm
import access_control
import migrations
import mplsrd_reservations
import ui_name_profiles
import ui_component_states
import reconciliation_entities
class controller(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /controller. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__topology_layout','__device_support','__network_functions','__resource_notification','__devices','__ncx','__data_grouping','__service_features','__tenants','__packages','__service_manager','__bgp_as_numbers','__admin_settings','__templates','__reconciliation','__virtual_appliance','__system','__rule_engine','__rule_engine_events','__oids','__model_extension','__service_model','__modelmaps','__data_references','__configuration','__credentials','__view_templates','__view_actions','__nacm','__access_control','__migrations','__mplsrd_reservations','__ui_name_profiles','__ui_component_states','__reconciliation_entities',)

  _yang_name = 'controller'
  _module_name = 'controller'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__templates = YANGDynClass(base=templates.templates, is_container='container', yang_name="templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__view_templates = YANGDynClass(base=view_templates.view_templates, is_container='container', yang_name="view-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__virtual_appliance = YANGDynClass(base=virtual_appliance.virtual_appliance, is_container='container', yang_name="virtual-appliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__view_actions = YANGDynClass(base=view_actions.view_actions, is_container='container', yang_name="view-actions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__nacm = YANGDynClass(base=nacm.nacm, is_container='container', yang_name="nacm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ui_name_profiles = YANGDynClass(base=ui_name_profiles.ui_name_profiles, is_container='container', yang_name="ui-name-profiles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__mplsrd_reservations = YANGDynClass(base=mplsrd_reservations.mplsrd_reservations, is_container='container', yang_name="mplsrd-reservations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__service_model = YANGDynClass(base=service_model.service_model, is_container='container', yang_name="service-model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__credentials = YANGDynClass(base=credentials.credentials, is_container='container', yang_name="credentials", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__reconciliation = YANGDynClass(base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__resource_notification = YANGDynClass(base=resource_notification.resource_notification, is_container='container', yang_name="resource-notification", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__topology_layout = YANGDynClass(base=topology_layout.topology_layout, is_container='container', yang_name="topology-layout", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__model_extension = YANGDynClass(base=model_extension.model_extension, is_container='container', yang_name="model-extension", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__oids = YANGDynClass(base=oids.oids, is_container='container', yang_name="oids", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__migrations = YANGDynClass(base=migrations.migrations, is_container='container', yang_name="migrations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__rule_engine_events = YANGDynClass(base=rule_engine_events.rule_engine_events, is_container='container', yang_name="rule-engine-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__service_manager = YANGDynClass(base=service_manager.service_manager, is_container='container', yang_name="service-manager", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ui_component_states = YANGDynClass(base=ui_component_states.ui_component_states, is_container='container', yang_name="ui-component-states", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__network_functions = YANGDynClass(base=network_functions.network_functions, is_container='container', yang_name="network-functions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ncx = YANGDynClass(base=ncx.ncx, is_container='container', yang_name="ncx", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__service_features = YANGDynClass(base=service_features.service_features, is_container='container', yang_name="service-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__access_control = YANGDynClass(base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__device_support = YANGDynClass(base=device_support.device_support, is_container='container', yang_name="device-support", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__reconciliation_entities = YANGDynClass(base=reconciliation_entities.reconciliation_entities, is_container='container', yang_name="reconciliation-entities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__data_grouping = YANGDynClass(base=data_grouping.data_grouping, is_container='container', yang_name="data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__packages = YANGDynClass(base=packages.packages, is_container='container', yang_name="packages", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__modelmaps = YANGDynClass(base=modelmaps.modelmaps, is_container='container', yang_name="modelmaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__data_references = YANGDynClass(base=data_references.data_references, is_container='container', yang_name="data-references", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__admin_settings = YANGDynClass(base=admin_settings.admin_settings, is_container='container', yang_name="admin-settings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__devices = YANGDynClass(base=devices.devices, is_container='container', yang_name="devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__bgp_as_numbers = YANGDynClass(base=bgp_as_numbers.bgp_as_numbers, is_container='container', yang_name="bgp-as-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__rule_engine = YANGDynClass(base=rule_engine.rule_engine, is_container='container', yang_name="rule-engine", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__configuration = YANGDynClass(base=configuration.configuration, is_container='container', yang_name="configuration", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__tenants = YANGDynClass(base=tenants.tenants, is_container='container', yang_name="tenants", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_topology_layout(self):
    """
    Getter method for topology_layout, mapped from YANG variable /topology_layout (container)
    """
    return self.__topology_layout
      
  def _set_topology_layout(self, v, load=False):
    """
    Setter method for topology_layout, mapped from YANG variable /topology_layout (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topology_layout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topology_layout() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=topology_layout.topology_layout, is_container='container', yang_name="topology-layout", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topology_layout must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=topology_layout.topology_layout, is_container='container', yang_name="topology-layout", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__topology_layout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topology_layout(self):
    self.__topology_layout = YANGDynClass(base=topology_layout.topology_layout, is_container='container', yang_name="topology-layout", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_device_support(self):
    """
    Getter method for device_support, mapped from YANG variable /device_support (container)
    """
    return self.__device_support
      
  def _set_device_support(self, v, load=False):
    """
    Setter method for device_support, mapped from YANG variable /device_support (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_support() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_support.device_support, is_container='container', yang_name="device-support", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_support must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_support.device_support, is_container='container', yang_name="device-support", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__device_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_support(self):
    self.__device_support = YANGDynClass(base=device_support.device_support, is_container='container', yang_name="device-support", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_network_functions(self):
    """
    Getter method for network_functions, mapped from YANG variable /network_functions (container)
    """
    return self.__network_functions
      
  def _set_network_functions(self, v, load=False):
    """
    Setter method for network_functions, mapped from YANG variable /network_functions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_functions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_functions() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=network_functions.network_functions, is_container='container', yang_name="network-functions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_functions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_functions.network_functions, is_container='container', yang_name="network-functions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__network_functions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_functions(self):
    self.__network_functions = YANGDynClass(base=network_functions.network_functions, is_container='container', yang_name="network-functions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_resource_notification(self):
    """
    Getter method for resource_notification, mapped from YANG variable /resource_notification (container)
    """
    return self.__resource_notification
      
  def _set_resource_notification(self, v, load=False):
    """
    Setter method for resource_notification, mapped from YANG variable /resource_notification (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resource_notification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resource_notification() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=resource_notification.resource_notification, is_container='container', yang_name="resource-notification", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resource_notification must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=resource_notification.resource_notification, is_container='container', yang_name="resource-notification", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__resource_notification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resource_notification(self):
    self.__resource_notification = YANGDynClass(base=resource_notification.resource_notification, is_container='container', yang_name="resource-notification", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=devices.devices, is_container='container', yang_name="devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=devices.devices, is_container='container', yang_name="devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=devices.devices, is_container='container', yang_name="devices", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ncx(self):
    """
    Getter method for ncx, mapped from YANG variable /ncx (container)
    """
    return self.__ncx
      
  def _set_ncx(self, v, load=False):
    """
    Setter method for ncx, mapped from YANG variable /ncx (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ncx is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ncx() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ncx.ncx, is_container='container', yang_name="ncx", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ncx must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ncx.ncx, is_container='container', yang_name="ncx", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ncx = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ncx(self):
    self.__ncx = YANGDynClass(base=ncx.ncx, is_container='container', yang_name="ncx", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_data_grouping(self):
    """
    Getter method for data_grouping, mapped from YANG variable /data_grouping (container)
    """
    return self.__data_grouping
      
  def _set_data_grouping(self, v, load=False):
    """
    Setter method for data_grouping, mapped from YANG variable /data_grouping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_grouping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_grouping() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=data_grouping.data_grouping, is_container='container', yang_name="data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_grouping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=data_grouping.data_grouping, is_container='container', yang_name="data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__data_grouping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_grouping(self):
    self.__data_grouping = YANGDynClass(base=data_grouping.data_grouping, is_container='container', yang_name="data-grouping", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_service_features(self):
    """
    Getter method for service_features, mapped from YANG variable /service_features (container)
    """
    return self.__service_features
      
  def _set_service_features(self, v, load=False):
    """
    Setter method for service_features, mapped from YANG variable /service_features (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_features is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_features() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_features.service_features, is_container='container', yang_name="service-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_features must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_features.service_features, is_container='container', yang_name="service-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__service_features = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_features(self):
    self.__service_features = YANGDynClass(base=service_features.service_features, is_container='container', yang_name="service-features", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_tenants(self):
    """
    Getter method for tenants, mapped from YANG variable /tenants (container)
    """
    return self.__tenants
      
  def _set_tenants(self, v, load=False):
    """
    Setter method for tenants, mapped from YANG variable /tenants (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tenants is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tenants() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tenants.tenants, is_container='container', yang_name="tenants", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tenants must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tenants.tenants, is_container='container', yang_name="tenants", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__tenants = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tenants(self):
    self.__tenants = YANGDynClass(base=tenants.tenants, is_container='container', yang_name="tenants", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_packages(self):
    """
    Getter method for packages, mapped from YANG variable /packages (container)
    """
    return self.__packages
      
  def _set_packages(self, v, load=False):
    """
    Setter method for packages, mapped from YANG variable /packages (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packages() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=packages.packages, is_container='container', yang_name="packages", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packages must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=packages.packages, is_container='container', yang_name="packages", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__packages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packages(self):
    self.__packages = YANGDynClass(base=packages.packages, is_container='container', yang_name="packages", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_service_manager(self):
    """
    Getter method for service_manager, mapped from YANG variable /service_manager (container)
    """
    return self.__service_manager
      
  def _set_service_manager(self, v, load=False):
    """
    Setter method for service_manager, mapped from YANG variable /service_manager (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_manager is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_manager() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_manager.service_manager, is_container='container', yang_name="service-manager", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_manager must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_manager.service_manager, is_container='container', yang_name="service-manager", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__service_manager = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_manager(self):
    self.__service_manager = YANGDynClass(base=service_manager.service_manager, is_container='container', yang_name="service-manager", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_bgp_as_numbers(self):
    """
    Getter method for bgp_as_numbers, mapped from YANG variable /bgp_as_numbers (container)
    """
    return self.__bgp_as_numbers
      
  def _set_bgp_as_numbers(self, v, load=False):
    """
    Setter method for bgp_as_numbers, mapped from YANG variable /bgp_as_numbers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp_as_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp_as_numbers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=bgp_as_numbers.bgp_as_numbers, is_container='container', yang_name="bgp-as-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp_as_numbers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bgp_as_numbers.bgp_as_numbers, is_container='container', yang_name="bgp-as-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__bgp_as_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp_as_numbers(self):
    self.__bgp_as_numbers = YANGDynClass(base=bgp_as_numbers.bgp_as_numbers, is_container='container', yang_name="bgp-as-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_admin_settings(self):
    """
    Getter method for admin_settings, mapped from YANG variable /admin_settings (container)
    """
    return self.__admin_settings
      
  def _set_admin_settings(self, v, load=False):
    """
    Setter method for admin_settings, mapped from YANG variable /admin_settings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_settings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_settings() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=admin_settings.admin_settings, is_container='container', yang_name="admin-settings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_settings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=admin_settings.admin_settings, is_container='container', yang_name="admin-settings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__admin_settings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_settings(self):
    self.__admin_settings = YANGDynClass(base=admin_settings.admin_settings, is_container='container', yang_name="admin-settings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_templates(self):
    """
    Getter method for templates, mapped from YANG variable /templates (container)
    """
    return self.__templates
      
  def _set_templates(self, v, load=False):
    """
    Setter method for templates, mapped from YANG variable /templates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_templates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=templates.templates, is_container='container', yang_name="templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """templates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=templates.templates, is_container='container', yang_name="templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_templates(self):
    self.__templates = YANGDynClass(base=templates.templates, is_container='container', yang_name="templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_reconciliation(self):
    """
    Getter method for reconciliation, mapped from YANG variable /reconciliation (container)
    """
    return self.__reconciliation
      
  def _set_reconciliation(self, v, load=False):
    """
    Setter method for reconciliation, mapped from YANG variable /reconciliation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconciliation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconciliation() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconciliation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__reconciliation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconciliation(self):
    self.__reconciliation = YANGDynClass(base=reconciliation.reconciliation, is_container='container', yang_name="reconciliation", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_virtual_appliance(self):
    """
    Getter method for virtual_appliance, mapped from YANG variable /virtual_appliance (container)
    """
    return self.__virtual_appliance
      
  def _set_virtual_appliance(self, v, load=False):
    """
    Setter method for virtual_appliance, mapped from YANG variable /virtual_appliance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_appliance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_appliance() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=virtual_appliance.virtual_appliance, is_container='container', yang_name="virtual-appliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_appliance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=virtual_appliance.virtual_appliance, is_container='container', yang_name="virtual-appliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__virtual_appliance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_appliance(self):
    self.__virtual_appliance = YANGDynClass(base=virtual_appliance.virtual_appliance, is_container='container', yang_name="virtual-appliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_system(self):
    """
    Getter method for system, mapped from YANG variable /system (container)
    """
    return self.__system
      
  def _set_system(self, v, load=False):
    """
    Setter method for system, mapped from YANG variable /system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=system.system, is_container='container', yang_name="system", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system.system, is_container='container', yang_name="system", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system(self):
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_rule_engine(self):
    """
    Getter method for rule_engine, mapped from YANG variable /rule_engine (container)
    """
    return self.__rule_engine
      
  def _set_rule_engine(self, v, load=False):
    """
    Setter method for rule_engine, mapped from YANG variable /rule_engine (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_engine is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_engine() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rule_engine.rule_engine, is_container='container', yang_name="rule-engine", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_engine must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rule_engine.rule_engine, is_container='container', yang_name="rule-engine", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__rule_engine = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_engine(self):
    self.__rule_engine = YANGDynClass(base=rule_engine.rule_engine, is_container='container', yang_name="rule-engine", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_rule_engine_events(self):
    """
    Getter method for rule_engine_events, mapped from YANG variable /rule_engine_events (container)
    """
    return self.__rule_engine_events
      
  def _set_rule_engine_events(self, v, load=False):
    """
    Setter method for rule_engine_events, mapped from YANG variable /rule_engine_events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule_engine_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule_engine_events() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=rule_engine_events.rule_engine_events, is_container='container', yang_name="rule-engine-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rule_engine_events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=rule_engine_events.rule_engine_events, is_container='container', yang_name="rule-engine-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__rule_engine_events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rule_engine_events(self):
    self.__rule_engine_events = YANGDynClass(base=rule_engine_events.rule_engine_events, is_container='container', yang_name="rule-engine-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_oids(self):
    """
    Getter method for oids, mapped from YANG variable /oids (container)
    """
    return self.__oids
      
  def _set_oids(self, v, load=False):
    """
    Setter method for oids, mapped from YANG variable /oids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oids() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=oids.oids, is_container='container', yang_name="oids", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=oids.oids, is_container='container', yang_name="oids", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__oids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oids(self):
    self.__oids = YANGDynClass(base=oids.oids, is_container='container', yang_name="oids", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_model_extension(self):
    """
    Getter method for model_extension, mapped from YANG variable /model_extension (container)
    """
    return self.__model_extension
      
  def _set_model_extension(self, v, load=False):
    """
    Setter method for model_extension, mapped from YANG variable /model_extension (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_model_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_model_extension() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=model_extension.model_extension, is_container='container', yang_name="model-extension", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """model_extension must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=model_extension.model_extension, is_container='container', yang_name="model-extension", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__model_extension = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_model_extension(self):
    self.__model_extension = YANGDynClass(base=model_extension.model_extension, is_container='container', yang_name="model-extension", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_service_model(self):
    """
    Getter method for service_model, mapped from YANG variable /service_model (container)
    """
    return self.__service_model
      
  def _set_service_model(self, v, load=False):
    """
    Setter method for service_model, mapped from YANG variable /service_model (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_model() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_model.service_model, is_container='container', yang_name="service-model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_model must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_model.service_model, is_container='container', yang_name="service-model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__service_model = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_model(self):
    self.__service_model = YANGDynClass(base=service_model.service_model, is_container='container', yang_name="service-model", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_modelmaps(self):
    """
    Getter method for modelmaps, mapped from YANG variable /modelmaps (container)
    """
    return self.__modelmaps
      
  def _set_modelmaps(self, v, load=False):
    """
    Setter method for modelmaps, mapped from YANG variable /modelmaps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modelmaps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modelmaps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=modelmaps.modelmaps, is_container='container', yang_name="modelmaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modelmaps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modelmaps.modelmaps, is_container='container', yang_name="modelmaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__modelmaps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modelmaps(self):
    self.__modelmaps = YANGDynClass(base=modelmaps.modelmaps, is_container='container', yang_name="modelmaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_data_references(self):
    """
    Getter method for data_references, mapped from YANG variable /data_references (container)
    """
    return self.__data_references
      
  def _set_data_references(self, v, load=False):
    """
    Setter method for data_references, mapped from YANG variable /data_references (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_references is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_references() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=data_references.data_references, is_container='container', yang_name="data-references", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """data_references must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=data_references.data_references, is_container='container', yang_name="data-references", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__data_references = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_data_references(self):
    self.__data_references = YANGDynClass(base=data_references.data_references, is_container='container', yang_name="data-references", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_configuration(self):
    """
    Getter method for configuration, mapped from YANG variable /configuration (container)
    """
    return self.__configuration
      
  def _set_configuration(self, v, load=False):
    """
    Setter method for configuration, mapped from YANG variable /configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configuration() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=configuration.configuration, is_container='container', yang_name="configuration", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=configuration.configuration, is_container='container', yang_name="configuration", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configuration(self):
    self.__configuration = YANGDynClass(base=configuration.configuration, is_container='container', yang_name="configuration", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_credentials(self):
    """
    Getter method for credentials, mapped from YANG variable /credentials (container)
    """
    return self.__credentials
      
  def _set_credentials(self, v, load=False):
    """
    Setter method for credentials, mapped from YANG variable /credentials (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_credentials is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_credentials() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=credentials.credentials, is_container='container', yang_name="credentials", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """credentials must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=credentials.credentials, is_container='container', yang_name="credentials", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__credentials = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_credentials(self):
    self.__credentials = YANGDynClass(base=credentials.credentials, is_container='container', yang_name="credentials", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_view_templates(self):
    """
    Getter method for view_templates, mapped from YANG variable /view_templates (container)
    """
    return self.__view_templates
      
  def _set_view_templates(self, v, load=False):
    """
    Setter method for view_templates, mapped from YANG variable /view_templates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_view_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_view_templates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=view_templates.view_templates, is_container='container', yang_name="view-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """view_templates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=view_templates.view_templates, is_container='container', yang_name="view-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__view_templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_view_templates(self):
    self.__view_templates = YANGDynClass(base=view_templates.view_templates, is_container='container', yang_name="view-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_view_actions(self):
    """
    Getter method for view_actions, mapped from YANG variable /view_actions (container)
    """
    return self.__view_actions
      
  def _set_view_actions(self, v, load=False):
    """
    Setter method for view_actions, mapped from YANG variable /view_actions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_view_actions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_view_actions() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=view_actions.view_actions, is_container='container', yang_name="view-actions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """view_actions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=view_actions.view_actions, is_container='container', yang_name="view-actions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__view_actions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_view_actions(self):
    self.__view_actions = YANGDynClass(base=view_actions.view_actions, is_container='container', yang_name="view-actions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_nacm(self):
    """
    Getter method for nacm, mapped from YANG variable /nacm (container)
    """
    return self.__nacm
      
  def _set_nacm(self, v, load=False):
    """
    Setter method for nacm, mapped from YANG variable /nacm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nacm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nacm() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=nacm.nacm, is_container='container', yang_name="nacm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nacm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=nacm.nacm, is_container='container', yang_name="nacm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__nacm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nacm(self):
    self.__nacm = YANGDynClass(base=nacm.nacm, is_container='container', yang_name="nacm", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_access_control(self):
    """
    Getter method for access_control, mapped from YANG variable /access_control (container)
    """
    return self.__access_control
      
  def _set_access_control(self, v, load=False):
    """
    Setter method for access_control, mapped from YANG variable /access_control (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_control() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_control must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__access_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_control(self):
    self.__access_control = YANGDynClass(base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_migrations(self):
    """
    Getter method for migrations, mapped from YANG variable /migrations (container)
    """
    return self.__migrations
      
  def _set_migrations(self, v, load=False):
    """
    Setter method for migrations, mapped from YANG variable /migrations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_migrations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_migrations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=migrations.migrations, is_container='container', yang_name="migrations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """migrations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=migrations.migrations, is_container='container', yang_name="migrations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__migrations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_migrations(self):
    self.__migrations = YANGDynClass(base=migrations.migrations, is_container='container', yang_name="migrations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_mplsrd_reservations(self):
    """
    Getter method for mplsrd_reservations, mapped from YANG variable /mplsrd_reservations (container)
    """
    return self.__mplsrd_reservations
      
  def _set_mplsrd_reservations(self, v, load=False):
    """
    Setter method for mplsrd_reservations, mapped from YANG variable /mplsrd_reservations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mplsrd_reservations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mplsrd_reservations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=mplsrd_reservations.mplsrd_reservations, is_container='container', yang_name="mplsrd-reservations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mplsrd_reservations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mplsrd_reservations.mplsrd_reservations, is_container='container', yang_name="mplsrd-reservations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__mplsrd_reservations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mplsrd_reservations(self):
    self.__mplsrd_reservations = YANGDynClass(base=mplsrd_reservations.mplsrd_reservations, is_container='container', yang_name="mplsrd-reservations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ui_name_profiles(self):
    """
    Getter method for ui_name_profiles, mapped from YANG variable /ui_name_profiles (container)
    """
    return self.__ui_name_profiles
      
  def _set_ui_name_profiles(self, v, load=False):
    """
    Setter method for ui_name_profiles, mapped from YANG variable /ui_name_profiles (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ui_name_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ui_name_profiles() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ui_name_profiles.ui_name_profiles, is_container='container', yang_name="ui-name-profiles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ui_name_profiles must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ui_name_profiles.ui_name_profiles, is_container='container', yang_name="ui-name-profiles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ui_name_profiles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ui_name_profiles(self):
    self.__ui_name_profiles = YANGDynClass(base=ui_name_profiles.ui_name_profiles, is_container='container', yang_name="ui-name-profiles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ui_component_states(self):
    """
    Getter method for ui_component_states, mapped from YANG variable /ui_component_states (container)
    """
    return self.__ui_component_states
      
  def _set_ui_component_states(self, v, load=False):
    """
    Setter method for ui_component_states, mapped from YANG variable /ui_component_states (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ui_component_states is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ui_component_states() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ui_component_states.ui_component_states, is_container='container', yang_name="ui-component-states", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ui_component_states must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ui_component_states.ui_component_states, is_container='container', yang_name="ui-component-states", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ui_component_states = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ui_component_states(self):
    self.__ui_component_states = YANGDynClass(base=ui_component_states.ui_component_states, is_container='container', yang_name="ui-component-states", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_reconciliation_entities(self):
    """
    Getter method for reconciliation_entities, mapped from YANG variable /reconciliation_entities (container)
    """
    return self.__reconciliation_entities
      
  def _set_reconciliation_entities(self, v, load=False):
    """
    Setter method for reconciliation_entities, mapped from YANG variable /reconciliation_entities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconciliation_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconciliation_entities() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=reconciliation_entities.reconciliation_entities, is_container='container', yang_name="reconciliation-entities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconciliation_entities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=reconciliation_entities.reconciliation_entities, is_container='container', yang_name="reconciliation-entities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__reconciliation_entities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconciliation_entities(self):
    self.__reconciliation_entities = YANGDynClass(base=reconciliation_entities.reconciliation_entities, is_container='container', yang_name="reconciliation-entities", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

  topology_layout = __builtin__.property(_get_topology_layout, _set_topology_layout)
  device_support = __builtin__.property(_get_device_support, _set_device_support)
  network_functions = __builtin__.property(_get_network_functions, _set_network_functions)
  resource_notification = __builtin__.property(_get_resource_notification, _set_resource_notification)
  devices = __builtin__.property(_get_devices, _set_devices)
  ncx = __builtin__.property(_get_ncx, _set_ncx)
  data_grouping = __builtin__.property(_get_data_grouping, _set_data_grouping)
  service_features = __builtin__.property(_get_service_features, _set_service_features)
  tenants = __builtin__.property(_get_tenants, _set_tenants)
  packages = __builtin__.property(_get_packages, _set_packages)
  service_manager = __builtin__.property(_get_service_manager, _set_service_manager)
  bgp_as_numbers = __builtin__.property(_get_bgp_as_numbers, _set_bgp_as_numbers)
  admin_settings = __builtin__.property(_get_admin_settings, _set_admin_settings)
  templates = __builtin__.property(_get_templates, _set_templates)
  reconciliation = __builtin__.property(_get_reconciliation, _set_reconciliation)
  virtual_appliance = __builtin__.property(_get_virtual_appliance, _set_virtual_appliance)
  system = __builtin__.property(_get_system, _set_system)
  rule_engine = __builtin__.property(_get_rule_engine, _set_rule_engine)
  rule_engine_events = __builtin__.property(_get_rule_engine_events, _set_rule_engine_events)
  oids = __builtin__.property(_get_oids, _set_oids)
  model_extension = __builtin__.property(_get_model_extension, _set_model_extension)
  service_model = __builtin__.property(_get_service_model, _set_service_model)
  modelmaps = __builtin__.property(_get_modelmaps, _set_modelmaps)
  data_references = __builtin__.property(_get_data_references, _set_data_references)
  configuration = __builtin__.property(_get_configuration, _set_configuration)
  credentials = __builtin__.property(_get_credentials, _set_credentials)
  view_templates = __builtin__.property(_get_view_templates, _set_view_templates)
  view_actions = __builtin__.property(_get_view_actions, _set_view_actions)
  nacm = __builtin__.property(_get_nacm, _set_nacm)
  access_control = __builtin__.property(_get_access_control, _set_access_control)
  migrations = __builtin__.property(_get_migrations, _set_migrations)
  mplsrd_reservations = __builtin__.property(_get_mplsrd_reservations, _set_mplsrd_reservations)
  ui_name_profiles = __builtin__.property(_get_ui_name_profiles, _set_ui_name_profiles)
  ui_component_states = __builtin__.property(_get_ui_component_states, _set_ui_component_states)
  reconciliation_entities = __builtin__.property(_get_reconciliation_entities, _set_reconciliation_entities)


  _pyangbind_elements = collections.OrderedDict([('topology_layout', topology_layout), ('device_support', device_support), ('network_functions', network_functions), ('resource_notification', resource_notification), ('devices', devices), ('ncx', ncx), ('data_grouping', data_grouping), ('service_features', service_features), ('tenants', tenants), ('packages', packages), ('service_manager', service_manager), ('bgp_as_numbers', bgp_as_numbers), ('admin_settings', admin_settings), ('templates', templates), ('reconciliation', reconciliation), ('virtual_appliance', virtual_appliance), ('system', system), ('rule_engine', rule_engine), ('rule_engine_events', rule_engine_events), ('oids', oids), ('model_extension', model_extension), ('service_model', service_model), ('modelmaps', modelmaps), ('data_references', data_references), ('configuration', configuration), ('credentials', credentials), ('view_templates', view_templates), ('view_actions', view_actions), ('nacm', nacm), ('access_control', access_control), ('migrations', migrations), ('mplsrd_reservations', mplsrd_reservations), ('ui_name_profiles', ui_name_profiles), ('ui_component_states', ui_component_states), ('reconciliation_entities', reconciliation_entities), ])


class datagrouping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module datagrouping - based on the path /datagrouping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class service_manager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module service-manager - based on the path /service-manager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class services(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module services - based on the path /services. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class devicemanagement(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module devicemanagement - based on the path /devicemanagement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class packages(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module packages - based on the path /packages. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class deviceOnBoarding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module deviceOnBoarding - based on the path /deviceOnBoarding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class ncx_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-extensions - based on the path /ncx-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class modelExtensionMap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module modelExtensionMap - based on the path /modelExtensionMap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import ipaddress_pool_groups
import ipaddress_pools
class ipam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ipam - based on the path /ipam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__ipaddress_pool_groups','__ipaddress_pools',)

  _yang_name = 'ipam'
  _module_name = 'ipam'
  _namespace = 'http://anutanetworks.com/ipam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipaddress_pools = YANGDynClass(base=ipaddress_pools.ipaddress_pools, is_container='container', yang_name="ipaddress-pools", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)
    self.__ipaddress_pool_groups = YANGDynClass(base=ipaddress_pool_groups.ipaddress_pool_groups, is_container='container', yang_name="ipaddress-pool-groups", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ipaddress_pool_groups(self):
    """
    Getter method for ipaddress_pool_groups, mapped from YANG variable /ipaddress_pool_groups (container)
    """
    return self.__ipaddress_pool_groups
      
  def _set_ipaddress_pool_groups(self, v, load=False):
    """
    Setter method for ipaddress_pool_groups, mapped from YANG variable /ipaddress_pool_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipaddress_pool_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipaddress_pool_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ipaddress_pool_groups.ipaddress_pool_groups, is_container='container', yang_name="ipaddress-pool-groups", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipaddress_pool_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipaddress_pool_groups.ipaddress_pool_groups, is_container='container', yang_name="ipaddress-pool-groups", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)""",
        })

    self.__ipaddress_pool_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipaddress_pool_groups(self):
    self.__ipaddress_pool_groups = YANGDynClass(base=ipaddress_pool_groups.ipaddress_pool_groups, is_container='container', yang_name="ipaddress-pool-groups", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)


  def _get_ipaddress_pools(self):
    """
    Getter method for ipaddress_pools, mapped from YANG variable /ipaddress_pools (container)
    """
    return self.__ipaddress_pools
      
  def _set_ipaddress_pools(self, v, load=False):
    """
    Setter method for ipaddress_pools, mapped from YANG variable /ipaddress_pools (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipaddress_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipaddress_pools() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ipaddress_pools.ipaddress_pools, is_container='container', yang_name="ipaddress-pools", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipaddress_pools must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ipaddress_pools.ipaddress_pools, is_container='container', yang_name="ipaddress-pools", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)""",
        })

    self.__ipaddress_pools = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipaddress_pools(self):
    self.__ipaddress_pools = YANGDynClass(base=ipaddress_pools.ipaddress_pools, is_container='container', yang_name="ipaddress-pools", module_name="ipam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/ipam', defining_module='ipam', yang_type='container', is_config=True)

  ipaddress_pool_groups = __builtin__.property(_get_ipaddress_pool_groups, _set_ipaddress_pool_groups)
  ipaddress_pools = __builtin__.property(_get_ipaddress_pools, _set_ipaddress_pools)


  _pyangbind_elements = collections.OrderedDict([('ipaddress_pool_groups', ipaddress_pool_groups), ('ipaddress_pools', ipaddress_pools), ])


class accesscontrol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module accesscontrol - based on the path /accesscontrol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import settings
class logging(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module logging - based on the path /logging. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__settings',)

  _yang_name = 'logging'
  _module_name = 'logging'
  _namespace = 'http://anutanetworks.com/logging'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__settings = YANGDynClass(base=settings.settings, is_container='container', yang_name="settings", module_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/logging', defining_module='logging', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_settings(self):
    """
    Getter method for settings, mapped from YANG variable /settings (container)
    """
    return self.__settings
      
  def _set_settings(self, v, load=False):
    """
    Setter method for settings, mapped from YANG variable /settings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_settings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_settings() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=settings.settings, is_container='container', yang_name="settings", module_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/logging', defining_module='logging', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """settings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=settings.settings, is_container='container', yang_name="settings", module_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/logging', defining_module='logging', yang_type='container', is_config=True)""",
        })

    self.__settings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_settings(self):
    self.__settings = YANGDynClass(base=settings.settings, is_container='container', yang_name="settings", module_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/logging', defining_module='logging', yang_type='container', is_config=True)

  settings = __builtin__.property(_get_settings, _set_settings)


  _pyangbind_elements = collections.OrderedDict([('settings', settings), ])


class mplsrd_reservation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mplsrd-reservation - based on the path /mplsrd-reservation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class ncx_network_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-network-types - based on the path /ncx-network-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class ncx_ui_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-ui-extensions - based on the path /ncx-ui-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class ncx_ui_component_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-ui-component-state - based on the path /ncx-ui-component-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class compliance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module compliance - based on the path /compliance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class virtualappliance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module virtualappliance - based on the path /virtualappliance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import instructions
class engine(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module engine - based on the path /engine. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__instructions',)

  _yang_name = 'engine'
  _module_name = 'engine'
  _namespace = 'http://anutanetworks.com/engine'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instructions = YANGDynClass(base=instructions.instructions, is_container='container', yang_name="instructions", module_name="engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/engine', defining_module='engine', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_instructions(self):
    """
    Getter method for instructions, mapped from YANG variable /instructions (container)
    """
    return self.__instructions
      
  def _set_instructions(self, v, load=False):
    """
    Setter method for instructions, mapped from YANG variable /instructions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instructions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instructions() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=instructions.instructions, is_container='container', yang_name="instructions", module_name="engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/engine', defining_module='engine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instructions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=instructions.instructions, is_container='container', yang_name="instructions", module_name="engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/engine', defining_module='engine', yang_type='container', is_config=True)""",
        })

    self.__instructions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instructions(self):
    self.__instructions = YANGDynClass(base=instructions.instructions, is_container='container', yang_name="instructions", module_name="engine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/engine', defining_module='engine', yang_type='container', is_config=True)

  instructions = __builtin__.property(_get_instructions, _set_instructions)


  _pyangbind_elements = collections.OrderedDict([('instructions', instructions), ])


class entity_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module entity-extensions - based on the path /entity-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class adminsettings(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module adminsettings - based on the path /adminsettings. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import compliance_execution_reports
import compliance_templates
import policy_features
import policy_categories
class device_comp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device-comp - based on the path /device-comp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__compliance_execution_reports','__compliance_templates','__policy_features','__policy_categories',)

  _yang_name = 'device-comp'
  _module_name = 'device-comp'
  _namespace = 'http://anutanetworks.com/device-comp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__policy_categories = YANGDynClass(base=policy_categories.policy_categories, is_container='container', yang_name="policy-categories", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    self.__compliance_templates = YANGDynClass(base=compliance_templates.compliance_templates, is_container='container', yang_name="compliance-templates", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    self.__compliance_execution_reports = YANGDynClass(base=compliance_execution_reports.compliance_execution_reports, is_container='container', yang_name="compliance-execution-reports", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    self.__policy_features = YANGDynClass(base=policy_features.policy_features, is_container='container', yang_name="policy-features", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_compliance_execution_reports(self):
    """
    Getter method for compliance_execution_reports, mapped from YANG variable /compliance_execution_reports (container)
    """
    return self.__compliance_execution_reports
      
  def _set_compliance_execution_reports(self, v, load=False):
    """
    Setter method for compliance_execution_reports, mapped from YANG variable /compliance_execution_reports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compliance_execution_reports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compliance_execution_reports() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=compliance_execution_reports.compliance_execution_reports, is_container='container', yang_name="compliance-execution-reports", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compliance_execution_reports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=compliance_execution_reports.compliance_execution_reports, is_container='container', yang_name="compliance-execution-reports", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)""",
        })

    self.__compliance_execution_reports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compliance_execution_reports(self):
    self.__compliance_execution_reports = YANGDynClass(base=compliance_execution_reports.compliance_execution_reports, is_container='container', yang_name="compliance-execution-reports", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)


  def _get_compliance_templates(self):
    """
    Getter method for compliance_templates, mapped from YANG variable /compliance_templates (container)
    """
    return self.__compliance_templates
      
  def _set_compliance_templates(self, v, load=False):
    """
    Setter method for compliance_templates, mapped from YANG variable /compliance_templates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compliance_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compliance_templates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=compliance_templates.compliance_templates, is_container='container', yang_name="compliance-templates", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compliance_templates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=compliance_templates.compliance_templates, is_container='container', yang_name="compliance-templates", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)""",
        })

    self.__compliance_templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compliance_templates(self):
    self.__compliance_templates = YANGDynClass(base=compliance_templates.compliance_templates, is_container='container', yang_name="compliance-templates", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)


  def _get_policy_features(self):
    """
    Getter method for policy_features, mapped from YANG variable /policy_features (container)
    """
    return self.__policy_features
      
  def _set_policy_features(self, v, load=False):
    """
    Setter method for policy_features, mapped from YANG variable /policy_features (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_features is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_features() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=policy_features.policy_features, is_container='container', yang_name="policy-features", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_features must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_features.policy_features, is_container='container', yang_name="policy-features", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)""",
        })

    self.__policy_features = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_features(self):
    self.__policy_features = YANGDynClass(base=policy_features.policy_features, is_container='container', yang_name="policy-features", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)


  def _get_policy_categories(self):
    """
    Getter method for policy_categories, mapped from YANG variable /policy_categories (container)
    """
    return self.__policy_categories
      
  def _set_policy_categories(self, v, load=False):
    """
    Setter method for policy_categories, mapped from YANG variable /policy_categories (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy_categories is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy_categories() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=policy_categories.policy_categories, is_container='container', yang_name="policy-categories", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """policy_categories must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=policy_categories.policy_categories, is_container='container', yang_name="policy-categories", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)""",
        })

    self.__policy_categories = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_policy_categories(self):
    self.__policy_categories = YANGDynClass(base=policy_categories.policy_categories, is_container='container', yang_name="policy-categories", module_name="device-comp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/device-comp', defining_module='device-comp', yang_type='container', is_config=True)

  compliance_execution_reports = __builtin__.property(_get_compliance_execution_reports, _set_compliance_execution_reports)
  compliance_templates = __builtin__.property(_get_compliance_templates, _set_compliance_templates)
  policy_features = __builtin__.property(_get_policy_features, _set_policy_features)
  policy_categories = __builtin__.property(_get_policy_categories, _set_policy_categories)


  _pyangbind_elements = collections.OrderedDict([('compliance_execution_reports', compliance_execution_reports), ('compliance_templates', compliance_templates), ('policy_features', policy_features), ('policy_categories', policy_categories), ])


class ncx_cli_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ncx-cli-extensions - based on the path /ncx-cli-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines all NCX YANG extensions statements
related to CLI customization.
  """
  pass


  

class debug(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module debug - based on the path /debug. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

class tenants(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module tenants - based on the path /tenants. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

import vlan_pool_groups
class vlangroups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vlangroups - based on the path /vlangroups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__vlan_pool_groups',)

  _yang_name = 'vlangroups'
  _module_name = 'vlangroups'
  _namespace = 'http://anutanetworks.com/vlans'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vlan_pool_groups = YANGDynClass(base=vlan_pool_groups.vlan_pool_groups, is_container='container', yang_name="vlan-pool-groups", module_name="vlangroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vlans', defining_module='vlangroups', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_vlan_pool_groups(self):
    """
    Getter method for vlan_pool_groups, mapped from YANG variable /vlan_pool_groups (container)
    """
    return self.__vlan_pool_groups
      
  def _set_vlan_pool_groups(self, v, load=False):
    """
    Setter method for vlan_pool_groups, mapped from YANG variable /vlan_pool_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_pool_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_pool_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vlan_pool_groups.vlan_pool_groups, is_container='container', yang_name="vlan-pool-groups", module_name="vlangroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vlans', defining_module='vlangroups', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlan_pool_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlan_pool_groups.vlan_pool_groups, is_container='container', yang_name="vlan-pool-groups", module_name="vlangroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vlans', defining_module='vlangroups', yang_type='container', is_config=True)""",
        })

    self.__vlan_pool_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlan_pool_groups(self):
    self.__vlan_pool_groups = YANGDynClass(base=vlan_pool_groups.vlan_pool_groups, is_container='container', yang_name="vlan-pool-groups", module_name="vlangroups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/vlans', defining_module='vlangroups', yang_type='container', is_config=True)

  vlan_pool_groups = __builtin__.property(_get_vlan_pool_groups, _set_vlan_pool_groups)


  _pyangbind_elements = collections.OrderedDict([('vlan_pool_groups', vlan_pool_groups), ])


class networkfunctionssupport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module networkfunctionssupport - based on the path /networkfunctionssupport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  pass


  

