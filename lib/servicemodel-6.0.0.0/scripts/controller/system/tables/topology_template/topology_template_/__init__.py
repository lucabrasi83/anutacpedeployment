
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import all_port_channels
import port_channel_segment
class topology_template(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /system/tables/topology-template/topology-template. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__name','__mandatory_device_roles','__all_port_channels','__ha_segments','__number_of_access_layers','__number_of_firewall_tiers','__va_templates','__load_sharing','__topology_type','__fw_mode','__is_collapsed_dist_service','__is_non_vss6kha','__is_branch_in_the_box','__default_template','__reconciliation_approval_roles','__abort_service_for_offline_roles','__extended_multipath','__port_channel_segment',)

  _yang_name = 'topology-template'
  _module_name = 'system'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__number_of_access_layers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-access-layers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)
    self.__is_branch_in_the_box = YANGDynClass(base=unicode, is_leaf=True, yang_name="is-branch-in-the-box", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__abort_service_for_offline_roles = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="abort-service-for-offline-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__is_collapsed_dist_service = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-collapsed-dist-service", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__fw_mode = YANGDynClass(base=unicode, is_leaf=True, yang_name="fw-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__extended_multipath = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended-multipath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__va_templates = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="va-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__ha_segments = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="ha-segments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__port_channel_segment = YANGDynClass(base=YANGListType("name",port_channel_segment.port_channel_segment, yang_name="port-channel-segment", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="port-channel-segment", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)
    self.__reconciliation_approval_roles = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reconciliation-approval-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__topology_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="topology-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    self.__mandatory_device_roles = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="mandatory-device-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__load_sharing = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="load-sharing", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    self.__default_template = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__all_port_channels = YANGDynClass(base=all_port_channels.all_port_channels, is_container='container', yang_name="all-port-channels", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__is_non_vss6kha = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-non-vss6kha", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    self.__number_of_firewall_tiers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-firewall-tiers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'system', u'tables', u'topology-template', u'topology-template']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /system/tables/topology_template/topology_template/name (string)

    YANG Description: string
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /system/tables/topology_template/topology_template/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=unicode, is_leaf=True, yang_name="name", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_mandatory_device_roles(self):
    """
    Getter method for mandatory_device_roles, mapped from YANG variable /system/tables/topology_template/topology_template/mandatory_device_roles (leafref)

    YANG Description: mandatory-device-roles
    """
    return self.__mandatory_device_roles
      
  def _set_mandatory_device_roles(self, v, load=False):
    """
    Setter method for mandatory_device_roles, mapped from YANG variable /system/tables/topology_template/topology_template/mandatory_device_roles (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory_device_roles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory_device_roles() directly.

    YANG Description: mandatory-device-roles
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="mandatory-device-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mandatory_device_roles must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="mandatory-device-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__mandatory_device_roles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mandatory_device_roles(self):
    self.__mandatory_device_roles = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="mandatory-device-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_all_port_channels(self):
    """
    Getter method for all_port_channels, mapped from YANG variable /system/tables/topology_template/topology_template/all_port_channels (container)
    """
    return self.__all_port_channels
      
  def _set_all_port_channels(self, v, load=False):
    """
    Setter method for all_port_channels, mapped from YANG variable /system/tables/topology_template/topology_template/all_port_channels (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_all_port_channels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_all_port_channels() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=all_port_channels.all_port_channels, is_container='container', yang_name="all-port-channels", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """all_port_channels must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=all_port_channels.all_port_channels, is_container='container', yang_name="all-port-channels", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__all_port_channels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_all_port_channels(self):
    self.__all_port_channels = YANGDynClass(base=all_port_channels.all_port_channels, is_container='container', yang_name="all-port-channels", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ha_segments(self):
    """
    Getter method for ha_segments, mapped from YANG variable /system/tables/topology_template/topology_template/ha_segments (leafref)

    YANG Description: ha-segments
    """
    return self.__ha_segments
      
  def _set_ha_segments(self, v, load=False):
    """
    Setter method for ha_segments, mapped from YANG variable /system/tables/topology_template/topology_template/ha_segments (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_segments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_segments() directly.

    YANG Description: ha-segments
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="ha-segments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_segments must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="ha-segments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__ha_segments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_segments(self):
    self.__ha_segments = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="ha-segments", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_number_of_access_layers(self):
    """
    Getter method for number_of_access_layers, mapped from YANG variable /system/tables/topology_template/topology_template/number_of_access_layers (uint32)

    YANG Description: 0..4294967295
    """
    return self.__number_of_access_layers
      
  def _set_number_of_access_layers(self, v, load=False):
    """
    Setter method for number_of_access_layers, mapped from YANG variable /system/tables/topology_template/topology_template/number_of_access_layers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_access_layers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_access_layers() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-access-layers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number_of_access_layers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-access-layers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)""",
        })

    self.__number_of_access_layers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number_of_access_layers(self):
    self.__number_of_access_layers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-access-layers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)


  def _get_number_of_firewall_tiers(self):
    """
    Getter method for number_of_firewall_tiers, mapped from YANG variable /system/tables/topology_template/topology_template/number_of_firewall_tiers (uint32)

    YANG Description: 0..4294967295
    """
    return self.__number_of_firewall_tiers
      
  def _set_number_of_firewall_tiers(self, v, load=False):
    """
    Setter method for number_of_firewall_tiers, mapped from YANG variable /system/tables/topology_template/topology_template/number_of_firewall_tiers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_firewall_tiers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_firewall_tiers() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-firewall-tiers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number_of_firewall_tiers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-firewall-tiers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)""",
        })

    self.__number_of_firewall_tiers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number_of_firewall_tiers(self):
    self.__number_of_firewall_tiers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-firewall-tiers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='uint32', is_config=True)


  def _get_va_templates(self):
    """
    Getter method for va_templates, mapped from YANG variable /system/tables/topology_template/topology_template/va_templates (leafref)

    YANG Description: va-templates
    """
    return self.__va_templates
      
  def _set_va_templates(self, v, load=False):
    """
    Setter method for va_templates, mapped from YANG variable /system/tables/topology_template/topology_template/va_templates (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_va_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_va_templates() directly.

    YANG Description: va-templates
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="va-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """va_templates must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="va-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__va_templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_va_templates(self):
    self.__va_templates = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="va-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_load_sharing(self):
    """
    Getter method for load_sharing, mapped from YANG variable /system/tables/topology_template/topology_template/load_sharing (leafref)

    YANG Description: load-sharing
    """
    return self.__load_sharing
      
  def _set_load_sharing(self, v, load=False):
    """
    Setter method for load_sharing, mapped from YANG variable /system/tables/topology_template/topology_template/load_sharing (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_load_sharing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_load_sharing() directly.

    YANG Description: load-sharing
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="load-sharing", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """load_sharing must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="load-sharing", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__load_sharing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_load_sharing(self):
    self.__load_sharing = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="load-sharing", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_topology_type(self):
    """
    Getter method for topology_type, mapped from YANG variable /system/tables/topology_template/topology_template/topology_type (string)

    YANG Description: string
    """
    return self.__topology_type
      
  def _set_topology_type(self, v, load=False):
    """
    Setter method for topology_type, mapped from YANG variable /system/tables/topology_template/topology_template/topology_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topology_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topology_type() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="topology-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topology_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="topology-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__topology_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topology_type(self):
    self.__topology_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="topology-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_fw_mode(self):
    """
    Getter method for fw_mode, mapped from YANG variable /system/tables/topology_template/topology_template/fw_mode (string)

    YANG Description: string
    """
    return self.__fw_mode
      
  def _set_fw_mode(self, v, load=False):
    """
    Setter method for fw_mode, mapped from YANG variable /system/tables/topology_template/topology_template/fw_mode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fw_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fw_mode() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="fw-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fw_mode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="fw-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__fw_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fw_mode(self):
    self.__fw_mode = YANGDynClass(base=unicode, is_leaf=True, yang_name="fw-mode", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_is_collapsed_dist_service(self):
    """
    Getter method for is_collapsed_dist_service, mapped from YANG variable /system/tables/topology_template/topology_template/is_collapsed_dist_service (boolean)

    YANG Description: is-collapsed-dist-service: True/False
    """
    return self.__is_collapsed_dist_service
      
  def _set_is_collapsed_dist_service(self, v, load=False):
    """
    Setter method for is_collapsed_dist_service, mapped from YANG variable /system/tables/topology_template/topology_template/is_collapsed_dist_service (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_collapsed_dist_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_collapsed_dist_service() directly.

    YANG Description: is-collapsed-dist-service: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-collapsed-dist-service", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_collapsed_dist_service must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-collapsed-dist-service", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__is_collapsed_dist_service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_collapsed_dist_service(self):
    self.__is_collapsed_dist_service = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-collapsed-dist-service", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_is_non_vss6kha(self):
    """
    Getter method for is_non_vss6kha, mapped from YANG variable /system/tables/topology_template/topology_template/is_non_vss6kha (boolean)

    YANG Description: is-non-vss6kha: True/False
    """
    return self.__is_non_vss6kha
      
  def _set_is_non_vss6kha(self, v, load=False):
    """
    Setter method for is_non_vss6kha, mapped from YANG variable /system/tables/topology_template/topology_template/is_non_vss6kha (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_non_vss6kha is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_non_vss6kha() directly.

    YANG Description: is-non-vss6kha: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-non-vss6kha", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_non_vss6kha must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-non-vss6kha", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__is_non_vss6kha = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_non_vss6kha(self):
    self.__is_non_vss6kha = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-non-vss6kha", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_is_branch_in_the_box(self):
    """
    Getter method for is_branch_in_the_box, mapped from YANG variable /system/tables/topology_template/topology_template/is_branch_in_the_box (string)

    YANG Description: string
    """
    return self.__is_branch_in_the_box
      
  def _set_is_branch_in_the_box(self, v, load=False):
    """
    Setter method for is_branch_in_the_box, mapped from YANG variable /system/tables/topology_template/topology_template/is_branch_in_the_box (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_branch_in_the_box is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_branch_in_the_box() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="is-branch-in-the-box", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_branch_in_the_box must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="is-branch-in-the-box", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)""",
        })

    self.__is_branch_in_the_box = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_branch_in_the_box(self):
    self.__is_branch_in_the_box = YANGDynClass(base=unicode, is_leaf=True, yang_name="is-branch-in-the-box", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='string', is_config=True)


  def _get_default_template(self):
    """
    Getter method for default_template, mapped from YANG variable /system/tables/topology_template/topology_template/default_template (boolean)

    YANG Description: default-template: True/False
    """
    return self.__default_template
      
  def _set_default_template(self, v, load=False):
    """
    Setter method for default_template, mapped from YANG variable /system/tables/topology_template/topology_template/default_template (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_template is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_template() directly.

    YANG Description: default-template: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="default-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_template must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__default_template = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_template(self):
    self.__default_template = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="default-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_reconciliation_approval_roles(self):
    """
    Getter method for reconciliation_approval_roles, mapped from YANG variable /system/tables/topology_template/topology_template/reconciliation_approval_roles (leafref)

    YANG Description: reconciliation-approval-roles
    """
    return self.__reconciliation_approval_roles
      
  def _set_reconciliation_approval_roles(self, v, load=False):
    """
    Setter method for reconciliation_approval_roles, mapped from YANG variable /system/tables/topology_template/topology_template/reconciliation_approval_roles (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reconciliation_approval_roles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reconciliation_approval_roles() directly.

    YANG Description: reconciliation-approval-roles
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reconciliation-approval-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reconciliation_approval_roles must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reconciliation-approval-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__reconciliation_approval_roles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reconciliation_approval_roles(self):
    self.__reconciliation_approval_roles = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="reconciliation-approval-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_abort_service_for_offline_roles(self):
    """
    Getter method for abort_service_for_offline_roles, mapped from YANG variable /system/tables/topology_template/topology_template/abort_service_for_offline_roles (leafref)

    YANG Description: abort-service-for-offline-roles
    """
    return self.__abort_service_for_offline_roles
      
  def _set_abort_service_for_offline_roles(self, v, load=False):
    """
    Setter method for abort_service_for_offline_roles, mapped from YANG variable /system/tables/topology_template/topology_template/abort_service_for_offline_roles (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abort_service_for_offline_roles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abort_service_for_offline_roles() directly.

    YANG Description: abort-service-for-offline-roles
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="abort-service-for-offline-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abort_service_for_offline_roles must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="abort-service-for-offline-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)""",
        })

    self.__abort_service_for_offline_roles = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abort_service_for_offline_roles(self):
    self.__abort_service_for_offline_roles = YANGDynClass(base=TypedListType(allowed_type=unicode), is_leaf=False, yang_name="abort-service-for-offline-roles", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='leafref', is_config=True)


  def _get_extended_multipath(self):
    """
    Getter method for extended_multipath, mapped from YANG variable /system/tables/topology_template/topology_template/extended_multipath (boolean)

    YANG Description: extended-multipath: True/False
    """
    return self.__extended_multipath
      
  def _set_extended_multipath(self, v, load=False):
    """
    Setter method for extended_multipath, mapped from YANG variable /system/tables/topology_template/topology_template/extended_multipath (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended_multipath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended_multipath() directly.

    YANG Description: extended-multipath: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended-multipath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended_multipath must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended-multipath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)""",
        })

    self.__extended_multipath = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended_multipath(self):
    self.__extended_multipath = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended-multipath", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='boolean', is_config=True)


  def _get_port_channel_segment(self):
    """
    Getter method for port_channel_segment, mapped from YANG variable /system/tables/topology_template/topology_template/port_channel_segment (list)
    """
    return self.__port_channel_segment
      
  def _set_port_channel_segment(self, v, load=False):
    """
    Setter method for port_channel_segment, mapped from YANG variable /system/tables/topology_template/topology_template/port_channel_segment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_channel_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_channel_segment() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGListType("name",port_channel_segment.port_channel_segment, yang_name="port-channel-segment", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="port-channel-segment", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_channel_segment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",port_channel_segment.port_channel_segment, yang_name="port-channel-segment", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="port-channel-segment", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)""",
        })

    self.__port_channel_segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_channel_segment(self):
    self.__port_channel_segment = YANGDynClass(base=YANGListType("name",port_channel_segment.port_channel_segment, yang_name="port-channel-segment", module_name="controller", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name'), is_container='list', yang_name="port-channel-segment", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  mandatory_device_roles = __builtin__.property(_get_mandatory_device_roles, _set_mandatory_device_roles)
  all_port_channels = __builtin__.property(_get_all_port_channels, _set_all_port_channels)
  ha_segments = __builtin__.property(_get_ha_segments, _set_ha_segments)
  number_of_access_layers = __builtin__.property(_get_number_of_access_layers, _set_number_of_access_layers)
  number_of_firewall_tiers = __builtin__.property(_get_number_of_firewall_tiers, _set_number_of_firewall_tiers)
  va_templates = __builtin__.property(_get_va_templates, _set_va_templates)
  load_sharing = __builtin__.property(_get_load_sharing, _set_load_sharing)
  topology_type = __builtin__.property(_get_topology_type, _set_topology_type)
  fw_mode = __builtin__.property(_get_fw_mode, _set_fw_mode)
  is_collapsed_dist_service = __builtin__.property(_get_is_collapsed_dist_service, _set_is_collapsed_dist_service)
  is_non_vss6kha = __builtin__.property(_get_is_non_vss6kha, _set_is_non_vss6kha)
  is_branch_in_the_box = __builtin__.property(_get_is_branch_in_the_box, _set_is_branch_in_the_box)
  default_template = __builtin__.property(_get_default_template, _set_default_template)
  reconciliation_approval_roles = __builtin__.property(_get_reconciliation_approval_roles, _set_reconciliation_approval_roles)
  abort_service_for_offline_roles = __builtin__.property(_get_abort_service_for_offline_roles, _set_abort_service_for_offline_roles)
  extended_multipath = __builtin__.property(_get_extended_multipath, _set_extended_multipath)
  port_channel_segment = __builtin__.property(_get_port_channel_segment, _set_port_channel_segment)


  _pyangbind_elements = collections.OrderedDict([('name', name), ('mandatory_device_roles', mandatory_device_roles), ('all_port_channels', all_port_channels), ('ha_segments', ha_segments), ('number_of_access_layers', number_of_access_layers), ('number_of_firewall_tiers', number_of_firewall_tiers), ('va_templates', va_templates), ('load_sharing', load_sharing), ('topology_type', topology_type), ('fw_mode', fw_mode), ('is_collapsed_dist_service', is_collapsed_dist_service), ('is_non_vss6kha', is_non_vss6kha), ('is_branch_in_the_box', is_branch_in_the_box), ('default_template', default_template), ('reconciliation_approval_roles', reconciliation_approval_roles), ('abort_service_for_offline_roles', abort_service_for_offline_roles), ('extended_multipath', extended_multipath), ('port_channel_segment', port_channel_segment), ])


