
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
import reports
import capacity_monitor_jobs
import job_schedules
import vlangroups
import device_tier_type
import service_request_revision
import tacacs
import vss_chassis
import device_component_indexpool
import stack_member
import group
import ha_clusters
import ha_cluster_entry
import openstack_data_networks
import openstack_info
import eventhistory
import lbft_groups
import device_monitor_jobs
import openstack_interface_mappings
import device_component_indexes
import server_service_config
import task
import usertask
import service_requests
import subnetwork_groups
import topology_template
import grid_configurations
import organizations
import events
import datapathconfig
import yang_upgrade_components
import ucs_vnic_template
import ucs_vnic
import snmp_trap_destination
import basic_device_details
import openstack_floating_ips
import openstack_resource_mappings
import openstack_routers
import openstack_projects
import openstack_configs
import openstack_project_details
import vsmconnectors
import vcconnectors
import device_user_contexts
import ldaps
import filter_contexts
import naas_events
import naas_event_specs
import user_subscribers
import event_category_specs
import event_subscriber_templates
import role_to_permissions
import sequence_numbers
import ca_trust_point_certificates
import compliance
import filters
import access_control
import third_party
class tables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module controller - based on the path /system/tables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__reports','__capacity_monitor_jobs','__job_schedules','__vlangroups','__device_tier_type','__service_request_revision','__tacacs','__vss_chassis','__device_component_indexpool','__stack_member','__group','__ha_clusters','__ha_cluster_entry','__openstack_data_networks','__openstack_info','__eventhistory','__lbft_groups','__device_monitor_jobs','__openstack_interface_mappings','__device_component_indexes','__server_service_config','__task','__usertask','__service_requests','__subnetwork_groups','__topology_template','__grid_configurations','__organizations','__events','__datapathconfig','__yang_upgrade_components','__ucs_vnic_template','__ucs_vnic','__snmp_trap_destination','__basic_device_details','__openstack_floating_ips','__openstack_resource_mappings','__openstack_routers','__openstack_projects','__openstack_configs','__openstack_project_details','__vsmconnectors','__vcconnectors','__device_user_contexts','__ldaps','__filter_contexts','__naas_events','__naas_event_specs','__user_subscribers','__event_category_specs','__event_subscriber_templates','__role_to_permissions','__sequence_numbers','__ca_trust_point_certificates','__compliance','__filters','__access_control','__third_party',)

  _yang_name = 'tables'
  _module_name = 'system'
  _namespace = 'http://anutanetworks.com/controller'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__openstack_resource_mappings = YANGDynClass(base=openstack_resource_mappings.openstack_resource_mappings, is_container='container', yang_name="openstack-resource-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_info = YANGDynClass(base=openstack_info.openstack_info, is_container='container', yang_name="openstack-info", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_routers = YANGDynClass(base=openstack_routers.openstack_routers, is_container='container', yang_name="openstack-routers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__user_subscribers = YANGDynClass(base=user_subscribers.user_subscribers, is_container='container', yang_name="user-subscribers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_interface_mappings = YANGDynClass(base=openstack_interface_mappings.openstack_interface_mappings, is_container='container', yang_name="openstack-interface-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__job_schedules = YANGDynClass(base=job_schedules.job_schedules, is_container='container', yang_name="job-schedules", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__filter_contexts = YANGDynClass(base=filter_contexts.filter_contexts, is_container='container', yang_name="filter-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__usertask = YANGDynClass(base=usertask.usertask, is_container='container', yang_name="usertask", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__filters = YANGDynClass(base=filters.filters, is_container='container', yang_name="filters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__device_user_contexts = YANGDynClass(base=device_user_contexts.device_user_contexts, is_container='container', yang_name="device-user-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__compliance = YANGDynClass(base=compliance.compliance, is_container='container', yang_name="compliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__yang_upgrade_components = YANGDynClass(base=yang_upgrade_components.yang_upgrade_components, is_container='container', yang_name="yang-upgrade-components", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__topology_template = YANGDynClass(base=topology_template.topology_template, is_container='container', yang_name="topology-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__group = YANGDynClass(base=group.group, is_container='container', yang_name="group", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__subnetwork_groups = YANGDynClass(base=subnetwork_groups.subnetwork_groups, is_container='container', yang_name="subnetwork-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__datapathconfig = YANGDynClass(base=datapathconfig.datapathconfig, is_container='container', yang_name="datapathconfig", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__event_subscriber_templates = YANGDynClass(base=event_subscriber_templates.event_subscriber_templates, is_container='container', yang_name="event-subscriber-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__service_request_revision = YANGDynClass(base=service_request_revision.service_request_revision, is_container='container', yang_name="service-request-revision", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ha_clusters = YANGDynClass(base=ha_clusters.ha_clusters, is_container='container', yang_name="ha-clusters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ldaps = YANGDynClass(base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_data_networks = YANGDynClass(base=openstack_data_networks.openstack_data_networks, is_container='container', yang_name="openstack-data-networks", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__vss_chassis = YANGDynClass(base=vss_chassis.vss_chassis, is_container='container', yang_name="vss-chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__naas_event_specs = YANGDynClass(base=naas_event_specs.naas_event_specs, is_container='container', yang_name="naas-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__snmp_trap_destination = YANGDynClass(base=snmp_trap_destination.snmp_trap_destination, is_container='container', yang_name="snmp-trap-destination", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__device_component_indexes = YANGDynClass(base=device_component_indexes.device_component_indexes, is_container='container', yang_name="device-component-indexes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__events = YANGDynClass(base=events.events, is_container='container', yang_name="events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_floating_ips = YANGDynClass(base=openstack_floating_ips.openstack_floating_ips, is_container='container', yang_name="openstack-floating-ips", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__vcconnectors = YANGDynClass(base=vcconnectors.vcconnectors, is_container='container', yang_name="vcconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__access_control = YANGDynClass(base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__service_requests = YANGDynClass(base=service_requests.service_requests, is_container='container', yang_name="service-requests", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__eventhistory = YANGDynClass(base=eventhistory.eventhistory, is_container='container', yang_name="eventhistory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__device_monitor_jobs = YANGDynClass(base=device_monitor_jobs.device_monitor_jobs, is_container='container', yang_name="device-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__naas_events = YANGDynClass(base=naas_events.naas_events, is_container='container', yang_name="naas-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ha_cluster_entry = YANGDynClass(base=ha_cluster_entry.ha_cluster_entry, is_container='container', yang_name="ha-cluster-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__event_category_specs = YANGDynClass(base=event_category_specs.event_category_specs, is_container='container', yang_name="event-category-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__server_service_config = YANGDynClass(base=server_service_config.server_service_config, is_container='container', yang_name="server-service-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ca_trust_point_certificates = YANGDynClass(base=ca_trust_point_certificates.ca_trust_point_certificates, is_container='container', yang_name="ca-trust-point-certificates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__organizations = YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__task = YANGDynClass(base=task.task, is_container='container', yang_name="task", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_configs = YANGDynClass(base=openstack_configs.openstack_configs, is_container='container', yang_name="openstack-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__capacity_monitor_jobs = YANGDynClass(base=capacity_monitor_jobs.capacity_monitor_jobs, is_container='container', yang_name="capacity-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__device_tier_type = YANGDynClass(base=device_tier_type.device_tier_type, is_container='container', yang_name="device-tier-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__tacacs = YANGDynClass(base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ucs_vnic = YANGDynClass(base=ucs_vnic.ucs_vnic, is_container='container', yang_name="ucs-vnic", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_projects = YANGDynClass(base=openstack_projects.openstack_projects, is_container='container', yang_name="openstack-projects", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__basic_device_details = YANGDynClass(base=basic_device_details.basic_device_details, is_container='container', yang_name="basic-device-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__reports = YANGDynClass(base=reports.reports, is_container='container', yang_name="reports", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__vlangroups = YANGDynClass(base=vlangroups.vlangroups, is_container='container', yang_name="vlangroups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__sequence_numbers = YANGDynClass(base=sequence_numbers.sequence_numbers, is_container='container', yang_name="sequence-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__grid_configurations = YANGDynClass(base=grid_configurations.grid_configurations, is_container='container', yang_name="grid-configurations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__ucs_vnic_template = YANGDynClass(base=ucs_vnic_template.ucs_vnic_template, is_container='container', yang_name="ucs-vnic-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__lbft_groups = YANGDynClass(base=lbft_groups.lbft_groups, is_container='container', yang_name="lbft-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__openstack_project_details = YANGDynClass(base=openstack_project_details.openstack_project_details, is_container='container', yang_name="openstack-project-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__role_to_permissions = YANGDynClass(base=role_to_permissions.role_to_permissions, is_container='container', yang_name="role-to-permissions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__vsmconnectors = YANGDynClass(base=vsmconnectors.vsmconnectors, is_container='container', yang_name="vsmconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__device_component_indexpool = YANGDynClass(base=device_component_indexpool.device_component_indexpool, is_container='container', yang_name="device-component-indexpool", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__stack_member = YANGDynClass(base=stack_member.stack_member, is_container='container', yang_name="stack-member", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    self.__third_party = YANGDynClass(base=third_party.third_party, is_container='container', yang_name="third-party", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'system', u'tables']

  def _get_reports(self):
    """
    Getter method for reports, mapped from YANG variable /system/tables/reports (container)
    """
    return self.__reports
      
  def _set_reports(self, v, load=False):
    """
    Setter method for reports, mapped from YANG variable /system/tables/reports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reports() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=reports.reports, is_container='container', yang_name="reports", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=reports.reports, is_container='container', yang_name="reports", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__reports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reports(self):
    self.__reports = YANGDynClass(base=reports.reports, is_container='container', yang_name="reports", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_capacity_monitor_jobs(self):
    """
    Getter method for capacity_monitor_jobs, mapped from YANG variable /system/tables/capacity_monitor_jobs (container)
    """
    return self.__capacity_monitor_jobs
      
  def _set_capacity_monitor_jobs(self, v, load=False):
    """
    Setter method for capacity_monitor_jobs, mapped from YANG variable /system/tables/capacity_monitor_jobs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacity_monitor_jobs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacity_monitor_jobs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=capacity_monitor_jobs.capacity_monitor_jobs, is_container='container', yang_name="capacity-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacity_monitor_jobs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=capacity_monitor_jobs.capacity_monitor_jobs, is_container='container', yang_name="capacity-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__capacity_monitor_jobs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacity_monitor_jobs(self):
    self.__capacity_monitor_jobs = YANGDynClass(base=capacity_monitor_jobs.capacity_monitor_jobs, is_container='container', yang_name="capacity-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_job_schedules(self):
    """
    Getter method for job_schedules, mapped from YANG variable /system/tables/job_schedules (container)
    """
    return self.__job_schedules
      
  def _set_job_schedules(self, v, load=False):
    """
    Setter method for job_schedules, mapped from YANG variable /system/tables/job_schedules (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_job_schedules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_job_schedules() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=job_schedules.job_schedules, is_container='container', yang_name="job-schedules", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """job_schedules must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=job_schedules.job_schedules, is_container='container', yang_name="job-schedules", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__job_schedules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_job_schedules(self):
    self.__job_schedules = YANGDynClass(base=job_schedules.job_schedules, is_container='container', yang_name="job-schedules", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_vlangroups(self):
    """
    Getter method for vlangroups, mapped from YANG variable /system/tables/vlangroups (container)
    """
    return self.__vlangroups
      
  def _set_vlangroups(self, v, load=False):
    """
    Setter method for vlangroups, mapped from YANG variable /system/tables/vlangroups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlangroups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlangroups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vlangroups.vlangroups, is_container='container', yang_name="vlangroups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vlangroups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vlangroups.vlangroups, is_container='container', yang_name="vlangroups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__vlangroups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vlangroups(self):
    self.__vlangroups = YANGDynClass(base=vlangroups.vlangroups, is_container='container', yang_name="vlangroups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_device_tier_type(self):
    """
    Getter method for device_tier_type, mapped from YANG variable /system/tables/device_tier_type (container)
    """
    return self.__device_tier_type
      
  def _set_device_tier_type(self, v, load=False):
    """
    Setter method for device_tier_type, mapped from YANG variable /system/tables/device_tier_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_tier_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_tier_type() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_tier_type.device_tier_type, is_container='container', yang_name="device-tier-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_tier_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_tier_type.device_tier_type, is_container='container', yang_name="device-tier-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__device_tier_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_tier_type(self):
    self.__device_tier_type = YANGDynClass(base=device_tier_type.device_tier_type, is_container='container', yang_name="device-tier-type", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_service_request_revision(self):
    """
    Getter method for service_request_revision, mapped from YANG variable /system/tables/service_request_revision (container)
    """
    return self.__service_request_revision
      
  def _set_service_request_revision(self, v, load=False):
    """
    Setter method for service_request_revision, mapped from YANG variable /system/tables/service_request_revision (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_request_revision is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_request_revision() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_request_revision.service_request_revision, is_container='container', yang_name="service-request-revision", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_request_revision must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_request_revision.service_request_revision, is_container='container', yang_name="service-request-revision", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__service_request_revision = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_request_revision(self):
    self.__service_request_revision = YANGDynClass(base=service_request_revision.service_request_revision, is_container='container', yang_name="service-request-revision", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_tacacs(self):
    """
    Getter method for tacacs, mapped from YANG variable /system/tables/tacacs (container)
    """
    return self.__tacacs
      
  def _set_tacacs(self, v, load=False):
    """
    Setter method for tacacs, mapped from YANG variable /system/tables/tacacs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tacacs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tacacs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tacacs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__tacacs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tacacs(self):
    self.__tacacs = YANGDynClass(base=tacacs.tacacs, is_container='container', yang_name="tacacs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_vss_chassis(self):
    """
    Getter method for vss_chassis, mapped from YANG variable /system/tables/vss_chassis (container)
    """
    return self.__vss_chassis
      
  def _set_vss_chassis(self, v, load=False):
    """
    Setter method for vss_chassis, mapped from YANG variable /system/tables/vss_chassis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vss_chassis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vss_chassis() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vss_chassis.vss_chassis, is_container='container', yang_name="vss-chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vss_chassis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vss_chassis.vss_chassis, is_container='container', yang_name="vss-chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__vss_chassis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vss_chassis(self):
    self.__vss_chassis = YANGDynClass(base=vss_chassis.vss_chassis, is_container='container', yang_name="vss-chassis", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_device_component_indexpool(self):
    """
    Getter method for device_component_indexpool, mapped from YANG variable /system/tables/device_component_indexpool (container)
    """
    return self.__device_component_indexpool
      
  def _set_device_component_indexpool(self, v, load=False):
    """
    Setter method for device_component_indexpool, mapped from YANG variable /system/tables/device_component_indexpool (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_component_indexpool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_component_indexpool() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_component_indexpool.device_component_indexpool, is_container='container', yang_name="device-component-indexpool", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_component_indexpool must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_component_indexpool.device_component_indexpool, is_container='container', yang_name="device-component-indexpool", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__device_component_indexpool = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_component_indexpool(self):
    self.__device_component_indexpool = YANGDynClass(base=device_component_indexpool.device_component_indexpool, is_container='container', yang_name="device-component-indexpool", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_stack_member(self):
    """
    Getter method for stack_member, mapped from YANG variable /system/tables/stack_member (container)
    """
    return self.__stack_member
      
  def _set_stack_member(self, v, load=False):
    """
    Setter method for stack_member, mapped from YANG variable /system/tables/stack_member (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stack_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stack_member() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=stack_member.stack_member, is_container='container', yang_name="stack-member", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stack_member must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=stack_member.stack_member, is_container='container', yang_name="stack-member", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__stack_member = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stack_member(self):
    self.__stack_member = YANGDynClass(base=stack_member.stack_member, is_container='container', yang_name="stack-member", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_group(self):
    """
    Getter method for group, mapped from YANG variable /system/tables/group (container)
    """
    return self.__group
      
  def _set_group(self, v, load=False):
    """
    Setter method for group, mapped from YANG variable /system/tables/group (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=group.group, is_container='container', yang_name="group", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=group.group, is_container='container', yang_name="group", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group(self):
    self.__group = YANGDynClass(base=group.group, is_container='container', yang_name="group", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ha_clusters(self):
    """
    Getter method for ha_clusters, mapped from YANG variable /system/tables/ha_clusters (container)
    """
    return self.__ha_clusters
      
  def _set_ha_clusters(self, v, load=False):
    """
    Setter method for ha_clusters, mapped from YANG variable /system/tables/ha_clusters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_clusters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_clusters() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ha_clusters.ha_clusters, is_container='container', yang_name="ha-clusters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_clusters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha_clusters.ha_clusters, is_container='container', yang_name="ha-clusters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ha_clusters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_clusters(self):
    self.__ha_clusters = YANGDynClass(base=ha_clusters.ha_clusters, is_container='container', yang_name="ha-clusters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ha_cluster_entry(self):
    """
    Getter method for ha_cluster_entry, mapped from YANG variable /system/tables/ha_cluster_entry (container)
    """
    return self.__ha_cluster_entry
      
  def _set_ha_cluster_entry(self, v, load=False):
    """
    Setter method for ha_cluster_entry, mapped from YANG variable /system/tables/ha_cluster_entry (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_cluster_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_cluster_entry() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ha_cluster_entry.ha_cluster_entry, is_container='container', yang_name="ha-cluster-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_cluster_entry must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha_cluster_entry.ha_cluster_entry, is_container='container', yang_name="ha-cluster-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ha_cluster_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_cluster_entry(self):
    self.__ha_cluster_entry = YANGDynClass(base=ha_cluster_entry.ha_cluster_entry, is_container='container', yang_name="ha-cluster-entry", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_data_networks(self):
    """
    Getter method for openstack_data_networks, mapped from YANG variable /system/tables/openstack_data_networks (container)
    """
    return self.__openstack_data_networks
      
  def _set_openstack_data_networks(self, v, load=False):
    """
    Setter method for openstack_data_networks, mapped from YANG variable /system/tables/openstack_data_networks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_data_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_data_networks() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_data_networks.openstack_data_networks, is_container='container', yang_name="openstack-data-networks", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_data_networks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_data_networks.openstack_data_networks, is_container='container', yang_name="openstack-data-networks", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_data_networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_data_networks(self):
    self.__openstack_data_networks = YANGDynClass(base=openstack_data_networks.openstack_data_networks, is_container='container', yang_name="openstack-data-networks", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_info(self):
    """
    Getter method for openstack_info, mapped from YANG variable /system/tables/openstack_info (container)
    """
    return self.__openstack_info
      
  def _set_openstack_info(self, v, load=False):
    """
    Setter method for openstack_info, mapped from YANG variable /system/tables/openstack_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_info() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_info.openstack_info, is_container='container', yang_name="openstack-info", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_info.openstack_info, is_container='container', yang_name="openstack-info", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_info(self):
    self.__openstack_info = YANGDynClass(base=openstack_info.openstack_info, is_container='container', yang_name="openstack-info", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_eventhistory(self):
    """
    Getter method for eventhistory, mapped from YANG variable /system/tables/eventhistory (container)
    """
    return self.__eventhistory
      
  def _set_eventhistory(self, v, load=False):
    """
    Setter method for eventhistory, mapped from YANG variable /system/tables/eventhistory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eventhistory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eventhistory() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=eventhistory.eventhistory, is_container='container', yang_name="eventhistory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eventhistory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=eventhistory.eventhistory, is_container='container', yang_name="eventhistory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__eventhistory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eventhistory(self):
    self.__eventhistory = YANGDynClass(base=eventhistory.eventhistory, is_container='container', yang_name="eventhistory", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_lbft_groups(self):
    """
    Getter method for lbft_groups, mapped from YANG variable /system/tables/lbft_groups (container)
    """
    return self.__lbft_groups
      
  def _set_lbft_groups(self, v, load=False):
    """
    Setter method for lbft_groups, mapped from YANG variable /system/tables/lbft_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lbft_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lbft_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=lbft_groups.lbft_groups, is_container='container', yang_name="lbft-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lbft_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lbft_groups.lbft_groups, is_container='container', yang_name="lbft-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__lbft_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lbft_groups(self):
    self.__lbft_groups = YANGDynClass(base=lbft_groups.lbft_groups, is_container='container', yang_name="lbft-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_device_monitor_jobs(self):
    """
    Getter method for device_monitor_jobs, mapped from YANG variable /system/tables/device_monitor_jobs (container)
    """
    return self.__device_monitor_jobs
      
  def _set_device_monitor_jobs(self, v, load=False):
    """
    Setter method for device_monitor_jobs, mapped from YANG variable /system/tables/device_monitor_jobs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_monitor_jobs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_monitor_jobs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_monitor_jobs.device_monitor_jobs, is_container='container', yang_name="device-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_monitor_jobs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_monitor_jobs.device_monitor_jobs, is_container='container', yang_name="device-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__device_monitor_jobs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_monitor_jobs(self):
    self.__device_monitor_jobs = YANGDynClass(base=device_monitor_jobs.device_monitor_jobs, is_container='container', yang_name="device-monitor-jobs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_interface_mappings(self):
    """
    Getter method for openstack_interface_mappings, mapped from YANG variable /system/tables/openstack_interface_mappings (container)
    """
    return self.__openstack_interface_mappings
      
  def _set_openstack_interface_mappings(self, v, load=False):
    """
    Setter method for openstack_interface_mappings, mapped from YANG variable /system/tables/openstack_interface_mappings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_interface_mappings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_interface_mappings() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_interface_mappings.openstack_interface_mappings, is_container='container', yang_name="openstack-interface-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_interface_mappings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_interface_mappings.openstack_interface_mappings, is_container='container', yang_name="openstack-interface-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_interface_mappings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_interface_mappings(self):
    self.__openstack_interface_mappings = YANGDynClass(base=openstack_interface_mappings.openstack_interface_mappings, is_container='container', yang_name="openstack-interface-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_device_component_indexes(self):
    """
    Getter method for device_component_indexes, mapped from YANG variable /system/tables/device_component_indexes (container)
    """
    return self.__device_component_indexes
      
  def _set_device_component_indexes(self, v, load=False):
    """
    Setter method for device_component_indexes, mapped from YANG variable /system/tables/device_component_indexes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_component_indexes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_component_indexes() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_component_indexes.device_component_indexes, is_container='container', yang_name="device-component-indexes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_component_indexes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_component_indexes.device_component_indexes, is_container='container', yang_name="device-component-indexes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__device_component_indexes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_component_indexes(self):
    self.__device_component_indexes = YANGDynClass(base=device_component_indexes.device_component_indexes, is_container='container', yang_name="device-component-indexes", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_server_service_config(self):
    """
    Getter method for server_service_config, mapped from YANG variable /system/tables/server_service_config (container)
    """
    return self.__server_service_config
      
  def _set_server_service_config(self, v, load=False):
    """
    Setter method for server_service_config, mapped from YANG variable /system/tables/server_service_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_server_service_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_server_service_config() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=server_service_config.server_service_config, is_container='container', yang_name="server-service-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """server_service_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=server_service_config.server_service_config, is_container='container', yang_name="server-service-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__server_service_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_server_service_config(self):
    self.__server_service_config = YANGDynClass(base=server_service_config.server_service_config, is_container='container', yang_name="server-service-config", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_task(self):
    """
    Getter method for task, mapped from YANG variable /system/tables/task (container)
    """
    return self.__task
      
  def _set_task(self, v, load=False):
    """
    Setter method for task, mapped from YANG variable /system/tables/task (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_task is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_task() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=task.task, is_container='container', yang_name="task", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """task must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=task.task, is_container='container', yang_name="task", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__task = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_task(self):
    self.__task = YANGDynClass(base=task.task, is_container='container', yang_name="task", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_usertask(self):
    """
    Getter method for usertask, mapped from YANG variable /system/tables/usertask (container)
    """
    return self.__usertask
      
  def _set_usertask(self, v, load=False):
    """
    Setter method for usertask, mapped from YANG variable /system/tables/usertask (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_usertask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_usertask() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=usertask.usertask, is_container='container', yang_name="usertask", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """usertask must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=usertask.usertask, is_container='container', yang_name="usertask", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__usertask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_usertask(self):
    self.__usertask = YANGDynClass(base=usertask.usertask, is_container='container', yang_name="usertask", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_service_requests(self):
    """
    Getter method for service_requests, mapped from YANG variable /system/tables/service_requests (container)
    """
    return self.__service_requests
      
  def _set_service_requests(self, v, load=False):
    """
    Setter method for service_requests, mapped from YANG variable /system/tables/service_requests (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_requests is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_requests() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=service_requests.service_requests, is_container='container', yang_name="service-requests", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_requests must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=service_requests.service_requests, is_container='container', yang_name="service-requests", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__service_requests = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_requests(self):
    self.__service_requests = YANGDynClass(base=service_requests.service_requests, is_container='container', yang_name="service-requests", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_subnetwork_groups(self):
    """
    Getter method for subnetwork_groups, mapped from YANG variable /system/tables/subnetwork_groups (container)
    """
    return self.__subnetwork_groups
      
  def _set_subnetwork_groups(self, v, load=False):
    """
    Setter method for subnetwork_groups, mapped from YANG variable /system/tables/subnetwork_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnetwork_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnetwork_groups() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=subnetwork_groups.subnetwork_groups, is_container='container', yang_name="subnetwork-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subnetwork_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=subnetwork_groups.subnetwork_groups, is_container='container', yang_name="subnetwork-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__subnetwork_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subnetwork_groups(self):
    self.__subnetwork_groups = YANGDynClass(base=subnetwork_groups.subnetwork_groups, is_container='container', yang_name="subnetwork-groups", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_topology_template(self):
    """
    Getter method for topology_template, mapped from YANG variable /system/tables/topology_template (container)
    """
    return self.__topology_template
      
  def _set_topology_template(self, v, load=False):
    """
    Setter method for topology_template, mapped from YANG variable /system/tables/topology_template (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_topology_template is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_topology_template() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=topology_template.topology_template, is_container='container', yang_name="topology-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """topology_template must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=topology_template.topology_template, is_container='container', yang_name="topology-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__topology_template = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_topology_template(self):
    self.__topology_template = YANGDynClass(base=topology_template.topology_template, is_container='container', yang_name="topology-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_grid_configurations(self):
    """
    Getter method for grid_configurations, mapped from YANG variable /system/tables/grid_configurations (container)
    """
    return self.__grid_configurations
      
  def _set_grid_configurations(self, v, load=False):
    """
    Setter method for grid_configurations, mapped from YANG variable /system/tables/grid_configurations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grid_configurations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grid_configurations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=grid_configurations.grid_configurations, is_container='container', yang_name="grid-configurations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grid_configurations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=grid_configurations.grid_configurations, is_container='container', yang_name="grid-configurations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__grid_configurations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grid_configurations(self):
    self.__grid_configurations = YANGDynClass(base=grid_configurations.grid_configurations, is_container='container', yang_name="grid-configurations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_organizations(self):
    """
    Getter method for organizations, mapped from YANG variable /system/tables/organizations (container)
    """
    return self.__organizations
      
  def _set_organizations(self, v, load=False):
    """
    Setter method for organizations, mapped from YANG variable /system/tables/organizations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_organizations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_organizations() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=organizations.organizations, is_container='container', yang_name="organizations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """organizations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__organizations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_organizations(self):
    self.__organizations = YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_events(self):
    """
    Getter method for events, mapped from YANG variable /system/tables/events (container)
    """
    return self.__events
      
  def _set_events(self, v, load=False):
    """
    Setter method for events, mapped from YANG variable /system/tables/events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_events() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=events.events, is_container='container', yang_name="events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=events.events, is_container='container', yang_name="events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_events(self):
    self.__events = YANGDynClass(base=events.events, is_container='container', yang_name="events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_datapathconfig(self):
    """
    Getter method for datapathconfig, mapped from YANG variable /system/tables/datapathconfig (container)
    """
    return self.__datapathconfig
      
  def _set_datapathconfig(self, v, load=False):
    """
    Setter method for datapathconfig, mapped from YANG variable /system/tables/datapathconfig (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_datapathconfig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_datapathconfig() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=datapathconfig.datapathconfig, is_container='container', yang_name="datapathconfig", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """datapathconfig must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=datapathconfig.datapathconfig, is_container='container', yang_name="datapathconfig", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__datapathconfig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_datapathconfig(self):
    self.__datapathconfig = YANGDynClass(base=datapathconfig.datapathconfig, is_container='container', yang_name="datapathconfig", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_yang_upgrade_components(self):
    """
    Getter method for yang_upgrade_components, mapped from YANG variable /system/tables/yang_upgrade_components (container)
    """
    return self.__yang_upgrade_components
      
  def _set_yang_upgrade_components(self, v, load=False):
    """
    Setter method for yang_upgrade_components, mapped from YANG variable /system/tables/yang_upgrade_components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_yang_upgrade_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_yang_upgrade_components() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=yang_upgrade_components.yang_upgrade_components, is_container='container', yang_name="yang-upgrade-components", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """yang_upgrade_components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yang_upgrade_components.yang_upgrade_components, is_container='container', yang_name="yang-upgrade-components", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__yang_upgrade_components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_yang_upgrade_components(self):
    self.__yang_upgrade_components = YANGDynClass(base=yang_upgrade_components.yang_upgrade_components, is_container='container', yang_name="yang-upgrade-components", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ucs_vnic_template(self):
    """
    Getter method for ucs_vnic_template, mapped from YANG variable /system/tables/ucs_vnic_template (container)
    """
    return self.__ucs_vnic_template
      
  def _set_ucs_vnic_template(self, v, load=False):
    """
    Setter method for ucs_vnic_template, mapped from YANG variable /system/tables/ucs_vnic_template (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ucs_vnic_template is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ucs_vnic_template() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ucs_vnic_template.ucs_vnic_template, is_container='container', yang_name="ucs-vnic-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ucs_vnic_template must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ucs_vnic_template.ucs_vnic_template, is_container='container', yang_name="ucs-vnic-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ucs_vnic_template = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ucs_vnic_template(self):
    self.__ucs_vnic_template = YANGDynClass(base=ucs_vnic_template.ucs_vnic_template, is_container='container', yang_name="ucs-vnic-template", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ucs_vnic(self):
    """
    Getter method for ucs_vnic, mapped from YANG variable /system/tables/ucs_vnic (container)
    """
    return self.__ucs_vnic
      
  def _set_ucs_vnic(self, v, load=False):
    """
    Setter method for ucs_vnic, mapped from YANG variable /system/tables/ucs_vnic (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ucs_vnic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ucs_vnic() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ucs_vnic.ucs_vnic, is_container='container', yang_name="ucs-vnic", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ucs_vnic must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ucs_vnic.ucs_vnic, is_container='container', yang_name="ucs-vnic", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ucs_vnic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ucs_vnic(self):
    self.__ucs_vnic = YANGDynClass(base=ucs_vnic.ucs_vnic, is_container='container', yang_name="ucs-vnic", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_snmp_trap_destination(self):
    """
    Getter method for snmp_trap_destination, mapped from YANG variable /system/tables/snmp_trap_destination (container)
    """
    return self.__snmp_trap_destination
      
  def _set_snmp_trap_destination(self, v, load=False):
    """
    Setter method for snmp_trap_destination, mapped from YANG variable /system/tables/snmp_trap_destination (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_snmp_trap_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_snmp_trap_destination() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=snmp_trap_destination.snmp_trap_destination, is_container='container', yang_name="snmp-trap-destination", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """snmp_trap_destination must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=snmp_trap_destination.snmp_trap_destination, is_container='container', yang_name="snmp-trap-destination", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__snmp_trap_destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_snmp_trap_destination(self):
    self.__snmp_trap_destination = YANGDynClass(base=snmp_trap_destination.snmp_trap_destination, is_container='container', yang_name="snmp-trap-destination", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_basic_device_details(self):
    """
    Getter method for basic_device_details, mapped from YANG variable /system/tables/basic_device_details (container)
    """
    return self.__basic_device_details
      
  def _set_basic_device_details(self, v, load=False):
    """
    Setter method for basic_device_details, mapped from YANG variable /system/tables/basic_device_details (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_basic_device_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_basic_device_details() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=basic_device_details.basic_device_details, is_container='container', yang_name="basic-device-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """basic_device_details must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=basic_device_details.basic_device_details, is_container='container', yang_name="basic-device-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__basic_device_details = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_basic_device_details(self):
    self.__basic_device_details = YANGDynClass(base=basic_device_details.basic_device_details, is_container='container', yang_name="basic-device-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_floating_ips(self):
    """
    Getter method for openstack_floating_ips, mapped from YANG variable /system/tables/openstack_floating_ips (container)
    """
    return self.__openstack_floating_ips
      
  def _set_openstack_floating_ips(self, v, load=False):
    """
    Setter method for openstack_floating_ips, mapped from YANG variable /system/tables/openstack_floating_ips (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_floating_ips is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_floating_ips() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_floating_ips.openstack_floating_ips, is_container='container', yang_name="openstack-floating-ips", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_floating_ips must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_floating_ips.openstack_floating_ips, is_container='container', yang_name="openstack-floating-ips", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_floating_ips = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_floating_ips(self):
    self.__openstack_floating_ips = YANGDynClass(base=openstack_floating_ips.openstack_floating_ips, is_container='container', yang_name="openstack-floating-ips", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_resource_mappings(self):
    """
    Getter method for openstack_resource_mappings, mapped from YANG variable /system/tables/openstack_resource_mappings (container)
    """
    return self.__openstack_resource_mappings
      
  def _set_openstack_resource_mappings(self, v, load=False):
    """
    Setter method for openstack_resource_mappings, mapped from YANG variable /system/tables/openstack_resource_mappings (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_resource_mappings is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_resource_mappings() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_resource_mappings.openstack_resource_mappings, is_container='container', yang_name="openstack-resource-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_resource_mappings must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_resource_mappings.openstack_resource_mappings, is_container='container', yang_name="openstack-resource-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_resource_mappings = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_resource_mappings(self):
    self.__openstack_resource_mappings = YANGDynClass(base=openstack_resource_mappings.openstack_resource_mappings, is_container='container', yang_name="openstack-resource-mappings", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_routers(self):
    """
    Getter method for openstack_routers, mapped from YANG variable /system/tables/openstack_routers (container)
    """
    return self.__openstack_routers
      
  def _set_openstack_routers(self, v, load=False):
    """
    Setter method for openstack_routers, mapped from YANG variable /system/tables/openstack_routers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_routers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_routers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_routers.openstack_routers, is_container='container', yang_name="openstack-routers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_routers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_routers.openstack_routers, is_container='container', yang_name="openstack-routers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_routers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_routers(self):
    self.__openstack_routers = YANGDynClass(base=openstack_routers.openstack_routers, is_container='container', yang_name="openstack-routers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_projects(self):
    """
    Getter method for openstack_projects, mapped from YANG variable /system/tables/openstack_projects (container)
    """
    return self.__openstack_projects
      
  def _set_openstack_projects(self, v, load=False):
    """
    Setter method for openstack_projects, mapped from YANG variable /system/tables/openstack_projects (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_projects is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_projects() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_projects.openstack_projects, is_container='container', yang_name="openstack-projects", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_projects must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_projects.openstack_projects, is_container='container', yang_name="openstack-projects", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_projects = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_projects(self):
    self.__openstack_projects = YANGDynClass(base=openstack_projects.openstack_projects, is_container='container', yang_name="openstack-projects", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_configs(self):
    """
    Getter method for openstack_configs, mapped from YANG variable /system/tables/openstack_configs (container)
    """
    return self.__openstack_configs
      
  def _set_openstack_configs(self, v, load=False):
    """
    Setter method for openstack_configs, mapped from YANG variable /system/tables/openstack_configs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_configs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_configs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_configs.openstack_configs, is_container='container', yang_name="openstack-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_configs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_configs.openstack_configs, is_container='container', yang_name="openstack-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_configs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_configs(self):
    self.__openstack_configs = YANGDynClass(base=openstack_configs.openstack_configs, is_container='container', yang_name="openstack-configs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_openstack_project_details(self):
    """
    Getter method for openstack_project_details, mapped from YANG variable /system/tables/openstack_project_details (container)
    """
    return self.__openstack_project_details
      
  def _set_openstack_project_details(self, v, load=False):
    """
    Setter method for openstack_project_details, mapped from YANG variable /system/tables/openstack_project_details (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openstack_project_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openstack_project_details() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=openstack_project_details.openstack_project_details, is_container='container', yang_name="openstack-project-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openstack_project_details must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openstack_project_details.openstack_project_details, is_container='container', yang_name="openstack-project-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__openstack_project_details = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openstack_project_details(self):
    self.__openstack_project_details = YANGDynClass(base=openstack_project_details.openstack_project_details, is_container='container', yang_name="openstack-project-details", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_vsmconnectors(self):
    """
    Getter method for vsmconnectors, mapped from YANG variable /system/tables/vsmconnectors (container)
    """
    return self.__vsmconnectors
      
  def _set_vsmconnectors(self, v, load=False):
    """
    Setter method for vsmconnectors, mapped from YANG variable /system/tables/vsmconnectors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vsmconnectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vsmconnectors() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vsmconnectors.vsmconnectors, is_container='container', yang_name="vsmconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vsmconnectors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vsmconnectors.vsmconnectors, is_container='container', yang_name="vsmconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__vsmconnectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vsmconnectors(self):
    self.__vsmconnectors = YANGDynClass(base=vsmconnectors.vsmconnectors, is_container='container', yang_name="vsmconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_vcconnectors(self):
    """
    Getter method for vcconnectors, mapped from YANG variable /system/tables/vcconnectors (container)
    """
    return self.__vcconnectors
      
  def _set_vcconnectors(self, v, load=False):
    """
    Setter method for vcconnectors, mapped from YANG variable /system/tables/vcconnectors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcconnectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcconnectors() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=vcconnectors.vcconnectors, is_container='container', yang_name="vcconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vcconnectors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=vcconnectors.vcconnectors, is_container='container', yang_name="vcconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__vcconnectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vcconnectors(self):
    self.__vcconnectors = YANGDynClass(base=vcconnectors.vcconnectors, is_container='container', yang_name="vcconnectors", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_device_user_contexts(self):
    """
    Getter method for device_user_contexts, mapped from YANG variable /system/tables/device_user_contexts (container)
    """
    return self.__device_user_contexts
      
  def _set_device_user_contexts(self, v, load=False):
    """
    Setter method for device_user_contexts, mapped from YANG variable /system/tables/device_user_contexts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_user_contexts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_user_contexts() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=device_user_contexts.device_user_contexts, is_container='container', yang_name="device-user-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_user_contexts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=device_user_contexts.device_user_contexts, is_container='container', yang_name="device-user-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__device_user_contexts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_user_contexts(self):
    self.__device_user_contexts = YANGDynClass(base=device_user_contexts.device_user_contexts, is_container='container', yang_name="device-user-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ldaps(self):
    """
    Getter method for ldaps, mapped from YANG variable /system/tables/ldaps (container)
    """
    return self.__ldaps
      
  def _set_ldaps(self, v, load=False):
    """
    Setter method for ldaps, mapped from YANG variable /system/tables/ldaps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ldaps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ldaps() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ldaps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ldaps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ldaps(self):
    self.__ldaps = YANGDynClass(base=ldaps.ldaps, is_container='container', yang_name="ldaps", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_filter_contexts(self):
    """
    Getter method for filter_contexts, mapped from YANG variable /system/tables/filter_contexts (container)
    """
    return self.__filter_contexts
      
  def _set_filter_contexts(self, v, load=False):
    """
    Setter method for filter_contexts, mapped from YANG variable /system/tables/filter_contexts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_contexts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_contexts() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=filter_contexts.filter_contexts, is_container='container', yang_name="filter-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_contexts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=filter_contexts.filter_contexts, is_container='container', yang_name="filter-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__filter_contexts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_contexts(self):
    self.__filter_contexts = YANGDynClass(base=filter_contexts.filter_contexts, is_container='container', yang_name="filter-contexts", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_naas_events(self):
    """
    Getter method for naas_events, mapped from YANG variable /system/tables/naas_events (container)
    """
    return self.__naas_events
      
  def _set_naas_events(self, v, load=False):
    """
    Setter method for naas_events, mapped from YANG variable /system/tables/naas_events (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_naas_events is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_naas_events() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=naas_events.naas_events, is_container='container', yang_name="naas-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """naas_events must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=naas_events.naas_events, is_container='container', yang_name="naas-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__naas_events = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_naas_events(self):
    self.__naas_events = YANGDynClass(base=naas_events.naas_events, is_container='container', yang_name="naas-events", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_naas_event_specs(self):
    """
    Getter method for naas_event_specs, mapped from YANG variable /system/tables/naas_event_specs (container)
    """
    return self.__naas_event_specs
      
  def _set_naas_event_specs(self, v, load=False):
    """
    Setter method for naas_event_specs, mapped from YANG variable /system/tables/naas_event_specs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_naas_event_specs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_naas_event_specs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=naas_event_specs.naas_event_specs, is_container='container', yang_name="naas-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """naas_event_specs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=naas_event_specs.naas_event_specs, is_container='container', yang_name="naas-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__naas_event_specs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_naas_event_specs(self):
    self.__naas_event_specs = YANGDynClass(base=naas_event_specs.naas_event_specs, is_container='container', yang_name="naas-event-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_user_subscribers(self):
    """
    Getter method for user_subscribers, mapped from YANG variable /system/tables/user_subscribers (container)
    """
    return self.__user_subscribers
      
  def _set_user_subscribers(self, v, load=False):
    """
    Setter method for user_subscribers, mapped from YANG variable /system/tables/user_subscribers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_subscribers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_subscribers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=user_subscribers.user_subscribers, is_container='container', yang_name="user-subscribers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_subscribers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=user_subscribers.user_subscribers, is_container='container', yang_name="user-subscribers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__user_subscribers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_subscribers(self):
    self.__user_subscribers = YANGDynClass(base=user_subscribers.user_subscribers, is_container='container', yang_name="user-subscribers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_event_category_specs(self):
    """
    Getter method for event_category_specs, mapped from YANG variable /system/tables/event_category_specs (container)
    """
    return self.__event_category_specs
      
  def _set_event_category_specs(self, v, load=False):
    """
    Setter method for event_category_specs, mapped from YANG variable /system/tables/event_category_specs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_category_specs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_category_specs() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=event_category_specs.event_category_specs, is_container='container', yang_name="event-category-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_category_specs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=event_category_specs.event_category_specs, is_container='container', yang_name="event-category-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__event_category_specs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_category_specs(self):
    self.__event_category_specs = YANGDynClass(base=event_category_specs.event_category_specs, is_container='container', yang_name="event-category-specs", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_event_subscriber_templates(self):
    """
    Getter method for event_subscriber_templates, mapped from YANG variable /system/tables/event_subscriber_templates (container)
    """
    return self.__event_subscriber_templates
      
  def _set_event_subscriber_templates(self, v, load=False):
    """
    Setter method for event_subscriber_templates, mapped from YANG variable /system/tables/event_subscriber_templates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event_subscriber_templates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event_subscriber_templates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=event_subscriber_templates.event_subscriber_templates, is_container='container', yang_name="event-subscriber-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """event_subscriber_templates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=event_subscriber_templates.event_subscriber_templates, is_container='container', yang_name="event-subscriber-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__event_subscriber_templates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_event_subscriber_templates(self):
    self.__event_subscriber_templates = YANGDynClass(base=event_subscriber_templates.event_subscriber_templates, is_container='container', yang_name="event-subscriber-templates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_role_to_permissions(self):
    """
    Getter method for role_to_permissions, mapped from YANG variable /system/tables/role_to_permissions (container)
    """
    return self.__role_to_permissions
      
  def _set_role_to_permissions(self, v, load=False):
    """
    Setter method for role_to_permissions, mapped from YANG variable /system/tables/role_to_permissions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role_to_permissions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role_to_permissions() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=role_to_permissions.role_to_permissions, is_container='container', yang_name="role-to-permissions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """role_to_permissions must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=role_to_permissions.role_to_permissions, is_container='container', yang_name="role-to-permissions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__role_to_permissions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_role_to_permissions(self):
    self.__role_to_permissions = YANGDynClass(base=role_to_permissions.role_to_permissions, is_container='container', yang_name="role-to-permissions", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_sequence_numbers(self):
    """
    Getter method for sequence_numbers, mapped from YANG variable /system/tables/sequence_numbers (container)
    """
    return self.__sequence_numbers
      
  def _set_sequence_numbers(self, v, load=False):
    """
    Setter method for sequence_numbers, mapped from YANG variable /system/tables/sequence_numbers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sequence_numbers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sequence_numbers() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=sequence_numbers.sequence_numbers, is_container='container', yang_name="sequence-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sequence_numbers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sequence_numbers.sequence_numbers, is_container='container', yang_name="sequence-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__sequence_numbers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sequence_numbers(self):
    self.__sequence_numbers = YANGDynClass(base=sequence_numbers.sequence_numbers, is_container='container', yang_name="sequence-numbers", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_ca_trust_point_certificates(self):
    """
    Getter method for ca_trust_point_certificates, mapped from YANG variable /system/tables/ca_trust_point_certificates (container)
    """
    return self.__ca_trust_point_certificates
      
  def _set_ca_trust_point_certificates(self, v, load=False):
    """
    Setter method for ca_trust_point_certificates, mapped from YANG variable /system/tables/ca_trust_point_certificates (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ca_trust_point_certificates is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ca_trust_point_certificates() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=ca_trust_point_certificates.ca_trust_point_certificates, is_container='container', yang_name="ca-trust-point-certificates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ca_trust_point_certificates must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ca_trust_point_certificates.ca_trust_point_certificates, is_container='container', yang_name="ca-trust-point-certificates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__ca_trust_point_certificates = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ca_trust_point_certificates(self):
    self.__ca_trust_point_certificates = YANGDynClass(base=ca_trust_point_certificates.ca_trust_point_certificates, is_container='container', yang_name="ca-trust-point-certificates", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_compliance(self):
    """
    Getter method for compliance, mapped from YANG variable /system/tables/compliance (container)
    """
    return self.__compliance
      
  def _set_compliance(self, v, load=False):
    """
    Setter method for compliance, mapped from YANG variable /system/tables/compliance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compliance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compliance() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=compliance.compliance, is_container='container', yang_name="compliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compliance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=compliance.compliance, is_container='container', yang_name="compliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__compliance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compliance(self):
    self.__compliance = YANGDynClass(base=compliance.compliance, is_container='container', yang_name="compliance", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_filters(self):
    """
    Getter method for filters, mapped from YANG variable /system/tables/filters (container)
    """
    return self.__filters
      
  def _set_filters(self, v, load=False):
    """
    Setter method for filters, mapped from YANG variable /system/tables/filters (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filters() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=filters.filters, is_container='container', yang_name="filters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filters must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=filters.filters, is_container='container', yang_name="filters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__filters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filters(self):
    self.__filters = YANGDynClass(base=filters.filters, is_container='container', yang_name="filters", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_access_control(self):
    """
    Getter method for access_control, mapped from YANG variable /system/tables/access_control (container)
    """
    return self.__access_control
      
  def _set_access_control(self, v, load=False):
    """
    Setter method for access_control, mapped from YANG variable /system/tables/access_control (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_control is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_control() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_control must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__access_control = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_control(self):
    self.__access_control = YANGDynClass(base=access_control.access_control, is_container='container', yang_name="access-control", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)


  def _get_third_party(self):
    """
    Getter method for third_party, mapped from YANG variable /system/tables/third_party (container)
    """
    return self.__third_party
      
  def _set_third_party(self, v, load=False):
    """
    Setter method for third_party, mapped from YANG variable /system/tables/third_party (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_third_party is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_third_party() directly.
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=third_party.third_party, is_container='container', yang_name="third-party", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """third_party must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=third_party.third_party, is_container='container', yang_name="third-party", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)""",
        })

    self.__third_party = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_third_party(self):
    self.__third_party = YANGDynClass(base=third_party.third_party, is_container='container', yang_name="third-party", module_name="controller", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/controller', defining_module='controller', yang_type='container', is_config=True)

  reports = __builtin__.property(_get_reports, _set_reports)
  capacity_monitor_jobs = __builtin__.property(_get_capacity_monitor_jobs, _set_capacity_monitor_jobs)
  job_schedules = __builtin__.property(_get_job_schedules, _set_job_schedules)
  vlangroups = __builtin__.property(_get_vlangroups, _set_vlangroups)
  device_tier_type = __builtin__.property(_get_device_tier_type, _set_device_tier_type)
  service_request_revision = __builtin__.property(_get_service_request_revision, _set_service_request_revision)
  tacacs = __builtin__.property(_get_tacacs, _set_tacacs)
  vss_chassis = __builtin__.property(_get_vss_chassis, _set_vss_chassis)
  device_component_indexpool = __builtin__.property(_get_device_component_indexpool, _set_device_component_indexpool)
  stack_member = __builtin__.property(_get_stack_member, _set_stack_member)
  group = __builtin__.property(_get_group, _set_group)
  ha_clusters = __builtin__.property(_get_ha_clusters, _set_ha_clusters)
  ha_cluster_entry = __builtin__.property(_get_ha_cluster_entry, _set_ha_cluster_entry)
  openstack_data_networks = __builtin__.property(_get_openstack_data_networks, _set_openstack_data_networks)
  openstack_info = __builtin__.property(_get_openstack_info, _set_openstack_info)
  eventhistory = __builtin__.property(_get_eventhistory, _set_eventhistory)
  lbft_groups = __builtin__.property(_get_lbft_groups, _set_lbft_groups)
  device_monitor_jobs = __builtin__.property(_get_device_monitor_jobs, _set_device_monitor_jobs)
  openstack_interface_mappings = __builtin__.property(_get_openstack_interface_mappings, _set_openstack_interface_mappings)
  device_component_indexes = __builtin__.property(_get_device_component_indexes, _set_device_component_indexes)
  server_service_config = __builtin__.property(_get_server_service_config, _set_server_service_config)
  task = __builtin__.property(_get_task, _set_task)
  usertask = __builtin__.property(_get_usertask, _set_usertask)
  service_requests = __builtin__.property(_get_service_requests, _set_service_requests)
  subnetwork_groups = __builtin__.property(_get_subnetwork_groups, _set_subnetwork_groups)
  topology_template = __builtin__.property(_get_topology_template, _set_topology_template)
  grid_configurations = __builtin__.property(_get_grid_configurations, _set_grid_configurations)
  organizations = __builtin__.property(_get_organizations, _set_organizations)
  events = __builtin__.property(_get_events, _set_events)
  datapathconfig = __builtin__.property(_get_datapathconfig, _set_datapathconfig)
  yang_upgrade_components = __builtin__.property(_get_yang_upgrade_components, _set_yang_upgrade_components)
  ucs_vnic_template = __builtin__.property(_get_ucs_vnic_template, _set_ucs_vnic_template)
  ucs_vnic = __builtin__.property(_get_ucs_vnic, _set_ucs_vnic)
  snmp_trap_destination = __builtin__.property(_get_snmp_trap_destination, _set_snmp_trap_destination)
  basic_device_details = __builtin__.property(_get_basic_device_details, _set_basic_device_details)
  openstack_floating_ips = __builtin__.property(_get_openstack_floating_ips, _set_openstack_floating_ips)
  openstack_resource_mappings = __builtin__.property(_get_openstack_resource_mappings, _set_openstack_resource_mappings)
  openstack_routers = __builtin__.property(_get_openstack_routers, _set_openstack_routers)
  openstack_projects = __builtin__.property(_get_openstack_projects, _set_openstack_projects)
  openstack_configs = __builtin__.property(_get_openstack_configs, _set_openstack_configs)
  openstack_project_details = __builtin__.property(_get_openstack_project_details, _set_openstack_project_details)
  vsmconnectors = __builtin__.property(_get_vsmconnectors, _set_vsmconnectors)
  vcconnectors = __builtin__.property(_get_vcconnectors, _set_vcconnectors)
  device_user_contexts = __builtin__.property(_get_device_user_contexts, _set_device_user_contexts)
  ldaps = __builtin__.property(_get_ldaps, _set_ldaps)
  filter_contexts = __builtin__.property(_get_filter_contexts, _set_filter_contexts)
  naas_events = __builtin__.property(_get_naas_events, _set_naas_events)
  naas_event_specs = __builtin__.property(_get_naas_event_specs, _set_naas_event_specs)
  user_subscribers = __builtin__.property(_get_user_subscribers, _set_user_subscribers)
  event_category_specs = __builtin__.property(_get_event_category_specs, _set_event_category_specs)
  event_subscriber_templates = __builtin__.property(_get_event_subscriber_templates, _set_event_subscriber_templates)
  role_to_permissions = __builtin__.property(_get_role_to_permissions, _set_role_to_permissions)
  sequence_numbers = __builtin__.property(_get_sequence_numbers, _set_sequence_numbers)
  ca_trust_point_certificates = __builtin__.property(_get_ca_trust_point_certificates, _set_ca_trust_point_certificates)
  compliance = __builtin__.property(_get_compliance, _set_compliance)
  filters = __builtin__.property(_get_filters, _set_filters)
  access_control = __builtin__.property(_get_access_control, _set_access_control)
  third_party = __builtin__.property(_get_third_party, _set_third_party)


  _pyangbind_elements = collections.OrderedDict([('reports', reports), ('capacity_monitor_jobs', capacity_monitor_jobs), ('job_schedules', job_schedules), ('vlangroups', vlangroups), ('device_tier_type', device_tier_type), ('service_request_revision', service_request_revision), ('tacacs', tacacs), ('vss_chassis', vss_chassis), ('device_component_indexpool', device_component_indexpool), ('stack_member', stack_member), ('group', group), ('ha_clusters', ha_clusters), ('ha_cluster_entry', ha_cluster_entry), ('openstack_data_networks', openstack_data_networks), ('openstack_info', openstack_info), ('eventhistory', eventhistory), ('lbft_groups', lbft_groups), ('device_monitor_jobs', device_monitor_jobs), ('openstack_interface_mappings', openstack_interface_mappings), ('device_component_indexes', device_component_indexes), ('server_service_config', server_service_config), ('task', task), ('usertask', usertask), ('service_requests', service_requests), ('subnetwork_groups', subnetwork_groups), ('topology_template', topology_template), ('grid_configurations', grid_configurations), ('organizations', organizations), ('events', events), ('datapathconfig', datapathconfig), ('yang_upgrade_components', yang_upgrade_components), ('ucs_vnic_template', ucs_vnic_template), ('ucs_vnic', ucs_vnic), ('snmp_trap_destination', snmp_trap_destination), ('basic_device_details', basic_device_details), ('openstack_floating_ips', openstack_floating_ips), ('openstack_resource_mappings', openstack_resource_mappings), ('openstack_routers', openstack_routers), ('openstack_projects', openstack_projects), ('openstack_configs', openstack_configs), ('openstack_project_details', openstack_project_details), ('vsmconnectors', vsmconnectors), ('vcconnectors', vcconnectors), ('device_user_contexts', device_user_contexts), ('ldaps', ldaps), ('filter_contexts', filter_contexts), ('naas_events', naas_events), ('naas_event_specs', naas_event_specs), ('user_subscribers', user_subscribers), ('event_category_specs', event_category_specs), ('event_subscriber_templates', event_subscriber_templates), ('role_to_permissions', role_to_permissions), ('sequence_numbers', sequence_numbers), ('ca_trust_point_certificates', ca_trust_point_certificates), ('compliance', compliance), ('filters', filters), ('access_control', access_control), ('third_party', third_party), ])


