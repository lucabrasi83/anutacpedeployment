
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType, RestrictedClassType, TypedListType
from pyangbind.lib.yangtypes import YANGBool, YANGListType, YANGDynClass, ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import __builtin__
import collections
def isEmpty(val):
    """ Check weather val is empty 
    
    Args:
    Val : Value need to check
    Returns:
    True: if the value is empty
    False: if the value is not empty
    """
    if(val == None):
        return True
    if isinstance(val, list):
        return len(val) == 0
    if isinstance(val, str):
        return val.strip() == ''
    if isinstance(val, unicode):
        return str(val).strip() == ''
       
    return False
class capacity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module capacities - based on the path /capacities/capacity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_pybind_generated_by', '_netconf_operation_type', '_path_helper', '_yang_name', '_extmethods', '_module_name', '_namespace','__capacity_id','__capacity_type','__capacity_units','__total','__reserved','__used','__available','__alarm_spec_name','__parent','__component_id','__component_type','__used_in_aggregated_capacity','__previous_value',)

  _yang_name = 'capacity'
  _module_name = 'capacities'
  _namespace = 'http://anutanetworks.com/capacities'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__available = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="available", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    self.__used = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    self.__reserved = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reserved", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    self.__component_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VDC_DEVICE': {}, u'RESOURCEPOOL': {}, u'VIRTUALROUTINGINSTANCE': {}, u'NETWORK_CONNECTION': {}, u'LINK': {}, u'IPADDRESSENTRY': {}, u'ADDRESSES': {}, u'REVERSEPROXY': {}, u'SECURITYPOLICY': {}, u'PORTPROFILE': {}, u'SUBNETWORK': {}, u'LOADBALANCER': {}, u'REALSERVER': {}, u'SERVERPORT': {}, u'FIREWALL': {}, u'SERVICEPOLICY': {}, u'MODULE': {}, u'DEVICE_IP_ADDRESS': {}, u'OPENLDAP': {}, u'VZONECONDITION': {}, u'DATACENTER': {}, u'FIREWALLRULE': {}, u'REGION': {}, u'ADDRESSBOOK': {}, u'SERVER': {}, u'CLUSTER': {}, u'API': {}, u'INTERFACE': {}, u'OBJECTGROUP': {}, u'ROGUE_IP_ADDRESS': {}, u'OPERATION': {}, u'PROTOCOLGROUP': {}, u'VZONE': {}, u'VDC': {}, u'CONTEXT': {}, u'PROTOCOL': {}, u'DNSPROXY': {}, u'PORT': {}, u'SSLKEY': {}, u'WANOPTIMIZER': {}, u'ORDER': {}, u'LOCATION': {}, u'IPADDRESSPOOL': {}, u'VIRTUALSERVER': {}, u'WANOPREDIRECTIONCONDITION': {}, u'PERFORMANCEROUTINGPOLICY': {}, u'INTERCONNECTNETWORKS': {}, u'DYNAMICNAT': {}, u'TACACS': {}, u'NETWORKOBJECT': {}, u'L3ZONE': {}, u'ACTIVEDIRECTORY': {}, u'FORWARDPROXY': {}, u'DEVICE_GROUP': {}, u'SERVICEPOLICYRULE': {}, u'SECURITYPROFILE': {}, u'NATOVERLOAD': {}, u'SERVICE': {}, u'APPLICATION': {}, u'AGENT': {}, u'LBSSLKEY': {}, u'NETWORKFUNCTION': {}, u'ROUTERSECURITYPOLICY': {}, u'DHCPPOOL': {}, u'APPLICATIONSET': {}, u'FIREWALLZONE': {}, u'COMPUTEFIREWALLOBJECTGROUP': {}, u'RESOURCE_POOL_DEVICE_GROUP': {}, u'REPLACEDEVICE': {}, u'VIRTUALNETWORK': {}, u'RSERVICE': {}, u'HOST': {}, u'FILTERURLTRAFFIC': {}, u'TENANT': {}, u'COMPUTEFIREWALL': {}, u'GLOBALLBTOPOLOGY': {}, u'STATICROUTE': {}, u'NATEXEMPT': {}, u'FOLDER': {}, u'RESOURCE_POOL_GROUP': {}, u'GLOBALAPPLICATIONSERVICE': {}, u'POLICYGROUP': {}, u'REMOTEACCESSVPN': {}, u'WANEDGEQOSPOLICY': {}, u'SERVERFARM': {}, u'SERVERJOB': {}, u'FORWARDINGHOST': {}, u'WIRELESSLAN': {}, u'GLOBALVIRTUALSERVER': {}, u'CONFIGSCRIPT': {}, u'DATANODE': {}, u'VPC': {}, u'PORT_CHANNEL': {}, u'POD': {}, u'ADDDEVICE': {}, u'SUBINTERFACE': {}, u'RESOURCE_POOL': {}, u'VCD': {}, u'POLICYROUTING': {}, u'GROUPPOLICY': {}, u'VM': {}, u'GLOBALVDC': {}, u'DEVICE': {}, u'LBSSLCERTIFICATE': {}, u'POLICYCONDITION': {}, u'ROUTELEAK': {}, u'STACK_MEMBER': {}, u'SUBNET': {}, u'STATICNAT': {}, u'SYSTEM': {}, u'EXTNETWORK': {}, u'ADDRESSSET': {}, u'OBJECTGROUPCONDITION': {}},), is_leaf=True, yang_name="component-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:component-type', is_config=True)
    self.__parent = YANGDynClass(base=unicode, is_leaf=True, yang_name="parent", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)
    self.__capacity_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="capacity-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)
    self.__previous_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="previous-value", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint64', is_config=True)
    self.__component_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="component-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)
    self.__capacity_units = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'G_BYTES': {}, u'K_BYTES': {}, u'M_BITS': {}, u'M_BYTES': {}, u'G_BITS': {}, u'BYTES': {}, u'K_BITS': {}, u'PACKETS': {}, u'PERCENTAGE': {}, u'BITS': {}, u'ABSOLUTE': {}},), is_leaf=True, yang_name="capacity-units", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:capacity-units', is_config=True)
    self.__alarm_spec_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="alarm-spec-name", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)
    self.__total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    self.__capacity_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="capacity-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)
    self.__used_in_aggregated_capacity = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="used-in-aggregated-capacity", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'capacities', u'capacity']

  def _get_capacity_id(self):
    """
    Getter method for capacity_id, mapped from YANG variable /capacities/capacity/capacity_id (string)

    YANG Description: string
    """
    return self.__capacity_id
      
  def _set_capacity_id(self, v, load=False):
    """
    Setter method for capacity_id, mapped from YANG variable /capacities/capacity/capacity_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacity_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacity_id() directly.

    YANG Description: string
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="capacity-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacity_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="capacity-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)""",
        })

    self.__capacity_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacity_id(self):
    self.__capacity_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="capacity-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)


  def _get_capacity_type(self):
    """
    Getter method for capacity_type, mapped from YANG variable /capacities/capacity/capacity_type (leafref)

    YANG Description: capacity-type
    """
    return self.__capacity_type
      
  def _set_capacity_type(self, v, load=False):
    """
    Setter method for capacity_type, mapped from YANG variable /capacities/capacity/capacity_type (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacity_type() directly.

    YANG Description: capacity-type
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="capacity-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacity_type must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="capacity-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)""",
        })

    self.__capacity_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacity_type(self):
    self.__capacity_type = YANGDynClass(base=unicode, is_leaf=True, yang_name="capacity-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)


  def _get_capacity_units(self):
    """
    Getter method for capacity_units, mapped from YANG variable /capacities/capacity/capacity_units (ndt:capacity-units)

    YANG Description: ABSOLUTE
PERCENTAGE
BYTES
K_BYTES
M_BYTES
G_BYTES
BITS
K_BITS
M_BITS
G_BITS
PACKETS

    """
    return self.__capacity_units
      
  def _set_capacity_units(self, v, load=False):
    """
    Setter method for capacity_units, mapped from YANG variable /capacities/capacity/capacity_units (ndt:capacity-units)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_capacity_units is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_capacity_units() directly.

    YANG Description: ABSOLUTE
PERCENTAGE
BYTES
K_BYTES
M_BYTES
G_BYTES
BITS
K_BITS
M_BITS
G_BITS
PACKETS

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'G_BYTES': {}, u'K_BYTES': {}, u'M_BITS': {}, u'M_BYTES': {}, u'G_BITS': {}, u'BYTES': {}, u'K_BITS': {}, u'PACKETS': {}, u'PERCENTAGE': {}, u'BITS': {}, u'ABSOLUTE': {}},), is_leaf=True, yang_name="capacity-units", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:capacity-units', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """capacity_units must be of a type compatible with ndt:capacity-units""",
          'defined-type': "ndt:capacity-units",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'G_BYTES': {}, u'K_BYTES': {}, u'M_BITS': {}, u'M_BYTES': {}, u'G_BITS': {}, u'BYTES': {}, u'K_BITS': {}, u'PACKETS': {}, u'PERCENTAGE': {}, u'BITS': {}, u'ABSOLUTE': {}},), is_leaf=True, yang_name="capacity-units", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:capacity-units', is_config=True)""",
        })

    self.__capacity_units = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_capacity_units(self):
    self.__capacity_units = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'G_BYTES': {}, u'K_BYTES': {}, u'M_BITS': {}, u'M_BYTES': {}, u'G_BITS': {}, u'BYTES': {}, u'K_BITS': {}, u'PACKETS': {}, u'PERCENTAGE': {}, u'BITS': {}, u'ABSOLUTE': {}},), is_leaf=True, yang_name="capacity-units", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:capacity-units', is_config=True)


  def _get_total(self):
    """
    Getter method for total, mapped from YANG variable /capacities/capacity/total (uint32)

    YANG Description: 0..4294967295
    """
    return self.__total
      
  def _set_total(self, v, load=False):
    """
    Setter method for total, mapped from YANG variable /capacities/capacity/total (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)""",
        })

    self.__total = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total(self):
    self.__total = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)


  def _get_reserved(self):
    """
    Getter method for reserved, mapped from YANG variable /capacities/capacity/reserved (uint32)

    YANG Description: 0..4294967295
    """
    return self.__reserved
      
  def _set_reserved(self, v, load=False):
    """
    Setter method for reserved, mapped from YANG variable /capacities/capacity/reserved (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserved is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserved() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reserved", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reserved must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reserved", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)""",
        })

    self.__reserved = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reserved(self):
    self.__reserved = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="reserved", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)


  def _get_used(self):
    """
    Getter method for used, mapped from YANG variable /capacities/capacity/used (uint32)

    YANG Description: 0..4294967295
    """
    return self.__used
      
  def _set_used(self, v, load=False):
    """
    Setter method for used, mapped from YANG variable /capacities/capacity/used (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_used() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """used must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)""",
        })

    self.__used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_used(self):
    self.__used = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)


  def _get_available(self):
    """
    Getter method for available, mapped from YANG variable /capacities/capacity/available (uint32)

    YANG Description: 0..4294967295
    """
    return self.__available
      
  def _set_available(self, v, load=False):
    """
    Setter method for available, mapped from YANG variable /capacities/capacity/available (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_available is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_available() directly.

    YANG Description: 0..4294967295
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="available", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """available must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="available", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)""",
        })

    self.__available = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_available(self):
    self.__available = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="available", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint32', is_config=True)


  def _get_alarm_spec_name(self):
    """
    Getter method for alarm_spec_name, mapped from YANG variable /capacities/capacity/alarm_spec_name (leafref)

    YANG Description: alarm-spec-name
    """
    return self.__alarm_spec_name
      
  def _set_alarm_spec_name(self, v, load=False):
    """
    Setter method for alarm_spec_name, mapped from YANG variable /capacities/capacity/alarm_spec_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_spec_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_spec_name() directly.

    YANG Description: alarm-spec-name
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="alarm-spec-name", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_spec_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="alarm-spec-name", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)""",
        })

    self.__alarm_spec_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_spec_name(self):
    self.__alarm_spec_name = YANGDynClass(base=unicode, is_leaf=True, yang_name="alarm-spec-name", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)


  def _get_parent(self):
    """
    Getter method for parent, mapped from YANG variable /capacities/capacity/parent (leafref)

    YANG Description: parent
    """
    return self.__parent
      
  def _set_parent(self, v, load=False):
    """
    Setter method for parent, mapped from YANG variable /capacities/capacity/parent (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent() directly.

    YANG Description: parent
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="parent", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="parent", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)""",
        })

    self.__parent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent(self):
    self.__parent = YANGDynClass(base=unicode, is_leaf=True, yang_name="parent", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='leafref', is_config=True)


  def _get_component_id(self):
    """
    Getter method for component_id, mapped from YANG variable /capacities/capacity/component_id (string)

    YANG Description: string
    """
    return self.__component_id
      
  def _set_component_id(self, v, load=False):
    """
    Setter method for component_id, mapped from YANG variable /capacities/capacity/component_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_id() directly.

    YANG Description: string
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=unicode, is_leaf=True, yang_name="component-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="component-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)""",
        })

    self.__component_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_id(self):
    self.__component_id = YANGDynClass(base=unicode, is_leaf=True, yang_name="component-id", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='string', is_config=True)


  def _get_component_type(self):
    """
    Getter method for component_type, mapped from YANG variable /capacities/capacity/component_type (ndt:component-type)

    YANG Description: ADDDEVICE
REPLACEDEVICE
CONFIGSCRIPT
DEVICE
DEVICE_GROUP
INTERFACE
NETWORK_CONNECTION
SUBINTERFACE
MODULE
STACK_MEMBER
PORT_CHANNEL
LINK
SERVICE
SUBNETWORK
RESOURCEPOOL
VIRTUALNETWORK
VIRTUALSERVER
PORTPROFILE
IPADDRESSPOOL
IPADDRESSENTRY
STATICNAT
NATOVERLOAD
NATEXEMPT
FORWARDINGHOST
FILTERURLTRAFFIC
DYNAMICNAT
TENANT
VDC
VDC_DEVICE
NETWORKFUNCTION
VPC
INTERCONNECTNETWORKS
SSLKEY
L3ZONE
LOADBALANCER
REVERSEPROXY
EXTNETWORK
FIREWALL
FIREWALLRULE
ROUTELEAK
ADDRESSBOOK
ADDRESSES
ADDRESSSET
APPLICATION
APPLICATIONSET
DNSPROXY
DHCPPOOL
OBJECTGROUP
POLICYGROUP
GROUPPOLICY
PROTOCOL
PROTOCOLGROUP
NETWORKOBJECT
COMPUTEFIREWALL
COMPUTEFIREWALLOBJECTGROUP
OBJECTGROUPCONDITION
SECURITYPROFILE
SERVICEPOLICY
SERVICEPOLICYRULE
POLICYCONDITION
VZONE
VZONECONDITION
SERVER
DATACENTER
LOCATION
SERVERJOB
VCD
HOST
CLUSTER
VM
PORT
AGENT
REALSERVER
REMOTEACCESSVPN
SERVERFARM
RSERVICE
LBSSLKEY
LBSSLCERTIFICATE
GLOBALAPPLICATIONSERVICE
GLOBALVIRTUALSERVER
GLOBALLBTOPOLOGY
STATICROUTE
SERVERPORT
FIREWALLZONE
VIRTUALROUTINGINSTANCE
REGION
RESOURCE_POOL
RESOURCE_POOL_GROUP
SUBNET
WANOPTIMIZER
WANOPREDIRECTIONCONDITION
POD
RESOURCE_POOL_DEVICE_GROUP
FORWARDPROXY
CONTEXT
POLICYROUTING
PERFORMANCEROUTINGPOLICY
GLOBALVDC
WANEDGEQOSPOLICY
SECURITYPOLICY
ROUTERSECURITYPOLICY
OPENLDAP
TACACS
SYSTEM
DEVICE_IP_ADDRESS
ROGUE_IP_ADDRESS
ACTIVEDIRECTORY
WIRELESSLAN
API
DATANODE
OPERATION
FOLDER
ORDER

    """
    return self.__component_type
      
  def _set_component_type(self, v, load=False):
    """
    Setter method for component_type, mapped from YANG variable /capacities/capacity/component_type (ndt:component-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_type() directly.

    YANG Description: ADDDEVICE
REPLACEDEVICE
CONFIGSCRIPT
DEVICE
DEVICE_GROUP
INTERFACE
NETWORK_CONNECTION
SUBINTERFACE
MODULE
STACK_MEMBER
PORT_CHANNEL
LINK
SERVICE
SUBNETWORK
RESOURCEPOOL
VIRTUALNETWORK
VIRTUALSERVER
PORTPROFILE
IPADDRESSPOOL
IPADDRESSENTRY
STATICNAT
NATOVERLOAD
NATEXEMPT
FORWARDINGHOST
FILTERURLTRAFFIC
DYNAMICNAT
TENANT
VDC
VDC_DEVICE
NETWORKFUNCTION
VPC
INTERCONNECTNETWORKS
SSLKEY
L3ZONE
LOADBALANCER
REVERSEPROXY
EXTNETWORK
FIREWALL
FIREWALLRULE
ROUTELEAK
ADDRESSBOOK
ADDRESSES
ADDRESSSET
APPLICATION
APPLICATIONSET
DNSPROXY
DHCPPOOL
OBJECTGROUP
POLICYGROUP
GROUPPOLICY
PROTOCOL
PROTOCOLGROUP
NETWORKOBJECT
COMPUTEFIREWALL
COMPUTEFIREWALLOBJECTGROUP
OBJECTGROUPCONDITION
SECURITYPROFILE
SERVICEPOLICY
SERVICEPOLICYRULE
POLICYCONDITION
VZONE
VZONECONDITION
SERVER
DATACENTER
LOCATION
SERVERJOB
VCD
HOST
CLUSTER
VM
PORT
AGENT
REALSERVER
REMOTEACCESSVPN
SERVERFARM
RSERVICE
LBSSLKEY
LBSSLCERTIFICATE
GLOBALAPPLICATIONSERVICE
GLOBALVIRTUALSERVER
GLOBALLBTOPOLOGY
STATICROUTE
SERVERPORT
FIREWALLZONE
VIRTUALROUTINGINSTANCE
REGION
RESOURCE_POOL
RESOURCE_POOL_GROUP
SUBNET
WANOPTIMIZER
WANOPREDIRECTIONCONDITION
POD
RESOURCE_POOL_DEVICE_GROUP
FORWARDPROXY
CONTEXT
POLICYROUTING
PERFORMANCEROUTINGPOLICY
GLOBALVDC
WANEDGEQOSPOLICY
SECURITYPOLICY
ROUTERSECURITYPOLICY
OPENLDAP
TACACS
SYSTEM
DEVICE_IP_ADDRESS
ROGUE_IP_ADDRESS
ACTIVEDIRECTORY
WIRELESSLAN
API
DATANODE
OPERATION
FOLDER
ORDER

    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VDC_DEVICE': {}, u'RESOURCEPOOL': {}, u'VIRTUALROUTINGINSTANCE': {}, u'NETWORK_CONNECTION': {}, u'LINK': {}, u'IPADDRESSENTRY': {}, u'ADDRESSES': {}, u'REVERSEPROXY': {}, u'SECURITYPOLICY': {}, u'PORTPROFILE': {}, u'SUBNETWORK': {}, u'LOADBALANCER': {}, u'REALSERVER': {}, u'SERVERPORT': {}, u'FIREWALL': {}, u'SERVICEPOLICY': {}, u'MODULE': {}, u'DEVICE_IP_ADDRESS': {}, u'OPENLDAP': {}, u'VZONECONDITION': {}, u'DATACENTER': {}, u'FIREWALLRULE': {}, u'REGION': {}, u'ADDRESSBOOK': {}, u'SERVER': {}, u'CLUSTER': {}, u'API': {}, u'INTERFACE': {}, u'OBJECTGROUP': {}, u'ROGUE_IP_ADDRESS': {}, u'OPERATION': {}, u'PROTOCOLGROUP': {}, u'VZONE': {}, u'VDC': {}, u'CONTEXT': {}, u'PROTOCOL': {}, u'DNSPROXY': {}, u'PORT': {}, u'SSLKEY': {}, u'WANOPTIMIZER': {}, u'ORDER': {}, u'LOCATION': {}, u'IPADDRESSPOOL': {}, u'VIRTUALSERVER': {}, u'WANOPREDIRECTIONCONDITION': {}, u'PERFORMANCEROUTINGPOLICY': {}, u'INTERCONNECTNETWORKS': {}, u'DYNAMICNAT': {}, u'TACACS': {}, u'NETWORKOBJECT': {}, u'L3ZONE': {}, u'ACTIVEDIRECTORY': {}, u'FORWARDPROXY': {}, u'DEVICE_GROUP': {}, u'SERVICEPOLICYRULE': {}, u'SECURITYPROFILE': {}, u'NATOVERLOAD': {}, u'SERVICE': {}, u'APPLICATION': {}, u'AGENT': {}, u'LBSSLKEY': {}, u'NETWORKFUNCTION': {}, u'ROUTERSECURITYPOLICY': {}, u'DHCPPOOL': {}, u'APPLICATIONSET': {}, u'FIREWALLZONE': {}, u'COMPUTEFIREWALLOBJECTGROUP': {}, u'RESOURCE_POOL_DEVICE_GROUP': {}, u'REPLACEDEVICE': {}, u'VIRTUALNETWORK': {}, u'RSERVICE': {}, u'HOST': {}, u'FILTERURLTRAFFIC': {}, u'TENANT': {}, u'COMPUTEFIREWALL': {}, u'GLOBALLBTOPOLOGY': {}, u'STATICROUTE': {}, u'NATEXEMPT': {}, u'FOLDER': {}, u'RESOURCE_POOL_GROUP': {}, u'GLOBALAPPLICATIONSERVICE': {}, u'POLICYGROUP': {}, u'REMOTEACCESSVPN': {}, u'WANEDGEQOSPOLICY': {}, u'SERVERFARM': {}, u'SERVERJOB': {}, u'FORWARDINGHOST': {}, u'WIRELESSLAN': {}, u'GLOBALVIRTUALSERVER': {}, u'CONFIGSCRIPT': {}, u'DATANODE': {}, u'VPC': {}, u'PORT_CHANNEL': {}, u'POD': {}, u'ADDDEVICE': {}, u'SUBINTERFACE': {}, u'RESOURCE_POOL': {}, u'VCD': {}, u'POLICYROUTING': {}, u'GROUPPOLICY': {}, u'VM': {}, u'GLOBALVDC': {}, u'DEVICE': {}, u'LBSSLCERTIFICATE': {}, u'POLICYCONDITION': {}, u'ROUTELEAK': {}, u'STACK_MEMBER': {}, u'SUBNET': {}, u'STATICNAT': {}, u'SYSTEM': {}, u'EXTNETWORK': {}, u'ADDRESSSET': {}, u'OBJECTGROUPCONDITION': {}},), is_leaf=True, yang_name="component-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:component-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_type must be of a type compatible with ndt:component-type""",
          'defined-type': "ndt:component-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VDC_DEVICE': {}, u'RESOURCEPOOL': {}, u'VIRTUALROUTINGINSTANCE': {}, u'NETWORK_CONNECTION': {}, u'LINK': {}, u'IPADDRESSENTRY': {}, u'ADDRESSES': {}, u'REVERSEPROXY': {}, u'SECURITYPOLICY': {}, u'PORTPROFILE': {}, u'SUBNETWORK': {}, u'LOADBALANCER': {}, u'REALSERVER': {}, u'SERVERPORT': {}, u'FIREWALL': {}, u'SERVICEPOLICY': {}, u'MODULE': {}, u'DEVICE_IP_ADDRESS': {}, u'OPENLDAP': {}, u'VZONECONDITION': {}, u'DATACENTER': {}, u'FIREWALLRULE': {}, u'REGION': {}, u'ADDRESSBOOK': {}, u'SERVER': {}, u'CLUSTER': {}, u'API': {}, u'INTERFACE': {}, u'OBJECTGROUP': {}, u'ROGUE_IP_ADDRESS': {}, u'OPERATION': {}, u'PROTOCOLGROUP': {}, u'VZONE': {}, u'VDC': {}, u'CONTEXT': {}, u'PROTOCOL': {}, u'DNSPROXY': {}, u'PORT': {}, u'SSLKEY': {}, u'WANOPTIMIZER': {}, u'ORDER': {}, u'LOCATION': {}, u'IPADDRESSPOOL': {}, u'VIRTUALSERVER': {}, u'WANOPREDIRECTIONCONDITION': {}, u'PERFORMANCEROUTINGPOLICY': {}, u'INTERCONNECTNETWORKS': {}, u'DYNAMICNAT': {}, u'TACACS': {}, u'NETWORKOBJECT': {}, u'L3ZONE': {}, u'ACTIVEDIRECTORY': {}, u'FORWARDPROXY': {}, u'DEVICE_GROUP': {}, u'SERVICEPOLICYRULE': {}, u'SECURITYPROFILE': {}, u'NATOVERLOAD': {}, u'SERVICE': {}, u'APPLICATION': {}, u'AGENT': {}, u'LBSSLKEY': {}, u'NETWORKFUNCTION': {}, u'ROUTERSECURITYPOLICY': {}, u'DHCPPOOL': {}, u'APPLICATIONSET': {}, u'FIREWALLZONE': {}, u'COMPUTEFIREWALLOBJECTGROUP': {}, u'RESOURCE_POOL_DEVICE_GROUP': {}, u'REPLACEDEVICE': {}, u'VIRTUALNETWORK': {}, u'RSERVICE': {}, u'HOST': {}, u'FILTERURLTRAFFIC': {}, u'TENANT': {}, u'COMPUTEFIREWALL': {}, u'GLOBALLBTOPOLOGY': {}, u'STATICROUTE': {}, u'NATEXEMPT': {}, u'FOLDER': {}, u'RESOURCE_POOL_GROUP': {}, u'GLOBALAPPLICATIONSERVICE': {}, u'POLICYGROUP': {}, u'REMOTEACCESSVPN': {}, u'WANEDGEQOSPOLICY': {}, u'SERVERFARM': {}, u'SERVERJOB': {}, u'FORWARDINGHOST': {}, u'WIRELESSLAN': {}, u'GLOBALVIRTUALSERVER': {}, u'CONFIGSCRIPT': {}, u'DATANODE': {}, u'VPC': {}, u'PORT_CHANNEL': {}, u'POD': {}, u'ADDDEVICE': {}, u'SUBINTERFACE': {}, u'RESOURCE_POOL': {}, u'VCD': {}, u'POLICYROUTING': {}, u'GROUPPOLICY': {}, u'VM': {}, u'GLOBALVDC': {}, u'DEVICE': {}, u'LBSSLCERTIFICATE': {}, u'POLICYCONDITION': {}, u'ROUTELEAK': {}, u'STACK_MEMBER': {}, u'SUBNET': {}, u'STATICNAT': {}, u'SYSTEM': {}, u'EXTNETWORK': {}, u'ADDRESSSET': {}, u'OBJECTGROUPCONDITION': {}},), is_leaf=True, yang_name="component-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:component-type', is_config=True)""",
        })

    self.__component_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_type(self):
    self.__component_type = YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VDC_DEVICE': {}, u'RESOURCEPOOL': {}, u'VIRTUALROUTINGINSTANCE': {}, u'NETWORK_CONNECTION': {}, u'LINK': {}, u'IPADDRESSENTRY': {}, u'ADDRESSES': {}, u'REVERSEPROXY': {}, u'SECURITYPOLICY': {}, u'PORTPROFILE': {}, u'SUBNETWORK': {}, u'LOADBALANCER': {}, u'REALSERVER': {}, u'SERVERPORT': {}, u'FIREWALL': {}, u'SERVICEPOLICY': {}, u'MODULE': {}, u'DEVICE_IP_ADDRESS': {}, u'OPENLDAP': {}, u'VZONECONDITION': {}, u'DATACENTER': {}, u'FIREWALLRULE': {}, u'REGION': {}, u'ADDRESSBOOK': {}, u'SERVER': {}, u'CLUSTER': {}, u'API': {}, u'INTERFACE': {}, u'OBJECTGROUP': {}, u'ROGUE_IP_ADDRESS': {}, u'OPERATION': {}, u'PROTOCOLGROUP': {}, u'VZONE': {}, u'VDC': {}, u'CONTEXT': {}, u'PROTOCOL': {}, u'DNSPROXY': {}, u'PORT': {}, u'SSLKEY': {}, u'WANOPTIMIZER': {}, u'ORDER': {}, u'LOCATION': {}, u'IPADDRESSPOOL': {}, u'VIRTUALSERVER': {}, u'WANOPREDIRECTIONCONDITION': {}, u'PERFORMANCEROUTINGPOLICY': {}, u'INTERCONNECTNETWORKS': {}, u'DYNAMICNAT': {}, u'TACACS': {}, u'NETWORKOBJECT': {}, u'L3ZONE': {}, u'ACTIVEDIRECTORY': {}, u'FORWARDPROXY': {}, u'DEVICE_GROUP': {}, u'SERVICEPOLICYRULE': {}, u'SECURITYPROFILE': {}, u'NATOVERLOAD': {}, u'SERVICE': {}, u'APPLICATION': {}, u'AGENT': {}, u'LBSSLKEY': {}, u'NETWORKFUNCTION': {}, u'ROUTERSECURITYPOLICY': {}, u'DHCPPOOL': {}, u'APPLICATIONSET': {}, u'FIREWALLZONE': {}, u'COMPUTEFIREWALLOBJECTGROUP': {}, u'RESOURCE_POOL_DEVICE_GROUP': {}, u'REPLACEDEVICE': {}, u'VIRTUALNETWORK': {}, u'RSERVICE': {}, u'HOST': {}, u'FILTERURLTRAFFIC': {}, u'TENANT': {}, u'COMPUTEFIREWALL': {}, u'GLOBALLBTOPOLOGY': {}, u'STATICROUTE': {}, u'NATEXEMPT': {}, u'FOLDER': {}, u'RESOURCE_POOL_GROUP': {}, u'GLOBALAPPLICATIONSERVICE': {}, u'POLICYGROUP': {}, u'REMOTEACCESSVPN': {}, u'WANEDGEQOSPOLICY': {}, u'SERVERFARM': {}, u'SERVERJOB': {}, u'FORWARDINGHOST': {}, u'WIRELESSLAN': {}, u'GLOBALVIRTUALSERVER': {}, u'CONFIGSCRIPT': {}, u'DATANODE': {}, u'VPC': {}, u'PORT_CHANNEL': {}, u'POD': {}, u'ADDDEVICE': {}, u'SUBINTERFACE': {}, u'RESOURCE_POOL': {}, u'VCD': {}, u'POLICYROUTING': {}, u'GROUPPOLICY': {}, u'VM': {}, u'GLOBALVDC': {}, u'DEVICE': {}, u'LBSSLCERTIFICATE': {}, u'POLICYCONDITION': {}, u'ROUTELEAK': {}, u'STACK_MEMBER': {}, u'SUBNET': {}, u'STATICNAT': {}, u'SYSTEM': {}, u'EXTNETWORK': {}, u'ADDRESSSET': {}, u'OBJECTGROUPCONDITION': {}},), is_leaf=True, yang_name="component-type", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='ndt:component-type', is_config=True)


  def _get_used_in_aggregated_capacity(self):
    """
    Getter method for used_in_aggregated_capacity, mapped from YANG variable /capacities/capacity/used_in_aggregated_capacity (boolean)

    YANG Description: used-in-aggregated-capacity: True/False
    """
    return self.__used_in_aggregated_capacity
      
  def _set_used_in_aggregated_capacity(self, v, load=False):
    """
    Setter method for used_in_aggregated_capacity, mapped from YANG variable /capacities/capacity/used_in_aggregated_capacity (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_used_in_aggregated_capacity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_used_in_aggregated_capacity() directly.

    YANG Description: used-in-aggregated-capacity: True/False
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="used-in-aggregated-capacity", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """used_in_aggregated_capacity must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="used-in-aggregated-capacity", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='boolean', is_config=True)""",
        })

    self.__used_in_aggregated_capacity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_used_in_aggregated_capacity(self):
    self.__used_in_aggregated_capacity = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="used-in-aggregated-capacity", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='boolean', is_config=True)


  def _get_previous_value(self):
    """
    Getter method for previous_value, mapped from YANG variable /capacities/capacity/previous_value (uint64)

    YANG Description: 0..18446744073709551615
    """
    return self.__previous_value
      
  def _set_previous_value(self, v, load=False):
    """
    Setter method for previous_value, mapped from YANG variable /capacities/capacity/previous_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_previous_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_previous_value() directly.

    YANG Description: 0..18446744073709551615
    """
    try:
      if isEmpty(v):
        return
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="previous-value", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """previous_value must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="previous-value", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint64', is_config=True)""",
        })

    self.__previous_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_previous_value(self):
    self.__previous_value = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="previous-value", module_name="capacities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://anutanetworks.com/capacities', defining_module='capacities', yang_type='uint64', is_config=True)

  capacity_id = __builtin__.property(_get_capacity_id, _set_capacity_id)
  capacity_type = __builtin__.property(_get_capacity_type, _set_capacity_type)
  capacity_units = __builtin__.property(_get_capacity_units, _set_capacity_units)
  total = __builtin__.property(_get_total, _set_total)
  reserved = __builtin__.property(_get_reserved, _set_reserved)
  used = __builtin__.property(_get_used, _set_used)
  available = __builtin__.property(_get_available, _set_available)
  alarm_spec_name = __builtin__.property(_get_alarm_spec_name, _set_alarm_spec_name)
  parent = __builtin__.property(_get_parent, _set_parent)
  component_id = __builtin__.property(_get_component_id, _set_component_id)
  component_type = __builtin__.property(_get_component_type, _set_component_type)
  used_in_aggregated_capacity = __builtin__.property(_get_used_in_aggregated_capacity, _set_used_in_aggregated_capacity)
  previous_value = __builtin__.property(_get_previous_value, _set_previous_value)


  _pyangbind_elements = collections.OrderedDict([('capacity_id', capacity_id), ('capacity_type', capacity_type), ('capacity_units', capacity_units), ('total', total), ('reserved', reserved), ('used', used), ('available', available), ('alarm_spec_name', alarm_spec_name), ('parent', parent), ('component_id', component_id), ('component_type', component_type), ('used_in_aggregated_capacity', used_in_aggregated_capacity), ('previous_value', previous_value), ])


